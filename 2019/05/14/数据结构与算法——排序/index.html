<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。"><title>数据结构与算法——排序 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bbf19a98c9ae28f2e1e8cfcee1d9585e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构与算法——排序</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/message/"><i class="fa fa-comment"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构与算法——排序</h1><div class="post-meta">2019-05-14<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><div class="post-content"><p><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/zonghebijiao.jpg"></p>
<h3 id="一、排序-上-：为什么插入排序比冒泡排序更受欢迎？"><a href="#一、排序-上-：为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="一、排序(上)：为什么插入排序比冒泡排序更受欢迎？"></a>一、排序(上)：为什么插入排序比冒泡排序更受欢迎？</h3><p>分析一个排序算法，从哪几方面入手：</p>
<h4 id="1-排序算法的执行效率"><a href="#1-排序算法的执行效率" class="headerlink" title="1.排序算法的执行效率"></a>1.排序算法的执行效率</h4><p>1）最好情况、最坏情况、平均情况时间复杂度。<br>2）时间复杂度的系数、常数、低阶。<br>3）比较次数和交换(或移动)次数。基于比较的排序算法会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。</p>
<h4 id="2-排序算法的内存消耗"><a href="#2-排序算法的内存消耗" class="headerlink" title="2.排序算法的内存消耗"></a>2.排序算法的内存消耗</h4><p>算法的内存消耗可以通过空间复杂度来衡量，针对排序算法的空间复杂度，引入了一个概念——原地排序(Sorted in place)。原地排序算法就是特指空间复杂度为O(1)的排序算法，包括冒泡排序、插入排序、选择排序。</p>
<h4 id="3-排序算法的稳定性"><a href="#3-排序算法的稳定性" class="headerlink" title="3.排序算法的稳定性"></a>3.排序算法的稳定性</h4><p>除了执行效率和内存消耗，针对排序算法还有一个重要的度量指标——稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。<br>假如现在有一组数据：2，9，3，4，8，3，按照大小排序之后是2，3，3，4，8，9。这组数据里有两个3，经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那这种排序算法就是稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就是不稳定的。<br>数据结构和算法在讲排序的时候，都是用整数来举例，在真正软件开发中，要排序的往往不是单纯的整数，而是一组对象，需要按照对象的某个key来排序。<br>比如，现在要给电商交易系统中的“订单”排序，订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有10万条订单数据，希望按照金额从小到大对订单数据排序。对于金额相同的订单，希望按照下单时间从早到晚有序。<br>对于这样一个排序需求，借助稳定排序算法，先按照下单时间给订单排序，然后用稳定排序算法，按照订单金额重新排序。这样两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间排序。稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</p>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><h4 id="1-1冒泡排序是原地排序算法吗？"><a href="#1-1冒泡排序是原地排序算法吗？" class="headerlink" title="1.1冒泡排序是原地排序算法吗？"></a>1.1冒泡排序是原地排序算法吗？</h4><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是一个原地排序算法。</p>
<h4 id="1-2冒泡排序是稳定的排序算法吗？"><a href="#1-2冒泡排序是稳定的排序算法吗？" class="headerlink" title="1.2冒泡排序是稳定的排序算法吗？"></a>1.2冒泡排序是稳定的排序算法吗？</h4><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的。</p>
<h4 id="1-3冒泡排序的时间复杂度"><a href="#1-3冒泡排序的时间复杂度" class="headerlink" title="1.3冒泡排序的时间复杂度"></a>1.3冒泡排序的时间复杂度</h4><p>最好情况下要排序的数据是有序的，只需要进行一次比较操作，是O(n)。而最坏情况下，要排序的数据刚好是倒序排列的，要进行n次冒泡操作，为O(n2)。<br>对于包含n个数据的数组，这n个数据有n!中排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的，如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算很复杂。<br>这里，通过“有序度”和“逆序度”这两个概念来进行分析。<br>有序度是数组中具有有序关系的元素对的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/youxudu.jpg"><br>对于一个倒序排列的数组，比如654321，有序度为0；对于一个完全有序的数组，比如123456，有序度就是n×(n-1)/2，就是15。我们把这种完全有序的数组的有序度叫做满有序度。<br>逆序度的定义正好跟有序度相反(默认从小到大为有序)。</p>
<h4 id="逆序度-满有序度-有序度"><a href="#逆序度-满有序度-有序度" class="headerlink" title="逆序度 = 满有序度 - 有序度"></a>逆序度 = 满有序度 - 有序度</h4><p>排序的过程就是增加有序度，减少逆序度的过程，最后达到满有序度。</p>
<p>对于包含n个数据的数组进行冒泡排序，平均交换次数在最坏情况下，初始状态有序度为0，要进行n×(n-1)/2次交换；最好情况下，初始状态的有序度是n×(n-1)/2，就不需要进行交换。取中间值n×(n-1)/4来表示平均情况。定性分析下平均情况的时间复杂度为O(n2)。</p>
<h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h3><h4 id="2-1插入排序是原地排序算法吗？"><a href="#2-1插入排序是原地排序算法吗？" class="headerlink" title="2.1插入排序是原地排序算法吗？"></a>2.1插入排序是原地排序算法吗？</h4><p>插入排序算法不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。</p>
<h4 id="2-2插入排序是稳定的排序算法吗？"><a href="#2-2插入排序是稳定的排序算法吗？" class="headerlink" title="2.2插入排序是稳定的排序算法吗？"></a>2.2插入排序是稳定的排序算法吗？</h4><p>在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
<h4 id="2-3插入排序的时间复杂度"><a href="#2-3插入排序的时间复杂度" class="headerlink" title="2.3插入排序的时间复杂度"></a>2.3插入排序的时间复杂度</h4><p>最好情况下从头遍历已经有序的元素O(n)；最坏情况下数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，为O(n2)。平均时间复杂度为O(n2)。</p>
<h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><p>选择排序算法的实现思路有点类似插入排序，也区分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<h4 id="3-1选择排序是原地排序算法吗？"><a href="#3-1选择排序是原地排序算法吗？" class="headerlink" title="3.1选择排序是原地排序算法吗？"></a>3.1选择排序是原地排序算法吗？</h4><p>空间复杂度为O(1)，是一种原地排序算法。</p>
<h4 id="3-2选择排序是稳定的排序算法吗？"><a href="#3-2选择排序是稳定的排序算法吗？" class="headerlink" title="3.2选择排序是稳定的排序算法吗？"></a>3.2选择排序是稳定的排序算法吗？</h4><p>选择排序是一种不稳定的排序算法。</p>
<h4 id="3-3选择排序的时间复杂度"><a href="#3-3选择排序的时间复杂度" class="headerlink" title="3.3选择排序的时间复杂度"></a>3.3选择排序的时间复杂度</h4><p>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为O(n2)。</p>
<h3 id="为什么插入排序要比冒泡排序更受欢迎？"><a href="#为什么插入排序要比冒泡排序更受欢迎？" class="headerlink" title="为什么插入排序要比冒泡排序更受欢迎？"></a>为什么插入排序要比冒泡排序更受欢迎？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line">if (a[j] &gt; a[j+1]) &#123; // 交换</span><br><span class="line">   int tmp = a[j];</span><br><span class="line">   a[j] = a[j+1];</span><br><span class="line">   a[j+1] = tmp;</span><br><span class="line">   flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line">if (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+1] = a[j];  // 数据移动</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码实现上看，冒泡排序的数据交换要比插入排序的数据移动操作要多，cpu处理时间就长。虽然两者时间复杂度一样，但是插入排序优化空间要大，例如其中的希尔排序。</p>
<h3 id="二、排序-下-：如何用快排思想在O-n-内查找无序数组中第k大元素？"><a href="#二、排序-下-：如何用快排思想在O-n-内查找无序数组中第k大元素？" class="headerlink" title="二、排序(下)：如何用快排思想在O(n)内查找无序数组中第k大元素？"></a>二、排序(下)：如何用快排思想在O(n)内查找无序数组中第k大元素？</h3><p>时间复杂度为O(nlogn)的归并排序和快速排序，都用到了分治思想。</p>
<h3 id="4-归并排序-Merge-Sort"><a href="#4-归并排序-Merge-Sort" class="headerlink" title="4.归并排序(Merge Sort)"></a>4.归并排序(Merge Sort)</h3><p>思想：要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br>归并排序使用的是分治思想。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//归并排序的递推公式</span><br><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure>
<p>给下标从p到r的数组排序，将这个排序问题转化为两个子问题，p到q和q+1到r，下标q等于p和r的中间位置(p+r)/2。当两个子数组都排好序之后，合并在一起，p到r也就排好序了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序算法, A 是数组，n 表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  // 递归终止条件</span><br><span class="line">  if p &gt;= r  then return</span><br><span class="line"></span><br><span class="line">  // 取 p 到 r 之间的中间位置 q</span><br><span class="line">  q = (p+r) / 2</span><br><span class="line">  // 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+1, r)</span><br><span class="line">  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+1...r])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merge(A[p...r], A[p...q], A[q+1...r]) &#123;</span><br><span class="line">  var i := p，j := q+1，k := 0 // 初始化变量 i, j, k</span><br><span class="line">  var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组</span><br><span class="line">  while i&lt;=q AND j&lt;=r do &#123;</span><br><span class="line">    if A[i] &lt;= A[j] &#123;</span><br><span class="line">      tmp[k++] = A[i++] // i++ 等于 i:=i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] = A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 判断哪个子数组中有剩余的数据</span><br><span class="line">  var start := i，end := q</span><br><span class="line">  if j&lt;=r then start := j, end:=r</span><br><span class="line">  </span><br><span class="line">  // 将剩余的数据拷贝到临时数组 tmp</span><br><span class="line">  while start &lt;= end do &#123;</span><br><span class="line">    tmp[k++] = A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 将 tmp 中的数组拷贝回 A[p...r]</span><br><span class="line">  for i:=0 to r-p do &#123;</span><br><span class="line">    A[p+i] = tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1归并排序是稳定的排序算法吗？"><a href="#4-1归并排序是稳定的排序算法吗？" class="headerlink" title="4.1归并排序是稳定的排序算法吗？"></a>4.1归并排序是稳定的排序算法吗？</h4><p>归并排序的稳定性要看merge()合并函数。另外，稳定性是由方法本身决定的，对不稳定的排序方法而言，不管其描述形式如何，总能举出一个说明不稳定的实例来；反之，对稳定的排序方法，总能找到一种不引起不稳定的描述形式。<br>合并前后的前后顺序不变，就是稳定的。</p>
<h4 id="4-2归并排序的时间复杂度"><a href="#4-2归并排序的时间复杂度" class="headerlink" title="4.2归并排序的时间复杂度"></a>4.2归并排序的时间复杂度</h4><p>归并排序可以递归实现，递归代码的时间复杂度也可以写成递推公式。<br>我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br><span class="line"></span><br><span class="line">T(n) = 2*T(n/2) + n</span><br><span class="line">     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</span><br><span class="line">     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span><br><span class="line">     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     = 2^k * T(n/2^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>
<p>当T(n/2^k)=T(1)时，也就是n/2^k=1，得到k=log2n。代入得到T(n)=Cn+nlog2n。大O标记法表示就是T(n)=O(nlogn)。</p>
<h4 id="4-3归并排序的空间复杂度"><a href="#4-3归并排序的空间复杂度" class="headerlink" title="4.3归并排序的空间复杂度"></a>4.3归并排序的空间复杂度</h4><p>归并排序的时间复杂度任何情况下都是O(nlogn)，但是归并排序并没有像快排那样应用广泛，原因在于它不是原地排序算法。因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。<br>空间复杂度为O(n)。</p>
<h3 id="5-快速排序-Quick-Sort"><a href="#5-快速排序-Quick-Sort" class="headerlink" title="5.快速排序(Quick Sort)"></a>5.快速排序(Quick Sort)</h3><p>快排利用的也是分治。不稳定。<br>思想：假设要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点)。遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。经过这一步骤之后，数组p到r之间的数据就被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。<br>根据分治、递推的处理思想，递归排序下标从p到<br>q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，说明所有的数据都有序了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r</span><br><span class="line"></span><br><span class="line">// 快速排序，A 是数组，n 表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">// 快速排序递归函数，p,r 为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  if p &gt;= r then return</span><br><span class="line">  </span><br><span class="line">  q = partition(A, p, r) // 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-1)</span><br><span class="line">  quick_sort_c(A, q+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序的处理过程是从下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程由上到下，先分区，然后再处理子问题。快排通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>现在有10个接口访问日志文件，每个日志文件大小约为300MB，每个文件里的日志都是按照时间戳从小到大排序的。希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB，如何能“快速”地将这10个日志文件合并？</p>
<h3 id="三、线性排序：如何根据年龄给100万用户数据排序？"><a href="#三、线性排序：如何根据年龄给100万用户数据排序？" class="headerlink" title="三、线性排序：如何根据年龄给100万用户数据排序？"></a>三、线性排序：如何根据年龄给100万用户数据排序？</h3><p>桶排序、计数排序、基数排序，这三种排序算法的时间复杂度是线性的，所以叫做线性排序(Linear Sort)。之所以能做到线性的时间复杂度，是因为这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p>
<h3 id="6-桶排序"><a href="#6-桶排序" class="headerlink" title="6.桶排序"></a>6.桶排序</h3><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<h4 id="6-1桶排序的时间复杂度"><a href="#6-1桶排序的时间复杂度" class="headerlink" title="6.1桶排序的时间复杂度"></a>6.1桶排序的时间复杂度</h4><p>如果要排序的数据有n个，我们把它们均匀地划分到m个桶内，每个桶内就有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为O(klogk)。m个桶排序的时间复杂度就是O(mklogk)，因为k=n/m，所以整个桶排序的时间复杂度就是O(nlog(n/m))。当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。</p>
<h4 id="6-2桶排序的应用场景"><a href="#6-2桶排序的应用场景" class="headerlink" title="6.2桶排序的应用场景"></a>6.2桶排序的应用场景</h4><p>桶排序对要排序数据的要求非常苛刻。首先，要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据排序完之后，桶与桶之间的数据不需要在进行排序。其次，数据在各个桶之间的分布是比较均匀的，如果数据经过桶的划分，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了，在极端情况下，如果数据都被分到一个桶里，那就退化为O(nlogn)了。<br>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。<br>比如说我们有10GB的订单数据，希望按订单金额(假设金额都是正整数)进行排序，但是我们内存有限，只有几百MB，没办法一次性把10GB的数据都加载到内存中。这个时候可以借助桶排序的思想来解决这个问题。<br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/tongpaixuyingxu.png"></p>
<h3 id="7-计数排序-Counting-Sort"><a href="#7-计数排序-Counting-Sort" class="headerlink" title="7.计数排序(Counting Sort)"></a>7.计数排序(Counting Sort)</h3><p>计数排序可以说是桶排序的一种特殊情况。<br>当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。<br>我们都经历过高考，高考查分系统，我们查分数的时候，系统会显示我们的成绩以及所在省的排名。2016年山东省有70万考生，如何通过成绩快速排序得出名次呢？<br>考生的满分是750分，最小是0分，这个数据的范围不算大，所以我们可以分成751个桶，对应分数从0到750分。根据考生的成绩，将这70万考生划分到751个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了70万考生的排序，因为只涉及扫描遍历操作，所以时间复杂度是O(n)。<br>计数排序的算法思想与桶排序类似，只是桶的大小粒度不一样，为什么叫“计数”，“计数”的含义来自哪里？<br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu1.png"><br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu2.png"><br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu3.png"><br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu4.jpg"></p>
<h3 id="8-基数排序-Radix-Sort"><a href="#8-基数排序-Radix-Sort" class="headerlink" title="8.基数排序(Radix Sort)"></a>8.基数排序(Radix Sort)</h3><p>再来看这样一个排序问题，假设我们有10万个手机号码，希望将这10万个手机号码从小到大排序，有什么比较快速的排序方法？<br>快排可以做到O(nlogn)，手机号码有11位，范围太大，不适合用桶排序、计数排序。<br>可以用基数排序。<br>假设要比较两个手机号码a和b的大小，如果在前面几位中，a手机号码已经比b的大了，那后面的几位就不用看了。<br>基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。</p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/Kaiyuan/donate-page" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.png"></li><li id="WeChat" qr="/img/WeChatQR.png"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="tags"><a href="/tags/数据结构与算法"><i class="fa fa-tag">数据结构与算法</i></a></div><div class="post-nav"><a class="pre" href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%946%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">深入理解JVM——6类文件结构</a><a class="next" href="/2019/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '8359b7a19b78f2b9e112',
  clientSecret: '5ad69dc1633a1834322067d017b6313bd231457c',
  repo: 'gitalk',
  owner: 'Th3Crave',
  admin: ['Th3Crave'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/img/frozenwind.jpg"/></a><p>世上万物 向心公转</p><a class="info-icon" href="https://frozenwind.online" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:mail@frozenwind.online" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/Th3Crave" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/emotion/">emotion</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a><span class="category-list-count">86</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Elasticsearch/" style="font-size: 15px;">Elasticsearch</a> <a href="/tags/IDE%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">IDE插件</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">Java并发和多线程</a> <a href="/tags/Maven/" style="font-size: 15px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 15px;">分布式</a> <a href="/tags/Nexus/" style="font-size: 15px;">Nexus</a> <a href="/tags/%E6%83%85%E4%B9%A6/" style="font-size: 15px;">情书</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/%E6%B8%AF%E4%B9%90/" style="font-size: 15px;">港乐</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E8%AF%8D/" style="font-size: 15px;">词</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">随笔</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/Spring-MVC/">Spring-MVC</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/Spring-AOP/">Spring-AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/SpringCloud/">SpringCloud</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/26/myBatis-spring/">mybatis-spring</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/24/ElasticSearch-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/">ElasticSearch-数据同步方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/25/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/">SpringBoot源码分析-自动装配</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/25/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">SpringBoot源码分析-启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/22/JavaIO-BIO/">Java IO - BIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/21/JavaIO-NIO/">Java IO - NIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/">Java IO - 基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>