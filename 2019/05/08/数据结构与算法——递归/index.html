<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>数据结构与算法——递归 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构与算法——递归</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/MoonAndStar/"><i class="fa fa-heart"> Moon&amp;Star</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构与算法——递归</h1><div class="post-meta">2019-05-08<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><a class="disqus-comment-count" href="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/#vcomment"><span class="valine-comment-count" data-xid="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/"></span><span> 条评论</span></a><div class="post-content"><p>推荐注册返佣金——现在很多App都有这个功能。用户A推荐用户B来注册，用户B又推荐了用户C来注册。可以说，用户C的“最终推荐人”为用户A，用户B的“最终推荐人”也为用户A，用户A没有“最终推荐人”。<br>一般来说，会通过数据库来记录这种推荐关系。在数据库表中，可以记录两行数据，其中actor_id表示用户id，referrer_id表示推荐人id。<br><img src="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/acre.jpg"><br>基于这个背景，给定一个用户ID，如何查找这个用户的“最终推荐人”？</p>
<h3 id="1-关于递归"><a href="#1-关于递归" class="headerlink" title="1.关于递归"></a>1.关于递归</h3><p>数据结构与算法，有两个最难理解的知识点，一个是动态规划，一个是递归。<br>递归是一中应用非常广泛的算法(或者编程技巧)，有很多数据结构与算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等。<br>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</p>
<h3 id="2-递归需要满足的三个条件"><a href="#2-递归需要满足的三个条件" class="headerlink" title="2.递归需要满足的三个条件"></a>2.递归需要满足的三个条件</h3><h4 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1)一个问题的解可以分解为几个子问题的解"></a>1)一个问题的解可以分解为几个子问题的解</h4><p>子问题就是数据规模更小的问题。</p>
<h4 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2)这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2)这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h4><h4 id="3-存在递归终止条件"><a href="#3-存在递归终止条件" class="headerlink" title="3)存在递归终止条件"></a>3)存在递归终止条件</h4><p>把问题分解为子问题，子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，需要有终止条件。</p>
<h3 id="3-如何编写递归代码"><a href="#3-如何编写递归代码" class="headerlink" title="3.如何编写递归代码"></a>3.如何编写递归代码</h3><p>写递归代码最关键的是写出递推公式，找到终止条件，将递推公式转化为代码。<br>假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问这n个台阶有多少中走法？<br>如果有7个台阶，可以2，2，2，1这样上去，也可以1，2，1，1，2这样，走法很多，如何用编程求得总共有多少中走法？<br>想一下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法加上先走2阶后，n-2个台阶的走法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure>
<p>再来看终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法，所以f(1)=1。然而，只有这一个是不够的。<br>n=2时，f(2)=f(1)+f(0)，如果递归终止条件只有一个f(1)=1，那f(2)就无法求解了，而f(0)是客观不可行的，所以要把f(2)=2作为一个终止条件，表示走两个台阶，有两种走法，一步走完或者分两步来走。<br>把递归终止条件和递推公式放到一起就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(1)=1</span><br><span class="line">f(2)=2</span><br><span class="line">f(n)=f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure>
<p>转化为递归代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int f(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n == 1) return 1;</span><br><span class="line">	if(n == 2) return 2;</span><br><span class="line">	return f(n-1) + f(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。"><a href="#写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。" class="headerlink" title="写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。"></a>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。</h4><p>当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解。像刚刚这个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归坪铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。<br>对于递归代码，这种试图想搞清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。<br>如果一个问题A可以分解为若干子问题B、C、D，可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而且，只需要思考问题A和子问题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题和子子问题，子子问题和子子子问题之间的关系，屏蔽掉递归细节。</p>
<h4 id="编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。"><a href="#编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。" class="headerlink" title="编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。"></a>编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。</h4><h3 id="4-递归代码要警惕堆栈溢出"><a href="#4-递归代码要警惕堆栈溢出" class="headerlink" title="4.递归代码要警惕堆栈溢出"></a>4.递归代码要警惕堆栈溢出</h3><p>为什么递归代码容易造成堆栈溢出？如何预防堆栈溢出？<br>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br>上面的例子，如果将系统栈或者JVM堆栈大小设置为1KB，在求解f(1999)时便会出现如下堆栈报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>
<p>如何避免出现堆栈溢出？<br>声明一个全局变量，可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度(比如1000)之后，就不继续往下再递归了，直接返回报错。<br>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，会影响代码的可读性。所以，如果最大深度比较小，比如10、50，可以用这种方法，否则这种方法并不是很实用。</p>
<h3 id="5-递归代码要警惕重复计算"><a href="#5-递归代码要警惕重复计算" class="headerlink" title="5.递归代码要警惕重复计算"></a>5.递归代码要警惕重复计算</h3><p><img src="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/fchongfujisuan.jpg"><br>从图中，可以看到，想要计算f(5),需要先计算f(4)和 f(3)，而计算f(4) 还需要计算f(3)，因此f(3) 就被计算了很多次，这就是重复计算问题。<br>为了避免重复计算，可以通过一个数据结构(比如散列表)来保存已经求解过的f(k)。当递归调用到f(k)时，先从中看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">  if (n == 1) return 1;</span><br><span class="line">  if (n == 2) return 2;</span><br><span class="line">  </span><br><span class="line">  // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)</span><br><span class="line">  if (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    return hasSovledList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int ret = f(n-1) + f(n-2);</span><br><span class="line">  hasSovledList.put(n, ret);</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。</p>
<h3 id="6-递归代码改写为非递归代码"><a href="#6-递归代码改写为非递归代码" class="headerlink" title="6.递归代码改写为非递归代码"></a>6.递归代码改写为非递归代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int f(n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n == 1) return 1;</span><br><span class="line">	if(n == 2) return 2;</span><br><span class="line"></span><br><span class="line">	int ret = 0;</span><br><span class="line">	int pre = 2;</span><br><span class="line">	int prepre = 1;</span><br><span class="line">	for(int i = 3; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = pre + prepre;</span><br><span class="line">		prepre = pre;</span><br><span class="line">		pre = ret;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line">//刚好这个走台阶的问题类似斐波那契数列</span><br></pre></td></tr></table></figure>
<p>抽象出递推公式、初始值和边界条件，用迭代循环实现改写。<br>是不是所有的递归代码都可以改写为这种迭代循环的非递归写法？<br>笼统地讲，是的。因为递归本身就是借助栈来实现的，因不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。<br>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>
<h3 id="如何找到“最终推荐人”"><a href="#如何找到“最终推荐人”" class="headerlink" title="如何找到“最终推荐人”"></a>如何找到“最终推荐人”</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long findRootReferrerId(long actorId)</span><br><span class="line">&#123;</span><br><span class="line">	Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">	if(referrerId == null) return actorId;</span><br><span class="line">	return findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际项目中，这三行代码并不能工作，为啥？这里面有两个问题。<br>一，如果递归很深，可能会有堆栈溢出的问题。<br>二，如果数据库里存在脏数据，还需要处理由此产生的无限递归问题。比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果A的推荐人是B，B的推荐人是C，C 的推荐人是A，这样就会发生死循环。<br>第一个问题，可以用限制递归深度来解决。<br>第二个问题，自动检测A-B-C-A这种“环”的存在。如何来检测环的存在？</p>
<h3 id="思考：对于递归代码，有什么好的调试方法？"><a href="#思考：对于递归代码，有什么好的调试方法？" class="headerlink" title="思考：对于递归代码，有什么好的调试方法？"></a>思考：对于递归代码，有什么好的调试方法？</h3><p>1.打印日志发现，递归值。<br>2.结合条件断点进行调试。</p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/Kaiyuan/donate-page" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.png"></li><li id="WeChat" qr="/img/WeChatQR.png"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="tags"><a href="/tags/数据结构与算法"><i class="fa fa-tag">数据结构与算法</i></a></div><div class="post-nav"><a class="pre" href="/2019/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><a class="next" href="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/">数据结构与算法——队列</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'NPvQJfh7XNHqMqbmVYOg5VE5-9Nh9j0Va',
  appKey:'hgOdKtBYlsJzigDKoXqevrSI',
  placeholder:'我想听你说一句… （留言请填写您的昵称和邮箱，方便回复以邮件形式通知您）',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img src="/img/frozenwind.jpg"/></a><p>世上万物 向心公转</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/Th3Crave" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/emotion/">emotion</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a><span class="category-list-count">83</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/IDE%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">IDE插件</a> <a href="/tags/Elasticsearch/" style="font-size: 15px;">Elasticsearch</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">Java并发和多线程</a> <a href="/tags/Maven/" style="font-size: 15px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/Nexus/" style="font-size: 15px;">Nexus</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8FID/" style="font-size: 15px;">分布式ID</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 15px;">分布式事务</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" style="font-size: 15px;">分布式缓存</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 15px;">分布式锁</a> <a href="/tags/%E6%83%85%E4%B9%A6/" style="font-size: 15px;">情书</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">操作系统</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/%E6%B8%AF%E4%B9%90/" style="font-size: 15px;">港乐</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">随笔</a> <a href="/tags/%E8%AF%8D/" style="font-size: 15px;">词</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/03/25/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/">SpringBoot源码分析-自动装配</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/25/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">SpringBoot源码分析-启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/22/JavaIO-BIO/">Java IO - BIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/21/JavaIO-NIO/">Java IO - NIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/">Java IO - 基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/">消息队列——Kafka</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E5%8C%BA%E5%88%AB-%E5%AF%B9%E6%AF%94-%E9%80%89%E5%9E%8B/">消息队列—区别/对比/选型</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Redis数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/03/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E9%94%81-%E9%94%81%E6%A0%B8%E5%BF%83AQS/">Java并发和多线程-JUC锁-锁核心AQS</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/03/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E9%94%81-ReentrantLock/">Java并发和多线程-JUC锁-ReentrantLock</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>