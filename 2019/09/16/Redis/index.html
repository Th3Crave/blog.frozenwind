<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Redis | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/MoonAndStar/"><i class="fa fa-heart"> Moon&amp;Star</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Redis</h1><div class="post-meta">2019-09-16<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><a class="disqus-comment-count" href="/2019/09/16/Redis/#vcomment"><span class="valine-comment-count" data-xid="/2019/09/16/Redis/"></span><span> 条评论</span></a><div class="post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis，英文全称是Remote Dictionary Server（远程字典服务），Key-Value数据库。</p>
<p>可用于缓存，事件发布或订阅，高速队列等场景。<br>提供字符串、哈希、列表、队列、集合结构直接存取，基于内存，可持久化。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>热点数据的缓存</li>
<li>限时业务的运用<br>  redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。</li>
<li>计数器相关问题<br>  redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成。<br>  具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</li>
<li>分布式锁<br>  这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存，同时返回1，否则返回0 。<br>  这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。<br>  当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。<br>  在分布式锁的场景中，主要用在比如秒杀系统等。</li>
<li>延时操作<br>  比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。<br>  由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。<br>  所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期，我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。<br>  当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</li>
<li>排行榜相关问题<br>  关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。<br>  比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息。</li>
<li>点赞、好友等相互关系的存储<br>  Redis 利用集合的一些命令，比如求交集、并集、差集等。</li>
<li>简单队列<br>  由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。</li>
</ul>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h3 id="为什么单线程的Redis可以支持高并发访问？"><a href="#为什么单线程的Redis可以支持高并发访问？" class="headerlink" title="为什么单线程的Redis可以支持高并发访问？"></a>为什么单线程的Redis可以支持高并发访问？</h3><ul>
<li>为什么Redis选择单线程的实现方式<ol>
<li>redis是基于内存的，内存的读写速度非常快。CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽；</li>
<li>核心是基于非阻塞的IO多路复用机制；</li>
<li>redis是单线程的，反而省去了很多上下文切换线程的时间，避免了多线程的实现复杂度；</li>
</ol>
</li>
<li>为什么Redis能支持高并发访问<br>  从IO模型角度来说，Redis使用的是IO多路复用模型，使得它可以在网络IO操作并发处理数十万的客户端网络连接，实现非常高的网络吞吐率。<br>  这也是Redis可以实现高并发访问的最主要的原因。</li>
</ul>
<h2 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h2><h3 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h3><p>所谓redis的并发竞争key的问题也就是多个系统同时对一个key进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。</p>
<p>解决方案：分布式锁(zookeeper和redis都可以实现分布式锁)。如果不存在redis的并发竞争key问题，不要使用分布式锁，这样会影响性能。</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。<br>大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务器宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>只要使用缓存，就可能会涉及到缓存与数据库双存储双写，只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话(缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案)，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。<br>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<h2 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h2><p>Redis内部使用<code>文件事件处理器 file event handler</code>，这个文件事件处理器是<code>单线程</code>的，所以redis才叫做单线程的模型。</p>
<p>文件事件处理器的结构包含4个部分：</p>
<ul>
<li>多个socket</li>
<li>IO多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)</li>
</ul>
<p>文件事件处理器采用<code>IO多路复用机制</code>同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。<br>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<h3 id="Redis的IO多路复用"><a href="#Redis的IO多路复用" class="headerlink" title="Redis的IO多路复用"></a>Redis的IO多路复用</h3><p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。</p>
<p><code>多路</code>指的是多个网络连接，<code>复用</code>指的是复用同一个线程。<br>一个或一组线程处理多个 TCP 连接（socket或者channel）。</p>
<p>目前常用的IO复用模型：select，poll，<code>epoll</code>。</p>
<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><ul>
<li>5种基础类型<ul>
<li>String 字符串</li>
<li>Hash 哈希</li>
<li>List 列表</li>
<li>Set 集合</li>
<li>Sorted Set 有序集合</li>
</ul>
</li>
<li>3种特殊类型<ul>
<li>Bitmap 位图</li>
<li>HyperLogLog 基数统计</li>
<li>Geospatial 地理位置</li>
</ul>
</li>
<li>Stream类型 v5.0</li>
</ul>
<h3 id="五种基本数据类型"><a href="#五种基本数据类型" class="headerlink" title="五种基本数据类型"></a>五种基本数据类型</h3><p><img src="/2019/09/16/Redis/redis-5%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpeg"></p>
<h4 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1.String 字符串"></a>1.String 字符串</h4><blockquote>
<p>String是redis中最基本的数据类型，一个key对应一个value。</p>
</blockquote>
<p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p>
<p>Redis中string(字符串)是动态字符串，允许修改,，可以对字符串进行操作，比如增加字符或者求子串：如果是整数或者浮点数，可以实现计算，比如自增等</p>
<p>string类型是Redis最基本的数据结构，一个redis中字符串value最多可以是512M。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">简述</th>
<th align="left">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET</td>
<td align="left">获取存储在给定键中的值</td>
<td align="left">GET name</td>
</tr>
<tr>
<td align="left">SET</td>
<td align="left">设置存储在给定键中的值</td>
<td align="left">SET name value</td>
</tr>
<tr>
<td align="left">DEL</td>
<td align="left">删除存储在给定键中的值</td>
<td align="left">DEL name</td>
</tr>
<tr>
<td align="left">INCR</td>
<td align="left">将键存储的值加1</td>
<td align="left">INCR key</td>
</tr>
<tr>
<td align="left">DECR</td>
<td align="left">将键存储的值减1</td>
<td align="left">DECR key</td>
</tr>
<tr>
<td align="left">INCRBY</td>
<td align="left">将键存储的值加上整数</td>
<td align="left">INCRBY key amount</td>
</tr>
<tr>
<td align="left">DECRBY</td>
<td align="left">将键存储的值减去整数</td>
<td align="left">DECRBY key amount</td>
</tr>
</tbody></table>
<h4 id="2-Hash-哈希"><a href="#2-Hash-哈希" class="headerlink" title="2.Hash 哈希"></a>2.Hash 哈希</h4><blockquote>
<p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">简述</th>
<th align="left">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HSET</td>
<td align="left">添加键值对</td>
<td align="left">HSET hash-key sub-key1 value1</td>
</tr>
<tr>
<td align="left">HGET</td>
<td align="left">获取指定散列键的值</td>
<td align="left">HGET hash-key key1</td>
</tr>
<tr>
<td align="left">HGETALL</td>
<td align="left">获取散列中包含的所有键值对</td>
<td align="left">HGETALL hash-key</td>
</tr>
<tr>
<td align="left">HDEL</td>
<td align="left">如果给定键存在于散列中，那么就移除这个键</td>
<td align="left">HDEL hash-key sub-key1</td>
</tr>
</tbody></table>
<h4 id="3-List-列表"><a href="#3-List-列表" class="headerlink" title="3.List 列表"></a>3.List 列表</h4><blockquote>
<p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">简述</th>
<th align="left">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RPUSH</td>
<td align="left">将给定值推入到列表右端</td>
<td align="left">RPUSH key value</td>
</tr>
<tr>
<td align="left">LPUSH</td>
<td align="left">将给定值推入到列表左端</td>
<td align="left">LPUSH key value</td>
</tr>
<tr>
<td align="left">RPOP</td>
<td align="left">从列表的右端弹出一个值，并返回被弹出的值</td>
<td align="left">RPOP key</td>
</tr>
<tr>
<td align="left">LPOP</td>
<td align="left">从列表的左端弹出一个值，并返回被弹出的值</td>
<td align="left">LPOP key</td>
</tr>
<tr>
<td align="left">LRANGE</td>
<td align="left">获取列表在给定范围上的所有值</td>
<td align="left">LRANGE key 0 -1</td>
</tr>
<tr>
<td align="left">LINDEX</td>
<td align="left">通过索引获取列表中的元素。也可以使用负数下标，以-1表示列表的最后一个元素，-2表示列表的倒数第二个元素，以此类推。</td>
<td align="left">LINDEX key index</td>
</tr>
</tbody></table>
<ul>
<li>lpush+lpop=Stack(栈)</li>
<li>lpush+rpop=Queue（队列）</li>
<li>lpush+ltrim=Capped Collection（有限集合）</li>
<li>lpush+brpop=Message Queue（消息队列）</li>
</ul>
<h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4.Set 集合"></a>4.Set 集合</h4><blockquote>
<p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">简述</th>
<th align="left">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SADD</td>
<td align="left">向集合添加一个或多个成员</td>
<td align="left">SADD key value</td>
</tr>
<tr>
<td align="left">SCARD</td>
<td align="left">获取集合的成员数</td>
<td align="left">SCARD key</td>
</tr>
<tr>
<td align="left">SMEMBERS</td>
<td align="left">返回集合中的所有成员</td>
<td align="left">SMEMBERS key member</td>
</tr>
<tr>
<td align="left">SISMEMBER</td>
<td align="left">判断 member 元素是否是集合 key 的成员</td>
<td align="left">SISMEMBER key member</td>
</tr>
</tbody></table>
<h4 id="5-Sorted-Set-有序集合"><a href="#5-Sorted-Set-有序集合" class="headerlink" title="5.Sorted Set 有序集合"></a>5.Sorted Set 有序集合</h4><blockquote>
<p>Redis 有序集合，和集合一样也是 string 类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
</blockquote>
<p>有序集合的成员是唯一的, 但分数(score)却可以重复。<br>有序集合是通过两种数据结构实现：</p>
<ul>
<li>压缩列表(ziplist):<br>  ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。<br>  它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。<br>  它能在O(1)的时间复杂度下完成list两端的push和pop操作。<br>  但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li>
<li>跳跃表（zSkiplist)<br>  跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。<br>  跳跃表的复杂度是O(log(n))。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">简述</th>
<th align="left">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ZADD</td>
<td align="left">将一个带有给定分值的成员添加到有序集合里面</td>
<td align="left">ZADD zset-key 178 member1</td>
</tr>
<tr>
<td align="left">ZRANGE</td>
<td align="left">根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td>
<td align="left">ZRANGE zset-key 0-1 withccores</td>
</tr>
<tr>
<td align="left">ZREM</td>
<td align="left">如果给定元素成员存在于有序集合中，那么就移除这个元素</td>
<td align="left">ZREM zset-key member1</td>
</tr>
</tbody></table>
<h3 id="三种特殊类型"><a href="#三种特殊类型" class="headerlink" title="三种特殊类型"></a>三种特殊类型</h3><h4 id="6-Bitmaps"><a href="#6-Bitmaps" class="headerlink" title="6.Bitmaps"></a>6.Bitmaps</h4><blockquote>
<p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p>
</blockquote>
<h4 id="7-HyperLogLog"><a href="#7-HyperLogLog" class="headerlink" title="7.HyperLogLog"></a>7.HyperLogLog</h4><blockquote>
<p>Redis 2.8.9 版本更新了 Hyperloglog 数据结构！</p>
</blockquote>
<h4 id="8-Geospatial"><a href="#8-Geospatial" class="headerlink" title="8.Geospatial"></a>8.Geospatial</h4><blockquote>
<p>Redis 的 Geo 在 Redis 3.2 版本推出。<br>这个功能可以推算地理位置的信息: 两地之间的距离, 方圆几里的人</p>
</blockquote>
<h3 id="Stream类型"><a href="#Stream类型" class="headerlink" title="Stream类型"></a>Stream类型</h3><blockquote>
<p>Redis5.0中增加了一个数据类型Stream，它借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的消息队列。</p>
</blockquote>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p><img src="/2019/09/16/Redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"><br>Redis的每种对象其实都由对象结构(redisObject)与对应编码的数据结构组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。</p>
<p>从一下两个角度来研究底层：</p>
<ul>
<li>对象设计机制: 对象结构(redisObject)</li>
<li>编码类型和底层数据结构: 对应编码的数据结构</li>
</ul>
<h3 id="对象机制"><a href="#对象机制" class="headerlink" title="对象机制"></a>对象机制</h3><h4 id="为什么Redis会设计redisObject对象"><a href="#为什么Redis会设计redisObject对象" class="headerlink" title="为什么Redis会设计redisObject对象"></a>为什么Redis会设计redisObject对象</h4><ol>
<li>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式。</li>
<li>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理.</li>
</ol>
<p>为了解决以上问题, Redis 构建了自己的类型系统, 这个系统的主要功能包括:</p>
<ul>
<li>redisObject 对象.</li>
<li>基于 redisObject 对象的类型检查.</li>
<li>基于 redisObject 对象的显式多态函数.</li>
<li>对 redisObject 进行分配、共享和销毁的机制.</li>
</ul>
<h4 id="redisObject数据结构"><a href="#redisObject数据结构" class="headerlink" title="redisObject数据结构"></a>redisObject数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">// LRU_BITS: 24</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向底层数据结构实例</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<ul>
<li>type记录了对象所保存的值的类型  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0 <span class="comment">// 字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1 <span class="comment">// 列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2 <span class="comment">// 集合</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3 <span class="comment">// 有序集</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4 <span class="comment">// 哈希表</span></span></span><br></pre></td></tr></table></figure></li>
<li>encoding记录了对象所保存的值的编码  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对象编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* 注意：版本2.6后不再使用. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* 注意：不再使用了，旧版本2.x中String的底层之一. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure></li>
<li>ptr是一个指针，指向实际保存值的数据结构。<br>  这个数据结构由type和encoding属性决定。<br>  举个例子，如果一个redisObject 的type 属性为<code>OBJ_LIST</code> ，encoding 属性为<code>OBJ_ENCODING_QUICKLIST</code>，那么这个对象就是一个Redis 列表（List)，它的值保存在一个QuickList的数据结构内，而ptr 指针就指向quicklist的对象</li>
<li>lru属性: 记录了对象最后一次被命令程序访问的时间</li>
</ul>
<h4 id="命令的类型检查和多态"><a href="#命令的类型检查和多态" class="headerlink" title="命令的类型检查和多态"></a>命令的类型检查和多态</h4><blockquote>
<p>那么Redis是如何处理一条命令的呢？</p>
</blockquote>
<p>当执行一个处理数据类型命令的时候，redis执行以下步骤</p>
<ul>
<li>根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；</li>
<li>检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；</li>
<li>根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；</li>
<li>返回数据结构的操作结果作为命令的返回值。</li>
</ul>
<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><ul>
<li>简单动态字符串 - sds</li>
<li>压缩列表 - ZipList</li>
<li>快表 - QuickList</li>
<li>字典/哈希表 - Dict</li>
<li>整数集 - IntSet</li>
<li>跳表 - ZSkipList</li>
</ul>
<h4 id="简单动态字符串-sds"><a href="#简单动态字符串-sds" class="headerlink" title="简单动态字符串 - sds"></a>简单动态字符串 - sds</h4><blockquote>
<p>Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为<code>简单动态字符串（simple dynamic string,SDS）</code>的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p>
</blockquote>
<h4 id="压缩列表-ZipList"><a href="#压缩列表-ZipList" class="headerlink" title="压缩列表 - ZipList"></a>压缩列表 - ZipList</h4><blockquote>
<p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。<br>它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。<br>它能在O(1)的时间复杂度下完成list两端的push和pop操作。<br>但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p>
</blockquote>
<h4 id="快表-QuickList"><a href="#快表-QuickList" class="headerlink" title="快表 - QuickList"></a>快表 - QuickList</h4><blockquote>
<p>quicklist这个结构是Redis在3.2版本后新加的, 之前的版本是list(即linkedlist)， 用于String数据类型中。<br>它是一种以ziplist为结点的双端链表结构。<br>宏观上, quicklist是一个链表；微观上, 链表中的每个结点都是一个ziplist。</p>
</blockquote>
<h4 id="字典-哈希表-Dict"><a href="#字典-哈希表-Dict" class="headerlink" title="字典/哈希表 - Dict"></a>字典/哈希表 - Dict</h4><blockquote>
<p>本质上就是哈希表</p>
</blockquote>
<h4 id="整数集-IntSet"><a href="#整数集-IntSet" class="headerlink" title="整数集 - IntSet"></a>整数集 - IntSet</h4><blockquote>
<p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p>
</blockquote>
<h4 id="跳表-ZSkipList"><a href="#跳表-ZSkipList" class="headerlink" title="跳表 - ZSkipList"></a>跳表 - ZSkipList</h4><blockquote>
<p>跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。<br>跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。<br>跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p>
</blockquote>
<h3 id="Redis对象和底层结构对应关系"><a href="#Redis对象和底层结构对应关系" class="headerlink" title="Redis对象和底层结构对应关系"></a>Redis对象和底层结构对应关系</h3><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><blockquote>
<p>为什么需要持久化？<br>Redis是个基于内存的数据库。服务一旦宕机，内存中的数据将全部丢失。<br>通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复，1、会对数据库带来巨大的压力，2、数据库的性能不如Redis，导致程序响应慢。<br>所以对Redis来说，实现数据的持久化，避免从后端数据库中恢复数据，是至关重要的。</p>
</blockquote>
<h3 id="RDB-Redis-DataBase-持久化"><a href="#RDB-Redis-DataBase-持久化" class="headerlink" title="RDB(Redis DataBase)持久化"></a>RDB(Redis DataBase)持久化</h3><p>RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。</p>
<h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><ul>
<li><p>手动触发</p>
<ul>
<li>save命令<br>  阻塞当前Redis服务器，直到RDB过程完成为止。<br>  对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</li>
<li>bgsave命令<br>  Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。<br>  阻塞只发生在fork阶段，一般时间很短。</li>
</ul>
</li>
<li><p>自动触发</p>
<ul>
<li><code>redis.conf</code>中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</li>
<li>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</li>
<li>执行debug reload命令重新加载redis时也会触发bgsave操作；</li>
<li>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；</li>
</ul>
</li>
</ul>
<h4 id="redis-conf中配置RDB"><a href="#redis-conf中配置RDB" class="headerlink" title="redis.conf中配置RDB"></a>redis.conf中配置RDB</h4><ul>
<li><p>Redis中默认的周期新设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 周期性执行条件的设置格式为</span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"># 默认的设置为：</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"># 以下设置方式为关闭RDB快照功能</span><br><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>其它相关配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># RDB文件在磁盘上的名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 文件保存路径</span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"># 如果持久化出错，主进程是否停止写入</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"># 是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 导入时是否检查</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul>
<li>优点<ul>
<li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li>
<li>Redis加载RDB文件恢复数据要远远快于AOF方式；</li>
</ul>
</li>
<li>缺点<ul>
<li>RDB方式实时性不够，无法做到秒级的持久化；</li>
<li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li>
<li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li>
<li>版本兼容RDB文件问题；</li>
</ul>
</li>
</ul>
<p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决</p>
<h3 id="AOF-append-only-file-持久化"><a href="#AOF-append-only-file-持久化" class="headerlink" title="AOF(append-only file)持久化"></a>AOF(append-only file)持久化</h3><blockquote>
<p>Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。<br>日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。<br>PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。</p>
</blockquote>
<p>AOF日志采用写后日志，即<code>先写内存，后写日志</code>。</p>
<h4 id="如何实现AOF"><a href="#如何实现AOF" class="headerlink" title="如何实现AOF"></a>如何实现AOF</h4><p>AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。</p>
<ul>
<li>命令追加<br>  当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</li>
<li>文件写入和同步<br>  关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：<ul>
<li>Always 同步写回：每个写命令执行完，立马同步地将日志写回磁盘。可靠性高，数据基本不丢失。每个写命令都要落盘，性能影响较大。</li>
<li>Everysec 每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘。性能适中。宕机时丢失1秒内的数据。</li>
<li>No 操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。性能好。宕机时丢失数据较多。<h4 id="redis-conf中配置AOF"><a href="#redis-conf中配置AOF" class="headerlink" title="redis.conf中配置AOF"></a>redis.conf中配置AOF</h4>默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># appendonly参数开启AOF持久化</span><br><span class="line">appendonly no/yes</span><br><span class="line"># AOF持久化的文件名，默认是appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"># 同步策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"># 加载aof出错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。<br>为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写机制来对AOF文件进行“瘦身”。</p>
<p>Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。<br><img src="/2019/09/16/Redis/redis-aof%E9%87%8D%E5%86%99.jpeg"></p>
<blockquote>
<p>AOF重写会阻塞吗？<br>AOF重写过程是由后台进程bgrewriteaof来完成的。<br>主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。<br>然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p>
</blockquote>
<p>所以aof在重写时，在fork进程时是会阻塞住主线程的。</p>
<blockquote>
<p>AOF日志何时会重写？<br>有两个配置项控制AOF重写的触发：<br><code>auto-aof-rewrite-min-size</code>:表示运行AOF重写时文件的最小大小，默认为64MB。<br><code>auto-aof-rewrite-percentage</code>:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。</p>
</blockquote>
<blockquote>
<p>重写日志时，有新数据写入咋整？<br>主线程fork出子进程的是如何复制内存数据的？<br>在重写日志整个过程时，主线程有哪些地方会被阻塞？<br>为什么AOF重写不复用原AOF日志？</p>
</blockquote>
<h3 id="RDB和AOF的混合持久化"><a href="#RDB和AOF的混合持久化" class="headerlink" title="RDB和AOF的混合持久化"></a>RDB和AOF的混合持久化</h3><p>Redis 4.0 中提出了一个混合使用AOF日志和内存快照的方法。<br>简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作。</p>
<h2 id="Redis消息传递：发布订阅模式"><a href="#Redis消息传递：发布订阅模式" class="headerlink" title="Redis消息传递：发布订阅模式"></a>Redis消息传递：发布订阅模式</h2><p>Redis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<h3 id="发布-订阅使用"><a href="#发布-订阅使用" class="headerlink" title="发布/订阅使用"></a>发布/订阅使用</h3><h4 id="基于频道-Channel-的发布-订阅"><a href="#基于频道-Channel-的发布-订阅" class="headerlink" title="基于频道(Channel)的发布/订阅"></a>基于频道(Channel)的发布/订阅</h4><h4 id="基于模式-pattern-的发布-订阅"><a href="#基于模式-pattern-的发布-订阅" class="headerlink" title="基于模式(pattern)的发布/订阅"></a>基于模式(pattern)的发布/订阅</h4><h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><h4 id="基于频道-Channel-的发布-订阅如何实现的？"><a href="#基于频道-Channel-的发布-订阅如何实现的？" class="headerlink" title="基于频道(Channel)的发布/订阅如何实现的？"></a>基于频道(Channel)的发布/订阅如何实现的？</h4><h4 id="基于模式-pattern-的发布-订阅如何实现的？"><a href="#基于模式-pattern-的发布-订阅如何实现的？" class="headerlink" title="基于模式(pattern)的发布/订阅如何实现的？"></a>基于模式(pattern)的发布/订阅如何实现的？</h4><h4 id="SpringBoot结合Redis发布-订阅实例？"><a href="#SpringBoot结合Redis发布-订阅实例？" class="headerlink" title="SpringBoot结合Redis发布/订阅实例？"></a>SpringBoot结合Redis发布/订阅实例？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/llll234/article/details/80966952">springboot集成redis实现消息发布订阅模式-双通道</a></p>
<h2 id="Redis事件"><a href="#Redis事件" class="headerlink" title="Redis事件"></a>Redis事件</h2><blockquote>
<p>Redis 采用事件驱动机制来处理大量的网络IO。<br>它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。</p>
</blockquote>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><blockquote>
<p>Redis 事务的本质是一组命令的集合。<br>事务支持一次执行多个命令，一个事务中所有命令都会被序列化。<br>在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
</blockquote>
<h3 id="Redis事务相关命令和使用"><a href="#Redis事务相关命令和使用" class="headerlink" title="Redis事务相关命令和使用"></a>Redis事务相关命令和使用</h3><ul>
<li>MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li>
<li>EXEC：执行事务中的所有操作命令。</li>
<li>DISCARD：取消事务，放弃执行事务块中的所有命令。</li>
<li>WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li>
<li>UNWATCH：取消WATCH对所有key的监视。<h4 id="CAS操作实现乐观锁"><a href="#CAS操作实现乐观锁" class="headerlink" title="CAS操作实现乐观锁"></a>CAS操作实现乐观锁</h4></li>
</ul>
<h2 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><h3 id="高可扩展-分片技术"><a href="#高可扩展-分片技术" class="headerlink" title="高可扩展-分片技术"></a>高可扩展-分片技术</h3><h2 id="缓存并发问题"><a href="#缓存并发问题" class="headerlink" title="缓存并发问题"></a>缓存并发问题</h2><h3 id="数据库和缓存一致性"><a href="#数据库和缓存一致性" class="headerlink" title="数据库和缓存一致性"></a>数据库和缓存一致性</h3><h4 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h4><blockquote>
<p>更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching</p>
</blockquote>
<p>Cache Aside Pattern</p>
<ul>
<li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li>
<li>更新的时候，先更新数据库，然后再删除缓存。</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>是什么：缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决办法：</p>
<ul>
<li>事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li>
<li>事中：本地ehcache+hystrix限流&amp;降级，避免mysql崩掉</li>
<li>事后：利用redis持久化机制保存的数据尽快恢复缓存</li>
</ul>
<p><img src="/2019/09/16/Redis/huancunxuebeng.jpg"></p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>是什么：一般是黑客故意去请求缓存和数据库中都不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决办法：</p>
<ul>
<li>采用布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li>
<li>缓存空结果：如果一个查询返回的数据为空(不管是数据不存在，还是系统故障)，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿，是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这是由于并发用户特别多，同时读缓存没读到数据(并发查询同一条数据)，又同时去数据库去数据，引起数据库压力瞬间增大，造成过大压力。</p>
<p>解决方案：</p>
<ul>
<li>设置热点数据，永远不过期</li>
<li>加互斥锁。</li>
</ul>
<h3 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h3><p>缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。</p>
<p>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。<br>缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。<br>这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</p>
<h4 id="最大缓存设置"><a href="#最大缓存设置" class="headerlink" title="最大缓存设置"></a>最大缓存设置</h4><p>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置缓存大小为4G</span><br><span class="line">CONFIG SET maxmemory 4gb</span><br></pre></td></tr></table></figure>
<h4 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h4><ul>
<li>不淘汰 <ul>
<li>noeviction （v4.0后默认的）</li>
</ul>
</li>
<li>对设置了过期时间的数据中进行淘汰 <ul>
<li>随机：volatile-random</li>
<li>ttl：volatile-ttl 移除即将过期的键值对</li>
<li>lru：volatile-lru 移除最近最少使用的键值对 跟使用的最后一次时间有关，淘汰最近使用时间离现在最久的</li>
<li>lfu：volatile-lfu 移除最近最不频繁使用的键值对 跟使用的次数有关，淘汰使用次数最少的</li>
</ul>
</li>
<li>全部数据进行淘汰 <ul>
<li>随机：allkeys-random</li>
<li>lru：allkeys-lru</li>
<li>lfu：allkeys-lfu</li>
</ul>
</li>
</ul>
<h2 id="版本特性"><a href="#版本特性" class="headerlink" title="版本特性"></a>版本特性</h2><h3 id="4-0"><a href="#4-0" class="headerlink" title="4.0"></a>4.0</h3><h3 id="5-0"><a href="#5-0" class="headerlink" title="5.0"></a>5.0</h3><h3 id="6-0"><a href="#6-0" class="headerlink" title="6.0"></a>6.0</h3></div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/Kaiyuan/donate-page" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.png"></li><li id="WeChat" qr="/img/WeChatQR.png"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="tags"><a href="/tags/Redis"><i class="fa fa-tag">Redis</i></a></div><div class="post-nav"><a class="pre" href="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/">消息队列——RabbitMQ</a><a class="next" href="/2019/08/21/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/">Linux常用命令总结</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'NPvQJfh7XNHqMqbmVYOg5VE5-9Nh9j0Va',
  appKey:'hgOdKtBYlsJzigDKoXqevrSI',
  placeholder:'我想听你说一句… （留言请填写您的昵称和邮箱，方便回复以邮件形式通知您）',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-text">为什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84Redis%E5%8F%AF%E4%BB%A5%E6%94%AF%E6%8C%81%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%EF%BC%9F"><span class="toc-text">为什么单线程的Redis可以支持高并发访问？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95"><span class="toc-text">如何</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3redis%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89key%E9%97%AE%E9%A2%98"><span class="toc-text">如何解决redis的并发竞争key问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-text">如何保证缓存与数据库双写时的数据一致性？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">Redis的线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">Redis的IO多路复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">Redis数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">五种基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">1.String 字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Hash-%E5%93%88%E5%B8%8C"><span class="toc-text">2.Hash 哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-List-%E5%88%97%E8%A1%A8"><span class="toc-text">3.List 列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Set-%E9%9B%86%E5%90%88"><span class="toc-text">4.Set 集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Sorted-Set-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-text">5.Sorted Set 有序集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-text">三种特殊类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Bitmaps"><span class="toc-text">6.Bitmaps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-HyperLogLog"><span class="toc-text">7.HyperLogLog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Geospatial"><span class="toc-text">8.Geospatial</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E7%B1%BB%E5%9E%8B"><span class="toc-text">Stream类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">Redis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6"><span class="toc-text">对象机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%BC%9A%E8%AE%BE%E8%AE%A1redisObject%E5%AF%B9%E8%B1%A1"><span class="toc-text">为什么Redis会设计redisObject对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisObject%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">redisObject数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-text">命令的类型检查和多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-sds"><span class="toc-text">简单动态字符串 - sds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-ZipList"><span class="toc-text">压缩列表 - ZipList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8-QuickList"><span class="toc-text">快表 - QuickList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-%E5%93%88%E5%B8%8C%E8%A1%A8-Dict"><span class="toc-text">字典&#x2F;哈希表 - Dict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86-IntSet"><span class="toc-text">整数集 - IntSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8-ZSkipList"><span class="toc-text">跳表 - ZSkipList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-text">Redis对象和底层结构对应关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-text">字符串对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">哈希对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">列表对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-text">集合对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-text">有序集合对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-text">Redis持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-Redis-DataBase-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">RDB(Redis DataBase)持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-text">触发方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-conf%E4%B8%AD%E9%85%8D%E7%BD%AERDB"><span class="toc-text">redis.conf中配置RDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">RDB优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-append-only-file-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">AOF(append-only file)持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0AOF"><span class="toc-text">如何实现AOF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-conf%E4%B8%AD%E9%85%8D%E7%BD%AEAOF"><span class="toc-text">redis.conf中配置AOF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E9%87%8D%E5%86%99"><span class="toc-text">AOF重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E5%92%8CAOF%E7%9A%84%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">RDB和AOF的混合持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%EF%BC%9A%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">Redis消息传递：发布订阅模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%BD%BF%E7%94%A8"><span class="toc-text">发布&#x2F;订阅使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A2%91%E9%81%93-Channel-%E7%9A%84%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85"><span class="toc-text">基于频道(Channel)的发布&#x2F;订阅</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%BC%8F-pattern-%E7%9A%84%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85"><span class="toc-text">基于模式(pattern)的发布&#x2F;订阅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-text">深入理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A2%91%E9%81%93-Channel-%E7%9A%84%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">基于频道(Channel)的发布&#x2F;订阅如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%BC%8F-pattern-%E7%9A%84%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">基于模式(pattern)的发布&#x2F;订阅如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E7%BB%93%E5%90%88Redis%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E5%AE%9E%E4%BE%8B%EF%BC%9F"><span class="toc-text">SpringBoot结合Redis发布&#x2F;订阅实例？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E4%BB%B6"><span class="toc-text">Redis事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="toc-text">Redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">Redis事务相关命令和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">CAS操作实现乐观锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">Redis高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="toc-text">哨兵机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E6%89%A9%E5%B1%95-%E5%88%86%E7%89%87%E6%8A%80%E6%9C%AF"><span class="toc-text">高可扩展-分片技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">缓存并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">数据库和缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%BC%8F"><span class="toc-text">相关模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="toc-text">缓存污染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E7%BC%93%E5%AD%98%E8%AE%BE%E7%BD%AE"><span class="toc-text">最大缓存设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">缓存淘汰策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-text">版本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-0"><span class="toc-text">4.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-0"><span class="toc-text">5.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-0"><span class="toc-text">6.0</span></a></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>