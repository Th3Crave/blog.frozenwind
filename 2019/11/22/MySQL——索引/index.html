<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MySQL-索引 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL-索引</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/MoonAndStar/"><i class="fa fa-heart"> Moon&amp;Star</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL-索引</h1><div class="post-meta">2019-11-22<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><a class="disqus-comment-count" href="/2019/11/22/MySQL%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/#vcomment"><span class="valine-comment-count" data-xid="/2019/11/22/MySQL%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/"></span><span> 条评论</span></a><div class="post-content"><p>基于MySQL InnoDB</p>
<p>索引对查询的速度有着至关重要的的影响，理解索引也是进行数据库性能调优的起点。<br>索引就是提高数据查询的效率的一种数据结构。</p>
<h2 id="MySQL为什么使用B-TRee"><a href="#MySQL为什么使用B-TRee" class="headerlink" title="MySQL为什么使用B+TRee"></a>MySQL为什么使用B+TRee</h2><p>文件系统及数据库系统普通采用<code>B-/+Tree</code>作为索引结构。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/P操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ol>
<li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li>
<li>在关键字全集内做一次查找,性能逼近二分查找；</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ol>
<li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)。B+树只有叶子节点保存了data，时间复杂度固定为 O(log n)。</li>
<li>为所有叶子结点增加了一个链指针</li>
</ol>
<h3 id="MySQL-InnoDB存储引擎中B-树一个节点有多大？一千万条数据，B-树多高？"><a href="#MySQL-InnoDB存储引擎中B-树一个节点有多大？一千万条数据，B-树多高？" class="headerlink" title="MySQL InnoDB存储引擎中B+树一个节点有多大？一千万条数据，B+树多高？"></a>MySQL InnoDB存储引擎中B+树一个节点有多大？一千万条数据，B+树多高？</h3><h4 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h4><ol>
<li>数据持久化存储磁盘里，磁盘的最小单元是扇区，一个扇区的大小是 512个字节</li>
<li>文件系统的最小单元是块，一个块的大小是 4K</li>
<li>InnoDB存储引擎，有自己的最小单元，称之为页，一个页的大小是 16K</li>
</ol>
<h4 id="InnoDB引擎的页大小"><a href="#InnoDB引擎的页大小" class="headerlink" title="InnoDB引擎的页大小"></a>InnoDB引擎的页大小</h4><p>InnoDB存储引擎的最小存储单位是页，页的大小为<code>16K = 16384Byte</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_page_size&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/22/MySQL%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/innodb-pagesize.jpg"></p>
<h5 id="B-树的存储结构"><a href="#B-树的存储结构" class="headerlink" title="B+树的存储结构"></a>B+树的存储结构</h5><p>B+树的叶子节点和非叶子节点的大小为一页，16K。</p>
<ul>
<li>叶子节点存放<code>数据</code>，非叶子节点存放<code>指针和键值</code></li>
<li>主键索引：叶子节点存放真正的数据</li>
<li>二级索引：叶子节点存放主键索引的值</li>
</ul>
<p><img src="/2019/11/22/MySQL%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/innodb-b+.jpg"></p>
<h5 id="B-树如何检索记录"><a href="#B-树如何检索记录" class="headerlink" title="B+树如何检索记录"></a>B+树如何检索记录</h5><ul>
<li>首先找到根页，你怎么知道一张表的根页在哪呢？</li>
<li>其实每张表的根页位置在表空间文件中是固定的，即page number=3的页</li>
<li>找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中</li>
<li>然后再去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录</li>
</ul>
<p>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据。</p>
<h4 id="叶子节点可以存放多少行数据"><a href="#叶子节点可以存放多少行数据" class="headerlink" title="叶子节点可以存放多少行数据"></a>叶子节点可以存放多少行数据</h4><p>单个叶子节点（也就是一页）的大小为16K。<br>一行记录的数据大小为数据表各字段的大小的和，假设为1K。</p>
<h4 id="非叶子节点可以存放多少指针"><a href="#非叶子节点可以存放多少指针" class="headerlink" title="非叶子节点可以存放多少指针"></a>非叶子节点可以存放多少指针</h4><p>单个非叶子节点的大小也为一页，16K。<br>非叶子节点存储<code>指针和键值</code>，假设主键为bigint类型，长度为8字节，指针大小在InnoDB中的大小为6字节，指针+键值一共14字节。<br>一个页中能够存放<code>16384 / 14 = 1170</code>个单元，这也是指针的个数。</p>
<h4 id="一颗B-树可以存放多少行记录"><a href="#一颗B-树可以存放多少行记录" class="headerlink" title="一颗B+树可以存放多少行记录"></a>一颗B+树可以存放多少行记录</h4><p>假设树高为k，B+树可存储的记录行数 = （非叶子节点的指针个数）的k-1次方 * 叶子节点的记录行数。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="主键索引-VS-唯一索引-VS-普通索引"><a href="#主键索引-VS-唯一索引-VS-普通索引" class="headerlink" title="主键索引 VS 唯一索引 VS 普通索引"></a>主键索引 VS 唯一索引 VS 普通索引</h3><p>同一个叶子节点(大小为一个内存页或磁盘页，MySQL一页16KB)内的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到<code>装载因子(InnoDB默认为15/16)</code>，则开辟一个新的页(节点)。</p>
<ul>
<li><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。<br>这样就会形成一个紧凑的索引结构，近似顺序填满。<br>由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
</li>
<li><p>如果使用非自增主键(如果身份证号或uuid等)，由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置<br>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，<br>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，<br>后续不得不通过OPTIMIZE TABLE语句来重建表并优化填充页面。因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>
</li>
</ul>
<h3 id="聚合索引"><a href="#聚合索引" class="headerlink" title="聚合索引"></a>聚合索引</h3><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>当某个索引的索引列覆盖了select的所有字段时，会使用到覆盖索引。<br>覆盖索引能够只通过索引就获取到所需要的数据而不需要在回表一条条的查询，同时由于索引是有顺序的，这样对于I/O密集型的范围查询效率也很高。</p>
<p>但是，往往我们很少能够遇到覆盖索引的情况，一般情况都是select的列会多于索引列，这样就无法使用到覆盖索引。</p>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="B-TREE索引"><a href="#B-TREE索引" class="headerlink" title="B-TREE索引"></a>B-TREE索引</h3><p>通常我们所说的索引是指B-Tree索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。<br>使用B-Tree这个术语，是因为 MySQL 在CREATE TABLE或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如 InnoDB 就是使用的B+Tree。</p>
<p>B+Tree中的 B 是指balance，意为平衡。<br>需要注意的是，B+树索引并不能找到一个给定键值的具体行，<code>它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，</code>最后得到要查找的数据。</p>
<p>B+树和B树相比，主要的不同点在以下3项：</p>
<ul>
<li>所有关键码都存放在叶节点中，上层的非叶节点的关键码是其子树中最小（或最大）关键码的复写</li>
<li>叶节点包含了全部关键码及指向相应数据记录存放地址的指针，且叶节点本身按关键码从小到大顺序连接。如果按下层结点“最小关键码复写”原则，则树中每个非叶结点中有 m 棵子树必有 m - 1 个关键码；如果按下层结点“最大关键码复写”原则，则树中每个非叶结点中有 m 棵子树必有 m 个关键码</li>
<li>在搜索过程中，如果查询和内部节点的关键字一致，那么搜索过程不停止，而是继续向下搜索这个分支。</li>
</ul>
<p>根据B+树的结构，我们可以发现B+树相比于B树，在文件系统，数据库系统当中，更有优势，原因如下：<br><strong>B+树的磁盘读写代价更低</strong><br>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说I/O读写次数也就降低了。</p>
<p><strong>B+树的查询效率更加稳定</strong><br>由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p><strong>B+树更有利于对数据库的扫描</strong><br>B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题，而B+树只需要遍历叶子节点就可以解决对全部关键字信息的扫描，所以对于数据库中频繁使用的range query，B+树有着更高的性能</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><h4 id="B树-1"><a href="#B树-1" class="headerlink" title="B树"></a>B树</h4><h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h4><h5 id="聚簇索引-1"><a href="#聚簇索引-1" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><h5 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h5><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><h3 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h3><h4 id="为频繁查询的字段建立索引"><a href="#为频繁查询的字段建立索引" class="headerlink" title="为频繁查询的字段建立索引"></a>为频繁查询的字段建立索引</h4><h4 id="避免为大字段建立索引"><a href="#避免为大字段建立索引" class="headerlink" title="避免为大字段建立索引"></a>避免为大字段建立索引</h4><h4 id="选择区分度大的列作索引"><a href="#选择区分度大的列作索引" class="headerlink" title="选择区分度大的列作索引"></a>选择区分度大的列作索引</h4><p>最好是连续且分散的，不要用uuid</p>
<h4 id="对常进行order-by和group-by的字段作索引"><a href="#对常进行order-by和group-by的字段作索引" class="headerlink" title="对常进行order by和group by的字段作索引"></a>对常进行order by和group by的字段作索引</h4><h4 id="频繁修改的字段不做索引"><a href="#频繁修改的字段不做索引" class="headerlink" title="频繁修改的字段不做索引"></a>频繁修改的字段不做索引</h4><h4 id="索引不要提多"><a href="#索引不要提多" class="headerlink" title="索引不要提多"></a>索引不要提多</h4><h3 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h3><h4 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h4><h4 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h4><h4 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h4><h4 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h4><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul>
<li><code>or</code>会导致索引失效，但是单列索引是有效的</li>
<li>不符合左前缀原则会失效</li>
<li>模糊查询%开头会导致失效</li>
<li>隐式类型转换会导致失效</li>
<li>条件中使用函数会失效</li>
<li>IN肯定会走索引，但是当IN的取值范围较大时会导致索引失效，走全表扫描</li>
</ul>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/Kaiyuan/donate-page" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.png"></li><li id="WeChat" qr="/img/WeChatQR.png"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="tags"><a href="/tags/MySQL"><i class="fa fa-tag">MySQL</i></a></div><div class="post-nav"><a class="pre" href="/2020/10/27/Spring/">Spring</a><a class="next" href="/2019/11/08/java8%E2%80%94%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/">java8—接口中的静态方法和默认方法</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'NPvQJfh7XNHqMqbmVYOg5VE5-9Nh9j0Va',
  appKey:'hgOdKtBYlsJzigDKoXqevrSI',
  placeholder:'我想听你说一句… （留言请填写您的昵称和邮箱，方便回复以邮件形式通知您）',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-TRee"><span class="toc-text">MySQL为什么使用B+TRee</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-text">B树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-text">B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%ADB-%E6%A0%91%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%9C%89%E5%A4%9A%E5%A4%A7%EF%BC%9F%E4%B8%80%E5%8D%83%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8CB-%E6%A0%91%E5%A4%9A%E9%AB%98%EF%BC%9F"><span class="toc-text">MySQL InnoDB存储引擎中B+树一个节点有多大？一千万条数据，B+树多高？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83"><span class="toc-text">存储单元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E9%A1%B5%E5%A4%A7%E5%B0%8F"><span class="toc-text">InnoDB引擎的页大小</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">B+树的存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E5%A6%82%E4%BD%95%E6%A3%80%E7%B4%A2%E8%AE%B0%E5%BD%95"><span class="toc-text">B+树如何检索记录</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E8%A1%8C%E6%95%B0%E6%8D%AE"><span class="toc-text">叶子节点可以存放多少行数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E6%8C%87%E9%92%88"><span class="toc-text">非叶子节点可以存放多少指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E9%A2%97B-%E6%A0%91%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E8%A1%8C%E8%AE%B0%E5%BD%95"><span class="toc-text">一颗B+树可以存放多少行记录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-VS-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-VS-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-text">主键索引 VS 唯一索引 VS 普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">聚合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-text">覆盖索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">索引的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-TREE%E7%B4%A2%E5%BC%95"><span class="toc-text">B-TREE索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91-1"><span class="toc-text">B树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91-1"><span class="toc-text">B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-1"><span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">非聚簇索引</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5"><span class="toc-text">索引策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E9%A2%91%E7%B9%81%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AD%97%E6%AE%B5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-text">为频繁查询的字段建立索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%B8%BA%E5%A4%A7%E5%AD%97%E6%AE%B5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-text">避免为大字段建立索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%8C%BA%E5%88%86%E5%BA%A6%E5%A4%A7%E7%9A%84%E5%88%97%E4%BD%9C%E7%B4%A2%E5%BC%95"><span class="toc-text">选择区分度大的列作索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%B8%B8%E8%BF%9B%E8%A1%8Corder-by%E5%92%8Cgroup-by%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BD%9C%E7%B4%A2%E5%BC%95"><span class="toc-text">对常进行order by和group by的字段作索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%91%E7%B9%81%E4%BF%AE%E6%94%B9%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%81%9A%E7%B4%A2%E5%BC%95"><span class="toc-text">频繁修改的字段不做索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8D%E8%A6%81%E6%8F%90%E5%A4%9A"><span class="toc-text">索引不要提多</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%9F%A5%E8%AF%A2"><span class="toc-text">匹配查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-text">全值匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80"><span class="toc-text">匹配最左前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%88%97%E5%89%8D%E7%BC%80"><span class="toc-text">匹配列前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4%E5%80%BC"><span class="toc-text">匹配范围值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">索引失效</span></a></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>