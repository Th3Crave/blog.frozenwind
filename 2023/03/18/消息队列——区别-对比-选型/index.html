<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。"><title>消息队列—区别/对比/选型 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bbf19a98c9ae28f2e1e8cfcee1d9585e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">消息队列—区别/对比/选型</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/message/"><i class="fa fa-comment"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">消息队列—区别/对比/选型</h1><div class="post-meta">2023-03-18<span> | </span><span class="category"><a href="/categories/technology/">technology</a><a href="/categories/technology/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><a href="/categories/technology/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></span></div><div class="post-content"><p><img src="/2023/03/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E5%8C%BA%E5%88%AB-%E5%AF%B9%E6%AF%94-%E9%80%89%E5%9E%8B/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="消息队列发展史"><br><img src="/2023/03/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E5%8C%BA%E5%88%AB-%E5%AF%B9%E6%AF%94-%E9%80%89%E5%9E%8B/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.jpeg" alt="主流消息队列对比"></p>
<ul>
<li>什么是消息队列</li>
<li>消息队列的应用场景</li>
<li>消息队列技术选型，Kafka还是RocketMQ，还是RabbitMQ</li>
<li>消息中间件如何做到高可用？</li>
<li>消息队列如何解决消息丢失问题</li>
<li>消息队列如何保证消息的顺序性。</li>
<li>消息队列有可能发生重复消费吗？如何幂等处理？</li>
<li>如何处理消息队列的消息积压问题</li>
<li>如何保证数据一致性，事务消息如何实现</li>
<li>如果让你写一个消息队列，该如何进行架构设计？</li>
</ul>
<h2 id="消息队列应用场景"><a href="#消息队列应用场景" class="headerlink" title="消息队列应用场景"></a>消息队列应用场景</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><h3 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h3><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><h3 id="引入消息队列的劣势分析"><a href="#引入消息队列的劣势分析" class="headerlink" title="引入消息队列的劣势分析"></a>引入消息队列的劣势分析</h3><p>引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。<br>一个使用了MQ的项目，如果连MQ的缺点都没有考虑过，就把MQ引进去了，那就会给自己的项目带来风险。</p>
<ul>
<li>系统可用性降低<br>  系统的可用性会受消息队列的可用性影响。</li>
<li>系统复杂度提高<br>  引入消息队列后，要多考虑很多方面的问题。<br>  消息丢失、消息重复消息、消息可靠传输、消息积压、数据一致性等等。<br>  需要考虑的东西多了，系统复杂性随之增加。</li>
<li>一致性问题</li>
</ul>
<h2 id="消息中间件基本架构"><a href="#消息中间件基本架构" class="headerlink" title="消息中间件基本架构"></a>消息中间件基本架构</h2><h3 id="架构组成"><a href="#架构组成" class="headerlink" title="架构组成"></a>架构组成</h3><ul>
<li>Producer 生产者，消息的产生方，生产者会将消息发送到消息队列。</li>
<li>queue 消息队列，接受并存储生产者的消息。</li>
<li>Consumer 消费者，消费消息队列中的消息。</li>
</ul>
<h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><h4 id="发布-订阅模式（一对多）"><a href="#发布-订阅模式（一对多）" class="headerlink" title="发布-订阅模式（一对多）"></a>发布-订阅模式（一对多）</h4><p>消费者消费完消息后，消息不会被删除，消息会存储一段时间，这种模式下的消息会被所有消费者消费。</p>
<h4 id="点对点模式（一对一）"><a href="#点对点模式（一对一）" class="headerlink" title="点对点模式（一对一）"></a>点对点模式（一对一）</h4><p>点对点模式是消费者主动拉取数据，消息确认被消费后，消息队列会删除队列中的消息，一条消息只会被一个消费者消费。</p>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul>
<li>如果消息队列不是将要构建系统的重点，对消息队列功能和性能没有很高的要求，只需要一个快速上手易于维护的消息队列，建议使用 RabbitMQ。</li>
<li>如果系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，需要低延迟和高稳定性，建议使用 RocketMQ。</li>
<li>如果需要处理海量的消息，像收集日志、监控信息或是埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那 Kafka 是最适合的消息队列。</li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="1-高可用"><a href="#1-高可用" class="headerlink" title="1. 高可用"></a>1. 高可用</h3><p>基于副本机制实现 Kafka 的高可用。</p>
<p>Kafka 集群由若干个 Broker 组成，Topic 由若干个 Partition 组成，每个 Partition 可存在不同的 Broker 上。可以这样说，一个 Topic 的数据，分散在多个机器上，即每个机器上都存放一部分数据。</p>
<ul>
<li>Kafka 0.8以前<br>  Kafka 0.8 以前是没有高可用机制的。<br>  假设一个 Topic，由 3 个 Partiton 组成。3 个 Partition 在不同机器上，如果其中某一台机器宕掉了，则 Topic 的部分数据就丢失了。</li>
<li>Kafka 0.8以后<br>  Kafka 0.8 以后，通过副本机制来实现高可用。</li>
</ul>
<h3 id="2-消息丢失"><a href="#2-消息丢失" class="headerlink" title="2. 消息丢失"></a>2. 消息丢失</h3><p>经过参数优化配置，能够做到零丢失。</p>
<h4 id="Producer丢失数据"><a href="#Producer丢失数据" class="headerlink" title="Producer丢失数据"></a>Producer丢失数据</h4><p>如果 Producer 端设置了 acks=all，则不会丢失数据。<br>Leader 在所有的 Follower 都同步到了消息之后，才认为本次写成功。如果没满足这个条件，生产者会进行无限次重试。</p>
<h4 id="Broker丢失数据"><a href="#Broker丢失数据" class="headerlink" title="Broker丢失数据"></a>Broker丢失数据</h4><p>比较常见的一个场景：Kafka 某个 Broker 宕机，然后重新选举新的 Leader ，但此时其他的 Follower 部分数据尚未同步，结果此时 Leader 挂了，然后选举某个 Follower 成 Leader，丢失一部分数据。</p>
<p>一般设置如下 4 个参数：</p>
<ul>
<li>Topic 设置<code>replication.factor</code>参数<br>  参数值必须大于 1，要求每个 Partition 必须有至少 2 个副本。</li>
<li>Kafka 服务端设置 <code>min.insync.replicas</code> 参数<br>  参数值必须大于 1，要求每个 Partition 必须有至少 2 个副本。</li>
<li>Producer 设置 <code>acks=all</code><br>  要求每条数据，必须是写入所有副本，才认为写成功。</li>
<li>Producer 端设置 <code>retries=MAX</code><br>  MAX 即是一个超级大的数字，表示无限次重试。<code>retries=MAX</code>要求一旦写入数据失败，就无限重试。</li>
</ul>
<h4 id="Consumer丢失数据"><a href="#Consumer丢失数据" class="headerlink" title="Consumer丢失数据"></a>Consumer丢失数据</h4><p>默认情况下，Kafka 会自动提交 Offset，Kafka 认为 Consumer 已经处理消息了，但是 Consumer 可能在处理消息的过程中挂掉了。重启系统后，Consumer 会根据提交的 Offset 进行消费，也就丢失了一部分数据。</p>
<p>解决：关闭自动提交 Offset，在处理完之后自己手动提交 Offset，就可以保证数据不会丢失。但可能会存在消息重复消费问题。 </p>
<h3 id="3-重复消费"><a href="#3-重复消费" class="headerlink" title="3. 重复消费"></a>3. 重复消费</h3><h4 id="消费者相关参数"><a href="#消费者相关参数" class="headerlink" title="消费者相关参数"></a>消费者相关参数</h4><ul>
<li><code>enable.auto.commit</code>：表示消费者会周期性自动提交消费的offset。默认值true。</li>
<li><code>auto.commit.interval.ms</code>：在<code>enable.auto.commit为</code>true的情况下，自动提交的间隔。默认值5秒。</li>
<li><code>max.poll.records</code>：单次消费者拉取的最大数据条数，默认值500。</li>
<li><code>max.poll.interval.ms</code>：表示若在阈值时间之内消费者没有消费完上一次poll的消息，consumer client会主动向 coordinator 发起LeaveGroup请求，触发Rebalance；然后consumer重新发送JoinGroup请求。</li>
<li><code>session.timeout.ms</code>：group Coordinator 检测consumer发生崩溃所需的时间。在这个时间内如果Coordinator未收到Consumer的任何消息，那Coordinator就认为Consumer挂了。默认值10秒。</li>
<li><code>heartbeat.interval.ms</code>：标识Consumer给Coordinator发一个心跳包的时间间隔。heartbeat.interval.ms越小，发的心跳包越多。默认值3秒。</li>
<li>Group Coordinator<br>  对于每一个Consumer Group，Kafka集群为其从Broker集群中选择一个Broker作为其Coordinator。Coordinator主要做两件事：<ol>
<li>维持Group成员的组成。这包括加入新的成员，检测成员的存活性，清除不再存活的成员。</li>
<li>协调Group成员的行为。</li>
</ol>
</li>
</ul>
<h4 id="重复消费的原因"><a href="#重复消费的原因" class="headerlink" title="重复消费的原因"></a>重复消费的原因</h4><ul>
<li>原因1：消费者宕机、重启或者被强行kill进程，导致消费者消费的offset没有提交。</li>
<li>原因2：设置<code>enable.auto.commit</code>为true，如果在关闭消费者进程之前，取消了消费者的订阅，则有可能部分offset没提交，下次重启会重复消费。</li>
<li>原因3：消费后的数据，当offset还没有提交时，Partition就断开连接。比如，通常会遇到消费的数据，处理很耗时，导致超过了Kafka的<code>session timeout.ms</code>时间，那么就会触发reblance重平衡，此时可能存在消费者offset没提交，会导致重平衡后重复消费。</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>提高消费者的处理速度。<br> 例如：对消息处理中比较耗时的步骤可通过异步的方式进行处理、利用多线程处理等。<br> 在缩短单条消息消费的同时，根据实际场景可将<code>max.poll.interval.ms</code>值设置大一点，避免不必要的Rebalance。<br> 可根据实际消息速率适当调小<code>max.poll.records</code>的值。</li>
<li>引入消息去重机制。<br> 例如：生成消息时，在消息中加入唯一标识符，如消息id等。在消费端，可以保存最近的<code>max.poll.records</code>条消息id到redis或mysql表中，这样在消费消息时先通过查询去重后，再进行消息的处理。</li>
<li>保证消费者逻辑幂等。<blockquote>
<p>如何实现接口的幂等性</p>
</blockquote>
</li>
</ol>
<h3 id="4-顺序消费"><a href="#4-顺序消费" class="headerlink" title="4. 顺序消费"></a>4. 顺序消费</h3><h3 id="5-消息积压"><a href="#5-消息积压" class="headerlink" title="5. 消息积压"></a>5. 消息积压</h3><h3 id><a href="#" class="headerlink" title></a></h3></div><div class="tags"><a href="/tags/消息队列"><i class="fa fa-tag">消息队列</i></a></div><div class="post-nav"><a class="pre" href="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/">消息队列——Kafka</a><a class="next" href="/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Redis数据结构</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '8359b7a19b78f2b9e112',
  clientSecret: '5ad69dc1633a1834322067d017b6313bd231457c',
  repo: 'gitalk',
  owner: 'Th3Crave',
  admin: ['Th3Crave'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">消息队列应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-text">异步处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6"><span class="toc-text">系统解耦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0"><span class="toc-text">流量削峰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8A%A3%E5%8A%BF%E5%88%86%E6%9E%90"><span class="toc-text">引入消息队列的劣势分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="toc-text">消息中间件基本架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%BB%84%E6%88%90"><span class="toc-text">架构组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">两种模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%89"><span class="toc-text">发布-订阅模式（一对多）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%89"><span class="toc-text">点对点模式（一对一）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B"><span class="toc-text">技术选型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka"><span class="toc-text">Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">1. 高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="toc-text">2. 消息丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Producer%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE"><span class="toc-text">Producer丢失数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Broker%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE"><span class="toc-text">Broker丢失数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consumer%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE"><span class="toc-text">Consumer丢失数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-text">3. 重复消费</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-text">消费者相关参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">重复消费的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="toc-text">4. 顺序消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B"><span class="toc-text">5. 消息积压</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>