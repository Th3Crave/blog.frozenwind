<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java IO - 基础 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java IO - 基础</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/MoonAndStar/"><i class="fa fa-heart"> Moon&amp;Star</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java IO - 基础</h1><div class="post-meta">2023-03-21<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><a class="disqus-comment-count" href="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/#vcomment"><span class="valine-comment-count" data-xid="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/"></span><span> 条评论</span></a><div class="post-content"><h2 id="Java-IO分类"><a href="#Java-IO分类" class="headerlink" title="Java IO分类"></a>Java IO分类</h2><p>从<strong>传输方式</strong>和<strong>数据操作</strong>两个方面分析Java IO的分类。</p>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>字节是给计算机看的，字符才是给人看的。</p>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>InputStream<br>OutputStream</p>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>Reader<br>Writer</p>
<h4 id="字节和字符的区别和理解"><a href="#字节和字符的区别和理解" class="headerlink" title="字节和字符的区别和理解"></a>字节和字符的区别和理解</h4><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><ul>
<li>文件(file)<br>FileInputStream、FileOutputStream、FileReader、FileWriter</li>
<li>数组([])<br>字节数组(byte[]): ByteArrayInputStream、ByteArrayOutputStream<br>字符数组(char[]): CharArrayReader、CharArrayWriter</li>
<li>管道操作<br>PipedInputStream、PipedOutputStream、PipedReader、PipedWrite</li>
<li>基本数据类型<br>DataInputStream、DataOutputStream</li>
<li>缓冲操作<br>BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</li>
<li>打印<br>PrintStream、PrintWriter</li>
<li>对象序列化反序列化<br>ObjectInputStream、ObjectOutputStream</li>
<li>转换<br>InputStreamReader、OutputStreamWriter</li>
</ul>
<h2 id="Java-IO的设计模式-装饰者模式"><a href="#Java-IO的设计模式-装饰者模式" class="headerlink" title="Java IO的设计模式 - 装饰者模式"></a>Java IO的设计模式 - 装饰者模式</h2><h2 id="Java-IO源码-InputStream"><a href="#Java-IO源码-InputStream" class="headerlink" title="Java IO源码 - InputStream"></a>Java IO源码 - InputStream</h2><h2 id="Java-IO源码-OutputStream"><a href="#Java-IO源码-OutputStream" class="headerlink" title="Java IO源码 - OutputStream"></a>Java IO源码 - OutputStream</h2><h2 id="IO模型-Unix-IO模型"><a href="#IO模型-Unix-IO模型" class="headerlink" title="IO模型 - Unix IO模型"></a>IO模型 - Unix IO模型</h2><h3 id="Unix的5种IO模型"><a href="#Unix的5种IO模型" class="headerlink" title="Unix的5种IO模型"></a>Unix的5种IO模型</h3><h4 id="阻塞I-O-blocking-IO"><a href="#阻塞I-O-blocking-IO" class="headerlink" title="阻塞I/O     blocking IO"></a>阻塞I/O     blocking IO</h4><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。<br>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p>
<p>下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。<br><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-%E9%98%BB%E5%A1%9Eio.png"></p>
<h4 id="非阻塞I-O-nonblocking-I-O"><a href="#非阻塞I-O-nonblocking-I-O" class="headerlink" title="非阻塞I/O   nonblocking I/O"></a>非阻塞I/O   nonblocking I/O</h4><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。<br>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。<br><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-%E9%9D%9E%E9%98%BB%E5%A1%9Eio.png"></p>
<h4 id="I-O复用-I-O-multiplexing"><a href="#I-O复用-I-O-multiplexing" class="headerlink" title="I/O复用     I/O multiplexing"></a>I/O复用     I/O multiplexing</h4><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。<br>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。<br>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。<br><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-io%E5%A4%8D%E7%94%A8.png"></p>
<h4 id="信号驱动I-O-signal-driven-I-O-SIGIO"><a href="#信号驱动I-O-signal-driven-I-O-SIGIO" class="headerlink" title="信号驱动I/O  signal driven I/O (SIGIO)"></a>信号驱动I/O  signal driven I/O (SIGIO)</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。<br>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。<br><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io.png"></p>
<h4 id="异步I-O-asynchronous-I-O"><a href="#异步I-O-asynchronous-I-O" class="headerlink" title="异步I/O     asynchronous I/O"></a>异步I/O     asynchronous I/O</h4><p>进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。<br>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。<br><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-%E5%BC%82%E6%AD%A5io.png"></p>
<h3 id="I-O模型比较"><a href="#I-O模型比较" class="headerlink" title="I/O模型比较"></a>I/O模型比较</h3><p><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-%E6%AF%94%E8%BE%83.png"><br>前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p>
<p>同步 I/O: 应用进程在调用 recvfrom 操作时会阻塞。<br>异步 I/O: 不会阻塞。<br>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><blockquote>
<p>IO多路复用最为重要，后面的文章<strong>Java IO - NIO</strong>将对IO多路复用，Ractor模型以及Java NIO对其的支持作详解。</p>
</blockquote>
<h4 id="IO多路复用工作模式"><a href="#IO多路复用工作模式" class="headerlink" title="IO多路复用工作模式"></a>IO多路复用工作模式</h4><p>epoll 的描述符事件有两种触发模式: LT(level trigger)和 ET(edge trigger)。</p>
<p><strong>LT模式</strong><br>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。<br>是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。<br><strong>ET模式</strong><br>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。<br>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。<br>只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h4 id="应用场景-select-amp-poll-amp-epoll"><a href="#应用场景-select-amp-poll-amp-epoll" class="headerlink" title="应用场景 select&amp;poll&amp;epoll"></a>应用场景 select&amp;poll&amp;epoll</h4><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。<br><strong>selent</strong><br><strong>poll</strong><br><strong>epoll</strong></p>
<h2 id="IO基础知识与概念"><a href="#IO基础知识与概念" class="headerlink" title="IO基础知识与概念"></a>IO基础知识与概念</h2><h3 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h3><p>在计算机操作系统中，所谓的I/O就是<strong>输入 input</strong>和<strong>输出 output</strong>，也可以理解为<strong>读 read</strong>和<strong>写 write</strong>。<br>针对不同的对象，I/O模式可以划分为<strong>磁盘IO</strong>和<strong>网络IO</strong>。</p>
<p>I/O操作会涉及到<strong>用户空间</strong>和<strong>内核空间</strong>的转换，理解以下规则：</p>
<ul>
<li>内存空间分为用户空间和内核空间，也称为用户缓冲区和内核缓冲区；</li>
<li>用户的应用程序不能直接操作内核空间，需要将数据从内核空间拷贝到用户空间才能使用；</li>
<li>无论是read操作，还是write操作，都只能在内核空间里执行；</li>
<li>磁盘IO和网络IO请求加载到内存的数据都是先放在内核空间的。</li>
</ul>
<p>在IO中（磁盘IO或者是网络IO），都是由用户去调用<strong>Read</strong>读取内核态中的数据，读取数据到用户态；而<strong>write</strong>则是将数据从用户态写到内核态中，由内核去写入文件或者是通过网络IO（网卡）发送数据。</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符(fd, File Descriptor)，用于描述指向文件的引用的抽象化概念。</p>
<p>当应用程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。<br>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。<br>在Linxu系统中，一切皆文件，因此socket也是一个文件，也有文件句柄（或文件描述符）。</p>
<h3 id="操作系统的内核态和用户态"><a href="#操作系统的内核态和用户态" class="headerlink" title="操作系统的内核态和用户态"></a>操作系统的内核态和用户态</h3><p>Linux系统中分为<strong>内核态 Kernel Model</strong>和<strong>用户态 User Model</strong>，CPU会在两个Model之间切换。</p>
<p>通俗点讲，<strong>内核空间</strong>是操作系统内核代码运行的地方，<strong>用户空间</strong>是用户程序代码运行的地方。<br>当应用进程在运行用户代码时就处于<strong>用户态</strong>。<br>当应用进程执行系统调用，从而内核代码执行时就处于<strong>内核态</strong>。</p>
<p>内核空间可以执行任意的命令，而用户空间只能执行简单的运算，不能直接调用系统资源和数据。必须通过操作系统提供接口，向系统内核发送指令。<br>一旦调用系统接口，应用进程就从用户态切换到内核态了，因为开始运行内核代码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;i am qige&quot;</span> <span class="comment">// 用户空间，赋值运算</span></span><br><span class="line">x = x + <span class="number">2</span>         <span class="comment">// 用户空间，赋值运算</span></span><br><span class="line">file.write(str)   <span class="comment">// 切换到内核空间。因为用户不能直接写文件，必须通过内核安排。</span></span><br><span class="line">y = x + <span class="number">4</span>         <span class="comment">// 切换回用户空间</span></span><br></pre></td></tr></table></figure>

<h4 id="用户态切换到内核态的3种方式"><a href="#用户态切换到内核态的3种方式" class="headerlink" title="用户态切换到内核态的3种方式"></a>用户态切换到内核态的3种方式</h4><ol>
<li>系统调用<br> 也称为 System Call，是说用户态进程<strong>主动</strong>要求切换到内核态的一种方式，用户态进程使用操作系统提供的服务程序完成工作。</li>
<li>异常<br> 当CPU在用户空间执行程序代码时发生了不可预期的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，切换到内核态，比如缺页异常。</li>
<li>外围设备的中断<br> 当外围设备完成用户请求的某些操作后，会向CPU发送相应的中断信号，这时CPU会暂停执行下一条即将执行的指令转而去执行与中断信号对应的处理程序，如果当前正在运行用户态下的程序指令，自然就发生由用户态到内核态的切换。<br> 比如硬盘数据读写完成，系统会切换到中断处理程序中执行后续操作等。</li>
</ol>
<h3 id="磁盘IO-amp-网络IO"><a href="#磁盘IO-amp-网络IO" class="headerlink" title="磁盘IO &amp; 网络IO"></a>磁盘IO &amp; 网络IO</h3><h4 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h4><p><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/IO%E5%9F%BA%E7%A1%80-%E7%A3%81%E7%9B%98IO.png"></p>
<p><strong>读操作</strong><br>当应用程序调用read()方法时，操作系统检查内核高速缓冲区中是否存在需要的数据。<br>如果存在，那么就直接把内核空间的数据copy到用户空间，供用户的应用程序使用。<br>如果内核缓冲区没有需要的数据，那么通过DMA方式从磁盘中读取数据到内核缓冲区，然后由CPU控制，把内核空间的数据copy到用户空间。</p>
<p>这个过程会涉及到两次缓冲区copy，第一次是从磁盘到内核缓冲区，第二次是从内核缓冲区到用户缓冲区，第一次是DMA的copy，第二次是CPU的copy。</p>
<p><strong>写操作</strong><br>当应用程序调用write()方法时，应用程序将数据从用户空间copy到内核空间的缓冲区中（如果用户空间没有相应的数据，则需要从磁盘—&gt;内核缓冲区—&gt;用户缓冲区），这时对用户程序来说写操作就已经完成。<br>至于什么时候把数据再写到磁盘（从内核缓冲区到磁盘的写操作也由DMA控制，不需要cpu参与），由操作系统决定。<br>除非应用程序显示地调用了sync命令，立即把数据写入磁盘。</p>
<p>如果应用程序没准备好写的数据，则必须先从磁盘读取数据才能执行写操作。<br>这时会涉及到<strong>四次</strong>缓冲区的copy，第一次是从磁盘的缓冲区到内核缓冲区，第二次是从内核缓冲区到用户缓冲区，第三次是从用户缓冲区到内核缓冲区，第四次是从内核缓冲区写回到磁盘。前两次是为了读，后两次是为了写。这其中有两次 CPU 拷贝，两次DMA拷贝。</p>
<p><strong>磁盘IO的延时</strong><br>为了读或写，磁头必须能移动到所指定的磁道上，并等待所指定的扇区的开始位置旋转到磁头下，然后再开始读或写数据。<br>磁盘IO的延时分成以下三部分：</p>
<ul>
<li>寻道时间：把磁头移动到指定磁道上所经历的时间；</li>
<li>旋转延迟时间 ：指定扇区移动到磁头下面所经历的时间；</li>
<li>传输时间 ：数据的传输时间（数据读出或写入的时间）。</li>
</ul>
<h4 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h4><p><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/IO%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9CIO.png"></p>
<p><strong>读操作</strong><br>网络 IO 既可以从物理磁盘中读数据，也可以从Socket中读数据（从网卡中获取）。<br>当从物理磁盘中读数据的时候，其流程和磁盘IO的读操作一样。<br>当从Socket中读数据，应用程序需要等待客户端发送数据，如果客户端还没有发送数据，对应的应用程序将会被阻塞，直到客户端发送了数据，该应用程序才会被唤醒，从Socket协议栈（网卡）中读取客户端发送的数据到内核空间的Socket Buffer（这个过程也由DMA控制），然后把内核空间的数据 copy 到用户空间，供应用程序使用。</p>
<p><strong>写操作</strong><br>假设网络IO的数据从磁盘中获取，读写操作的流程如下：</p>
<ul>
<li>当应用程序调用 read() 方法时，通过DMA方式将数据从磁盘拷贝到内核缓冲区；</li>
<li>由cpu控制，将内核缓冲区的数据拷贝到用户空间的缓冲区中，供应用程序使用；</li>
<li>当应用程序调用 write() 方法时，CPU 会把用户缓冲区中的数据 copy 到内核缓冲区的 Socket Buffer 中；</li>
<li>最后通过DMA方式将内核空间中的Socket Buffer拷贝到Socket协议栈（即网卡设备）中传输。</li>
</ul>
<p>网络IO 的写操作也有<strong>四次</strong>缓冲区的copy，第一次是从磁盘缓冲区到内核缓冲区（由DMA控制），第二次是内核缓冲区到用户缓冲区（CPU控制），第三次是用户缓冲区到内核缓冲区的 Socket Buffer（由CPU控制），第四次是从内核缓冲区的 Socket Buffer 到网卡设备（由DMA控制）。四次缓冲区的copy工作两次由CPU控制，两次由DMA控制。</p>
<p><strong>网络IO的延时</strong><br>网络IO主要延时是由：<strong>服务器响应延时+带宽限制+网络延时+跳转路由延时+本地接收延时</strong>决定。一般为几十到几千毫秒，受环境影响较大。<br>所以，一般来说，网络IO延时要大于磁盘IO延时(不过同数据中心的交互除外，会比磁盘 IO 更快)。</p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>mmap 是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一映射关系。</p>
<h4 id="sendFile"><a href="#sendFile" class="headerlink" title="sendFile"></a>sendFile</h4><p><strong>sendfile</strong>要求输入的fd必须是文件句柄，不能是socket，输出的fd必须是socket，也就是说，数据的来源必须是从本地的磁盘，而不能是从网络中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span></span><br></pre></td></tr></table></figure>
<p>in_fd 必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。<br>由此可见，sendfile 几乎是专门为在网络上传输文件而设计的。</p>
<h3 id="数据传输方式-PIO-amp-DMA"><a href="#数据传输方式-PIO-amp-DMA" class="headerlink" title="数据传输方式 PIO &amp; DMA"></a>数据传输方式 PIO &amp; DMA</h3><p>DMA（直接存储器访问）和 PIO（程控输入/输出）。<br>DMA和PIO分别是在电子设备中传输信息的两种方式；在计算机和其他类似设备中更为著名。<br>PIO是一种较老的方法，由于某些优点，在大多数应用中已被DMA取代。</p>
<h3 id="缓冲IO-amp-直接IO"><a href="#缓冲IO-amp-直接IO" class="headerlink" title="缓冲IO &amp; 直接IO"></a>缓冲IO &amp; 直接IO</h3><h4 id="缓冲IO"><a href="#缓冲IO" class="headerlink" title="缓冲IO"></a>缓冲IO</h4><p>机械硬盘的读写原理与特点是：一个机械硬盘中装有多个盘片，每个盘片上有多个同心圆（磁道），每个同心圆又由多个弧（扇区）组成，每个弧上都记录了等量的数据（比方说512byte）。<br>如果发起一个随机读写请求，磁头需要先找到对应的磁道，然后等待对应的扇区旋转到磁头正下方才能开始读取数据（民用机械硬盘的转速一般在5400或者7200RPM，工业界倒是经常使用10000RPM的机械硬盘。但是它们的寻道时间大概都在几ms到十几ms左右）。<br>机械硬盘的顺序读写很快（一般在100-200MB/s），但是随机读写很慢（寻道时间在十几ms，导致随机读写的iops只有几十）。</p>
<p>假定我们不做任何额外的优化处理，在用户发起读数据请求的时候，直接调用硬盘驱动读取磁盘数据并返回。<br>设想一个场景：循环调用read方法读取文件，但是每次只读取较少的数据（比方说每次只读一个byte）。那么每次read请求都对应于一次对磁盘的随机读写（两次读请求之前需要重新寻道），也就是说read操作的tps只有几十。<br>也就是说此时磁盘占用率为100%，但是只能提供不到100byte/s的数据读取率，这显然是不可接受的。</p>
<p>Linux对此有个很简单的优化，就是在内核中维护一块缓冲区（buffer cache），在用户第一次调用read读取数据的时候，无论用户想要读取的数据有多小，都会一次性从磁盘中加载一段数据放到缓冲区中，根据局部性原理，这样用户下一次调用read方法的时候可以直接从缓冲区中返回数据，不用再次访问磁盘了。<br>write方法也是同理，用户写入的数据不是直接落盘，而是先写到kernel中的缓冲区里，按照一定的策略批量刷盘。当然也可以调用flush方法强制将缓存区的数据落盘。<br>这个优化极大的提高了顺序读写的效率。由于直接读写的是kernel中的缓冲区而不是磁盘，这种IO被称为缓冲IO。</p>
<h4 id="直接IO"><a href="#直接IO" class="headerlink" title="直接IO"></a>直接IO</h4><p>一般来说，缓冲IO已经足够应付日常需求了。但是像数据库这种极度依赖IO的应用程序，为了追求极致的性能，往往更加愿意自己直接操作磁盘。<br>直接IO可以直接将数据从磁盘复制到用户空间，或者将数据从用户空间写到磁盘，减少了kernel中的缓冲区这一环节，这是直接IO可以提高性能的原理。<br>但是如果用得不好就悲剧了，所以直接IO只在少数场景下使用。</p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/Kaiyuan/donate-page" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.png"></li><li id="WeChat" qr="/img/WeChatQR.png"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="tags"><a href="/tags/Java"><i class="fa fa-tag">Java</i></a></div><div class="post-nav"><a class="pre" href="/2023/03/21/JavaIO-NIO/">Java IO - NIO</a><a class="next" href="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/">消息队列——Kafka</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'NPvQJfh7XNHqMqbmVYOg5VE5-9Nh9j0Va',
  appKey:'hgOdKtBYlsJzigDKoXqevrSI',
  placeholder:'我想听你说一句… （留言请填写您的昵称和邮箱，方便回复以邮件形式通知您）',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO%E5%88%86%E7%B1%BB"><span class="toc-text">Java IO分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-text">传输方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">字节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">字符流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%92%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%90%86%E8%A7%A3"><span class="toc-text">字节和字符的区别和理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-text">数据操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">Java IO的设计模式 - 装饰者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO%E6%BA%90%E7%A0%81-InputStream"><span class="toc-text">Java IO源码 - InputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO%E6%BA%90%E7%A0%81-OutputStream"><span class="toc-text">Java IO源码 - OutputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B-Unix-IO%E6%A8%A1%E5%9E%8B"><span class="toc-text">IO模型 - Unix IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unix%E7%9A%845%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="toc-text">Unix的5种IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EI-O-blocking-IO"><span class="toc-text">阻塞I&#x2F;O     blocking IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EI-O-nonblocking-I-O"><span class="toc-text">非阻塞I&#x2F;O   nonblocking I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O%E5%A4%8D%E7%94%A8-I-O-multiplexing"><span class="toc-text">I&#x2F;O复用     I&#x2F;O multiplexing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8I-O-signal-driven-I-O-SIGIO"><span class="toc-text">信号驱动I&#x2F;O  signal driven I&#x2F;O (SIGIO)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5I-O-asynchronous-I-O"><span class="toc-text">异步I&#x2F;O     asynchronous I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-text">I&#x2F;O模型比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">IO多路复用工作模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-select-amp-poll-amp-epoll"><span class="toc-text">应用场景 select&amp;poll&amp;epoll</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-text">IO基础知识与概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIO"><span class="toc-text">什么是IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">文件描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-text">操作系统的内核态和用户态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%88%87%E6%8D%A2%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">用户态切换到内核态的3种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98IO-amp-%E7%BD%91%E7%BB%9CIO"><span class="toc-text">磁盘IO &amp; 网络IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98IO"><span class="toc-text">磁盘IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9CIO"><span class="toc-text">网络IO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap"><span class="toc-text">mmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendFile"><span class="toc-text">sendFile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F-PIO-amp-DMA"><span class="toc-text">数据传输方式 PIO &amp; DMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2IO-amp-%E7%9B%B4%E6%8E%A5IO"><span class="toc-text">缓冲IO &amp; 直接IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2IO"><span class="toc-text">缓冲IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5IO"><span class="toc-text">直接IO</span></a></li></ol></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>