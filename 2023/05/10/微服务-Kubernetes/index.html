<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。"><title>Kubernetes | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bbf19a98c9ae28f2e1e8cfcee1d9585e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kubernetes</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/message/"><i class="fa fa-comment"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kubernetes</h1><div class="post-meta">2023-05-10<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><div class="post-content"><p>Kubernetes是一个开源容器管理工具，负责容器部署，容器扩缩容以及负载平衡。<br>作为Google的创意之作，它提供了出色的社区，并与所有云提供商合作。因此，我们可以说Kubernetes不是一个容器化平台，而是一个多容器管理解决方案。</p>
<p>众所周知，Docker提供容器的生命周期管理，Docker镜像构建运行时容器。但是，由于这些单独的容器必须通信，因此使用Kubernetes。因此，我们说Docker构建容器，这些容器通过Kubernetes相互通信。因此，可以使用Kubernetes手动关联和编排在多个主机上运行的容器。</p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/home/">kubernetes.io/zh-cn</a></p>
<h2 id="K8S整体架构"><a href="#K8S整体架构" class="headerlink" title="K8S整体架构"></a>K8S整体架构</h2><p><img src="/2023/05/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Kubernetes/k8s-arch-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p>
<h3 id="K8S组件"><a href="#K8S组件" class="headerlink" title="K8S组件"></a>K8S组件</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/">https://kubernetes.io/zh-cn/docs/concepts/overview/components/</a></p>
<p><strong>控制平面组件（Control Plane Components）：</strong><br>控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件。<br>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。</p>
<ol>
<li><strong>kube-apiserver</strong><br> API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。<br> Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</li>
<li><strong>etcd</strong><br> 一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。</li>
<li><strong>kube-scheduler</strong><br> 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。<br> 调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</li>
<li><strong>kube-controller-manager</strong><br> 负责运行控制器进程。<br> 从逻辑上讲， 每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。<br> 这些控制器包括：<ul>
<li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li>
<li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li>
<li>端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</li>
<li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。</li>
</ul>
</li>
<li><strong>cloud-controller-manager</strong><br> 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</li>
</ol>
<p><strong>Node 组件：</strong><br>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p>
<ol>
<li><strong>kubelet</strong><br> kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。<br> kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。<br> kubelet 不会管理不是由 Kubernetes 创建的容器。</li>
<li><strong>kube-proxy</strong><br> kube-proxy 是集群中每个节点（node）上所运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。<br> kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。<br> 如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</li>
<li><strong>容器运行时 container-runtime</strong><br> 负责管理运行容器的软件，比如docker。</li>
</ol>
<p><strong>插件（Addons）：</strong><br>插件使用 Kubernetes 资源（DaemonSet、 Deployment 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 kube-system 命名空间。</p>
<ol>
<li><strong>kube-dns</strong><br> 集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。<br> Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</li>
<li><strong>Ingress Controller</strong><br> 为服务提供k8s集群外网入口</li>
<li><strong>Heapster</strong><br> 提供资源监控</li>
<li><strong>Dashboard</strong><br> 提供GUI</li>
<li><strong>Federation</strong><br> 提供跨可用区的集群</li>
<li><strong>Fluentd-elasticsearch</strong><br> 提供集群日志采集、存储与查询</li>
</ol>
<h3 id="K8S资源对象"><a href="#K8S资源对象" class="headerlink" title="K8S资源对象"></a>K8S资源对象</h3><p>Kubernetes 中的所有内容都被抽象为“资源”，如 Pod、Service、Node 等都是资源。<br>“对象”就是“资源”的实例，是持久化的实体。如某个具体的 Pod、某个具体的 Node。Kubernetes 使用这些实体去表示整个集群的状态。</p>
<p>对象的创建、删除、修改都是通过 “Kubernetes API”，也就是 “Api Server” 组件提供的 API 接口，这些是 RESTful 风格的 Api，与 k8s 的“万物皆对象”理念相符。命令行工具 “kubectl”，实际上也是调用 kubernetes api。</p>
<p>K8s 中的资源类别有很多种，kubectl 可以通过配置文件来创建这些 “对象”，配置文件更像是描述对象“属性”的文件，配置文件格式可以是 “JSON” 或 “YAML”，常用 “YAML”。</p>
<p>几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置：<strong>对象 spec（规约）</strong> 和 <strong>对象 status（状态）</strong>。</p>
<p>这里有一个 <code>.yaml</code> 示例文件，展示了 Kubernetes Deployment 的必需字段和对象 spec：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 告知 Deployment 运行 2 个与该模板匹配的 Pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>在想要创建的 Kubernetes 对象所对应的 <code>.yaml</code> 文件中，需要配置的字段如下：</p>
<ul>
<li>apiVersion - 创建该对象所使用的 Kubernetes API 的版本</li>
<li><strong>kind</strong> - 想要创建的对象的类别</li>
<li>metadata - 帮助唯一标识对象的一些数据，包括一个 name 字符串、UID 和可选的 namespace</li>
<li>spec - 你所期望的该对象的状态</li>
</ul>
<h4 id="资源-对象种类"><a href="#资源-对象种类" class="headerlink" title="资源/对象种类"></a>资源/对象种类</h4><ol>
<li><p>（工作负载）Workload类对象</p>
<ol>
<li><p>Pod</p>
</li>
<li><p>Controllers<br> Deployment/Statefulset/Daemonset/Job等。</p>
<p> Certificate Controller<br> ClusterRoleAggregation Controller<br> Node Controller<br> CronJob Controller<br> Daemon Controller<br> Deployment Controller<br> StatefulSet Controller<br> Endpoint Controller<br> Endpointslice Controller<br> Garbage Collector<br> Namespace Controller<br> Job Controller<br> Pod AutoScaler<br> PodGC Controller<br> ReplicaSet Controller<br> Service Controller<br> ServiceAccount Controller<br> Volume Controller<br> Resource quota Controller<br> Disruption Controller</p>
</li>
</ol>
</li>
<li><p>Discovery&amp;Loadbalance类对象<br> Service/Endpoints/Ingress</p>
</li>
<li><p>Workload类对象<br> Configmap/ Secret/ Volume/ PersistentVolume</p>
</li>
<li><p>Cluster类对象<br> Node/Namespace/Role/ClusterRole</p>
</li>
</ol>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="Cluster、Master、Node"><a href="#Cluster、Master、Node" class="headerlink" title="Cluster、Master、Node"></a>Cluster、Master、Node</h4><ul>
<li>Cluster<br>   Cluster（集群） 是计算、存储和网络资源的集合，Kubernetes 利用这些资源运行各种基于容器的应用。<br>   最简单的 Cluster 可以只有一台主机（它既是 Mater 也是 Node）。</li>
<li>Master<br>   Master 是 Cluster 的大脑，它的主要职责是调度，即决定将应用放在哪里运行。<br>   Master 运行 Linux 操作系统，可以是物理机或者虚拟机。<br>   为了实现高可用，可以运行多个 Master。</li>
<li>Node<br>   Node 的职责是运行容器应用。<br>   Node 由 Master 管理，Node 负责监控并汇报容器的状态，并根据 Master 的要求管理容器的生命周期。<br>   Node 运行在 Linux 操作系统，可以是物理机或者是虚拟机。</li>
</ul>
<h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>基本概念：</p>
<ol>
<li>Pod 是 Kubernetes 的最小工作单元。</li>
<li>每个 Pod 包含一个或多个容器。Pod 中的容器会作为一个整体被 Master 调度到一个 Node 上运行。</li>
</ol>
<p>引入Pod的目的：</p>
<ol>
<li><strong>可管理性</strong>: 有些容器天生就是需要紧密联系，一起工作。Pod 提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes 以 Pod 为最小单位进行调度、扩展、共享资源、管理生命周期。</li>
<li><strong>通信和资源共享</strong>: Pod 中的所有容器使用同一个网络 namespace，即相同的 IP 地址和 Port 空间。它们可以直接用 localhost 通信。同样的，这些容器可以共享存储，当 Kubernetes 挂载 volume 到 Pod，本质上是将 volume 挂载到 Pod 中的每一个容器。</li>
</ol>
<p>Pod的使用方式：</p>
<ol>
<li><strong>运行单一容器</strong>: <code>one-container-per-Pod</code> 是 Kubernetes 最常见的模型，这种情况下，只是将单个容器简单封装成 Pod。即便是只有一个容器，Kubernetes 管理的也是 Pod 而不是直接管理容器。</li>
<li><strong>运行多个容器</strong>: 对于那些联系非常紧密，而且需要直接共享资源的容器，应该放在一个 Pod 中。比如下面这个 Pod 包含两个容器：一个 File Puller，一个是 Web Server。File Puller 会定期从外部的 Content Manager 中拉取最新的文件，将其存放在共享的 volume 中。Web Server 从 volume 读取文件，响应 Consumer 的请求。这两个容器是紧密协作的，它们一起为 Consumer 提供最新的数据；同时它们也通过 volume 共享数据。所以放到一个 Pod 是合适的。</li>
</ol>
<h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>基本概念：<br>Kubernetes 通常不会直接创建 Pod，而是通过 Controller 来管理 Pod 的。Controller 中定义了 Pod 的部署特性，比如有几个副本，在什么样的 Node 上运行等。为了满足不同的业务场景，Kubernetes 提供了多种 Controller，包括 Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job 等。</p>
<p>各个Controller：</p>
<ol>
<li><strong>Deployment：</strong> Deployment 是最常用的 Controller，比如我们可以通过创建 Deployment 来部署应用的。Deployment 可以管理 Pod 的多个副本，并确保 Pod 按照期望的状态运行。</li>
<li><strong>ReplicaSet：</strong> ReplicaSet 实现了 Pod 的多副本管理。使用 Deployment 时会自动创建 ReplicaSet，也就是说 Deployment 是通过 ReplicaSet 来管理 Pod 的多个副本，我们通常不需要直接使用 ReplicaSet。</li>
<li><strong>DaemonSet：</strong> DaemonSet 用于每个 Node 最多只运行一个 Pod 副本的场景。正如其名称所揭示的，DaemonSet 通常用于运行 daemon。</li>
<li><strong>StatefuleSet：</strong> StatefuleSet 能够保证 Pod 的每个副本在整个生命周期中名称是不变的。而其他 Controller 不提供这个功能，当某个 Pod 发生故障需要删除并重新启动时，Pod 的名称会发生变化。同时 StatefuleSet 会保证副本按照固定的顺序启动、更新或者删除。</li>
<li><strong>Job：</strong> Job 用于运行结束就删除的应用。而其他 Controller 中的 Pod 通常是长期持续运行。</li>
</ol>
<h4 id="Service、Namaspace"><a href="#Service、Namaspace" class="headerlink" title="Service、Namaspace"></a>Service、Namaspace</h4><ul>
<li>Service<ol>
<li>Deployment 可以部署多个副本，每个 Pod 都有自己的 IP。而 Pod 很可能会被频繁地销毁和重启，它们的 IP 会发生变化，用 IP 来访问 Deployment 副本不太现实。</li>
<li>Service 定义了外界访问一组特定 Pod 的方式。Service 有自己的 IP 和端口，Service 为 Pod 提供了负载均衡。</li>
</ol>
</li>
<li>Namespace<ol>
<li>Namespace 可以将一个物理的 Cluster 逻辑上划分成多个虚拟 Cluster，每个 Cluster 就是一个 Namespace。不同 Namespace 里的资源是完全隔离的。</li>
<li>Kubernetes 默认创建了两个 Namespace<ol>
<li>default：创建资源时如果不指定，将被放到这个 Namespace 中。</li>
<li>kube-system：Kubernetes 自己创建的系统资源将放到这个 Namespace 中。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="服务注册发现与负载均衡-Service"><a href="#服务注册发现与负载均衡-Service" class="headerlink" title="服务注册发现与负载均衡 - Service"></a>服务注册发现与负载均衡 - Service</h2><p>如果使用 Deployment 来运行应用服务，Deployment 可以动态的创建和销毁 Pod。每个 Pod 获取其自己的 IP 地址（K8S期待网络插件确保IP地址分配）。<br>对于集群中给定的 Deployment，这一刻运行的这组 Pod 可能不同于下一刻运行应用程序的另一组 Pod。<br>由此引出的的问题是：</p>
<ul>
<li>如果一组Pod（称为”后端“）为<strong>同一集群</strong>内的其它Pod（称为”前端”）提供功能，那么前端如何找出并跟踪要连接的IP地址，以便前端可以使用提供能力的后端部分？</li>
<li>如果一组前端Pod要调用<strong>不同集群</strong>的一组后端Pod呢？</li>
</ul>
<p>Kubernetes 中 Service 是一种抽象，通过网络暴露Pod组合。每个Service对象定义一组Pod以及如何访问这些Pod的策略。</p>
<p>Kubernetes Service 是集群中提供相同功能的一组 Pod 的抽象表达。 当每个 Service 创建时，会被分配一个唯一的 IP 地址（也称为 clusterIP）。 这个 IP 地址与 Service 的生命周期绑定在一起，只要 Service 存在，它就不会改变。 可以配置 Pod 使它与 Service 进行通信，Pod 知道与 Service 通信将被自动地负载均衡到该 Service 中的某些 Pod 上。</p>
<h3 id="定义Service"><a href="#定义Service" class="headerlink" title="定义Service"></a>定义Service</h3><p>Service 在 Kubernetes 中是一个对象 （与 Pod 或 ConfigMap 类似的对象）。可以使用 Kubernetes API 创建、查看或修改 Service 定义。 通常使用 <code>kubectl</code> 这类工具来进行这些 API 调用。</p>
<h4 id="EndpointPoints-amp-EndpointSlices"><a href="#EndpointPoints-amp-EndpointSlices" class="headerlink" title="EndpointPoints &amp; EndpointSlices"></a>EndpointPoints &amp; EndpointSlices</h4><p><strong>Endpoint</strong>: pod和service之间的关联关系，是通过<code>endpoint</code>实现的。<br>Endpoints表示了一个Service对应的所有Pod副本的访问地址；而Endpoints Controller负责生成和维护所有Endpoints对象的控制器，它负责监听Service和对应的Pod副本的变化。</p>
<p>在 Kubernetes API 中，Endpoints （该资源类别为复数）定义了网络端点的列表，通常由 Service 引用，以定义可以将流量发送到哪些 Pod。<br>推荐用 EndpointSlice API 替换 Endpoints。</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>Kubernetes 支持两种查找服务的主要模式：环境变量和 DNS。前者开箱即用，而后者则需要 CoreDNS 集群插件。</p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>当 Pod 在节点上运行时，kubelet 会针对每个活跃的 Service 为 Pod 添加一组环境变量。<br>kubelet 为 Pod 添加环境变量 <code>&#123;SVCNAME&#125;_SERVICE_HOST</code> 和 <code>&#123;SVCNAME&#125;_SERVICE_PORT</code>。</p>
<p>使用<strong>环境变量方法</strong>将端口和集群 IP 发布到客户端 Pod 时，<strong>必须在客户端 Pod 出现 之前 创建服务</strong>。 否则，这些客户端 Pod 将不会设定其环境变量。<br>如果仅使用 DNS 查找服务的集群 IP，则无需担心此设定问题。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>支持集群的 DNS 服务器（例如 CoreDNS：kube-dns）监视 Kubernetes API 中的新服务，并为每个服务创建一组 DNS 记录。 如果在整个集群中都启用了 DNS，则所有 Pod 都应该能够通过其 DNS 名称自动解析服务。</p>
<p>例如，如果你在 Kubernetes <strong>命名空间 my-ns</strong> 中有一个<strong>名为 my-service 的服务</strong>， 则控制平面和 DNS 服务共同为 <strong>my-service.my-ns</strong> 创建 DNS 记录。 <strong>my-ns 命名空间</strong>中的 Pod 应该能够通过<code>按名检索 my-service</code> 来找到服务 （my-service.my-ns 也可以工作）。<br>同一集群下<strong>其他命名空间中的 Pod</strong> 必须将名称限定为 <code>my-service.my-ns</code>，这些名称将解析为为服务分配的集群 IP。</p>
<p>Kubernetes 提供了一个自动为其它Service分配DNS名字的DNS插件Service：kube-dns。<br>可以通过如下命令检查它是否在工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services kube-dns --namespace=kube-system</span><br><span class="line"></span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m</span><br></pre></td></tr></table></figure>

<h3 id="发布服务（服务类型）"><a href="#发布服务（服务类型）" class="headerlink" title="发布服务（服务类型）"></a>发布服务（服务类型）</h3><p>对一些应用的某些部分（如前端），可能希望将其暴露给K8S集群外部的IP地址从而能够外网访问。</p>
<p>Kubernetes <code>ServiceTypes</code> 允许指定所需要的 Service 类型。</p>
<ul>
<li>ClusterIP<br>  通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。<br>  这也是没有为服务显式指定 type 时使用的<strong>默认值</strong>。<br>  可以使用 Ingress 或者 Gateway API 向公众暴露服务。</li>
<li>NodePort<br>  通过每个节点上的 IP 和静态端口（NodePort）暴露服务。<br>  为了让节点端口可用，Kubernetes 设置了集群 IP 地址，这等同于请求 <code>type: ClusterIP</code> 的服务。</li>
<li>LoadBalancer<br>  使用云提供商的负载均衡器向外部暴露服务。<br>  外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上。</li>
<li>ExternalName<br>  通过返回 <code>CNAME</code> 记录和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，foo.bar.example.com）。 无需创建任何类型代理。<br>  要使用 kube-dns 1.7 及以上版本或者 CoreDNS 0.0.8 及以上版本才能使用 <code>ExternalName</code> 类型。</li>
</ul>
<p>可以使用 <code>Ingress</code> 来暴露自己的服务。<br><code>Ingress</code> 不是一种服务类型，但它充当集群的入口点。它可以将路由规则整合到一个资源中，因为它可以在同一 IP 地址下公开多个服务。</p>
<h4 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h4><p>使用 type: ClusterIP 的 Service时，Service 可以具有集群作用域的虚拟 IP 地址。<br>客户端可以使用该虚拟 IP 地址进行连接，Kubernetes 通过不同的后台 Pod 对该 Service 的流量进行负载均衡。</p>
<p>Service ClusterIP 是如何分配的？</p>
<ul>
<li>动态分配<br>  集群的控制面自动从所配置的 IP 范围内为 <code>type: ClusterIP</code> 选择一个空闲 IP 地址。</li>
<li>静态分配<br>  根据为 Service 所配置的 IP 范围，选定并设置你的 IP 地址。</li>
</ul>
<p>在整个集群中，每个 Service 的 ClusterIP 都必须是唯一的。 尝试使用已分配的 ClusterIP 创建 Service 将返回错误。</p>
<h2 id="服务注册发现与负载均衡-Ingress"><a href="#服务注册发现与负载均衡-Ingress" class="headerlink" title="服务注册发现与负载均衡 - Ingress"></a>服务注册发现与负载均衡 - Ingress</h2><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。<br>Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。</p>
<p>Ingress 公开从集群外部到集群内服务的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。</p>
<p>下面是一个将所有流量都发送到同一 Service 的简单 Ingress 示例：<br><img src="/2023/05/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Kubernetes/k8s-ingress-%E5%9B%BE%E7%A4%BA.png"></p>
<p>Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及基于名称的虚拟托管。<br><strong>Ingress 控制器</strong> 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。<br>Ingress 不会公开任意端口或协议。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 Service.Type=NodePort 或 Service.Type=LoadBalancer 类型的 Service。</p>
<h4 id="Ingress资源"><a href="#Ingress资源" class="headerlink" title="Ingress资源"></a>Ingress资源</h4><p>一个Ingress资源示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-wildcard-host</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;foo.bar.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/bar&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;*.foo.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/foo&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>Ingress 对象的命名必须是合法的 DNS 子域名名称。 </p>
<h4 id="Ingress类"><a href="#Ingress类" class="headerlink" title="Ingress类"></a>Ingress类</h4><p>Ingress 可以由不同的控制器实现，通常使用不同的配置。 每个 Ingress 应当指定一个类，也就是一个对 IngressClass 资源的引用。 IngressClass 资源包含额外的配置，其中包括应当实现该类的控制器名称。</p>
<h5 id="IngressClass的作用域"><a href="#IngressClass的作用域" class="headerlink" title="IngressClass的作用域"></a>IngressClass的作用域</h5><p>取决于 Ingress 控制器，可以使用集群范围设置的参数或某个名字空间范围的参数。</p>
<ul>
<li>集群作用域<br>  IngressClass 的参数默认是集群范围的。</li>
<li>命名空间作用域  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">external-lb-2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">controller:</span> <span class="string">example.com/ingress-controller</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">    <span class="comment"># 此 IngressClass 的配置定义在一个名为 “external-config” 的</span></span><br><span class="line">    <span class="comment"># IngressParameter（API 组为 k8s.example.com）资源中，</span></span><br><span class="line">    <span class="comment"># 该资源位于 “external-configuration” 命名空间中。</span></span><br><span class="line">    <span class="attr">scope:</span> <span class="string">Namespace</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">k8s.example.com</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">IngressParameter</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">external-configuration</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">external-config</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h3><p>为了让 Ingress 资源工作，集群必须有一个正在运行的 Ingress 控制器。</p>
<p>与作为 kube-controller-manager 可执行文件的一部分运行的其他类型的控制器不同， Ingress 控制器不是随集群自动启动的。<br>Kubernetes 作为一个项目，目前支持和维护 AWS、 GCE 和 <strong>Nginx</strong> Ingress 控制器。</p>
</div><div class="tags"><a href="/tags/微服务"><i class="fa fa-tag">微服务</i></a></div><div class="post-nav"><a class="next" href="/2023/05/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '8359b7a19b78f2b9e112',
  clientSecret: '5ad69dc1633a1834322067d017b6313bd231457c',
  repo: 'gitalk',
  owner: 'Th3Crave',
  admin: ['Th3Crave'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#K8S%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-text">K8S整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K8S%E7%BB%84%E4%BB%B6"><span class="toc-text">K8S组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K8S%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1"><span class="toc-text">K8S资源对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90-%E5%AF%B9%E8%B1%A1%E7%A7%8D%E7%B1%BB"><span class="toc-text">资源&#x2F;对象种类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cluster%E3%80%81Master%E3%80%81Node"><span class="toc-text">Cluster、Master、Node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pod"><span class="toc-text">Pod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Controller"><span class="toc-text">Controller</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service%E3%80%81Namaspace"><span class="toc-text">Service、Namaspace</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Service"><span class="toc-text">服务注册发现与负载均衡 - Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89Service"><span class="toc-text">定义Service</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EndpointPoints-amp-EndpointSlices"><span class="toc-text">EndpointPoints &amp; EndpointSlices</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-text">服务发现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS"><span class="toc-text">DNS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-text">发布服务（服务类型）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ClusterIP"><span class="toc-text">ClusterIP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ingress"><span class="toc-text">服务注册发现与负载均衡 - Ingress</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ingress"><span class="toc-text">Ingress</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ingress%E8%B5%84%E6%BA%90"><span class="toc-text">Ingress资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ingress%E7%B1%BB"><span class="toc-text">Ingress类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IngressClass%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">IngressClass的作用域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ingress-Controller"><span class="toc-text">Ingress Controller</span></a></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>