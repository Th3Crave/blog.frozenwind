<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot源码分析-自动装配</title>
      <link href="/2023/03/25/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
      <url>/2023/03/25/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义starter包的知识盲区"><a href="#自定义starter包的知识盲区" class="headerlink" title="自定义starter包的知识盲区"></a>自定义starter包的知识盲区</h2><h3 id="Configuration配置类解析"><a href="#Configuration配置类解析" class="headerlink" title="@Configuration配置类解析"></a>@Configuration配置类解析</h3><p>ConfigurationClassPostProcessor</p><h3 id="Spring的SPI机制"><a href="#Spring的SPI机制" class="headerlink" title="Spring的SPI机制"></a>Spring的SPI机制</h3><p>SPI全称为Service Provider Interface 服务提供接口。</p><p>在SpringBoot的自动装配过程中，最终会加载<strong>META-INF/spring.factories</strong>文件，而加载的过程是由<strong>SpringFactoriesLoader</strong>加载的。<br>从CLASSPATH下的每个Jar包中搜寻所有<strong>META-INF/spring.factories</strong>配置文件，然后将解析properties文件，找到指定名称的配置后返回。<br>需要注意的是，其实这里不仅仅是会去Classpath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的Jar包中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"><span class="comment">// spring.factories文件的格式为：key=value1,value2,value3</span></span><br><span class="line"><span class="comment">// 从所有的jar包中找到META-INF/spring.factories文件</span></span><br><span class="line"><span class="comment">// 然后从文件中解析出key=factoryClass类名称的所有value值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="comment">// 取得资源文件的URL</span></span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有的URL</span></span><br><span class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">        URL url = urls.nextElement();</span><br><span class="line">        <span class="comment">// 根据资源文件URL解析properties文件，得到对应的一组@Configuration类</span></span><br><span class="line">        Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span><br><span class="line">        String factoryClassNames = properties.getProperty(factoryClassName);</span><br><span class="line">        <span class="comment">// 组装数据，并返回</span></span><br><span class="line">        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot的自动装配机制"><a href="#SpringBoot的自动装配机制" class="headerlink" title="SpringBoot的自动装配机制"></a>SpringBoot的自动装配机制</h3><h3 id="如何自定义SpringBoot的starter"><a href="#如何自定义SpringBoot的starter" class="headerlink" title="如何自定义SpringBoot的starter"></a>如何自定义SpringBoot的starter</h3><h2 id="什么是SpringBoot自动装配"><a href="#什么是SpringBoot自动装配" class="headerlink" title="什么是SpringBoot自动装配"></a>什么是SpringBoot自动装配</h2><p>何谓SpringBoot的自动装配，简要概括就是：引入<strong>第三方组件的starter包</strong>后能够<strong>自动</strong>将<strong>第三方组件的bean</strong>加载到<strong>IOC容器</strong>中供应用程序使用。</p><p>自动装配的机制是SpringBoot提供的，因此第三方组件的starter包在编写的时候，就需要根据SpringBoot的自动装配的规则来编写starter包。<br>规则概括如下：</p><ol><li><strong>starter包</strong>需要在<strong>META-INF</strong>目录下提供<strong>spring.factories</strong>文件；</li><li><strong>spring.factories</strong>文件中以<strong>Key-Values</strong>的形式来提供需要Springboot去加载的类的全限定名。<ul><li>Key就是Springboot中各种扩展点的全限定名。<br>  比如org.springframework.boot.autoconfigure.EnableAutoConfiguration。</li><li>Values就是starter包中提供的扩展点的所有类的全限定名，以逗号隔开。</li></ul></li></ol><h3 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="/META-INF/spring.factories"></a>/META-INF/spring.factories</h3><p><strong>spring-boot-autoconfigure-2.3.4.RELEASE.jar</strong>的spring.factories</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># Failure analyzers</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisUrlSyntaxFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayMigrationScriptMissingFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer</span><br><span class="line"></span><br><span class="line"># Template availability providers</span><br><span class="line">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure><h2 id="SpringBoot自动配置原理-相关注解"><a href="#SpringBoot自动配置原理-相关注解" class="headerlink" title="SpringBoot自动配置原理 - 相关注解"></a>SpringBoot自动配置原理 - 相关注解</h2><ul><li>SpringBoot 是依靠入口注解 <strong>@SpringBootApplication</strong> 来启动整个自动配置体系的<br>  其中 <strong>@EnableAutoConfiguration</strong> 注解启动AutoConfigure功能</li><li>SpringBoot 是通过读取 <code>META-INF/spring.factories</code> 文件中配置的自动配置类来完成自动配置的<br>  自动配置类大多以 AutoConfiguration 结尾，AutoConfiguration类主要是通过springboot自定义的条件注解来完成自动配置的</li></ul><h3 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@java</span>.lang.annotation.Target(&#123;java.lang.annotation.ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Documented</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Inherited</span><br><span class="line"><span class="meta">@org</span>.springframework.boot.SpringBootConfiguration</span><br><span class="line"><span class="meta">@org</span>.springframework.boot.autoconfigure.EnableAutoConfiguration</span><br><span class="line"><span class="meta">@org</span>.springframework.context.annotation.ComponentScan</span><br></pre></td></tr></table></figure><p><strong>@SpringBootApplication</strong>是由3个注解组成的复合注解。</p><ul><li><strong>@SpringBootConfiguration</strong><br>  该注解表明Springboot启动类是一个配置类。</li><li><strong>@ComponentScan</strong><br>  该注解会将指定路径下的被特定注解修饰的类加载为Spring中的bean。<br>  这些特定注解为@Component、@Controller、@Service、@Repository和@Configuration注解。</li><li><strong>@EnableAutoConfiguration</strong><br>  该注解用于开启Springboot的自动装配。</li></ul><h3 id="SpringBootConfiguration注解"><a href="#SpringBootConfiguration注解" class="headerlink" title="@SpringBootConfiguration注解"></a>@SpringBootConfiguration注解</h3><h3 id="ComponentScan注解"><a href="#ComponentScan注解" class="headerlink" title="@ComponentScan注解"></a>@ComponentScan注解</h3><h3 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="@EnableAutoConfiguration注解"></a>@EnableAutoConfiguration注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@java</span>.lang.annotation.Target(&#123;java.lang.annotation.ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Documented</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Inherited</span><br><span class="line"><span class="meta">@org</span>.springframework.boot.autoconfigure.AutoConfigurationPackage</span><br><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Import(&#123;org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    java.lang.String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    java.lang.Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    java.lang.String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@EnableAutoConfiguration</strong>注解也是一个复合注解，主要功能由 <strong>@AutoConfigurationPackage</strong>注解和 <strong>@Import</strong>注解实现，那么肯定的，自动装配，就是这两个注解实现的。</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>@AutoConfigurationPackage注解作用在Springboot启动类上，会向Spring容器注册一个类型为AutoConfigurationPackages.BasePackages的bean，这个bean中保存了Springboot启动类的包路径，后续Springboot就会扫描这个包路径下由@Component、@Controller、@Service、@Repository和@Configuration注解修饰的类。</p><h4 id="Import-AutoConfigurationImportSelector-class-重要！！！"><a href="#Import-AutoConfigurationImportSelector-class-重要！！！" class="headerlink" title="@Import(AutoConfigurationImportSelector.class) 重要！！！"></a>@Import(AutoConfigurationImportSelector.class) 重要！！！</h4><ul><li><strong>@Import(AutoConfigurationImportSelector.class)<strong>会通过</strong>AutoConfigurationImportSelector</strong>延迟且分组的向Spring容器导入需要自动装配的组件的配置类，从而在解析这些配置类的时候能够将自动装配的组件的bean注册到容器中<ul><li>所谓的延迟，是因为AutoConfigurationImportSelector实现了DeferredImportSelector接口，其逻辑会在Springboot启动类被解析完毕后才会执行；</li><li>所谓的分组，是因为处理DeferredImportSelector是一组一组的进行的，只要DeferredImportSelector的实现类实现的getImportGroup()方法返回的Class对象一样，那么这样的DeferredImportSelector的实现类就属于同一组；</li></ul></li><li><strong>AutoConfigurationImportSelector</strong>获取到需要自动装配的组件的配置类的全限定名，是通过<strong>SpringFactoriesLoader</strong>完成的，而SpringFactoriesLoader就是<strong>Spring中的SPI机制</strong>的实现。</li></ul><p><a href="https://www.bilibili.com/read/cv17225413/">https://www.bilibili.com/read/cv17225413/</a></p><h2 id="SpringBoot自动配置原理-自动装配过程"><a href="#SpringBoot自动配置原理-自动装配过程" class="headerlink" title="SpringBoot自动配置原理 - 自动装配过程"></a>SpringBoot自动配置原理 - 自动装配过程</h2><h3 id="SpringBootApplication启动对象的注入"><a href="#SpringBootApplication启动对象的注入" class="headerlink" title="SpringBootApplication启动对象的注入"></a>SpringBootApplication启动对象的注入</h3><p><strong>SpringApplication#run#prepareContext#load</strong><br>prepareContext过程中，当前sources列表中只有一个main启动方法所在的Application.class对象，在此处加载springboot启动类。</p><h3 id="自动装配过程的方法调用链"><a href="#自动装配过程的方法调用链" class="headerlink" title="自动装配过程的方法调用链"></a>自动装配过程的方法调用链</h3><ol><li>SpringApplication#run</li><li><strong>SpringApplication#refreshContext</strong></li><li><strong>AbstractApplicationContext#refresh()</strong></li><li><strong>AbstractApplicationContext#invokeBeanFactoryPostProcessors(beanFactory)</strong><br> 此处是自动装配的入口！！！</li><li>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())</li><li>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(registry)</li><li>ConfigurationClassParser#parse(candidates)#processConfigurationClass#doProcessConfigurationClass#processImports</li><li><strong>AutoConfigurationImportSelector#selectImports#getAutoConfigurationEntry#getCandidateConfigurations</strong></li><li> <strong>SpringFactoriesLoader#loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader())#loadSpringFactories</strong></li></ol><h4 id="AbstractApplicationContext-postProcessBeanFactory-beanFactory"><a href="#AbstractApplicationContext-postProcessBeanFactory-beanFactory" class="headerlink" title="AbstractApplicationContext#postProcessBeanFactory(beanFactory)"></a>AbstractApplicationContext#postProcessBeanFactory(beanFactory)</h4><p>beanFactory的后置处理器 postProcessBeanFactory(beanFactory)</p><p>当前applicationContext是AnnotationConfigServletWebServerApplicationContext的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigServletWebServerApplicationContext#postProcessBeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigServletWebServerApplicationContext</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ServletWebServerApplicationContext</span> <span class="keyword">implements</span> <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理beanFactory</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显式调用父类ServletWebServerApplicationContext#postProcessBeanFactory</span></span><br><span class="line">        <span class="keyword">super</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">//basePackages默认为null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.basePackages != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.basePackages.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//不为空的话,进行扫描</span></span><br><span class="line">            <span class="keyword">this</span>.scanner.scan(<span class="keyword">this</span>.basePackages);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//annotatedClasses默认为空</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.annotatedClasses.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//不为空的话注册类</span></span><br><span class="line">            <span class="keyword">this</span>.reader.register(ClassUtils.toClassArray(<span class="keyword">this</span>.annotatedClasses));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServletWebServerApplicationContext#postProcessBeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericWebApplicationContext</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConfigurableWebServerApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在ServletContext和ServletConfig初始化之前</span></span><br><span class="line">        <span class="comment">//进行bean处理</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(</span><br><span class="line">                <span class="keyword">new</span> WebApplicationContextServletContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">        <span class="comment">//忽略ServletContextAware自动配置</span></span><br><span class="line">        beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">        <span class="comment">//beanFactory注册web应用scopes</span></span><br><span class="line">        <span class="comment">//request和session</span></span><br><span class="line">        registerWebApplicationScopes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WebApplicationContextUtils#registerWebApplicationScopes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebApplicationContextUtils</span># </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWebApplicationScopes</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传入ServletContext为null</span></span><br><span class="line">        registerWebApplicationScopes(beanFactory, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWebApplicationScopes</span><span class="params">(ConfigurableListableBeanFactory beanFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@Nullable</span> ServletContext sc)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册Scope</span></span><br><span class="line">        <span class="comment">//request</span></span><br><span class="line">        beanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, <span class="keyword">new</span> RequestScope());</span><br><span class="line">        <span class="comment">//session</span></span><br><span class="line">        beanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, <span class="keyword">new</span> SessionScope());</span><br><span class="line">        <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//传入sc为null</span></span><br><span class="line">            <span class="comment">//注册application scope</span></span><br><span class="line">            ServletContextScope appScope = <span class="keyword">new</span> ServletContextScope(sc);</span><br><span class="line">            beanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);</span><br><span class="line">            <span class="comment">// 设置ServletContext属性</span></span><br><span class="line">            sc.setAttribute(ServletContextScope.class.getName(), appScope);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册几个Autowired自动装配</span></span><br><span class="line">        <span class="comment">//ServletRequest.class</span></span><br><span class="line">        beanFactory.registerResolvableDependency(ServletRequest.class, <span class="keyword">new</span> RequestObjectFactory());</span><br><span class="line">        <span class="comment">//ServletResponse.class</span></span><br><span class="line">        beanFactory.registerResolvableDependency(ServletResponse.class, <span class="keyword">new</span> ResponseObjectFactory());</span><br><span class="line">        <span class="comment">//HttpSession.class</span></span><br><span class="line">        beanFactory.registerResolvableDependency(HttpSession.class, <span class="keyword">new</span> SessionObjectFactory());</span><br><span class="line">        <span class="comment">//WebRequest.class</span></span><br><span class="line">        beanFactory.registerResolvableDependency(WebRequest.class, <span class="keyword">new</span> WebRequestObjectFactory());</span><br><span class="line">        <span class="keyword">if</span> (jsfPresent) &#123;</span><br><span class="line">            <span class="comment">//jsfPresent默认为false</span></span><br><span class="line">            FacesDependencyRegistrar.registerFacesDependencies(beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractApplicationContext-invokeBeanFactoryPostProcessors-beanFactory"><a href="#AbstractApplicationContext-invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="AbstractApplicationContext#invokeBeanFactoryPostProcessors(beanFactory)"></a>AbstractApplicationContext#invokeBeanFactoryPostProcessors(beanFactory)</h4><p>BeanFactoryPostProcessor是一个接口, 处理beanFactory中所有的bean, 在所有的beanDefinition加载完成之后, BeanFactoryPostProcessor可以对beanDefinition进行属性的修改, 之后再进行bean实例化。</p><p>BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子接口, 定义了postProcessBeanDefinitionRegistry方法, 会在postProcessBeanFactory方法执行之前, 获取bean定义, 并注册到spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext#invokeBeanFactoryPostProcessors(beanFactory)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理器代理类</span></span><br><span class="line">    <span class="comment">//处理this.beanFactoryPostProcessors中维护的bean处理器</span></span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TempClassLoader为空</span></span><br><span class="line">    <span class="comment">//包含了LoadTimeWeaver(加载到JVM时, 进行切面织入)</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors"><a href="#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors" class="headerlink" title="PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors"></a>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors</h4><p>如果beanFactory是BeanDefinitionRegistry的子类, 按优先级，先处理BeanDefinitionRegistryPostProcessor类型的后置处理器, 最后处理传入的其他类型后置处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PostProcessorRegistrationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactoryPostProcessors有三个:</span></span><br><span class="line"><span class="comment">     *      CachingMetadataReaderFactoryPostProcessor</span></span><br><span class="line"><span class="comment">     *      ConfigurationWarningsPostProcessor</span></span><br><span class="line"><span class="comment">     *      PropertySourceOrderingPostProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//processedBeans记录处理过的bean名称</span></span><br><span class="line">        Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">            <span class="comment">//优先处理传入的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">            BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">            <span class="comment">//非BeanDefinitionRegistryPostProcessor类型, 常规BeanFactory后置处理器</span></span><br><span class="line">            List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//BeanDefinitionRegistryPostProcessor类型的bean定义注册器后置处理器</span></span><br><span class="line">            List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//regularPostProcessors有1个:PropertySourceOrderingPostProcessor</span></span><br><span class="line">            <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                    <span class="comment">//bean定义注册器后置处理器,有如下两个:</span></span><br><span class="line">                    <span class="comment">//CachingMetadataReaderFactoryPostProcessor</span></span><br><span class="line">                    <span class="comment">//ConfigurationWarningsPostProcessor</span></span><br><span class="line">                    BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                            (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                            <span class="comment">//执行其postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">                    registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                    <span class="comment">//然后加入到registryProcessors中</span></span><br><span class="line">                    registryProcessors.add(registryProcessor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不是BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">                    <span class="comment">//那么放入regularPostProcessors(常规后置处理器)中</span></span><br><span class="line">                    regularPostProcessors.add(postProcessor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理beanFactory中注册的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当前正在处理的PostProcessor, 处理完成之后会清空</span></span><br><span class="line">            List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将其名称放入postProcessorNames数组中</span></span><br><span class="line">            <span class="comment">//当前只能获取到一个bean:        </span></span><br><span class="line">            <span class="comment">//名称为org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line">            <span class="comment">//类型为ConfigurationClassPostProcessor</span></span><br><span class="line">            String[] postProcessorNames =</span><br><span class="line">                    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                    <span class="comment">//优先处理PriorityOrdered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    <span class="comment">//处理完成之后, 放到processedBeans列表</span></span><br><span class="line">                    processedBeans列表中.add(ppName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            <span class="comment">//添加到registryProcessors</span></span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            <span class="comment">//遍历currentRegistryProcessors,调用其postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">            <span class="comment">//执行ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry, 扫描并注册模块中@Configuration注解的bean</span></span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            <span class="comment">//清空currentRegistryProcessors</span></span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实现Order注解的bean</span></span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后,调用其他的BeanDefinitionRegistryPostProcessor的方法</span></span><br><span class="line">            <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">                reiterate = <span class="keyword">false</span>;</span><br><span class="line">                postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                        processedBeans.add(ppName);</span><br><span class="line">                        reiterate = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">                registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">                <span class="comment">//调用其他BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">                invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">                currentRegistryProcessors.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用BeanDefinitionRegistryPostProcessor的postProcessBeanFactory</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">            <span class="comment">//方法传入普通BeanFactoryPostProcessor, 实现其postProcessBeanFactory方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果beanFactory不是BeanDefinitionRegistry</span></span><br><span class="line">            <span class="comment">//方法传入普通BeanFactoryPostProcessor, 实现其postProcessBeanFactory方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理beanFactory中注册的普通BeanFactoryPostProcessor</span></span><br><span class="line">        <span class="comment">//非BeanDefinitionRegistryPostProcessor类型后置处理器</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">                <span class="comment">//说明已经处理过了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                <span class="comment">//优先处理实现了PriorityOrdered接口的子类</span></span><br><span class="line">                priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                <span class="comment">//再处理实现了Ordered接口的子类</span></span><br><span class="line">                orderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//最后处理其他BeanFactoryPostProcessor</span></span><br><span class="line">                nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现了PriorityOrdered接口的BeanFactoryPostProcessor, 优先处理</span></span><br><span class="line">        sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现了Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">            orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后再实现不排序BeanFactoryPostProcessor</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">            nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除缓存</span></span><br><span class="line">        beanFactory.clearMetadataCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConfigurationClassPostProcessor-postProcessBeanDefinitionRegistry-registry"><a href="#ConfigurationClassPostProcessor-postProcessBeanDefinitionRegistry-registry" class="headerlink" title="ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(registry)"></a>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(registry)</h4><p>ConfigurationClassPostProcessor扫描和注册BeanDefinition</p><ol><li>首先处理手动注册的BeanDefinition</li><li>实例化<strong>ConfigurationClassParser</strong>, 递归扫描@Configuration, @ComponentScan, @Import等注解</li><li>实例化ConfigurationClassBeanDefinitionReader,递归读取并注册BeanDefinition</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>,</span></span><br><span class="line"><span class="class">        <span class="title">PriorityOrdered</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean定义扫描和注册</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">            <span class="comment">//this.registriesPostProcessed包含了registryId</span></span><br><span class="line">            <span class="comment">//说明postProcessBeanDefinitionRegistry方法已经执行</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">            <span class="comment">//this.factoriesPostProcessed已经包含了registryId</span></span><br><span class="line">            <span class="comment">//说明postProcessBeanFactory方法已经执行</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加到this.registriesPostProcessed中</span></span><br><span class="line">        <span class="comment">//标记已经被执行</span></span><br><span class="line">        <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理bean定义</span></span><br><span class="line">        processConfigBeanDefinitions(registry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理bean定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首先处理手动注册的BeanDefinition</span></span><br><span class="line">        <span class="comment">//获取手工注册的bean定义名称列表</span></span><br><span class="line">        String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">                    ConfigurationClassUtils.isLiteConfigurationClass(bean)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//beanDefinition是lite或者是full</span></span><br><span class="line">                <span class="comment">//full指的是使用了Configuration注解</span></span><br><span class="line">                <span class="comment">//lite指的是使用了Component, ComponentScan, Import, ImportResource注解</span></span><br><span class="line">                <span class="comment">//或者方法包含了Bean注解</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                <span class="comment">//当前beanDefinition是一个配置类</span></span><br><span class="line">                <span class="comment">//添加到configCandidates中</span></span><br><span class="line">                configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//如果配置类为空,那么立即返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//@Order注解排序</span></span><br><span class="line">        configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">            <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置bean名称生成策略</span></span><br><span class="line">        SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">            sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">                BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">                <span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                    <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ConfigurationClassParser只负责解析被注解的类</span></span><br><span class="line">        <span class="comment">//并不进行BeanDefinition的注册</span></span><br><span class="line">        ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">                <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">                <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Configuration类名</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">        <span class="comment">//已经解析过的ConfigurationClass</span></span><br><span class="line">        Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//解析, 维护到parser.configurationClasses中</span></span><br><span class="line">            parser.parse(candidates);</span><br><span class="line">            <span class="comment">//验证</span></span><br><span class="line">            <span class="comment">//类不可以为final类型, 必须可重写,  static方法不处理</span></span><br><span class="line">            parser.validate();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//configClasses维护待处理的ConfigurationClasse</span></span><br><span class="line">            Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">            configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// this.reader初始化为ConfigurationClassBeanDefinitionReader</span></span><br><span class="line">            <span class="comment">//进行BeanDefinition的加载</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                        registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                        <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加载BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">            <span class="comment">//alreadyParsed维护已经解析完的class</span></span><br><span class="line">            alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">            candidates.clear();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">                <span class="comment">//说明在加载Configuration注解类的过程中,</span></span><br><span class="line">                <span class="comment">//扫描到了Import注解, 引入了新的BeanDefinition</span></span><br><span class="line">                String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">                Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">                Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                    alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                        <span class="comment">//上次没有处理过的类</span></span><br><span class="line">                        BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                        <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                                !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                            <span class="comment">//@Configuration注解的类</span></span><br><span class="line">                            <span class="comment">//没有被处理过</span></span><br><span class="line">                            candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                candidateNames = newCandidateNames;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//candidates不为空, 说明处理@Configuration注解的类</span></span><br><span class="line">        <span class="comment">//扫描到了@Import注解, 引入了新的@Configuration注解类</span></span><br><span class="line">        <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将@Import引入的类列表注册为单例Bean</span></span><br><span class="line">        <span class="comment">//这样可以支持Configuration注解的ImportAware的实现类</span></span><br><span class="line">        <span class="comment">//在实例化Bean的时候, 可以将Import导入的类, 传递给Bean实例</span></span><br><span class="line">        <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">            <span class="comment">//清空缓存</span></span><br><span class="line">            ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConfigurationClassParser-parse"><a href="#ConfigurationClassParser-parse" class="headerlink" title="ConfigurationClassParser#parse"></a>ConfigurationClassParser#parse</h4><p>ConfigurationClassParser#parse方法, 共执行了下面8步：</p><ol><li>处理内部类ConfigurationClassParser#processMemberClasses</li><li>处理@PropertySource注解</li><li>ComponentScanAnnotationParser处理@ComponentScan注解</li><li>处理@Import注解</li><li>处理@ImportResource注解</li><li>处理方法上的@Bean注解</li><li>处理接口的中的default方法</li><li>处理@Import导入的DeferredImportSelector类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析</span></span><br><span class="line">    <span class="comment">//最终都会执行processConfigurationClass方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">            BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    <span class="comment">//AnnotatedBeanDefinition类型</span></span><br><span class="line">                    <span class="comment">//解析metadata</span></span><br><span class="line">                    parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                    <span class="comment">//AbstractBeanDefinition类型</span></span><br><span class="line">                    <span class="comment">//解析beanClass</span></span><br><span class="line">                    parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//MetadataReader类型</span></span><br><span class="line">                    <span class="comment">//解析beanClassName</span></span><br><span class="line">                    parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                        <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理@Import导入的DeferredImportSelectorHolder类</span></span><br><span class="line">        <span class="keyword">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理@Configuration注解的class</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否已经被处理过</span></span><br><span class="line">        ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">        <span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//已经被处理过了</span></span><br><span class="line">            <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">                <span class="comment">//configClass是被Import导入的</span></span><br><span class="line">                <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                    <span class="comment">//将configClass的importedBy合并到existingClass的existingClass中</span></span><br><span class="line">                    existingClass.mergeImportedBy(configClass);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果configClass不是被Import导入</span></span><br><span class="line">                <span class="comment">//那么说明是一个显式的bean定义, 我们旧的移除掉 </span></span><br><span class="line">                <span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">                <span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//递归扫描并处理父类, 以及其注解</span></span><br><span class="line">            sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//维护已经处理的类</span></span><br><span class="line">        <span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实际解析配置类的方法</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//configClass使用了@Component注解</span></span><br><span class="line">        <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">            <span class="comment">//递归处理内部类</span></span><br><span class="line">            processMemberClasses(configClass, sourceClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理@PropertySources注解</span></span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">                sourceClass.getMetadata(), <span class="meta">@PropertySources</span>.class,</span><br><span class="line">                org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">                <span class="comment">//this.environment是ConfigurableEnvironment实例, 才进行@PropertySources属性替换</span></span><br><span class="line">                processPropertySource(propertySource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                        <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理configClass类的@ComponentScans,ComponentScan注解</span></span><br><span class="line">        Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">                sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">        <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">                !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">                <span class="comment">// 交付给ComponentScanAnnotationParser进行扫描</span></span><br><span class="line">                Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                        <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">                        </span><br><span class="line">                <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                    <span class="comment">//获取来源Beanthis.reader.loadBeanDefinitions(configClasses)Definition</span></span><br><span class="line">                    <span class="comment">//OriginatingBeanDefinition由代理设置</span></span><br><span class="line">                    BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                    <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        bdCand = holder.getBeanDefinition();</span><br><span class="line">                    &#125;</span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                        <span class="comment">//BeanDefinition中的类由@Configuration注解</span></span><br><span class="line">                        <span class="comment">//调用parse方法, 递归处理@Configuration注解的类</span></span><br><span class="line">                        parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理configClass类的@Import注解</span></span><br><span class="line">        processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理configClass类的@ImportResource注解</span></span><br><span class="line">        AnnotationAttributes importResource =</span><br><span class="line">                AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">        <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取ImportResource的属性</span></span><br><span class="line">            String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">            Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">                <span class="comment">//处理导入的resource</span></span><br><span class="line">                String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">                configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理sourceClass中@Bean注解的方法</span></span><br><span class="line">        Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">        <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">            <span class="comment">//添加到configClass中</span></span><br><span class="line">            configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理接口中的default方法</span></span><br><span class="line">        processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有父类的话, 处理父类</span></span><br><span class="line">        <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">            String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">            <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">                    !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//返回父类</span></span><br><span class="line">                <span class="comment">//递归处理父类</span></span><br><span class="line">                <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有父类, 处理结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AutoConfigurationImportSelector-selectImports"><a href="#AutoConfigurationImportSelector-selectImports" class="headerlink" title="AutoConfigurationImportSelector#selectImports"></a>AutoConfigurationImportSelector#selectImports</h4><h4 id="SpringFactoriesLoader-loadFactoryNames-loadSpringFactories"><a href="#SpringFactoriesLoader-loadFactoryNames-loadSpringFactories" class="headerlink" title="SpringFactoriesLoader#loadFactoryNames#loadSpringFactories"></a>SpringFactoriesLoader#loadFactoryNames#loadSpringFactories</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot源码分析-启动过程</title>
      <link href="/2023/03/25/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/03/25/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot源码分析-启动过程"><a href="#SpringBoot源码分析-启动过程" class="headerlink" title="SpringBoot源码分析 - 启动过程"></a>SpringBoot源码分析 - 启动过程</h2><p>基于SpringBoot 2.3.4</p><h3 id="main-SpringApplication-run"><a href="#main-SpringApplication-run" class="headerlink" title="main#SpringApplication.run()"></a>main#SpringApplication.run()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringBoot Web服务入口</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SpringApplication#run</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 先构造SpringApplication实例，再调用run方法</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先构造SpringApplication实例，再调用run方法。</p><h3 id="SpringApplication-构造方法"><a href="#SpringApplication-构造方法" class="headerlink" title="SpringApplication#构造方法"></a>SpringApplication#构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line"><span class="comment">// 设置SpringApplication#primarySources，注意这里primarySources参数就是run方法的第一个参数</span></span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); <span class="comment">//#1</span></span><br><span class="line"><span class="comment">// 判断当前应用是JAVA应用，SERVLET应用或REACTIVE应用。</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath(); <span class="comment">//#2</span></span><br><span class="line"><span class="comment">// 加载spring.factories中配置的ApplicationContextInitializer实现类，将结果存放到SpringApplication#initializers</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); <span class="comment">//#3</span></span><br><span class="line"><span class="comment">// 加载spring.factories中配置的ApplicationListener实现类，将结果存放到SpringApplication#listeners</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); <span class="comment">//#4</span></span><br><span class="line"><span class="comment">// 获取main方法所在Class</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass(); <span class="comment">//#5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deduceFromClasspath-webApplicationType"><a href="#deduceFromClasspath-webApplicationType" class="headerlink" title="deduceFromClasspath - webApplicationType"></a>deduceFromClasspath - webApplicationType</h4><p>Springboot 项目的程序类型有三种：</p><ol><li>WebApplicationType.NONE<br>   非 web 应用程序（不内嵌服务器）</li><li>WebApplicationType.SERVLET<br>   内嵌基于 servlet 的 web 服务器（如：Tomcat，Jetty，Undertow 等，其实现在大多Java网站应用都是采用的基于 Tomcat 的 servlet 类型服务器）</li><li>WebApplicationType.REACTIVE<br>   内嵌基于反应式的 web 服务器（如： Netty）</li></ol><h4 id="deduceMainApplicationClass-mainApplicationClass"><a href="#deduceMainApplicationClass-mainApplicationClass" class="headerlink" title="deduceMainApplicationClass - mainApplicationClass"></a>deduceMainApplicationClass - mainApplicationClass</h4><p>获取main方法所在Class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用异常堆栈来判断 当前主类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">      StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">      <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="string">&quot;main&quot;</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      <span class="comment">// Swallow and continue</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring-boot的启动主类，一切都是由spring自己推导的，所以我们不要所以然的认为主类是我们传给spring容器的。</p><h4 id="SpringApplication-getSpringFactoriesInstances"><a href="#SpringApplication-getSpringFactoriesInstances" class="headerlink" title="SpringApplication#getSpringFactoriesInstances"></a>SpringApplication#getSpringFactoriesInstances</h4><p><strong>spring-boot</strong>:SpringApplication#getSpringFactoriesInstances<br><strong>spring-core</strong>:SpringFactoriesLoader#loadSpringFactories</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringApplication#getSpringFactoriesInstances</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line"><span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line"><span class="comment">// SpringFactoriesLoader.loadFactoryNames(type, classLoader)</span></span><br><span class="line">Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SpringFactoriesLoader#loadFactoryNames</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SpringFactoriesLoader#loadSpringFactories</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// FACTORIES_RESOURCE_LOCATION就是字符串&quot;META-INF/spring.factories&quot;，这里读取jar中META-INF/spring.factories文件内容</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line"><span class="comment">// 加载spring.factories文件（格式为Properties）</span></span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line"><span class="comment">// 读取Properties内容，缓存结果</span></span><br><span class="line">result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.haier.updaterecord.mybatis.plus.spring.boot.autoconfigure.UpdateRecordAutoConfiguration,\</span><br><span class="line">com.haier.updaterecord.core.factory.UpdateRecordServiceFactory</span><br></pre></td></tr></table></figure><p>key为spring扩展接口（或声明功能的注解），value为对应的功能实现类的列表</p><h3 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication#run"></a>SpringApplication#run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   <span class="comment">// 监视器启动，计算初始化需要花费多少时间</span></span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList();</span><br><span class="line">   <span class="comment">// 配置java.awt.headless</span></span><br><span class="line">   <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">   <span class="comment">// 从 META-INF/spring.factories 中获取 SpringApplicationRunListener 实现类，并调用starting（）</span></span><br><span class="line">   SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">   listeners.starting();</span><br><span class="line"></span><br><span class="line">   Collection exceptionReporters;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 命令行参数处理</span></span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">      <span class="comment">// 构建Environment，准备环境变量配置</span></span><br><span class="line">      ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">      <span class="comment">// 通过 spring.beaninfo.ignore 配置是否忽略bean信息 暂不明觉厉</span></span><br><span class="line">      <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">      <span class="comment">// 打印SpringBoot控制台启动图案</span></span><br><span class="line">      Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">      <span class="comment">// 创建应用上下文ApplicationContext</span></span><br><span class="line">      context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">      <span class="comment">// 从 META-INF/spring.factories 中获取异常报告处理器，用作处理启动异常</span></span><br><span class="line">      exceptionReporters = <span class="keyword">this</span>.getSpringFactoriesInstances(SpringBootExceptionReporter.class, <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 准备应用上下文</span></span><br><span class="line"><span class="comment">         * 1 设置上下文环境配置</span></span><br><span class="line"><span class="comment">         * 2 注册 beanNameGenerator 等</span></span><br><span class="line"><span class="comment">         * 3 执行 ApplicationContextInitializer#initialize()初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 刷新上下文 重要！！！</span></span><br><span class="line">      <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 容器初始化之后 开始执行 ApplicationRunner 和 CommandLineRunner 自定义初始化执行器</span></span><br><span class="line">      <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      listeners.started(context);</span><br><span class="line">      <span class="keyword">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      listeners.running(context);</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run-prepareEnvironment"><a href="#run-prepareEnvironment" class="headerlink" title="run#prepareEnvironment"></a>run#prepareEnvironment</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Create and configure the environment</span></span><br><span class="line">     <span class="comment">// 创建一个Environment</span></span><br><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">     <span class="comment">// 将SpringApplication#run中的可变参数列表传递给Environment</span></span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">     <span class="comment">// 发送ApplicationEnvironmentPreparedEvent事件</span></span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"><span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关于SpringApplication-run中的args参数"><a href="#关于SpringApplication-run中的args参数" class="headerlink" title="关于SpringApplication#run中的args参数"></a>关于SpringApplication#run中的args参数</h5><p>我们在启动SpringBoot时，可以添加命令行参数，如<strong>java -jar app.jar –spring.profiles.active=dev</strong>。<br>命令行参数<code>--spring.profiles.active=dev</code>会传递给main方法，main方法中需要将其传递给<strong>SpringApplication#run</strong>方法，<br>这里将命令行参数添加Environment中，作为一个PropertySource。</p><h4 id="run-createApplicationContext"><a href="#run-createApplicationContext" class="headerlink" title="run#createApplicationContext"></a>run#createApplicationContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line"><span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line"><span class="comment">// SERVLET应用，选择AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line"><span class="comment">// REACTIVE应用，选择AnnotationConfigReactiveWebServerApplicationContext</span></span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// JAVA应用，选择AnnotationConfigApplicationContext</span></span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造对应的Spring Context</span></span><br><span class="line"><span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般我们的<strong>SringBoot Web应用</strong>的<strong>webApplicationType</strong>为<strong>SERVLET</strong>，所以会创建<strong>AnnotationConfigServletWebServerApplicationContext</strong>。<br><strong>其父类ServletWebServerApplicationContext，通过ServletWebServerFactory创建并初始化WebServer。</strong><br>WebServer兼容不同的servlet容器（tomcat，jetty，netty），提供统一的start，stop操作。</p><h4 id="run-prepareContext"><a href="#run-prepareContext" class="headerlink" title="run#prepareContext"></a>run#prepareContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="params"><span class="function">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置context上下文环境</span></span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line"><span class="comment">// ApplicationContext的后置处理</span></span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line"><span class="comment">// 调用ApplicationContextInitializer#initialize，执行initialize</span></span><br><span class="line">applyInitializers(context);</span><br><span class="line"><span class="comment">// 调用SpringApplicationRunListener#contextPrepared方法，发布contextPrepared事件</span></span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="comment">// 打印项目启动日志</span></span><br><span class="line">logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 打印profile</span></span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add boot specific singleton beans</span></span><br><span class="line"><span class="comment">// 获取到DefaultListableBeanFactory实例</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line"><span class="comment">// 注册名为springApplicationArguments,值为applicationArguments的命令行参数单例bean</span></span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line"><span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果banner不为空,那么注册名为springBootBanner,值为printedBanner的单例bean</span></span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line"><span class="comment">// allowBeanDefinitionOverriding默认为false</span></span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Load the sources</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line"><span class="comment">// 当前sources列表中只有一个main启动方法所在的Application.class对象，在此处加载springboot启动类</span></span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SpringApplication#load</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化BeanDefinitionLoader</span></span><br><span class="line">BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setBeanNameGenerator(<span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setEnvironment(<span class="keyword">this</span>.environment);</span><br><span class="line">&#125;</span><br><span class="line">loader.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run-refreshContext"><a href="#run-refreshContext" class="headerlink" title="run#refreshContext"></a>run#refreshContext</h4><p>参照Spring源码解析的refreshContext部分。</p><p>AbstractApplicationContext#refresh()#invokeBeanFactoryPostProcessors(beanFactory)，<strong>自动装配在此完成</strong>。<br>当前applicationContext是AnnotationConfigServletWebServerApplicationContext。</p><h2 id="SpringBoot源码分析-启动过程-Tomcat启动"><a href="#SpringBoot源码分析-启动过程-Tomcat启动" class="headerlink" title="SpringBoot源码分析 - 启动过程 - Tomcat启动"></a>SpringBoot源码分析 - 启动过程 - Tomcat启动</h2><h3 id="Tomcat和Spring、Spring-MVC的关系"><a href="#Tomcat和Spring、Spring-MVC的关系" class="headerlink" title="Tomcat和Spring、Spring MVC的关系"></a>Tomcat和Spring、Spring MVC的关系</h3><h3 id="为什么默认是Tomcat"><a href="#为什么默认是Tomcat" class="headerlink" title="为什么默认是Tomcat"></a>为什么默认是Tomcat</h3><p>spring-boot-starter-web最原始依赖的是tomcat。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入springboot父依赖--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--引入启动器依赖 里面就有默认的tomcat --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--引入启动器依赖 里面就有默认的tomcat --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--排除tomcat--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--引入Jetty--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入Netty--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--引入Undertow--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="createApplicationContext-gt-AnnotationConfigServletWebServerApplicationContext"><a href="#createApplicationContext-gt-AnnotationConfigServletWebServerApplicationContext" class="headerlink" title="createApplicationContext -&gt; AnnotationConfigServletWebServerApplicationContext"></a>createApplicationContext -&gt; AnnotationConfigServletWebServerApplicationContext</h3><p>因为我们的应用是 Web Servlet 类型，<br>所以实例化的是AnnotationConfigServletWebServerApplicationContext。</p><p><img src="/2023/03/25/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/AnnotationConfigServletWebServerApplicationContext.png"></p><h3 id="refreshContext-gt-tomcat启动"><a href="#refreshContext-gt-tomcat启动" class="headerlink" title="refreshContext -&gt; tomcat启动"></a>refreshContext -&gt; tomcat启动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">    refresh(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">            <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">    ((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">        <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">            <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">/** 主要关系 onRefresh() 方法 ------------- **/</span></span><br><span class="line">            <span class="keyword">this</span>.onRefresh();</span><br><span class="line">            <span class="keyword">this</span>.registerListeners();</span><br><span class="line">            <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.warn(<span class="string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">            <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">            <span class="keyword">throw</span> var9;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.createWebServer();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;Unable to start web server&quot;</span>, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">    ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">    <span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/** 得到Servlet WebServer工厂 **/</span></span><br><span class="line">        ServletWebServerFactory factory = <span class="keyword">this</span>.getWebServerFactory();</span><br><span class="line">        <span class="keyword">this</span>.webServer = factory.getWebServer(<span class="keyword">new</span> ServletContextInitializer[]&#123;<span class="keyword">this</span>.getSelfInitializer()&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.getSelfInitializer().onStartup(servletContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.initPropertySources();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SpringBoot源码分析-启动过程-Spring-MVC启动"><a href="#SpringBoot源码分析-启动过程-Spring-MVC启动" class="headerlink" title="SpringBoot源码分析 - 启动过程 - Spring MVC启动"></a>SpringBoot源码分析 - 启动过程 - Spring MVC启动</h2><p>即Spring MVC的核心组件DispatcherServlet的注册过程。<br>DispatcherServlet 如何通过自动配置注册到ServletWebServer中。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO - BIO</title>
      <link href="/2023/03/22/JavaIO-BIO/"/>
      <url>/2023/03/22/JavaIO-BIO/</url>
      
        <content type="html"><![CDATA[<p>BIO，blocking IO，同步阻塞IO。最容易理解、最容易实现的IO工作方式。<br>应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送到应用程序；最后应用程序收到数据，并解除等待状态。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="阻塞IO-amp-非阻塞IO"><a href="#阻塞IO-amp-非阻塞IO" class="headerlink" title="阻塞IO &amp; 非阻塞IO"></a>阻塞IO &amp; 非阻塞IO</h3><p>这两个概念是<strong>应用程序级别</strong>的。<br>主要描述的是应用程序请求操作系统IO操作后，如果IO资源没有准备好，那么应用程序该如何处理的问题。</p><ul><li>阻塞IO：应用程序等待</li><li>非阻塞IO：应用程序继续执行（并且使用线程一直轮询，直到有IO资源准备好了）</li></ul><h3 id="同步IO-amp-异步IO"><a href="#同步IO-amp-异步IO" class="headerlink" title="同步IO &amp; 异步IO"></a>同步IO &amp; 异步IO</h3><p>这两个概念是<strong>操作系统级别</strong>的。<br>主要描述的是操作系统在收到应用程序请求IO操作后，如果IO资源没有准备好，该如何响应应用程序的问题。</p><ul><li>同步IO：不响应，直到IO资源准备好以后</li><li>异步IO：返回一个标记（好让应用程序和自己知道之后准备好的数据往哪里通知），当IO资源准备好以后，再用事件机制返回给应用程序。</li></ul><h2 id="传统的BIO通信方式简介"><a href="#传统的BIO通信方式简介" class="headerlink" title="传统的BIO通信方式简介"></a>传统的BIO通信方式简介</h2><p>以前大多数网络通信方式都是阻塞模式的，即：</p><ul><li>客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。</li><li>服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。</li></ul><p><a href="java-io-bio.png"></a></p><h3 id="BIO的问题"><a href="#BIO的问题" class="headerlink" title="BIO的问题"></a>BIO的问题</h3><ol><li>同一时间，服务器只能接受来自于客户端A的请求信息；虽然客户端A和客户端B的请求是同时进行的，但客户端B发送的请求信息只能等到服务器接受完A的请求数据后，才能被接受。</li><li>由于服务器一次只能处理一个客户端请求，当处理完成并返回后(或者异常时)，才能进行第二次请求的处理。很显然，这样的处理方式在高并发的情况下，是不能采用的。</li></ol><h3 id="多线程方式-伪异步"><a href="#多线程方式-伪异步" class="headerlink" title="多线程方式 - 伪异步"></a>多线程方式 - 伪异步</h3><p>上面说的情况是服务器只有一个线程的情况，那么是否可以使用多线程技术来解决这个问题:</p><ul><li>当服务器收到客户端X的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端Y的请求。</li><li>客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式/观察模式(等其他设计模式)通知主线程。</li></ul><p><a href="java-io-bio-%E5%A4%9A%E7%BA%BF%E7%A8%8B"></a><br>使用线程来解决这个问题实际上是有局限性的。</p><ol><li>虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知accept()的方式还是单个的。也就是，实际上是服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来</li><li>在linux系统中，可以创建的线程是有限的。我们可以通过cat /proc/sys/kernel/threads-max 命令查看可以创建的最大线程数。当然这个值是可以更改的，但是线程越多，CPU切换所需的时间也就越长，用来处理真正业务的需求也就越少。</li><li>创建一个线程是有较大的资源消耗的。JVM创建一个线程的时候，即使这个线程不做任何的工作，JVM都会分配一个堆栈空间。这个空间的大小默认为128K，您可以通过-Xss参数进行调整。当然还可以使用ThreadPoolExecutor线程池来缓解线程的创建问题，但是又会造成BlockingQueue积压任务的持续增加，同样消耗了大量资源。</li><li>另外，如果应用程序大量使用长连接的话，线程是不会关闭的。这样系统资源的消耗更容易失控。 </li></ol><p>那么，如果真想单纯使用线程解决阻塞的问题，那么都可以算出来一个服务器节点可以一次接受多大的并发了。<br>看来，单纯使用线程解决这个问题不是最好的办法。</p><h2 id="BIO通信方式深入分析"><a href="#BIO通信方式深入分析" class="headerlink" title="BIO通信方式深入分析"></a>BIO通信方式深入分析</h2><p>BIO的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于accept()、read()的操作点都是被阻塞。</p><p>要测试这个问题，也很简单。<br>我们模拟了20个客户端(用20根线程模拟)，利用JAVA的同步计数器CountDownLatch，保证这20个客户都初始化完成后然后同时向服务器发送请求，然后我们来观察一下Server这边接受信息的情况。</p><h3 id="模拟20个客户端并发请求，服务器端使用单线程"><a href="#模拟20个客户端并发请求，服务器端使用单线程" class="headerlink" title="模拟20个客户端并发请求，服务器端使用单线程"></a>模拟20个客户端并发请求，服务器端使用单线程</h3><h3 id="多线程来优化服务器端"><a href="#多线程来优化服务器端" class="headerlink" title="多线程来优化服务器端"></a>多线程来优化服务器端</h3><h3 id="看看服务器端的执行效果"><a href="#看看服务器端的执行效果" class="headerlink" title="看看服务器端的执行效果"></a>看看服务器端的执行效果</h3><h3 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line"><span class="keyword">int</span> realLen = in.read(contextBytes, <span class="number">0</span>, maxLen);</span><br></pre></td></tr></table></figure><p>重点的问题并不是“是否使用了多线程”，而是为什么accept()、read()方法会被阻塞。</p><p><strong>serverSocket.accept()会被阻塞?</strong><br><strong>它内部的实现是使用的操作系统级别的同步IO。</strong></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO - NIO</title>
      <link href="/2023/03/21/JavaIO-NIO/"/>
      <url>/2023/03/21/JavaIO-NIO/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h2><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p><h3 id="Java-IO与NIO的区别"><a href="#Java-IO与NIO的区别" class="headerlink" title="Java IO与NIO的区别"></a>Java IO与NIO的区别</h3><p>标准IO是对字节流的读写，在进行IO之前，首先创建一个流对象，流对象进行读写操作都是按字节 ，一个字节一个字节的来读或写。<br>而NIO把IO抽象成块，类似磁盘的读写，每次IO操作的单位都是一个块，块被读入内存之后就是一个byte[]，NIO一次可以读或写多个字节。</p><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p><p>Java NIO 由以下几个核心部分组成： </p><ol><li>缓冲区 Buffer</li><li>通道 Channel </li><li>选择器 Selector</li></ol><p>传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。<br>NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。</p><p>NIO的主要用途是网络IO，在NIO之前java要使用网络编程就只有用Socket。而Socket是阻塞的，显然对于高并发的场景是不适用的。所以NIO的出现就是解决了这个痛点。</p><p>主要思想是把Channel通道注册到Selector中，通过Selector去监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动。没有监听的事件，服务器可以做自己的事情。</p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>Buffer是一个内存块。<br>在NIO中，所有的数据都是用Buffer处理，有读写两种模式。在读模式下，应用程序只能从Buffer中读取数据，不能进行写操作。但是在写模式下，应用程序是可以进行读操作的，这就表示可能会出现脏读的情况。所以一旦决定要从Buffer中读取数据，一定要将Buffer的状态改为读模式。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。<br>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p><p>常用的四种channel</p><ul><li>FileChannel，读写文件中的数据。</li><li>SocketChannel，TCP Socket套接字的监听通道，一个<strong>Socket套接字</strong>对应了一个<strong>客户端IP: 端口 到 服务器IP: 端口</strong>的通信连接。</li><li>ServerSockectChannel，应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持<strong>多路复用IO</strong>的端口监听。同时支持UDP协议和TCP协议。</li><li>DatagramChannel，UDP 数据报文的监听通道。</li></ul><p>Channel本身并不存储数据，只是负责数据的运输。必须要和Buffer一起使用。</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector，选择器/多路复用器/轮询代理器/事件订阅器/channel容器管理机。<br>只有网络IO才会使用选择器，文件IO是不需要使用的。<br>选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现单线程管理多个Channel的目的。</p><ul><li>事件订阅和Channel管理<br>  应用程序将向Selector对象注册需要它关注的Channel，以及具体的某一个Channel会对哪些IO事件感兴趣。Selector中也会维护一个“已经注册的Channel”的容器。</li><li>轮询代理<br>  应用程序不再通过阻塞模式或者非阻塞模式直接询问操作系统“事件有没有发生”，而是由Selector代其询问。</li><li>实现不同操作系统的支持<br>  多路复用IO技术是需要操作系统进行支持的，其特点就是操作系统可以同时扫描同一个端口上不同网络连接的事件。<br>  所以作为上层的JVM，必须要为不同操作系统的多路复用IO实现编写不同的代码。</li></ul><p><strong>NIO 实现了 IO 多路复用中的 Reactor 模型</strong>，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p><p>监听配置为<strong>非阻塞的通道 Channel</strong>，那么当该 Channel 上的 IO 事件还未到达时，Selector 就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。<br>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。<br>应该注意的是，<strong>只有 SocketChannel 才能配置为非阻塞</strong>，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p><p><img src="/2023/03/21/JavaIO-NIO/javanio-selector.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、将通道注册到选择器上</span></span><br><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 通道配置为非阻塞</span></span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 注册的具体事件</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_CONNECT</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_ACCEPT</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_READ</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_WRITE</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、监听事件 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</span></span><br><span class="line"><span class="keyword">int</span> num = selector.select();</span><br><span class="line"><span class="comment">// 4、获取到达的事件</span></span><br><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5、事件循环</span></span><br><span class="line"><span class="comment">// 因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零拷贝在Java中的实现"><a href="#零拷贝在Java中的实现" class="headerlink" title="零拷贝在Java中的实现"></a>零拷贝在Java中的实现</h3><p>如果涉及到文件传输，transferTo是首选，但是如果涉及到对内存数据的修改选用MappedByteBuffer。</p><h4 id="mmap-MappedByteBuffer"><a href="#mmap-MappedByteBuffer" class="headerlink" title="mmap - MappedByteBuffer"></a>mmap - MappedByteBuffer</h4><p>MappedByteBuffer 是 Java 中的 mmap 操作类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. MappedByteBuffer 可让文件直接在内存(堆外内存)修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应的通道</span></span><br><span class="line">        FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1: FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">         * 参数2： 0 ： 可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">         * 参数3:  5: 是映射到内存的大小(不是索引位置) ,即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">         * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;Y&#x27;</span>);<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sendfile-FileChannel-transferTo"><a href="#sendfile-FileChannel-transferTo" class="headerlink" title="sendfile - FileChannel.transferTo()"></a>sendfile - FileChannel.transferTo()</h4><p>FileChannel的transferTo()/transferFrom()，底层就是sendfile() 系统调用函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        <span class="comment">//得到一个文件channel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.zip&quot;</span>).getChannel();</span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//在linux下一个transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在windows 下 一次调用 transferTo 只能发送8m , 就需要分段传输文件, 而且要主要</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总的字节数 =&quot;</span> + transferCount + <span class="string">&quot; 耗时:&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java对IO多路复用的支持"><a href="#Java对IO多路复用的支持" class="headerlink" title="Java对IO多路复用的支持"></a>Java对IO多路复用的支持</h3><p><img src="/2023/03/21/JavaIO-NIO/java%E5%AF%B9IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81.png"></p><p>多路复用IO技术是操作系统的内核实现。<br>在不同的操作系统，甚至同一系列操作系统的版本中所实现的多路复用IO技术都是不一样的。<br>那么作为跨平台的JAVA JVM来说如何适应多种多样的多路复用IO技术实现呢? </p><p>JAVA NIO中对各种多路复用IO的支持，主要的基础是java.nio.channels.spi.SelectorProvider抽象类。<br>其中的几个主要抽象方法包括:</p><ul><li>public abstract DatagramChannel openDatagramChannel(): 创建和这个操作系统匹配的UDP 通道实现。</li><li>public abstract AbstractSelector openSelector(): 创建和这个操作系统匹配的NIO选择器，就像上文所述，不同的操作系统，不同的版本所默认支持的NIO模型是不一样的。</li><li>public abstract ServerSocketChannel openServerSocketChannel(): 创建和这个NIO模型匹配的服务器端通道。</li><li>public abstract SocketChannel openSocketChannel(): 创建和这个NIO模型匹配的TCP Socket套接字通道(用来反映客户端的TCP连接)</li></ul><p><img src="/2023/03/21/JavaIO-NIO/java-nio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png"></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>什么是IO多路复用，简单讲，就是一个进程可以同时处理多个网络连接的IO请求。</p><p>IO多路复用技术最适用的是<strong>高并发</strong>场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下IO多路复用技术发挥不出来它的优势。</p><p>select、poll、epoll、kqueue是操作系统层面的IO多路复用的实现方法。<br>Reactor模型、Proactor模型是应用程序层面处理并发I/O的模型。</p><h3 id="Linux中典型的IO多路复用实现"><a href="#Linux中典型的IO多路复用实现" class="headerlink" title="Linux中典型的IO多路复用实现"></a>Linux中典型的IO多路复用实现</h3><p>select/poll/epoll 就是操作系统内核提供给用户态的多路复用系统调用函数，线程可以通过一个系统调用函数从内核中获取多个事件。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><ol><li><strong>用户态</strong>将<strong>已连接的 Socket （先 accept 好的）</strong>都放到一个<strong>文件描述符集合</strong>；</li><li>然后<strong>调用 select 函数将文件描述符集合拷贝到内核里</strong>，让<strong>内核来检查是否有网络事件产生</strong>，检查的方式很粗暴，就是通过<strong>遍历文件描述符集合</strong>的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写；</li><li>接着再把整个文件描述符集合<strong>拷贝回用户态</strong>里，用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</li></ol><p>对于 <strong>select</strong> 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里；<br>而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p><strong>select</strong> 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的<strong>FD_SETSIZE</strong>限制，<strong>默认最大值为1024，只能监听 0~1023 的文件描述符</strong>。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，<strong>突破了 select 的文件描述符个数限制</strong>，当然还会受到系统文件描述符限制。</p><p>但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是在Linux2.6版本推出的一种IO多路实现手段。</p><p><img src="/2023/03/21/JavaIO-NIO/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-epoll.png"></p><ul><li>epoll_create 负责创建一个池子，一个监控和管理句柄 fd 的池子；</li><li>epoll_ctl 负责管理这个池子里的 fd 增、删、改；</li><li>epoll_wait 就是负责打盹的，让出 CPU 调度，但是只要有“事”，立马会从这里唤醒；</li></ul><p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p><ol><li>epoll 在<strong>内核里</strong>使用<strong>红黑树</strong>来<strong>跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过<strong>epoll_ctl()函数</strong>加入内核中的红黑树里。<br> 红黑树是个高效的数据结构，增、删、改一般时间复杂度是 O(logn)。</li><li>epoll 使用<strong>事件驱动</strong>的机制，<strong>内核里维护了一个链表来记录就绪事件</strong>。<br> 当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中；<br> 当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符。<br> 不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li></ol><h5 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h5><p>mac平台的kqueue，类似于linux的epoll。</p><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><p>Reactor模型是对事件处理流程的一种模式抽象，是对IO多路复用模式的一种封装。<br>Reactor模式特别适合应用于处理多个客户端并发向服务器端发送请求的场景。</p><p>在Reactor模型中，主要有3个角色：</p><ul><li>Reactor<br>  派发器，负责监听和分配事件，并将事件分派给对应的 Handler。<br>  新的事件包含连接建立就绪、读就绪、写就绪等。</li><li>Acceptor<br>  请求连接器，处理客户端新连接。<br>  Reactor 接收到 client 端的连接事件后，会将其转发给 Acceptor，由 Acceptor 接收 Client 的连接，创建对应的 Handler，并向 Reactor 注册此 Handler。</li><li>Handler<br>  请求处理器，负责事件的处理，将自身与事件绑定，执行非阻塞读/写任务，完成 channel 的读入，完成处理业务逻辑后，负责将结果写出 channel。<br>  可用资源池/线程池来管理。</li></ul><h4 id="Reactor模型-单reactor单线程"><a href="#Reactor模型-单reactor单线程" class="headerlink" title="Reactor模型 - 单reactor单线程"></a>Reactor模型 - 单reactor单线程</h4><p><img src="/2023/03/21/JavaIO-NIO/%E5%8D%95reactor%E5%8D%95%E7%BA%BF%E7%A8%8B.png" alt="单reactor单线程"></p><ol><li>Reactor 线程通过 select 监听事件，收到事件后通过 Dispatch 进行分发</li><li>如果是连接建立事件，则将事件分发给 Acceptor，Acceptor 会通过 accept() 方法获取连接，并创建一个Handler 对象来处理后续的响应事件</li><li>如果是IO读写事件，则 Reactor 会将该事件交由当前连接的 Handler 来处理</li><li>Handler 会完成 read -&gt; 业务处理 -&gt; send 的完整业务流程</li></ol><p>改进后的Reactor模型相对于传统的IO模型主要有如下优点：</p><ul><li>从模型上来讲，如果仅仅还是只使用一个线程池来处理客户端连接的网络读写，以及业务计算，那么Reactor模型与传统IO模型在效率上并没有什么提升。但是Reactor模型是以事件进行驱动的，其能够将接收客户端连接，网络读和网络写，以及业务计算进行拆分，从而极大的提升处理效率；</li><li>Reactor模型是同步非阻塞模型，工作线程在没有网络事件时可以处理其他的任务，而不用像传统IO那样必须阻塞等待。</li></ul><h4 id="Reactor模型-单Reactor多线程-业务处理与IO分离"><a href="#Reactor模型-单Reactor多线程-业务处理与IO分离" class="headerlink" title="Reactor模型 - 单Reactor多线程 - 业务处理与IO分离"></a>Reactor模型 - 单Reactor多线程 - 业务处理与IO分离</h4><p>在上面的Reactor模型中，由于网络读写和业务操作都在同一个线程中，在高并发情况下，这里的系统瓶颈主要在两方面：</p><ul><li>高频率的网络读写事件处理</li><li>大量的业务操作处理</li></ul><p>基于上述两个问题，这里在单线程Reactor模型的基础上提出了使用线程池的方式处理业务操作的模型。<br>如下是该模型的示意图：<br><img src="/2023/03/21/JavaIO-NIO/%E5%8D%95reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="单reactor多线程"></p><ol><li>Reactor 线程通过 select 监听事件，收到事件后通过 Dispatch 进行分发</li><li>如果是连接建立事件，则将事件分发给 Acceptor，Acceptor 会通过 accept() 方法获取连接，并创建一个Handler 对象来处理后续的响应事件</li><li>如果是IO读写事件，则 Reactor 会将该事件交由当前连接对应的 Handler 来处理</li><li>与单Reactor单线程不同的是，Handler 不再做具体业务处理，只负责接收和响应事件，通过 read 接收数据后，将数据发送给后面的 Worker 线程池进行业务处理。</li><li>Worker 线程池再分配线程进行业务处理，完成后将响应结果发给 Handler 进行处理。</li><li>Handler 收到响应结果后通过 send 将响应结果返回给 Client。</li></ol><p>这种模式相较于单reactor单线程模式性能有了很大的提升，主要在于在进行网络读写的同时，也进行了业务计算，从而大大提升了系统的吞吐量。<br>但是这种模式也有其不足，主要在于：</p><ul><li>网络读写是一个比较消耗CPU的操作，在高并发的情况下，将会有大量的客户端数据需要进行网络读写，此时一个线程将不足以处理这么多请求。</li><li>Handler 使用多线程模式，自然带来了多线程竞争资源的开销，同时涉及共享数据的互斥和保护机制，实现比较复杂</li></ul><h4 id="Reactor模型-主从Reactor多线程-并发读写"><a href="#Reactor模型-主从Reactor多线程-并发读写" class="headerlink" title="Reactor模型 - 主从Reactor多线程 - 并发读写"></a>Reactor模型 - 主从Reactor多线程 - 并发读写</h4><p>主从 Reactor 多线程模型将 Reactor 分成两部分：</p><ol><li>MainReactor<br> 只负责处理连接建立事件，通过 select 监听 server socket，将建立的 socketChannel 指定注册给 subReactor，通常一个线程就可以了。</li><li>SubReactor<br> 负责读写事件，维护自己的 selector，基于 MainReactor 注册的 SocketChannel 进行多路分离 IO 读写事件，读写网络数据，并将业务处理交由 worker 线程池来完成。<br> SubReactor 的个数一般和 CPU 个数相同。</li></ol><p><img src="/2023/03/21/JavaIO-NIO/%E4%B8%BB%E4%BB%8Ereactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="主从reactor多线程"></p><h3 id="Proactor模型"><a href="#Proactor模型" class="headerlink" title="Proactor模型"></a>Proactor模型</h3><p>Proactor基于异步IO模式。<br>所有的 I/O 操作都交由系统提供的异步 I/O 接口去执行。工作线程仅仅负责业务逻辑。</p><p>在 Proactor 中，用户函数启动一个异步的文件操作。同时将这个操作注册到多路复用器上。多路复用器并不关心文件是否可读或可写而是关心这个异步读操作是否完成。异步操作是操作系统完成，用户程序不需要关心。多路复用器等待直到有完成通知到来。当操作系统完成了读文件操作——将读到的数据复制到了用户先前提供的缓冲区之后，通知多路复用器相关操作已完成。多路复用器再调用相应的处理程序，处理数据。</p><h2 id="Java-NIO的bug"><a href="#Java-NIO的bug" class="headerlink" title="Java NIO的bug"></a>Java NIO的bug</h2><h3 id="epoll空轮询"><a href="#epoll空轮询" class="headerlink" title="epoll空轮询"></a>epoll空轮询</h3><p>epoll机制是Linux下一种高效的IO复用方式，相较于select和poll机制来说，其高效的原因是将基于事件的fd放到内核中来完成，在内核中基于红黑树+链表数据结构来实现，链表存放有事件发生的fd集合，然后在调用epoll_wait时返回给应用程序，由应用程序来处理这些fd事件。</p><p>使用IO复用，Linux下一般默认就是epoll，Java NIO在Linux下默认也是epoll机制。<br>但是JDK中epoll的实现却是有漏洞的，其中最有名的<strong>java nio epoll bug</strong>就是即使是关注的select轮询事件返回数量为0，NIO照样不断的从select本应该阻塞的**Selector.select()/Selector.select(timeout)**中wake up出来，导致CPU 100%问题。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO - 基础</title>
      <link href="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-IO分类"><a href="#Java-IO分类" class="headerlink" title="Java IO分类"></a>Java IO分类</h2><p>从<strong>传输方式</strong>和<strong>数据操作</strong>两个方面分析Java IO的分类。</p><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>字节是给计算机看的，字符才是给人看的。</p><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>InputStream<br>OutputStream</p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>Reader<br>Writer</p><h4 id="字节和字符的区别和理解"><a href="#字节和字符的区别和理解" class="headerlink" title="字节和字符的区别和理解"></a>字节和字符的区别和理解</h4><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><ul><li>文件(file)<br>FileInputStream、FileOutputStream、FileReader、FileWriter</li><li>数组([])<br>字节数组(byte[]): ByteArrayInputStream、ByteArrayOutputStream<br>字符数组(char[]): CharArrayReader、CharArrayWriter</li><li>管道操作<br>PipedInputStream、PipedOutputStream、PipedReader、PipedWrite</li><li>基本数据类型<br>DataInputStream、DataOutputStream</li><li>缓冲操作<br>BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</li><li>打印<br>PrintStream、PrintWriter</li><li>对象序列化反序列化<br>ObjectInputStream、ObjectOutputStream</li><li>转换<br>InputStreamReader、OutputStreamWriter</li></ul><h2 id="Java-IO的设计模式-装饰者模式"><a href="#Java-IO的设计模式-装饰者模式" class="headerlink" title="Java IO的设计模式 - 装饰者模式"></a>Java IO的设计模式 - 装饰者模式</h2><h2 id="Java-IO源码-InputStream"><a href="#Java-IO源码-InputStream" class="headerlink" title="Java IO源码 - InputStream"></a>Java IO源码 - InputStream</h2><h2 id="Java-IO源码-OutputStream"><a href="#Java-IO源码-OutputStream" class="headerlink" title="Java IO源码 - OutputStream"></a>Java IO源码 - OutputStream</h2><h2 id="IO模型-Unix-IO模型"><a href="#IO模型-Unix-IO模型" class="headerlink" title="IO模型 - Unix IO模型"></a>IO模型 - Unix IO模型</h2><h3 id="Unix的5种IO模型"><a href="#Unix的5种IO模型" class="headerlink" title="Unix的5种IO模型"></a>Unix的5种IO模型</h3><h4 id="阻塞I-O-blocking-IO"><a href="#阻塞I-O-blocking-IO" class="headerlink" title="阻塞I/O     blocking IO"></a>阻塞I/O     blocking IO</h4><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。<br>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p><p>下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。<br><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-%E9%98%BB%E5%A1%9Eio.png"></p><h4 id="非阻塞I-O-nonblocking-I-O"><a href="#非阻塞I-O-nonblocking-I-O" class="headerlink" title="非阻塞I/O   nonblocking I/O"></a>非阻塞I/O   nonblocking I/O</h4><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。<br>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。<br><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-%E9%9D%9E%E9%98%BB%E5%A1%9Eio.png"></p><h4 id="I-O复用-I-O-multiplexing"><a href="#I-O复用-I-O-multiplexing" class="headerlink" title="I/O复用     I/O multiplexing"></a>I/O复用     I/O multiplexing</h4><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。<br>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。<br>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。<br><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-io%E5%A4%8D%E7%94%A8.png"></p><h4 id="信号驱动I-O-signal-driven-I-O-SIGIO"><a href="#信号驱动I-O-signal-driven-I-O-SIGIO" class="headerlink" title="信号驱动I/O  signal driven I/O (SIGIO)"></a>信号驱动I/O  signal driven I/O (SIGIO)</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。<br>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。<br><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io.png"></p><h4 id="异步I-O-asynchronous-I-O"><a href="#异步I-O-asynchronous-I-O" class="headerlink" title="异步I/O     asynchronous I/O"></a>异步I/O     asynchronous I/O</h4><p>进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。<br>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。<br><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-%E5%BC%82%E6%AD%A5io.png"></p><h3 id="I-O模型比较"><a href="#I-O模型比较" class="headerlink" title="I/O模型比较"></a>I/O模型比较</h3><p><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/io%E6%A8%A1%E5%9E%8B-%E6%AF%94%E8%BE%83.png"><br>前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p><p>同步 I/O: 应用进程在调用 recvfrom 操作时会阻塞。<br>异步 I/O: 不会阻塞。<br>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</p><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><blockquote><p>IO多路复用最为重要，后面的文章<strong>Java IO - NIO</strong>将对IO多路复用，Ractor模型以及Java NIO对其的支持作详解。</p></blockquote><h4 id="IO多路复用工作模式"><a href="#IO多路复用工作模式" class="headerlink" title="IO多路复用工作模式"></a>IO多路复用工作模式</h4><p>epoll 的描述符事件有两种触发模式: LT(level trigger)和 ET(edge trigger)。</p><p><strong>LT模式</strong><br>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。<br>是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。<br><strong>ET模式</strong><br>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。<br>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。<br>只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id="应用场景-select-amp-poll-amp-epoll"><a href="#应用场景-select-amp-poll-amp-epoll" class="headerlink" title="应用场景 select&amp;poll&amp;epoll"></a>应用场景 select&amp;poll&amp;epoll</h4><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。<br><strong>selent</strong><br><strong>poll</strong><br><strong>epoll</strong></p><h2 id="IO基础知识与概念"><a href="#IO基础知识与概念" class="headerlink" title="IO基础知识与概念"></a>IO基础知识与概念</h2><h3 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h3><p>在计算机操作系统中，所谓的I/O就是<strong>输入 input</strong>和<strong>输出 output</strong>，也可以理解为<strong>读 read</strong>和<strong>写 write</strong>。<br>针对不同的对象，I/O模式可以划分为<strong>磁盘IO</strong>和<strong>网络IO</strong>。</p><p>I/O操作会涉及到<strong>用户空间</strong>和<strong>内核空间</strong>的转换，理解以下规则：</p><ul><li>内存空间分为用户空间和内核空间，也称为用户缓冲区和内核缓冲区；</li><li>用户的应用程序不能直接操作内核空间，需要将数据从内核空间拷贝到用户空间才能使用；</li><li>无论是read操作，还是write操作，都只能在内核空间里执行；</li><li>磁盘IO和网络IO请求加载到内存的数据都是先放在内核空间的。</li></ul><p>在IO中（磁盘IO或者是网络IO），都是由用户去调用<strong>Read</strong>读取内核态中的数据，读取数据到用户态；而<strong>write</strong>则是将数据从用户态写到内核态中，由内核去写入文件或者是通过网络IO（网卡）发送数据。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符(fd, File Descriptor)，用于描述指向文件的引用的抽象化概念。</p><p>当应用程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。<br>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。<br>在Linxu系统中，一切皆文件，因此socket也是一个文件，也有文件句柄（或文件描述符）。</p><h3 id="操作系统的内核态和用户态"><a href="#操作系统的内核态和用户态" class="headerlink" title="操作系统的内核态和用户态"></a>操作系统的内核态和用户态</h3><p>Linux系统中分为<strong>内核态 Kernel Model</strong>和<strong>用户态 User Model</strong>，CPU会在两个Model之间切换。</p><p>通俗点讲，<strong>内核空间</strong>是操作系统内核代码运行的地方，<strong>用户空间</strong>是用户程序代码运行的地方。<br>当应用进程在运行用户代码时就处于<strong>用户态</strong>。<br>当应用进程执行系统调用，从而内核代码执行时就处于<strong>内核态</strong>。</p><p>内核空间可以执行任意的命令，而用户空间只能执行简单的运算，不能直接调用系统资源和数据。必须通过操作系统提供接口，向系统内核发送指令。<br>一旦调用系统接口，应用进程就从用户态切换到内核态了，因为开始运行内核代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;i am qige&quot;</span> <span class="comment">// 用户空间，赋值运算</span></span><br><span class="line">x = x + <span class="number">2</span>         <span class="comment">// 用户空间，赋值运算</span></span><br><span class="line">file.write(str)   <span class="comment">// 切换到内核空间。因为用户不能直接写文件，必须通过内核安排。</span></span><br><span class="line">y = x + <span class="number">4</span>         <span class="comment">// 切换回用户空间</span></span><br></pre></td></tr></table></figure><h4 id="用户态切换到内核态的3种方式"><a href="#用户态切换到内核态的3种方式" class="headerlink" title="用户态切换到内核态的3种方式"></a>用户态切换到内核态的3种方式</h4><ol><li>系统调用<br> 也称为 System Call，是说用户态进程<strong>主动</strong>要求切换到内核态的一种方式，用户态进程使用操作系统提供的服务程序完成工作。</li><li>异常<br> 当CPU在用户空间执行程序代码时发生了不可预期的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，切换到内核态，比如缺页异常。</li><li>外围设备的中断<br> 当外围设备完成用户请求的某些操作后，会向CPU发送相应的中断信号，这时CPU会暂停执行下一条即将执行的指令转而去执行与中断信号对应的处理程序，如果当前正在运行用户态下的程序指令，自然就发生由用户态到内核态的切换。<br> 比如硬盘数据读写完成，系统会切换到中断处理程序中执行后续操作等。</li></ol><h3 id="磁盘IO-amp-网络IO"><a href="#磁盘IO-amp-网络IO" class="headerlink" title="磁盘IO &amp; 网络IO"></a>磁盘IO &amp; 网络IO</h3><h4 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h4><p><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/IO%E5%9F%BA%E7%A1%80-%E7%A3%81%E7%9B%98IO.png"></p><p><strong>读操作</strong><br>当应用程序调用read()方法时，操作系统检查内核高速缓冲区中是否存在需要的数据。<br>如果存在，那么就直接把内核空间的数据copy到用户空间，供用户的应用程序使用。<br>如果内核缓冲区没有需要的数据，那么通过DMA方式从磁盘中读取数据到内核缓冲区，然后由CPU控制，把内核空间的数据copy到用户空间。</p><p>这个过程会涉及到两次缓冲区copy，第一次是从磁盘到内核缓冲区，第二次是从内核缓冲区到用户缓冲区，第一次是DMA的copy，第二次是CPU的copy。</p><p><strong>写操作</strong><br>当应用程序调用write()方法时，应用程序将数据从用户空间copy到内核空间的缓冲区中（如果用户空间没有相应的数据，则需要从磁盘—&gt;内核缓冲区—&gt;用户缓冲区），这时对用户程序来说写操作就已经完成。<br>至于什么时候把数据再写到磁盘（从内核缓冲区到磁盘的写操作也由DMA控制，不需要cpu参与），由操作系统决定。<br>除非应用程序显示地调用了sync命令，立即把数据写入磁盘。</p><p>如果应用程序没准备好写的数据，则必须先从磁盘读取数据才能执行写操作。<br>这时会涉及到<strong>四次</strong>缓冲区的copy，第一次是从磁盘的缓冲区到内核缓冲区，第二次是从内核缓冲区到用户缓冲区，第三次是从用户缓冲区到内核缓冲区，第四次是从内核缓冲区写回到磁盘。前两次是为了读，后两次是为了写。这其中有两次 CPU 拷贝，两次DMA拷贝。</p><p><strong>磁盘IO的延时</strong><br>为了读或写，磁头必须能移动到所指定的磁道上，并等待所指定的扇区的开始位置旋转到磁头下，然后再开始读或写数据。<br>磁盘IO的延时分成以下三部分：</p><ul><li>寻道时间：把磁头移动到指定磁道上所经历的时间；</li><li>旋转延迟时间 ：指定扇区移动到磁头下面所经历的时间；</li><li>传输时间 ：数据的传输时间（数据读出或写入的时间）。</li></ul><h4 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h4><p><img src="/2023/03/21/JavaIO-%E5%9F%BA%E7%A1%80/IO%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9CIO.png"></p><p><strong>读操作</strong><br>网络 IO 既可以从物理磁盘中读数据，也可以从Socket中读数据（从网卡中获取）。<br>当从物理磁盘中读数据的时候，其流程和磁盘IO的读操作一样。<br>当从Socket中读数据，应用程序需要等待客户端发送数据，如果客户端还没有发送数据，对应的应用程序将会被阻塞，直到客户端发送了数据，该应用程序才会被唤醒，从Socket协议栈（网卡）中读取客户端发送的数据到内核空间的Socket Buffer（这个过程也由DMA控制），然后把内核空间的数据 copy 到用户空间，供应用程序使用。</p><p><strong>写操作</strong><br>假设网络IO的数据从磁盘中获取，读写操作的流程如下：</p><ul><li>当应用程序调用 read() 方法时，通过DMA方式将数据从磁盘拷贝到内核缓冲区；</li><li>由cpu控制，将内核缓冲区的数据拷贝到用户空间的缓冲区中，供应用程序使用；</li><li>当应用程序调用 write() 方法时，CPU 会把用户缓冲区中的数据 copy 到内核缓冲区的 Socket Buffer 中；</li><li>最后通过DMA方式将内核空间中的Socket Buffer拷贝到Socket协议栈（即网卡设备）中传输。</li></ul><p>网络IO 的写操作也有<strong>四次</strong>缓冲区的copy，第一次是从磁盘缓冲区到内核缓冲区（由DMA控制），第二次是内核缓冲区到用户缓冲区（CPU控制），第三次是用户缓冲区到内核缓冲区的 Socket Buffer（由CPU控制），第四次是从内核缓冲区的 Socket Buffer 到网卡设备（由DMA控制）。四次缓冲区的copy工作两次由CPU控制，两次由DMA控制。</p><p><strong>网络IO的延时</strong><br>网络IO主要延时是由：<strong>服务器响应延时+带宽限制+网络延时+跳转路由延时+本地接收延时</strong>决定。一般为几十到几千毫秒，受环境影响较大。<br>所以，一般来说，网络IO延时要大于磁盘IO延时(不过同数据中心的交互除外，会比磁盘 IO 更快)。</p><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>mmap的核心思想是：应用程序这边由于在用户态无法直接操作寄存器的物理地址，于是通过mmap方法进行内存映射，将物理地址映射到用户态的虚拟地址上，然后应用程序通过读写自己手边的虚拟地址，就可以实现对物理地址的读取/写入。</p><h4 id="sendFile"><a href="#sendFile" class="headerlink" title="sendFile"></a>sendFile</h4><p>sendfile系统调用函数，可以直接把内核缓冲区的数据直接拷贝到socket缓冲区中，不再拷贝到用户态。</p><p><strong>sendfile</strong>要求输入的fd必须是文件句柄，不能是socket，输出的fd必须是socket，也就是说，数据的来源必须是从本地的磁盘，而不能是从网络中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span></span><br></pre></td></tr></table></figure><p>in_fd 必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。<br>由此可见，sendfile 几乎是专门为在网络上传输文件而设计的。</p><h3 id="数据传输方式-PIO-amp-DMA"><a href="#数据传输方式-PIO-amp-DMA" class="headerlink" title="数据传输方式 PIO &amp; DMA"></a>数据传输方式 PIO &amp; DMA</h3><p>DMA（直接存储器访问）和 PIO（程控输入/输出）。<br>DMA和PIO分别是在电子设备中传输信息的两种方式；在计算机和其他类似设备中更为著名。<br>PIO是一种较老的方法，由于某些优点，在大多数应用中已被DMA取代。</p><h3 id="缓冲IO-amp-直接IO"><a href="#缓冲IO-amp-直接IO" class="headerlink" title="缓冲IO &amp; 直接IO"></a>缓冲IO &amp; 直接IO</h3><h4 id="缓冲IO"><a href="#缓冲IO" class="headerlink" title="缓冲IO"></a>缓冲IO</h4><p>机械硬盘的读写原理与特点是：一个机械硬盘中装有多个盘片，每个盘片上有多个同心圆（磁道），每个同心圆又由多个弧（扇区）组成，每个弧上都记录了等量的数据（比方说512byte）。<br>如果发起一个随机读写请求，磁头需要先找到对应的磁道，然后等待对应的扇区旋转到磁头正下方才能开始读取数据（民用机械硬盘的转速一般在5400或者7200RPM，工业界倒是经常使用10000RPM的机械硬盘。但是它们的寻道时间大概都在几ms到十几ms左右）。<br>机械硬盘的顺序读写很快（一般在100-200MB/s），但是随机读写很慢（寻道时间在十几ms，导致随机读写的iops只有几十）。</p><p>假定我们不做任何额外的优化处理，在用户发起读数据请求的时候，直接调用硬盘驱动读取磁盘数据并返回。<br>设想一个场景：循环调用read方法读取文件，但是每次只读取较少的数据（比方说每次只读一个byte）。那么每次read请求都对应于一次对磁盘的随机读写（两次读请求之前需要重新寻道），也就是说read操作的tps只有几十。<br>也就是说此时磁盘占用率为100%，但是只能提供不到100byte/s的数据读取率，这显然是不可接受的。</p><p>Linux对此有个很简单的优化，就是在内核中维护一块缓冲区（buffer cache），在用户第一次调用read读取数据的时候，无论用户想要读取的数据有多小，都会一次性从磁盘中加载一段数据放到缓冲区中，根据局部性原理，这样用户下一次调用read方法的时候可以直接从缓冲区中返回数据，不用再次访问磁盘了。<br>write方法也是同理，用户写入的数据不是直接落盘，而是先写到kernel中的缓冲区里，按照一定的策略批量刷盘。当然也可以调用flush方法强制将缓存区的数据落盘。<br>这个优化极大的提高了顺序读写的效率。由于直接读写的是kernel中的缓冲区而不是磁盘，这种IO被称为缓冲IO。</p><h4 id="直接IO"><a href="#直接IO" class="headerlink" title="直接IO"></a>直接IO</h4><p>一般来说，缓冲IO已经足够应付日常需求了。但是像数据库这种极度依赖IO的应用程序，为了追求极致的性能，往往更加愿意自己直接操作磁盘。<br>直接IO可以直接将数据从磁盘复制到用户空间，或者将数据从用户空间写到磁盘，减少了kernel中的缓冲区这一环节，这是直接IO可以提高性能的原理。<br>但是如果用得不好就悲剧了，所以直接IO只在少数场景下使用。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——Kafka</title>
      <link href="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/"/>
      <url>/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/</url>
      
        <content type="html"><![CDATA[<p>首次接触到Kafka的背景，<code>实时同步mysql数据到doris，Mysql binlog + kafka + flink + doris</code></p><p><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="消息队列发展史"><br><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.jpeg" alt="主流消息队列对比"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kafka 是一种分布式的，基于发布 / 订阅的消息系统。<br>主要设计目标如下：</p><ul><li>以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。</li><li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒 100K 条以上消息的传输。</li><li>支持 Kafka Server 间的消息分区，及分布式消费，同时保证每个 Partition 内的消息顺序传输。</li><li>同时支持离线数据处理和实时数据处理。</li><li>Scale out：支持在线水平扩展。</li></ul><h3 id="创建背景"><a href="#创建背景" class="headerlink" title="创建背景"></a>创建背景</h3><p>Kafka 是一个消息系统，原本开发自 LinkedIn，用作 LinkedIn 的活动流（Activity Stream）和运营数据处理管道（Pipeline）的基础。</p><h2 id="Kafka基础概念"><a href="#Kafka基础概念" class="headerlink" title="Kafka基础概念"></a>Kafka基础概念</h2><p><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.png"></p><h3 id="Kafka的特性"><a href="#Kafka的特性" class="headerlink" title="Kafka的特性"></a>Kafka的特性</h3><ul><li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒。</li><li>可扩展性：kafka集群支持热扩展。</li><li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失。</li><li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）。</li><li>高并发：支持数千个客户端同时读写。</li></ul><h4 id="Kafka为什么吞吐量大、速度快【重要】"><a href="#Kafka为什么吞吐量大、速度快【重要】" class="headerlink" title="Kafka为什么吞吐量大、速度快【重要】"></a>Kafka为什么吞吐量大、速度快【重要】</h4><ol><li><p><strong>Partition并行 分区分段+索引</strong><br> Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。<br> 每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。<br> 这也非常符合分布式系统分区分桶的设计思想。</p><p> 通过这种分区分段的设计，Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。<br> 为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。<br> 这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p></li><li><p><strong>顺序读写磁盘</strong><br> Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入，这使得Kafka写入吞吐量得到了显著提升 。</p><blockquote><p>影响磁盘的关键因素是磁盘服务时间，即磁盘完成一个 I/O 请求所花费的时间，它由寻道时间、旋转延迟和数据传输时间三部分构成。<br>机械硬盘的<strong>连续读写</strong>性能很好，但<strong>随机读写</strong>性能很差，这主要是因为磁头移动到正确的磁道上需要时间，随机读写时，磁头需要不停的移动，时间都浪费在了磁头寻址上，所以性能不高。衡量磁盘的重要主要指标是 IOPS 和吞吐量。<br>在许多的开源框架如 Kafka、HBase 中，都通过追加写的方式来尽可能的将随机 I/O 转换为顺序 I/O，以此来降低寻址时间和旋转延时，从而最大限度的提高 IOPS。</p></blockquote><p> Kafka的每一个Partition其实都是一个文件，收到消息后Kafka会把数据插入到文件末尾。</p><p> 这种方法有一个缺陷：<strong>没有办法删除数据</strong>。所以Kafka是不会删除数据的，它会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个offset用来表示读取到了第几条数据。<br> 如果不删除硬盘肯定会被撑满，所以Kakfa提供了两种策略来删除数据。一是基于时间，二是基于partition文件大小。具体配置可以参看它的配置文档。</p></li><li><p><strong>Page Cache</strong></p><blockquote><p>操作系统层面引入 Cache 层的目的是为了提高 Linux 操作系统对磁盘访问的性能。Cache 层在内存中缓存了磁盘上的部分数据。当数据的请求到达时，如果在 Cache 中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。<br>在 Linux 的实现中，文件 Cache 分为两个层面，一是 Page Cache，另一个 Buffer Cache，每一个 Page Cache 包含若干 Buffer Cache。<br>Page Cache 主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有 read/write 操作的时候。<br>Buffer Cache 则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。</p></blockquote><p>通过操作系统的Page Cache，Kafka的读写操作基本上是基于内存的，读写速度得到了极大的提升。</p><p>在写磁盘文件的时候，就可以先直接写入 os cache 中，也就是仅仅写入内存中，接下来由操作系统自己决定什么时候把 os cache 里的数据真的刷入到磁盘中, 这样大大提高写入效率和性能。</p></li><li><p><strong>零拷贝</strong><br> Kafka 中存在大量的<strong>网络数据持久化到磁盘（Producer 到 Broker）</strong>和<strong>磁盘文件通过网络发送（Broker 到 Consumer）</strong>的过程。这一过程的性能直接影响 Kafka 的整体吞吐量。</p><blockquote><p><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/%E9%9B%B6%E6%8B%B7%E8%B4%9D-%E5%85%A8%E9%83%A8%E6%8B%B7%E8%B4%9D%E8%BF%87%E7%A8%8B.jpg"><br>在实际应用中，把磁盘中的某个文件内容发送到远程服务器上，必须要经过几个拷贝的过程：</p><ol><li>从磁盘中读取目标文件内容拷贝到内核缓冲区（OS Cache）；</li><li>CPU控制器再把内核缓冲区的数据赋值到用户空间的缓冲区中；</li><li>接着在应用程序中，调用write()方法，把用户空间缓冲区中的数据拷贝到内核下的Socket Buffer中；</li><li>最后，把在内核模式下的SocketBuffer中的数据赋值到网卡缓冲区（NIC Buffer），网卡缓冲区再把数据传输到目标服务器上。</li></ol></blockquote><blockquote><p>在这个过程中我们可以发现，数据从磁盘到最终发送出去，要经历4次拷贝，而在这四次拷贝过程中，有两次拷贝是浪费的，分别是：</p><ol><li>从内核空间赋值到用户空间</li><li>从用户空间再次复制到内核空间</li></ol></blockquote><blockquote><p>零拷贝，就是把这两次多余的拷贝省略掉，应用程序可以直接把磁盘中的数据从内核中直接传输给Socket，而不需要再经过应用程序所在的用户空间。<br><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/%E9%9B%B6%E6%8B%B7%E8%B4%9D-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E8%BF%87%E7%A8%8B.jpg"><br>零拷贝通过DMA（Direct Memory Access，直接存储器访问）技术把文件内容复制到内核空间中的Read Buffer，接着把包含数据位置和长度信息的文件描述符加载到Socket Buffer中，DMA引擎直接可以把数据从内核空间中传递给网卡设备。<br>在这个流程中，数据只经历了两次拷贝就发送到了网卡中，并且减少了2次cpu的上下文切换，对于效率有非常大的提高。<br>所以，所谓零拷贝，并不是完全没有数据赋值，只是相对于用户空间来说，不再需要进行数据拷贝。对于前面说的整个流程来说，零拷贝只是避免了在内核空间和用户空间之间的拷贝。</p></blockquote><ul><li><code>Producer 生产的数据持久化到 broker</code>，采用 mmap 文件映射，实现磁盘的快速写入。<br>   mmap 文件映射（Memory Mapped Files）：将磁盘文件映射到内存, 用户通过修改内存就能修改磁盘文件</li><li><code>Customer 从 broker 读取数据</code>，采用 sendfile，将磁盘文件读到 OS 内核缓冲区后，转到 NIO buffer 进行网络发送，减少 CPU 消耗。</li></ul></li><li><p><strong>批处理 批量读写</strong><br> Kafka数据读写也是批量的而不是单条的。</p><p> 除了利用底层的技术外，Kafka还在应用程序层面提供了一些手段来提升性能。最明显的就是使用批次。<br> 在向Kafka写入数据时，可以启用批次写入，这样可以避免在网络上频繁传输单个消息带来的延迟和带宽开销。<br> 假设网络带宽为10MB/S，一次性传输10MB的消息比传输1KB的消息10000万次显然要快得多。</p></li><li><p><strong>数据压缩</strong><br> 在很多情况下，系统的瓶颈不是 CPU 或磁盘，而是网络 IO。<br> Producer 可将数据压缩后发送给 broker，从而减少网络传输代价，目前支持的压缩算法有：Snappy、Gzip、LZ4。数据压缩一般都是和批处理配套使用来作为优化手段的。</p></li><li><p><strong>超高并发网络架构</strong></p></li></ol><h3 id="概念1-生产者与消费者"><a href="#概念1-生产者与消费者" class="headerlink" title="概念1 生产者与消费者"></a>概念1 生产者与消费者</h3><p>对于 Kafka 来说，客户端有两种基本类型：生产者（Producer）和消费者（Consumer）。<br>除此之外，还有用来做数据集成的 Kafka Connect API 和流式处理的 Kafka Streams 等高阶客户端，但这些高阶客户端底层仍然是生产者和消费者API，它们只不过是在上层做了封装。</p><ul><li><strong>Producer</strong><br>  消息生产者，就是向 kafka broker 发消息的客户端。</li><li><strong>Consumer</strong><br>  消息消费者，向 kafka broker 取消息的客户端。</li><li><strong>Consumer Group</strong><br>  消费者组，由多个 consumer 组成，消费者组是逻辑上的一个订阅者。<ul><li><strong>重平衡：Rebalance</strong><br>  消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。<br>  Rebalance 是 Kafka 消费者端实现高可用的重要手段。</li></ul></li></ul><h3 id="概念2-主题-Topic-与分区-Partition"><a href="#概念2-主题-Topic-与分区-Partition" class="headerlink" title="概念2 主题(Topic)与分区(Partition)"></a>概念2 主题(Topic)与分区(Partition)</h3><ul><li><p><strong>Topic</strong><br>  Topic是一个逻辑上的消息队列，同一类型的消息可以放到一个Topic（消息队列）中。<br>  主要作用是用来屏蔽底层分区和副本的复杂逻辑。</p></li><li><p><strong>Partition</strong><br>  Partition（分区），是Kafka下数据存储的基本单元，这个是物理上的概念。</p><p>  一个 topic 可以分为多个 partition，每个 partition 都是一个有序的队列。<br>  主题可以被分为若干个分区（partition），同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性，单一主题中的分区有序，但是无法保证主题中所有的分区有序。</p><p>  同一个分区（partition）可以被不同的消费者组同时消费；但是在同一个消费者组内，一个分区只能被一个消费者消费。</p></li></ul><h4 id="当broker里面的topic数量过多时，kafka的性能不如rocketMq？"><a href="#当broker里面的topic数量过多时，kafka的性能不如rocketMq？" class="headerlink" title="当broker里面的topic数量过多时，kafka的性能不如rocketMq？"></a>当broker里面的topic数量过多时，kafka的性能不如rocketMq？</h4><blockquote><p>Kafka与RocketMQ在topic处理上的不同</p><ol><li>kafka中partition增多会存在随机写的可能性，partition之间刷盘的冲撞率会高，但是RocketMQ是把消息都写到一个CommitLog文件中，所以相当于一个文件的顺序写。</li><li>RockertMQ的consumerQueue消息格式大小固定（20字节），写入pagecache之后被触发刷盘频率相对较低。</li></ol></blockquote><ul><li><p><strong>Replica</strong><br>  Replica（副本），就是Partition的一个备份，副本的数量是可以配置的。<br>  Kafka 定义了两类副本：领导者副本（Leader Replica） 和 追随者副本（Follower Replica），前者对外提供服务，后者只是被动跟随。<br>  一个分区（Partition）只能有一个leader，但是可以设置多个副本（follower），同一分区的副本不能在同一台机器上。</p><p>  <strong>leader partition</strong>：<br>  1、写数据、读数据操作都是从leader partition去操作的。<br>  2、会维护一个ISR（in-sync-replica）列表，但是会根据一定的规则删除ISR列表里面的值。生产者发送来一个消息，消息首先要写入到leader partition中，写完了以后，还要把消息写入到ISR列表里面的其它分区，写完后才算这个消息提交。<br>  <strong>follower partition</strong>：从leader partition同步数据。<br>  当 leader 发生故障时，某个 follower 会成为新的 leader，以此来保证kafka的可用性。</p><p>  自 Kafka 2.4 之后，Kafka 提供了有限度的读写分离，也就是说，Follower 副本能够对外提供读服务。</p></li></ul><h3 id="概念3-Broker和集群-Cluster"><a href="#概念3-Broker和集群-Cluster" class="headerlink" title="概念3 Broker和集群(Cluster)"></a>概念3 Broker和集群(Cluster)</h3><p>一台 kafka 服务器就是一个 broker。<br>一个kafka集群由多个 broker 组成，然后通过Zookeeper来进行集群的管理。</p><ul><li><p><strong>Zookeeper</strong><br>  2.8.0版本之前，Kafka 将 Broker、Topic 和 Partition 的元数据信息存储在 Zookeeper 上。</p><p>  <img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-kafka-zookeeper.png"></p><p>  通过在 Zookeeper 上建立相应的数据节点，并监听节点的变化。</p></li><li><p><strong>Controller</strong><br>  Controller 是从 Broker 中选举出来的，负责整个集群中所有分区、副本的管理。<br>  当分区中Leader副本出现问题时及时选举新的Leader副本。</p></li></ul><h3 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h3><p><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E6%A0%B8%E5%BF%83api.jpeg"></p><ul><li>Producer API<br>允许应用程序向一个或多个 topics 上发送消息记录。</li><li>Consumer API<br>允许应用程序订阅一个或多个 topics 并对发布给他们的流式数据进行处理。</li><li>Streams API<br>它允许应用程序作为流处理器，消费一个或者多个topic产生的输入流，然后生产一个输出流到一个或多个topic中去，在输入输出流中进行有效的转换。</li><li>Connector API<br>它允许构建并运行可重用的生产者或者消费者，将Kafka topics连接到已存在的应用程序或者数据系统。<br>比如，连接到一个关系型数据库，捕捉表（table）的所有变更内容。</li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;mid=2247488849&amp;idx=1&amp;sn=febda095589f02553d9191528f271c07&amp;chksm=cefb3c60f98cb576fd9c58d760b9a5e4ae32a0c001e2049b591297d904a0401646448999c78a&amp;scene=178&amp;cur_album_id=2147575846151290880#rd">https://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;mid=2247488849&amp;idx=1&amp;sn=febda095589f02553d9191528f271c07&amp;chksm=cefb3c60f98cb576fd9c58d760b9a5e4ae32a0c001e2049b591297d904a0401646448999c78a&amp;scene=178&amp;cur_album_id=2147575846151290880#rd</a></p><h2 id="Kafka-Producer"><a href="#Kafka-Producer" class="headerlink" title="Kafka Producer"></a>Kafka Producer</h2><p>在 Kafka 中, 我们把产生消息的一方称为 Producer 即 生产者, 它是 Kafka 的核心组件之一, 也是消息的来源所在。<br>它的主要功能是将客户端的请求打包封装发送到 kafka 集群的某个 Topic 的某个分区上。</p><p>那么这些生产者产生的消息是怎么传到 Kafka 服务端的呢？<br>初始化和发送过程是怎么样的呢？</p><h3 id="Producer初始化"><a href="#Producer初始化" class="headerlink" title="Producer初始化"></a>Producer初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1)、设置分区器(partitioner), 分区器是支持自定义的</span><br><span class="line">2)、设置重试时间(retryBackoffMs)默认100ms</span><br><span class="line">3)、设置序列化器(Serializer)</span><br><span class="line">4)、设置拦截器(interceptors)</span><br><span class="line">5)、初始化集群元数据(metadata),刚开始空的</span><br><span class="line">6)、设置最大的消息为多大(maxRequestSize), 默认最大1M, 生产环境可以提高到10M</span><br><span class="line">7)、设置缓存大小(totalMemorySize) 默认是32M</span><br><span class="line">8)、设置压缩格式(compressionType)</span><br><span class="line">9)、初始化RecordAccumulator也就是缓冲区指定为32M</span><br><span class="line">10)、定时更新(metadata.update)</span><br><span class="line">11)、创建NetworkClient</span><br><span class="line">12)、创建Sender线程</span><br><span class="line">13)、KafkaThread将Sender设置为守护线程并启动</span><br></pre></td></tr></table></figure><h3 id="Producer发送过程"><a href="#Producer发送过程" class="headerlink" title="Producer发送过程"></a>Producer发送过程</h3><h4 id="KafkaProducer-send-ProducerRecord-Callback"><a href="#KafkaProducer-send-ProducerRecord-Callback" class="headerlink" title="KafkaProducer.send(ProducerRecord, Callback)"></a>KafkaProducer.send(ProducerRecord, Callback)</h4><ol><li>序列化+计算目标分区</li><li>追加写入消息缓冲区(accumulator)</li><li>Sender线程预处理及消息发送</li><li>Sender线程处理response</li></ol><h4 id="Producer内存池设计"><a href="#Producer内存池设计" class="headerlink" title="Producer内存池设计"></a>Producer内存池设计</h4><h4 id="Ack应答确认机制"><a href="#Ack应答确认机制" class="headerlink" title="Ack应答确认机制"></a>Ack应答确认机制</h4><p>ack作用是确认收到消息，一是producer发送消息到leader收到消息之后发送ack，二是leader和follower之间同步完成数据会发送ack</p><p><strong>acks参数</strong>指定了必须要有多少个分区副本收到消息，生产者才认为该消息是写入成功的，这个参数对于消息是否丢失起着重要作用。<br>该参数的配置具体如下：</p><ul><li>acks=0<br>  producer不等待broker的ack，这一种操作提供了最低的延迟，broker一接受到还没有写入到磁盘就已经返回了，当broker故障的时候 丢失数据（相当于异步发送）</li><li>acks=1<br>  producer等待broker的ack，partition的leader落盘成功后返回ack。<br>  如果follower同步数据之前leader故障，此时会丢失数据。<br>  此时follower需要同步leader中的数据，但是leader宕机了，挂了之后kafka集群会重新选举leader，选举出leader之后，并没有同步到原有的数据，就会造成数据的丢失。</li><li>acks=-1<br>  producer等待broker的ackpartition的leader和follower全部落盘成功后，才会返回ack。<br>  但是如果follower同步完成之后，在broker发送ack之前，leader发生故障，生产者收不到ack确认，会重新发送消息，那么会出现数据的重复，但不会造成数据丢失。</li></ul><h3 id="Producer网络架构"><a href="#Producer网络架构" class="headerlink" title="Producer网络架构"></a>Producer网络架构</h3><h2 id="Kafka-Consumer"><a href="#Kafka-Consumer" class="headerlink" title="Kafka Consumer"></a>Kafka Consumer</h2><h3 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h3><p>Kafka Consumer 采用从 Broker 中主动拉取数据。</p><p>不采用 push（推）模式是因为：由 broker 决定消息发送速率，很难适应所有消费者的消费速率。</p><p>pull 模式不足之处是，如果 Kafka 没有数据，消费者可能会陷入循环中，一直返回空数据。</p><h3 id="Consumer初始化"><a href="#Consumer初始化" class="headerlink" title="Consumer初始化"></a>Consumer初始化</h3><h3 id="消费组概念"><a href="#消费组概念" class="headerlink" title="消费组概念"></a>消费组概念</h3><p>为什么 Kafka 要设计 Consumer Group, 只有 Consumer 不可以吗？<br>我们知道 Kafka 是一款高吞吐量，低延迟，高并发,  高可扩展性的消息队列产品，那么如果某个 Topic 拥有数百万到数千万的数据量，仅仅依靠 Consumer 进程消费，消费速度可想而知，所以需要一个扩展性较好的机制来保障消费进度，这个时候 Consumer Group 应运而生。<br>Consumer Group 是 Kafka 提供的可扩展且具有容错性的消费者机制。</p><p>特点：</p><ul><li>每个 Consumer Group 有一个或者多个 Consumer；</li><li>每个 Consumer Group 拥有一个公共且唯一的 Group ID；</li><li>Consumer Group 在消费 Topic 的时候，Topic 的每个 Partition 只能分配给组内的某个 Consumer，只要被任何 Consumer 消费一次, 那么这条数据就可以认为被当前 Consumer Group 消费成功。</li></ul><h4 id="Group-Coordinator"><a href="#Group-Coordinator" class="headerlink" title="Group Coordinator"></a>Group Coordinator</h4><p>所谓协调者，它专门为Consumer Group服务，负责为Group执行Rebalance以及提供位移管理和组成员管理等。<br>每个Consumer Group都会选择一个broker作为自己的Coordinator。</p><p>具体来讲，Consumer端应用程序在提交位移时，其实是向Coordinator所在的Broker提交位移，同样地，当Consumer应用启动时，也是向Coordinator所在的Broker发送各种请求，然后由Coordinator负责执行消费者组的注册、成员管理记录等元数据管理操作。</p><p>所有Broker在启动时，都会创建和开启相应的Coordinator组件。也就是说，「所有Broker都有各自的Coordinator组件」。</p><p><strong>Consumer Group</strong>如何确定为它服务的Coordinator在哪台Broker上？<br>通过Kafka内部主题<code>__consumer_offsets</code></p><p>Kafka为某个Consumer Group确定Coordinator所在的Broker的算法有2个步骤：</p><ol><li>确定由__consumer_offsets主题的哪个分区来保存该Group数据.<br> <code>partitionId = Math.abs(groupId.hashCode() % offsetsTopicPartitionCount)</code></li><li>找出该分区Leader副本所在的Broker，该Broker即为对应的Coordinator。</li></ol><h4 id="Rebalance消费者组重分配机制"><a href="#Rebalance消费者组重分配机制" class="headerlink" title="Rebalance消费者组重分配机制"></a>Rebalance消费者组重分配机制</h4><p>消费者组内所有消费者自动重新分配订阅主题分区的过程。<br>Rebalance是Kafka消费者端实现高可用的重要手段。<br>Consumer group靠Coordinator实现了Rebalance。</p><p><strong>Rebalance 的触发条件</strong></p><ol><li>当 Consumer Group 组成员数量发生变化(主动加入或者主动离组，故障下线等)</li><li>当订阅主题数量发生变化</li><li>当订阅主题的分区数发生变化</li></ol><p><strong>Rebalance 如何通知其他 consumer 进程？</strong><br>Rebalance 的通知机制是靠 Consumer 端的心跳线程，它会定期发送心跳请求到 Broker 端的 Coordinator，当协调者决定开启 Rebalance 后，它会将“REBALANCE_IN_PROGRESS”封装进心跳请求的响应中发送给 Consumer,当 Consumer 发现心跳响应中包含了“REBALANCE_IN_PROGRESS”，就知道 Rebalance开始了。</p><p><strong>Partition分区分配策略</strong></p><ul><li>rage<br>  RangeAssignor 是 Kafka 默认的分区分配算法。<br>  它是按照 Topic 的维度进行分配的，对于每个 Topic，首先对 Partition 按照分区ID进行排序，然后对订阅这个 Topic 的 Consumer Group 的 Consumer 再进行排序，之后尽量均衡的按照范围区段将分区分配给 Consumer。此时可能会造成先分配分区的 Consumer 进程的任务过重（分区数无法被消费者数量整除）。</li><li>round-robin<br>  RoundRobinAssignor 的分区分配策略是将 Consumer Group 内订阅的所有 Topic 的 Partition 及所有 Consumer 进行排序后按照顺序尽量均衡的一个一个进行分配。<br>  如果 Consumer Group 内，每个 Consumer 订阅都订阅了相同的Topic，那么分配结果是均衡的。<br>  如果订阅 Topic 是不同的，那么分配结果是不保证“尽量均衡”的，因为某些 Consumer 可能不参与一些 Topic 的分配。</li><li>sticky<br>  StickyAssignor 分区分配算法是 Kafka Java 客户端提供的分配策略中最复杂的一种，可以通过 partition.assignment.strategy 参数去设置，从 0.11 版本开始引入，目的就是在执行新分配时，尽量在上一次分配结果上少做调整。<br>  其主要实现了以下2个目标：<ol><li>Topic Partition 的分配要尽量均衡。</li><li>当 Rebalance(重分配，后面会详细分析) 发生时，尽量与上一次分配结果保持一致。<br>注意：当两个目标发生冲突的时候，优先保证第一个目标，这样可以使分配更加均匀，其中第一个目标是3种分配策略都尽量去尝试完成的，而第二个目标才是该算法的精髓所在。</li></ol></li></ul><h3 id="偏移量管理-位移提交机制"><a href="#偏移量管理-位移提交机制" class="headerlink" title="偏移量管理 位移提交机制"></a>偏移量管理 位移提交机制</h3><p>对于Kafka Partition而言，每条消息都有一个offset，用来表示消息的位置。存储层面。<br>对于消费者而言，也有一个offset，用来表示消费到分区中某个消息所在的位置，称为消费位移。消费层面。</p><p>在消费者每次调用pull方法的时候，拉取到的是还没有消费过的消费集，要做到这一点，就需要记录上一次消费时候的消费位移，并且这个位移必须做持久化的保存，而不是单单保存在消费者内存中，否则消费者重启后就无法获取之前的消费位移，以及如果新增一个消费者，分区再均衡的时候，新的消费者无法获取消费位移。</p><p>在 Kafka 0.9 版本之前，Consumer 默认将 Offset 保存在 ZooKeeper 中。<br>由于Zookeeper并不适合大批量的频繁写入操作，从 0.9 版本开始，消费者去掉了对ZK的依赖，当启动一个消费者时不再向ZK进行注册，而是由消费者协调器（Group Coordinator）统一管理，消费者已消费消息的偏移量提交会保存在名为**__consumer_offsets**的Kafka内部主题中，以支持高并发的读写。</p><p>将<strong>消费位移做持久化操作的动作</strong>称为<strong>提交</strong>，消费者在消费完消息之后需要执行消费位移的提交。</p><h4 id="consumer-offsets"><a href="#consumer-offsets" class="headerlink" title="__consumer_offsets"></a>__consumer_offsets</h4><p><code>__consumer_offsets</code> 是 kafka 自行创建的，和普通的 topic 相同。它存在的目的之一就是保存 consumer 提交的位移。</p><p>__consumer_offsets 的每条消息格式大致如图所示：<br><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/Consumer-%E5%81%8F%E7%A7%BB%E9%87%8F-consumer-offset.png"><br><code>&lt;K, V&gt; = &lt;group.id + topic + 分区号, offset&gt;</code></p><p>考虑到一个 kafka 生成环境中可能有很多 consumer 和 consumer group，如果这些 consumer 同时提交位移，则必将加重 __consumer_offsets 的写入负载，因此 kafka 默认为该 topic 创建了<strong>50个分区</strong>，并且对每个 group.id 做哈希求模运算<strong>Math.abs(groupID.hashCode()) % numPartitions</strong>，从而将负载分散到不同的 __consumer_offsets 分区上。</p><p>一般情况下，当集群中第一次有消费者消费消息时会自动创建 __consumer_offsets。<br>它的<strong>副本因子</strong>受 offsets.topic.replication.factor 参数的约束，默认值为3（注意：该参数的使用限制在0.11.0.0版本发生变化）；<br><strong>分区数</strong>可以通过 offsets.topic.num.partitions 参数设置，默认值为50。</p><h4 id="Kafka位移提交方式"><a href="#Kafka位移提交方式" class="headerlink" title="Kafka位移提交方式"></a>Kafka位移提交方式</h4><ul><li>自动提交<br>  kafka消费者中默认的消费位移提交方式是自动提交，由<code>enable.autto.commit</code>配置，默认每5s提交一次。</li><li>手动提交<ul><li>同步提交</li><li>异步提交</li></ul></li></ul><blockquote><p><strong>位移提交当中涉及到了很多消息重复消费和消息丢失的问题！！！</strong></p></blockquote><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg3MTcxMDgxNA==&amp;action=getalbum&amp;album_id=2147575846151290880&amp;scene=173&amp;from_msgid=2247488847&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect">https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg3MTcxMDgxNA==&amp;action=getalbum&amp;album_id=2147575846151290880&amp;scene=173&amp;from_msgid=2247488847&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect</a></p><h2 id="Kafka-Broker"><a href="#Kafka-Broker" class="headerlink" title="Kafka Broker"></a>Kafka Broker</h2><h3 id="Controller-控制器机制"><a href="#Controller-控制器机制" class="headerlink" title="Controller 控制器机制"></a>Controller 控制器机制</h3><p>每个正常运转的 Kafka 集群，在任意时刻都有且只有一个控制器。<br>Controller 在 Zookeeper 的帮助下管理和协调整个 Kafka 集群。</p><h4 id="Controller-选举"><a href="#Controller-选举" class="headerlink" title="Controller 选举"></a>Controller 选举</h4><p>Kafka 2.8.0 以前用ZooKeeper管理元数据，Controller的选择是在Zookeeper上完成的。</p><p>Kafka 当前选举控制器的规则是：Kafka 集群中第一个启动的 broker 通过在 ZooKeeper 里创建一个临时节点 /controller 让自己成为 controller 控制器。其他 broker 在启动时也会尝试创建这个节点，但是由于这个节点已存在，所以后面想要创建 /controller 节点时就会收到一个节点已存在的异常。然后其他 broker 会在这个控制器上注册一个 ZooKeeper 的 watch 对象，/controller节点发生变化时，其他 broker 就会收到节点变更通知。这种方式可以确保只有一个控制器存在。那么只有单独的节点一定是有个问题的，那就是单点问题。</p><p><strong>Controller Failover</strong><br>如果控制器关闭或者与 ZooKeeper 断开链接，ZooKeeper 上的临时节点就会消失。集群中的其他节点收到 watch 对象发送控制器下线的消息后，其他 broker 节点都会尝试让自己去成为新的控制器。其他节点的创建规则和第一个节点的创建原则一致，都是第一个在 ZooKeeper 里成功创建控制器节点的 broker 会成为新的控制器，那么其他节点就会收到节点已存在的异常，然后在新的控制器节点上再次创建 watch 对象进行监听。</p><h4 id="Controller-作用"><a href="#Controller-作用" class="headerlink" title="Controller 作用"></a>Controller 作用</h4><ol><li>Topic管理<br> 控制器帮助完成对Kafka主题的创建、删除以及分区增加的操作</li><li>分区重分配</li><li>Partition Leader选举</li><li>集群Broker管理<br> 新增Broker、Broker主动关闭、Broker故障</li></ol><h3 id="日志存储-分区分段保存"><a href="#日志存储-分区分段保存" class="headerlink" title="日志存储 分区分段保存"></a>日志存储 分区分段保存</h3><p>Kafka中的消息是以主题为基本单位进行归类的，每个主题在逻辑上相互独立。<br>每个主题又可以分为一个或多个分区，在不考虑副本的情况下，一个分区会对应一个日志。<br>但设计者考虑到随着时间推移，日志文件会不断扩大，因此为了防止Log过大，设计者引入了日志分段（LogSegment）的概念，将Log切分为多个LogSegment，便于后续的消息维护和清理工作。<br><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/broker-%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8.png" alt="主题、分区、Log、LogSegment"></p><h4 id="LogSegment"><a href="#LogSegment" class="headerlink" title="LogSegment"></a>LogSegment</h4><p>在Kafka中，每个Log对象又可以划分为多个LogSegment文件，每个LogSegment文件包括一个日志数据文件和两个索引文件（偏移量索引文件和消息时间戳索引文件）。</p><p>其中，每个LogSegment中的日志数据文件大小均相等（该日志数据文件的大小可以通过在Kafka Broker的<code>config/server.properties</code>配置文件的中的<code>「log.segment.bytes」</code>进行设置，默认为<strong>1G</strong>大小（1073741824字节），在顺序写入消息时如果超出该设定的阈值，将会创建一组新的日志数据和索引文件）。</p><p>index, log, snapshot, timeindex 文件以当前 Segment 的第一条消息的 Offset 命名。<br>“.index” 文件存储大量的索引信息。<br>“.log” 文件存储大量的数据，索引文件中的元数据指向对应数据文件中 Message 的物理偏移量。</p><p><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/broker-%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8-logsegment.png"></p><h3 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h3><ul><li><strong>AR（Assigned Replicas）</strong>：分区中的所有副本统称为AR。<br>  所有消息会先发送到leader副本，然后follower副本才能从leader中拉取消息进行同步。<br>  但是在同步期间，follower对于leader而言会有一定程度的滞后，这个时候follower和leader并非完全同步状态</li><li><strong>OSR（Out Sync Replicas）</strong>：follower副本与leader副本没有完全同步或滞后的副本集合</li><li><strong>ISR（In Sync Replicas）</strong>：AR中的一个子集，ISR中的副本都是与leader保持完全同步的副本<br>  如果某个在ISR中的follower副本落后于leader副本太多，则会被从ISR中移除，否则如果完全同步，会从OSR中移至ISR集合。<br>  在默认情况下，当leader副本发生故障时，只有在ISR集合中的follower副本才有资格被选举为新leader，而OSR中的副本没有机会（可以通过unclean.leader.election.enable进行配置）。</li><li><strong>HW（High Watermark）</strong>：高水位<br>  它标识了一个特定的消息偏移量（offset），消费者只能拉取到这个水位 offset 之前的消息</li><li><strong>LEO（Log End Offset）</strong>：标识当前日志文件中下一条待写入的消息的offset<br>  HW 之前的消息数据对消费者是可见的, 属于 commited 状态；<br>  HW 之后的消息数据对消费者是不可见的，属于 uncommited 状态。</li></ul><h4 id="HW和LEO更新机制"><a href="#HW和LEO更新机制" class="headerlink" title="HW和LEO更新机制"></a>HW和LEO更新机制</h4><p><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/broker-replica-hw&leo.png"><br>每个 kafka 副本对象都有两个重要的属性：LEO 和 HW。注意是所有的副本（leader + Follower）。<br>但实际上，在 Leader 副本所在的 Broker 上，还保存了其他 Follower 副本的 LEO 值。<br>Kafka之所以要在Leader副本上保存这些所有 Follower LEO, 就是为了帮助 Leader 副本确定其高水位，也就是分区高水位。</p><p><strong>1. follower副本何时更新LEO？</strong><br><strong>2. follower副本何时更新HW？</strong><br><strong>3. leader副本何时更新LEO？</strong><br>leader写log时就会自动地更新它自己的LEO值。<br><strong>4. leader副本何时更新HW？</strong></p><ol><li>producer向leader副本写入消息时：因为写入消息会更新leader的LEO，故有必要再查看下HW值是否也需要修改</li><li>leader处理follower FETCH请求时：当leader处理follower的FETCH请求时首先会从底层的log读取数据，之后会尝试更新分区HW值</li></ol><p>当尝试确定分区HW时，它会选出所有满足条件的副本，比较它们的LEO(当然也包括leader自己的LEO)，并选择最小的LEO值作为HW值。<br>这里的满足条件主要是指副本只需满足以下两个条件之一即可：</p><ol><li>处于ISR中</li><li>副本LEO落后于leader LEO的时长不大于 replica.lag.time.max.ms 参数值(默认是10s)</li></ol><h4 id="LeaderEpoch机制"><a href="#LeaderEpoch机制" class="headerlink" title="LeaderEpoch机制"></a>LeaderEpoch机制</h4><p>Kafka 0.11 引入了leader epoch来取代HW值。</p><blockquote><p>很多原因都可能造成 Leader 和 Follower 保存的消息序列不一致，比如程序 Bug、网络问题等。这是很严重的错误，必须要完全规避。<br>之前确保一致性的主要手段是高水位机制 High watermark，但高水位值无法保证 Leader 连续变更场景下的数据一致性。<br>因此，社区在 0.11 版本引入了 Leader Epoch 机制，来规避因 HW 更新错配导致的各种不一致问题。</p></blockquote><p>Leader端多开辟一段内存区域专门保存leader的epoch信息。<br>所谓leader epoch实际上是一对值：<code>&lt;epoch, offset&gt;</code></p><ul><li>epoch表示leader的版本号，从0开始，当leader变更过1次时epoch就会+1。</li><li>offset则对应于该epoch版本的leader写入第一条消息的offset。</li></ul><p>Kafka Broker 会在内存中为每个分区都缓存 Leader Epoch 数据，同时它还会定期地将这些信息持久化到一个 checkpoint 文件中。<br>当 Leader Partition 写入消息到磁盘时，Broker 会尝试更新这部分缓存。<br>如果该 Leader 是首次写入消息，那么 Broker 会向缓存中增加一个 Leader Epoch 条目，否则就不做更新。<br>这样，每次有 Leader 变更时，新的 Leader 副本会查询这部分缓存，取出对应的 Leader Epoch 的起始位移，以避免数据丢失和不一致的情况。</p><p><strong>规避数据丢失</strong><br><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/broker-leaderEpoch-%E8%A7%84%E9%81%BF%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1.png"><br><strong>规避数据不一致</strong><br><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/broker-leaderEpoch-%E8%A7%84%E9%81%BF%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4.png"></p><h2 id="Kafka-网络通信设计"><a href="#Kafka-网络通信设计" class="headerlink" title="Kafka 网络通信设计"></a>Kafka 网络通信设计</h2><p>KAFKA 并没有使用现有的网络框架比如 Netty 去作为自己通信的底座，而是基于 NIO 自行研发了一套适合 KAFKA 自身的网络框架模型。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;mid=2247497246&amp;idx=2&amp;sn=4d700a976a3c531bd77aab58f00bcb83&amp;chksm=cef8df2ff98f563949117c8055e7ff271346b84d12b698f7690181dca16ea9e679a9939a3f46&amp;scene=178&amp;cur_album_id=2147575846151290880#rd">https://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;mid=2247497246&amp;idx=2&amp;sn=4d700a976a3c531bd77aab58f00bcb83&amp;chksm=cef8df2ff98f563949117c8055e7ff271346b84d12b698f7690181dca16ea9e679a9939a3f46&amp;scene=178&amp;cur_album_id=2147575846151290880#rd</a></p><p><img src="/2023/03/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84-%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p><h2 id="版本演进"><a href="#版本演进" class="headerlink" title="版本演进"></a>版本演进</h2><h3 id="0-7-x"><a href="#0-7-x" class="headerlink" title="0.7.x"></a>0.7.x</h3><p>只提供最基础的消息队列功能。</p><h3 id="0-8-x"><a href="#0-8-x" class="headerlink" title="0.8.x"></a>0.8.x</h3><ul><li>Kafka 0.8.0增加了副本机制<br>  至此 Kafka 成为了一个真正意义上完备的分布式高可用消息队列解决方案。</li><li>Kafka 0.8.2.0引入了新版本Producer API</li></ul><h3 id="0-9-x"><a href="#0-9-x" class="headerlink" title="0.9.x"></a>0.9.x</h3><p>Kafka 0.9 是一个重大的版本迭代，增加了非常多的新特性，主要体现在三个方面：</p><ul><li>安全方面<br>  在0.9.0之前，Kafka安全方面的考虑几乎为0。<br>  Kafka 0.9.0 在安全认证、授权管理、数据加密等方面都得到了支持，包括支持Kerberos等。</li><li>新版本Consumer APi<br>  Kafka 0.9.0 重写并提供了新版消费端API，使用方式也是从连接Zookeeper切到了连接Broker，但是此时新版Consumer API也不太稳定、存在不少Bug，生产使用可能会比较痛苦；<br>  而0.9.0版本的Producer API已经比较稳定了，生产使用问题不大。</li><li>Kafka Connect<br>  Kafka 0.9.0 引入了新的组件 Kafka Connect ，用于实现Kafka与其他外部系统之间的数据抽取。</li></ul><h3 id="0-10-x"><a href="#0-10-x" class="headerlink" title="0.10.x"></a>0.10.x</h3><p>Kafka 0.10 是一个重要的大版本，因为Kafka 0.10.0.0 引入了 Kafka Streams，使得Kafka不再仅是一个消息引擎，而是往一个分布式流处理平台方向发展。<br>0.10 大版本包含两个小版本：0.10.1 和 0.10.2，它们的主要功能变更都是在 Kafka Streams 组件上。</p><p>值得一提的是，自 0.10.2.2 版本起，新版本 Consumer API 已经比较稳定了，而且 Producer API 的性能也得到了提升，因此对于使用 0.10.x 大版本的用户，建议使用或升级到 Kafka 0.10.2.2 版本。</p><h3 id="0-11-x"><a href="#0-11-x" class="headerlink" title="0.11.x"></a>0.11.x</h3><p>Kafka 0.11 是一个里程碑式的大版本，主要有两个大的变更。</p><ol><li>Kafka从这个版本开始支持Exactly-Once 语义即精准一次语义<br> 主要是实现了Producer端的消息幂等性，以及事务特性，这对于Kafka流式处理具有非常大的意义。</li><li>Kafka消息格式的重构<br> Kafka 0.11主要为了实现Producer幂等性与事务特性，重构了投递消息的数据结构。<br> 这一点非常值得关注，因为Kafka 0.11之后的消息格式发生了变化，所以我们要特别注意Kafka不同版本间消息格式不兼容的问题。</li></ol><h3 id="1-x"><a href="#1-x" class="headerlink" title="1.x"></a>1.x</h3><p>Kafka 1.x 更多的是Kafka Streams方面的改进，以及Kafka Connect的改进与功能完善等。<br>但仍有两个重要特性：</p><ol><li>Kafka 1.0.0实现了磁盘的故障转移<br> 当Broker的某一块磁盘损坏时数据会自动转移到其他正常的磁盘上，Broker还会正常工作，这在之前版本中则会直接导致Broker宕机，因此Kafka的可用性与可靠性得到了提升</li><li>Kafka 1.1.0开始支持副本跨路径迁移<br> 分区副本可以在同一Broker不同磁盘目录间进行移动，这对于磁盘的负载均衡非常有意义。</li></ol><h3 id="2-x"><a href="#2-x" class="headerlink" title="2.x"></a>2.x</h3><p>Kafka 2.x 更多的也是Kafka Streams、Connect方面的性能提升与功能完善，以及安全方面的增强等。</p><ul><li>Kafka 2.1.0开始支持ZStandard的压缩方式，提升了消息的压缩比，显著减少了磁盘空间与网络io消耗。</li><li>Kafka 2.8.0 用自管理的Quorum代替ZooKeeper管理元数据</li></ul><h4 id="为什么Kafka在2-8版本中会“抛弃”Zookeeper"><a href="#为什么Kafka在2-8版本中会“抛弃”Zookeeper" class="headerlink" title="为什么Kafka在2.8版本中会“抛弃”Zookeeper"></a>为什么Kafka在2.8版本中会“抛弃”Zookeeper</h4><h3 id="3-x"><a href="#3-x" class="headerlink" title="3.x"></a>3.x</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列—区别/对比/选型</title>
      <link href="/2023/03/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E5%8C%BA%E5%88%AB-%E5%AF%B9%E6%AF%94-%E9%80%89%E5%9E%8B/"/>
      <url>/2023/03/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E5%8C%BA%E5%88%AB-%E5%AF%B9%E6%AF%94-%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2023/03/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E5%8C%BA%E5%88%AB-%E5%AF%B9%E6%AF%94-%E9%80%89%E5%9E%8B/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="消息队列发展史"><br><img src="/2023/03/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E5%8C%BA%E5%88%AB-%E5%AF%B9%E6%AF%94-%E9%80%89%E5%9E%8B/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.jpeg" alt="主流消息队列对比"></p><ul><li>什么是消息队列</li><li>消息队列的应用场景</li><li>消息队列技术选型，Kafka还是RocketMQ，还是RabbitMQ</li><li>消息中间件如何做到高可用？</li><li>消息队列如何解决消息丢失问题</li><li>消息队列如何保证消息的顺序性。</li><li>消息队列有可能发生重复消费吗？如何幂等处理？</li><li>如何处理消息队列的消息积压问题</li><li>如何保证数据一致性，事务消息如何实现</li><li>如果让你写一个消息队列，该如何进行架构设计？</li></ul><h2 id="消息队列应用场景"><a href="#消息队列应用场景" class="headerlink" title="消息队列应用场景"></a>消息队列应用场景</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><h3 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h3><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><h3 id="引入消息队列的劣势分析"><a href="#引入消息队列的劣势分析" class="headerlink" title="引入消息队列的劣势分析"></a>引入消息队列的劣势分析</h3><p>引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。<br>一个使用了MQ的项目，如果连MQ的缺点都没有考虑过，就把MQ引进去了，那就会给自己的项目带来风险。</p><ul><li>系统可用性降低<br>  系统的可用性会受消息队列的可用性影响。</li><li>系统复杂度提高<br>  引入消息队列后，要多考虑很多方面的问题。<br>  消息丢失、消息重复消息、消息可靠传输、消息积压、数据一致性等等。<br>  需要考虑的东西多了，系统复杂性随之增加。</li><li>一致性问题</li></ul><h2 id="消息中间件基本架构"><a href="#消息中间件基本架构" class="headerlink" title="消息中间件基本架构"></a>消息中间件基本架构</h2><h3 id="架构组成"><a href="#架构组成" class="headerlink" title="架构组成"></a>架构组成</h3><ul><li>Producer 生产者，消息的产生方，生产者会将消息发送到消息队列。</li><li>queue 消息队列，接受并存储生产者的消息。</li><li>Consumer 消费者，消费消息队列中的消息。</li></ul><h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><h4 id="发布-订阅模式（一对多）"><a href="#发布-订阅模式（一对多）" class="headerlink" title="发布-订阅模式（一对多）"></a>发布-订阅模式（一对多）</h4><p>消费者消费完消息后，消息不会被删除，消息会存储一段时间，这种模式下的消息会被所有消费者消费。</p><h4 id="点对点模式（一对一）"><a href="#点对点模式（一对一）" class="headerlink" title="点对点模式（一对一）"></a>点对点模式（一对一）</h4><p>点对点模式是消费者主动拉取数据，消息确认被消费后，消息队列会删除队列中的消息，一条消息只会被一个消费者消费。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li>如果消息队列不是将要构建系统的重点，对消息队列功能和性能没有很高的要求，只需要一个快速上手易于维护的消息队列，建议使用 RabbitMQ。</li><li>如果系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，需要低延迟和高稳定性，建议使用 RocketMQ。</li><li>如果需要处理海量的消息，像收集日志、监控信息或是埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那 Kafka 是最适合的消息队列。</li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="1-高可用"><a href="#1-高可用" class="headerlink" title="1. 高可用"></a>1. 高可用</h3><p>基于副本机制实现 Kafka 的高可用。</p><p>Kafka 集群由若干个 Broker 组成，Topic 由若干个 Partition 组成，每个 Partition 可存在不同的 Broker 上。可以这样说，一个 Topic 的数据，分散在多个机器上，即每个机器上都存放一部分数据。</p><ul><li>Kafka 0.8以前<br>  Kafka 0.8 以前是没有高可用机制的。<br>  假设一个 Topic，由 3 个 Partiton 组成。3 个 Partition 在不同机器上，如果其中某一台机器宕掉了，则 Topic 的部分数据就丢失了。</li><li>Kafka 0.8以后<br>  Kafka 0.8 以后，通过副本机制来实现高可用。</li></ul><h3 id="2-消息丢失"><a href="#2-消息丢失" class="headerlink" title="2. 消息丢失"></a>2. 消息丢失</h3><p>经过参数优化配置，能够做到零丢失。</p><h4 id="Producer丢失数据"><a href="#Producer丢失数据" class="headerlink" title="Producer丢失数据"></a>Producer丢失数据</h4><p>如果 Producer 端设置了 acks=all，则不会丢失数据。<br>Leader 在所有的 Follower 都同步到了消息之后，才认为本次写成功。如果没满足这个条件，生产者会进行无限次重试。</p><h4 id="Broker丢失数据"><a href="#Broker丢失数据" class="headerlink" title="Broker丢失数据"></a>Broker丢失数据</h4><p>比较常见的一个场景：Kafka 某个 Broker 宕机，然后重新选举新的 Leader ，但此时其他的 Follower 部分数据尚未同步，结果此时 Leader 挂了，然后选举某个 Follower 成 Leader，丢失一部分数据。</p><p>一般设置如下 4 个参数：</p><ul><li>Topic 设置<code>replication.factor</code>参数<br>  参数值必须大于 1，要求每个 Partition 必须有至少 2 个副本。</li><li>Kafka 服务端设置 <code>min.insync.replicas</code> 参数<br>  参数值必须大于 1，要求每个 Partition 必须有至少 2 个副本。</li><li>Producer 设置 <code>acks=all</code><br>  要求每条数据，必须是写入所有副本，才认为写成功。</li><li>Producer 端设置 <code>retries=MAX</code><br>  MAX 即是一个超级大的数字，表示无限次重试。<code>retries=MAX</code>要求一旦写入数据失败，就无限重试。</li></ul><h4 id="Consumer丢失数据"><a href="#Consumer丢失数据" class="headerlink" title="Consumer丢失数据"></a>Consumer丢失数据</h4><p>默认情况下，Kafka 会自动提交 Offset，Kafka 认为 Consumer 已经处理消息了，但是 Consumer 可能在处理消息的过程中挂掉了。重启系统后，Consumer 会根据提交的 Offset 进行消费，也就丢失了一部分数据。</p><p>解决：关闭自动提交 Offset，在处理完之后自己手动提交 Offset，就可以保证数据不会丢失。但可能会存在消息重复消费问题。 </p><h3 id="3-重复消费"><a href="#3-重复消费" class="headerlink" title="3. 重复消费"></a>3. 重复消费</h3><h4 id="消费者相关参数"><a href="#消费者相关参数" class="headerlink" title="消费者相关参数"></a>消费者相关参数</h4><ul><li><code>enable.auto.commit</code>：表示消费者会周期性自动提交消费的offset。默认值true。</li><li><code>auto.commit.interval.ms</code>：在<code>enable.auto.commit为</code>true的情况下，自动提交的间隔。默认值5秒。</li><li><code>max.poll.records</code>：单次消费者拉取的最大数据条数，默认值500。</li><li><code>max.poll.interval.ms</code>：表示若在阈值时间之内消费者没有消费完上一次poll的消息，consumer client会主动向 coordinator 发起LeaveGroup请求，触发Rebalance；然后consumer重新发送JoinGroup请求。</li><li><code>session.timeout.ms</code>：group Coordinator 检测consumer发生崩溃所需的时间。在这个时间内如果Coordinator未收到Consumer的任何消息，那Coordinator就认为Consumer挂了。默认值10秒。</li><li><code>heartbeat.interval.ms</code>：标识Consumer给Coordinator发一个心跳包的时间间隔。heartbeat.interval.ms越小，发的心跳包越多。默认值3秒。</li><li>Group Coordinator<br>  对于每一个Consumer Group，Kafka集群为其从Broker集群中选择一个Broker作为其Coordinator。Coordinator主要做两件事：<ol><li>维持Group成员的组成。这包括加入新的成员，检测成员的存活性，清除不再存活的成员。</li><li>协调Group成员的行为。</li></ol></li></ul><h4 id="重复消费的原因"><a href="#重复消费的原因" class="headerlink" title="重复消费的原因"></a>重复消费的原因</h4><ul><li>原因1：消费者宕机、重启或者被强行kill进程，导致消费者消费的offset没有提交。</li><li>原因2：设置<code>enable.auto.commit</code>为true，如果在关闭消费者进程之前，取消了消费者的订阅，则有可能部分offset没提交，下次重启会重复消费。</li><li>原因3：消费后的数据，当offset还没有提交时，Partition就断开连接。比如，通常会遇到消费的数据，处理很耗时，导致超过了Kafka的<code>session timeout.ms</code>时间，那么就会触发reblance重平衡，此时可能存在消费者offset没提交，会导致重平衡后重复消费。</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li>提高消费者的处理速度。<br> 例如：对消息处理中比较耗时的步骤可通过异步的方式进行处理、利用多线程处理等。<br> 在缩短单条消息消费的同时，根据实际场景可将<code>max.poll.interval.ms</code>值设置大一点，避免不必要的Rebalance。<br> 可根据实际消息速率适当调小<code>max.poll.records</code>的值。</li><li>引入消息去重机制。<br> 例如：生成消息时，在消息中加入唯一标识符，如消息id等。在消费端，可以保存最近的<code>max.poll.records</code>条消息id到redis或mysql表中，这样在消费消息时先通过查询去重后，再进行消息的处理。</li><li>保证消费者逻辑幂等。<blockquote><p>如何实现接口的幂等性</p></blockquote></li></ol><h3 id="4-顺序消费"><a href="#4-顺序消费" class="headerlink" title="4. 顺序消费"></a>4. 顺序消费</h3><h3 id="5-消息积压"><a href="#5-消息积压" class="headerlink" title="5. 消息积压"></a>5. 消息积压</h3><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构</title>
      <link href="/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"><br>Redis的每种对象其实都由对象结构(redisObject)与对应编码的数据结构组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。</p><p>从一下两个角度来研究底层：</p><ul><li>对象设计机制: 对象结构(redisObject)</li><li>编码类型和底层数据结构: 对应编码的数据结构</li></ul><h2 id="对象机制"><a href="#对象机制" class="headerlink" title="对象机制"></a>对象机制</h2><h3 id="为什么Redis会设计redisObject对象"><a href="#为什么Redis会设计redisObject对象" class="headerlink" title="为什么Redis会设计redisObject对象"></a>为什么Redis会设计redisObject对象</h3><ol><li>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式。</li><li>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理.</li></ol><p>为了解决以上问题, Redis 构建了自己的类型系统, 这个系统的主要功能包括:</p><ul><li>redisObject 对象.</li><li>基于 redisObject 对象的类型检查.</li><li>基于 redisObject 对象的显式多态函数.</li><li>对 redisObject 进行分配、共享和销毁的机制.</li></ul><h3 id="redisObject数据结构"><a href="#redisObject数据结构" class="headerlink" title="redisObject数据结构"></a>redisObject数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">// LRU_BITS: 24</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向底层数据结构实例</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li>type记录了对象所保存的值的类型  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0 <span class="comment">// 字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1 <span class="comment">// 列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2 <span class="comment">// 集合</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3 <span class="comment">// 有序集</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4 <span class="comment">// 哈希表</span></span></span><br></pre></td></tr></table></figure></li><li>encoding记录了对象所保存的值的编码  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对象编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* 注意：版本2.6后不再使用. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* 注意：不再使用了，旧版本2.x中String的底层之一. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure></li><li>ptr是一个指针，指向实际保存值的数据结构。<br>  这个数据结构由type和encoding属性决定。<br>  举个例子，如果一个redisObject 的type 属性为<code>OBJ_LIST</code> ，encoding 属性为<code>OBJ_ENCODING_QUICKLIST</code>，那么这个对象就是一个Redis 列表（List)，它的值保存在一个QuickList的数据结构内，而ptr 指针就指向quicklist的对象</li><li>lru属性: 记录了对象最后一次被命令程序访问的时间</li></ul><h3 id="命令的类型检查和多态"><a href="#命令的类型检查和多态" class="headerlink" title="命令的类型检查和多态"></a>命令的类型检查和多态</h3><blockquote><p>那么Redis是如何处理一条命令的呢？</p></blockquote><p>当执行一个处理数据类型命令的时候，redis执行以下步骤</p><ul><li>根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；</li><li>检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；</li><li>根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；</li><li>返回数据结构的操作结果作为命令的返回值。</li></ul><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><ul><li>简单动态字符串 - sds</li><li>压缩列表 - ZipList</li><li>快表 - QuickList</li><li>字典/哈希表 - Dict</li><li>整数集 - IntSet</li><li>跳表 - ZSkipList</li></ul><h3 id="简单动态字符串-sds"><a href="#简单动态字符串-sds" class="headerlink" title="简单动态字符串 - sds"></a>简单动态字符串 - sds</h3><blockquote><p>Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为<code>简单动态字符串（simple dynamic string,SDS）</code>的抽象类型，并将 SDS 作为 Redis的默认字符串表示。<br>这是一种用于存储二进制数据的一种结构, 具有动态扩容的特点. 其实现位于src/sds.h与src/sds.c中。</p></blockquote><h4 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h4><p><img src="/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis-sds.png"><br>其中sdshdr是头部, buf是真实存储用户数据的地方。<br>另外注意, 从命名上能看出来, 这个数据结构除了能存储二进制数据, 显然是用于设计作为字符串使用的, 所以在buf中, 用户数据后总跟着一个\0. 即图中 “数据” + “\0” 是为所谓的buf。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sds.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的头部, 分别如下:<br><img src="/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis-sds-header.png"></p><ul><li>len 保存了SDS保存字符串的长度</li><li>buf[] 数组用来保存字符串的每个元素</li><li>alloc 分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数</li><li>flags 始终为一字节, 以低三位标示着头部的类型, 高5位未使用</li></ul><h4 id="为什么使用SDS"><a href="#为什么使用SDS" class="headerlink" title="为什么使用SDS"></a>为什么使用SDS</h4><blockquote><p>为什么不使用C语言字符串实现，而是使用 SDS呢？这样实现有什么好处？</p></blockquote><ul><li><p>常数复杂度获取字符串长度<br>  由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。<br>  而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。<br>  通过 strlen key 命令可以获取 key 的字符串长度。</p></li><li><p>杜绝缓冲区溢出<br>  我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。<br>  而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p></li><li><p>减少修改字符串的内存重新分配次数<br>  C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p><p>  而对于SDS，由于len属性和alloc属性的存在，对于修改字符串SDS实现了<code>空间预分配</code>和<code>惰性空间释放</code>两种策略：</p><ol><li>空间预分配<br> 对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li><li>惰性空间释放<br> 对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 alloc 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</li></ol></li><li><p>二进制安全<br>  因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；<br>  而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p></li><li><p>兼容部分 C 字符串函数<br>  虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。</p></li></ul><h3 id="压缩列表-ZipList"><a href="#压缩列表-ZipList" class="headerlink" title="压缩列表 - ZipList"></a>压缩列表 - ZipList</h3><blockquote><p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。<br>它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。<br>它能在O(1)的时间复杂度下完成list两端的push和pop操作。<br>但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p></blockquote><h3 id="快表-QuickList"><a href="#快表-QuickList" class="headerlink" title="快表 - QuickList"></a>快表 - QuickList</h3><blockquote><p>quicklist这个结构是Redis在3.2版本后新加的, 之前的版本是list(即linkedlist)， 用于String数据类型中。<br>它是一种以ziplist为结点的双端链表结构。<br>宏观上, quicklist是一个链表；微观上, 链表中的每个结点都是一个ziplist。</p></blockquote><h3 id="字典-哈希表-Dict"><a href="#字典-哈希表-Dict" class="headerlink" title="字典/哈希表 - Dict"></a>字典/哈希表 - Dict</h3><blockquote><p>本质上就是哈希表</p></blockquote><h3 id="整数集-IntSet"><a href="#整数集-IntSet" class="headerlink" title="整数集 - IntSet"></a>整数集 - IntSet</h3><blockquote><p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p></blockquote><h3 id="跳表-ZSkipList"><a href="#跳表-ZSkipList" class="headerlink" title="跳表 - ZSkipList"></a>跳表 - ZSkipList</h3><blockquote><p>跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。<br>跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。<br>跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p></blockquote><h4 id="什么是跳跃表"><a href="#什么是跳跃表" class="headerlink" title="什么是跳跃表"></a>什么是跳跃表</h4><p>跳表其实就是一种可以进行二分查找的有序链表。<br>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找，将查找的时间复杂度从O(N)降到O(logN)。</p><h4 id="跳跃表的设计"><a href="#跳跃表的设计" class="headerlink" title="跳跃表的设计"></a>跳跃表的设计</h4><p>redis跳跃表并没有在单独的类（比如skplist.c)中定义，而是其定义在server.h中, 如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><h2 id="Redis对象和底层结构对应关系"><a href="#Redis对象和底层结构对应关系" class="headerlink" title="Redis对象和底层结构对应关系"></a>Redis对象和底层结构对应关系</h2><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><blockquote><p>字符串是Redis最基本的数据类型，不仅所有key都是字符串类型，其它几种数据类型构成的元素也是字符串。<br>注意字符串的长度不能超过512M。</p></blockquote><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>字符串对象的编码可以是<code>int，raw或者embstr</code>。</p><ul><li>int 编码：保存的是可以用 long 类型表示的整数值。</li><li>embstr 编码：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li><li>raw 编码：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4>字符串对象支持三种编码方式: RAW, INT, EMBSTR, 三种方式的内存布局分别如下:<br><img src="/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis-string-encode.png"><h5 id="raw-和-embstr-的区别"><a href="#raw-和-embstr-的区别" class="headerlink" title="raw 和 embstr 的区别"></a>raw 和 embstr 的区别</h5><h4 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h4>当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。</li></ul><p>对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</p><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><blockquote><p>list 列表，它是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际上是个链表结构。</p></blockquote><h4 id="编码与内存布局"><a href="#编码与内存布局" class="headerlink" title="编码与内存布局"></a>编码与内存布局</h4><p>列表对象的编码是<code>quicklist</code>。 (之前版本中有linked和ziplist这两种编码。进一步的, 目前Redis定义的10个对象编码方式宏名中, 有两个被完全闲置了, 分别是: OBJ_ENCODING_ZIPMAP与OBJ_ENCODING_LINKEDLIST。 从Redis的演进历史上来看, 前者是后续可能会得到支持的编码值（代码还在）, 后者则应该是被彻底淘汰了)</p><p><img src="/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis-list-quicklist.png"></p><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的键是一个字符串类型，值是一个键值对集合。</p><h4 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h4><p>哈希对象的编码可以是 ziplist 或者 hashtable；对应的底层实现有两种, 一种是ziplist, 一种是dict。</p><h4 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>当同时满足下面两个条件时，使用ziplist（压缩列表）编码：</p><ol><li>列表保存元素个数小于512个</li><li>每个元素长度小于64字节</li></ol><p>不能满足这两个条件的时候使用 hashtable 编码。</p><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象 set 是 string 类型（整数也会转换成string类型进行存储）的无序集合。<br>注意集合和列表的区别：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。</p><h4 id="编码-2"><a href="#编码-2" class="headerlink" title="编码"></a>编码</h4><p>集合对象的编码可以是 intset 或者 hashtable; 底层实现有两种, 分别是intset和dict。 </p><p>显然当使用intset作为底层实现的数据结构时, 集合中存储的只能是数值数据, 且必须是整数;<br>而当使用dict作为集合对象的底层实现时, 是将数据全部存储于dict的键中, 值字段闲置不用.</p><h4 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>当集合同时满足以下两个条件时，使用 intset 编码：</p><ol><li>集合对象中所有元素都是整数</li><li>集合对象所有元素数量不超过512</li></ol><p>不能满足这两个条件的就使用 hashtable 编码。<br>第二个条件可以通过配置文件的 <code>set-max-intset-entries</code> 进行配置。</p><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>和集合对象相比，有序集合对象是有序的。<br>与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。</p><h4 id="编码-3"><a href="#编码-3" class="headerlink" title="编码"></a>编码</h4><p>有序集合的底层实现有两种：<br>一种是使用ziplist作为底层实现, 对应的编码值宏为<code>ZIPLIST</code>；<br>另外一种比较特殊, 底层使用了两种数据结构: dict与skiplist, 对应的编码值宏为<code>SKIPLIST</code>。</p><p>使用ziplist来实现有序集合很容易理解, 只需要在ziplist这个数据结构的基础上做好排序与去重就可以了。<br>使用zskiplist来实现有序集合也很容易理解, Redis中实现的这个跳跃表似乎天然就是为了实现有序集合对象而实现的, 那么为什么还要辅助一个dict实例呢?<br>我们先看来有序集合对象在这两种编码方式下的内存布局, 然后再做解释。</p><ul><li>ZIPLIST<br>  <img src="/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis-zset-ziplist.png"></li><li>SKIPLIST<br>  <img src="/2023/03/05/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis-zset-skiplist.png"></li></ul><h4 id="编码的转换-3"><a href="#编码的转换-3" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：</p><ol><li>保存的元素数量小于128；</li><li>保存的所有元素长度都小于64字节。</li></ol><p>不能满足上面两个条件的使用 skiplist 编码。<br>以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC锁-锁核心AQS</title>
      <link href="/2023/03/03/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E9%94%81-%E9%94%81%E6%A0%B8%E5%BF%83AQS/"/>
      <url>/2023/03/03/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E9%94%81-%E9%94%81%E6%A0%B8%E5%BF%83AQS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC锁-ReentrantLock</title>
      <link href="/2023/03/03/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E9%94%81-ReentrantLock/"/>
      <url>/2023/03/03/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E9%94%81-ReentrantLock/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC锁-LockSupport</title>
      <link href="/2023/03/03/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E9%94%81-LockSupport/"/>
      <url>/2023/03/03/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E9%94%81-LockSupport/</url>
      
        <content type="html"><![CDATA[<p>LockSupport用来创建锁和其他同步类的基本线程阻塞原语。<br>简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可；当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。</p><h3 id="线程阻塞原语"><a href="#线程阻塞原语" class="headerlink" title="线程阻塞原语"></a>线程阻塞原语</h3><p>Java 的线程阻塞和唤醒是通过 Unsafe 类的 park 和 unpark 方法做到的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LockSupport</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     setBlocker(t, blocker);</span><br><span class="line">     U.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">     setBlocker(t, <span class="keyword">null</span>); <span class="comment">// 醒来后置null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        U.unpark(thread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parkBlocker"><a href="#parkBlocker" class="headerlink" title="parkBlocker"></a>parkBlocker</h4><p>线程对象 Thread 里面有一个重要的属性 parkBlocker，它保存当前线程因为什么而 park。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">volatile</span> Object parkBlocker;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程被 unpark 唤醒后，这个属性会被置为 null。<br>Unsafe.park 和 unpark 并不会帮我们设置 parkBlocker 属性，负责管理这个属性的工具类是 LockSupport，它对 Unsafe 这两个方法进行了简单的包装。</p><p>Java 的锁数据结构正是通过调用 LockSupport 来实现休眠与唤醒的。</p><p>线程对象里面的 parkBlocker 字段的值就是「排队管理器」- AbstractQueuedSynchronizer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC工具类-CyclicBarrier</title>
      <link href="/2023/03/03/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-CyclicBarrier/"/>
      <url>/2023/03/03/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-CyclicBarrier/</url>
      
        <content type="html"><![CDATA[<p>对于CountDownLatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。</p><p>对于CyclicBarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。</p><p>和CountDownLatch对比</p><ul><li>CountDownLatch减计数，CyclicBarrier加计数。</li><li>CountDownLatch是一次性的，CyclicBarrier可以重用。</li><li>CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思<ul><li>CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；</li><li>CyclicBarrier的下一步动作实施者是最后一个进入屏障的线程，具有往复多次实施动作的特点。</li></ul></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><p>CyclicBarrier没有显示继承哪个父类或者实现哪个父接口, 所有AQS和重入锁不是通过继承实现的，而是通过组合实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 类的内部类</span></span><br><span class="line"><span class="comment">    * CyclicBarrier类存在一个内部类Generation，每一次使用的CycBarrier可以当成Generation的实例，其源代码如下</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性broken，用来表示当前屏障是否被损坏。</span></span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 条件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">// 参与的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">// 由最后一个进入 barrier 的线程执行的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">// 当前代</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    <span class="comment">// 正在等待进入屏障的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性有一个为ReentrantLock对象，有一个为Condition对象，而Condition对象又是基于AQS的，所以，归根到底，底层还是由AQS提供支持。</p><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><ul><li><p>CyclicBarrier(int parties, Runnable barrierAction)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 参与的线程数量小于等于0，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="comment">// 设置parties</span></span><br><span class="line"><span class="keyword">this</span>.parties = parties;</span><br><span class="line"><span class="comment">// 设置count</span></span><br><span class="line"><span class="keyword">this</span>.count = parties;</span><br><span class="line"><span class="comment">// 设置barrierCommand</span></span><br><span class="line"><span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  该构造函数可以指定关联该CyclicBarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。</p></li><li><p>CyclicBarrier(int parties)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用含有两个参数的构造函数</span></span><br><span class="line"><span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  该构造函数仅仅执行了关联该CyclicBarrier的线程数量，没有设置执行动作。</p></li></ul><h3 id="核心函数-dowait"><a href="#核心函数-dowait" class="headerlink" title="核心函数 dowait"></a>核心函数 dowait</h3><p>此函数为CyclicBarrier类的核心函数，CyclicBarrier类对外提供的await函数在底层都是调用该了doawait函数，其源代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">            TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">// 保存当前锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 锁定</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存当前代</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (g.broken) <span class="comment">// 屏障被破坏，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">// 线程被中断</span></span><br><span class="line">            <span class="comment">// 损坏当前屏障，并且唤醒所有的线程，只有拥有锁的时候才会调用</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减少正在等待进入屏障的线程数量</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 正在等待进入屏障的线程数量为0，所有线程都已经进入</span></span><br><span class="line">            <span class="comment">// 运行的动作标识</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 保存运行动作</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>) <span class="comment">// 动作不为空</span></span><br><span class="line">                    <span class="comment">// 运行</span></span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 设置ranAction状态</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 进入下一代</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction) <span class="comment">// 没有运行的动作</span></span><br><span class="line">                    <span class="comment">// 损坏当前屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed) <span class="comment">// 没有设置等待时间</span></span><br><span class="line">                    <span class="comment">// 等待</span></span><br><span class="line">                    trip.await(); </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>) <span class="comment">// 设置了等待时间，并且等待时间大于0</span></span><br><span class="line">                    <span class="comment">// 等待指定时长</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; </span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123; <span class="comment">// 等于当前代并且屏障没有被损坏</span></span><br><span class="line">                    <span class="comment">// 损坏当前屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="comment">// 抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不等于当前带后者是屏障被损坏</span></span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    <span class="comment">// 中断当前线程</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken) <span class="comment">// 屏障被损坏，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation) <span class="comment">// 不等于当前代</span></span><br><span class="line">                <span class="comment">// 返回索引</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123; <span class="comment">// 设置了等待时间，并且等待时间小于0</span></span><br><span class="line">                <span class="comment">// 损坏屏障</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="comment">// 抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心函数-nextGeneration"><a href="#核心函数-nextGeneration" class="headerlink" title="核心函数 nextGeneration"></a>核心函数 nextGeneration</h3><p>此函数在所有线程进入屏障后会被调用，即生成下一个版本，所有线程又可以重新进入到屏障中，其源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    <span class="comment">// 恢复正在等待进入屏障的线程数量</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 新生一代</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此函数中会调用AQS的signalAll方法，即唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。</p><h3 id="breakBarrier函数"><a href="#breakBarrier函数" class="headerlink" title="breakBarrier函数"></a>breakBarrier函数</h3><p>此函数的作用是损坏当前屏障，会唤醒所有在屏障中的线程。源代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 恢复正在等待进入屏障的线程数量</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC工具类-Semaphore</title>
      <link href="/2023/03/02/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore/"/>
      <url>/2023/03/02/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore/</url>
      
        <content type="html"><![CDATA[<p>Semaphore底层是基于AbstractQueuedSynchronizer来实现的。<br>Semaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Semaphore实现了Serializable接口，即可以进行序列化。</p><h3 id="类的内部类-Sync类"><a href="#类的内部类-Sync类" class="headerlink" title="类的内部类 Sync类"></a>类的内部类 Sync类</h3><p>Semaphore与ReentrantLock的内部类的结构相同，类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类，继承自AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="comment">// 设置状态数</span></span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享模式下非公平策略获取</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可数</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="comment">// 剩余的许可</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining)) <span class="comment">// 许可小于0或者比较并且设置状态成功</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共享模式下进行释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的缩减量减小可用许可的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Permit count underflow&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并返回立即可用的所有许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>)) <span class="comment">// 许可为0或者比较并设置成功</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的内部类-NonfairSync类"><a href="#类的内部类-NonfairSync类" class="headerlink" title="类的内部类 NonfairSync类"></a>类的内部类 NonfairSync类</h3><p>NonfairSync类继承了Sync类，表示采用非公平策略获取资源，其只有一个tryAcquireShared方法，重写了AQS的该方法，其源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享模式下获取</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从tryAcquireShared方法的源码可知，其会调用父类Sync的nonfairTryAcquireShared方法，表示按照非公平策略进行资源的获取。</p><h3 id="类的内部类-FairSync类"><a href="#类的内部类-FairSync类" class="headerlink" title="类的内部类 FairSync类"></a>类的内部类 FairSync类</h3><p>FairSync类继承了Sync类，表示采用公平策略获取资源，其只有一个tryAcquireShared方法，重写了AQS的该方法，其源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从tryAcquireShared方法的源码可知，它使用公平策略来获取资源，它会判断同步队列中是否存在其他的等待节点。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semaphore自身只有两个属性，最重要的是sync属性，基于Semaphore对象的操作绝大多数都转移到了对sync的操作。</p><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><ul><li><p>Semaphore(int permits)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  该构造函数会创建具有给定的许可数和非公平的公平设置的Semaphore。</p></li><li><p>Semaphore(int permits, boolean fair)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  该构造函数会创建具有给定的许可数和给定的公平设置的Semaphore。</p></li></ul><h3 id="核心函数-acquire函数"><a href="#核心函数-acquire函数" class="headerlink" title="核心函数 acquire函数"></a>核心函数 acquire函数</h3><p>方法从信号量获取一个(多个)许可，在提供一个许可前一直将线程阻塞，或者线程被中断，其源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中将会调用Sync对象的acquireSharedInterruptibly(从AQS继承而来的方法)方法</p><h3 id="核心函数-release函数"><a href="#核心函数-release函数" class="headerlink" title="核心函数 release函数"></a>核心函数 release函数</h3><p>此方法释放一个(多个)许可，将其返回给信号量，源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中将会调用Sync对象的releaseShared(从AQS继承而来的方法)方法</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC工具类-CountDownLatch</title>
      <link href="/2023/02/24/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-CountDownLatch/"/>
      <url>/2023/02/24/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-CountDownLatch/</url>
      
        <content type="html"><![CDATA[<p>CountDownLatch典型的用法是将一个程序分为n个互相独立的可解决任务，并创建值为n的CountDownLatch。当每一个任务完成时，都会在这个锁存器上调用<code>countDown()</code>，等待问题被解决的任务调用这个锁存器的<code>await()</code>，将他们自己拦住，直至锁存器计数结束。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><p>CountDownLatch没有显示继承哪个父类或者实现哪个父接口, 它底层是AQS是通过内部类Sync来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>CountDownLatch类存在一个内部类Sync，继承自AbstractQueuedSynchronizer。</p><p>对CountDownLatch方法的调用会转发到对Sync或AQS的方法的调用，所以，AQS对CountDownLatch提供支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图在共享模式下获取对象状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图设置状态来反映共享模式下的一个释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 没有被线程占有</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 下一个状态</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 比较并且设置成功</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的属性和构造函数"><a href="#类的属性和构造函数" class="headerlink" title="类的属性和构造函数"></a>类的属性和构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化状态数</span></span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心函数-await"><a href="#核心函数-await" class="headerlink" title="核心函数 await()"></a>核心函数 await()</h3><p>此函数将会使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 转发到sync对象上</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对CountDownLatch对象的await的调用会转发为对Sync的acquireSharedInterruptibly(从AQS继承的方法)方法的调用。</p><p>CountDownLatch的await调用链：<br><img src="/2023/02/24/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-CountDownLatch/countdownlatch-await.png"></p><h3 id="核心函数-countDown"><a href="#核心函数-countDown" class="headerlink" title="核心函数 countDown()"></a>核心函数 countDown()</h3><p>此函数将递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对countDown的调用转换为对Sync对象的releaseShared(从AQS继承而来)方法的调用。</p><p>CountDownLatch的countDown调用链：<br><img src="/2023/02/24/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-CountDownLatch/countdownlatch-countdown.png"></p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><blockquote><p>实现一个容器，提供两个方法，add，size<br>写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束.</p></blockquote><h3 id="使用wait和notify实现"><a href="#使用wait和notify实现" class="headerlink" title="使用wait和notify实现"></a>使用wait和notify实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  必须先让t2先进行启动 使用wait 和 notify 进行相互通讯，wait会释放锁，notify不会释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        T2 t2 = <span class="keyword">new</span> T2();</span><br><span class="line"></span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 启动&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(t2.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">/**会释放锁*/</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;t2 结束&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t1 启动&quot;</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">                   t2.add(i);</span><br><span class="line">                   System.out.println(<span class="string">&quot;add&quot;</span>+i);</span><br><span class="line">                   <span class="keyword">if</span>(t2.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                       <span class="comment">/**不会释放锁*/</span></span><br><span class="line">                       lock.notify();</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           lock.wait();</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch实现"><a href="#CountDownLatch实现" class="headerlink" title="CountDownLatch实现"></a>CountDownLatch实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用CountDownLatch 代替wait notify 好处是通讯方式简单，不涉及锁定。  Count 值为0时当前线程继续执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T3 t = <span class="keyword">new</span> T3();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 start&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(t.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   countDownLatch.await();</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2 end&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 start&quot;</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">               t.add(i);</span><br><span class="line">               System.out.println(<span class="string">&quot;add&quot;</span>+ i);</span><br><span class="line">               <span class="keyword">if</span>(t.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;countdown is open&quot;</span>);</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 end&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC原子类</title>
      <link href="/2023/02/24/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
      <url>/2023/02/24/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS的全称为Compare-And-Swap，直译就是对比交换。<br>是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值。<br>经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。  </p><p>简单解释：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。<br>CAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。</p><h3 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>因为CAS需要在操作值的时候，检查值有没有发生变化，没有发生变化则更新。但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。<br>在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么 A-&gt;B-&gt;A 就会变成 1A-&gt;2B-&gt;3A。</p><p>从Java 1.5开始，JDK的Atomic包里提供了一个类<code>AtomicStampedReference</code>来解决ABA问题。<br>这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><p>如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。<br>pause指令有两个作用：</p><ul><li>第一，它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；</li><li>第二，它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率。</li></ul><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p><p>还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i = 2，j = a，合并一下ij = 2a，然后用CAS来操作ij。</p><p>从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p><img src="/2023/02/24/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-JUC%E5%8E%9F%E5%AD%90%E7%B1%BB/JUC-unsafe-api.png"></p><h3 id="Unsafe与CAS"><a href="#Unsafe与CAS" class="headerlink" title="Unsafe与CAS"></a>Unsafe与CAS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object newValue)</span> </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getObjectVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2, Object paramObject3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt1, <span class="keyword">int</span> paramInt2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2, <span class="keyword">long</span> paramLong3)</span></span>;</span><br></pre></td></tr></table></figure><p>Unsafe内部使用自旋的方式进行CAS更新(while循环进行CAS更新，如果更新失败，则循环再次重试)。</p><p>Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong。都是native方法。</p><h4 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h4><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用于获取value字段相对当前对象的“起始地址”的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递增加detla</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递增加1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> AtomicInteger 底层用的是volatile的变量和CAS来进行更改数据的。</p><ul><li>volatile保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值</li><li>CAS 保证数据更新的原子性。</li></ul><h3 id="12个原子类"><a href="#12个原子类" class="headerlink" title="12个原子类"></a>12个原子类</h3><h4 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h4><ul><li>AtomicBoolean: 原子更新布尔类型。</li><li>AtomicInteger: 原子更新整型。</li><li>AtomicLong: 原子更新长整型。<h4 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h4></li><li>AtomicIntegerArray: 原子更新整型数组里的元素。</li><li>AtomicLongArray: 原子更新长整型数组里的元素。</li><li>AtomicReferenceArray: 原子更新引用类型数组里的元素。</li></ul><p>这三个类的最常用的方法是如下两个方法：</p><ul><li>get(int index)：获取索引为index的元素值。</li><li>compareAndSet(int i,E expect,E update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值。<h4 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h4></li><li>AtomicReference: 原子更新引用类型。</li><li>AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。</li><li>AtomicMarkableReferce: 原子更新带有标记位的引用类型。</li></ul><h4 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h4><ul><li>AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater: 原子更新长整型字段的更新器。</li><li>AtomicReferenceFieldUpdater: 原子更新饮用类型字段的更新器。</li></ul><h3 id="AtomicStampedReference解决CAS的ABA问题"><a href="#AtomicStampedReference解决CAS的ABA问题" class="headerlink" title="AtomicStampedReference解决CAS的ABA问题"></a>AtomicStampedReference解决CAS的ABA问题</h3><p>AtomicStampedReference主要维护包含一个对象引用以及一个可以自动更新的整数<code>stamp</code>的<code>pair对象</code>来解决ABA问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;  <span class="comment">//维护对象引用</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;  <span class="comment">//用于标志版本</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * expectedReference ：更新之前的原始值</span></span><br><span class="line"><span class="comment">      * newReference : 将要更新的新值</span></span><br><span class="line"><span class="comment">      * expectedStamp : 期待更新的标志版本</span></span><br><span class="line"><span class="comment">      * newStamp : 将要更新的标志版本</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                             V   newReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前的(元素值，版本号)对</span></span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            <span class="comment">// 引用没变</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            <span class="comment">// 版本号没变</span></span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            <span class="comment">// 新引用等于旧引用</span></span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">            <span class="comment">// 新版本号等于旧版本号</span></span><br><span class="line">            newStamp == current.stamp) ||</span><br><span class="line">            <span class="comment">// 构造新的Pair对象并CAS更新</span></span><br><span class="line">            casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用Unsafe的compareAndSwapObject()方法CAS更新pair的引用为新引用</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——RocketMQ</title>
      <link href="/2023/02/22/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RocketMQ/"/>
      <url>/2023/02/22/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RocketMQ/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/48816137">https://zhuanlan.zhihu.com/p/48816137</a></p><p><a href="https://www.zhihu.com/question/449611434/answer/1824707689">https://www.zhihu.com/question/449611434/answer/1824707689</a></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty</title>
      <link href="/2023/02/20/Netty/"/>
      <url>/2023/02/20/Netty/</url>
      
        <content type="html"><![CDATA[<p>Netty是一个高性能、异步事件驱动的NIO框架，提供了对TCP、UDP和文件传输的支持。<br>作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码分析</title>
      <link href="/2023/02/05/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/02/05/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="Bean是如何注册到IOC容器中的"><a href="#Bean是如何注册到IOC容器中的" class="headerlink" title="Bean是如何注册到IOC容器中的"></a>Bean是如何注册到IOC容器中的</h3><h4 id="xml配置文件方式下Bean的注册"><a href="#xml配置文件方式下Bean的注册" class="headerlink" title="xml配置文件方式下Bean的注册"></a>xml配置文件方式下Bean的注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="comment">//将传入的xml配置位置信息设置到configLocations</span></span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">    <span class="comment">//核心方法</span></span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注册xml配置文件到configLocations</li><li>调用refresh()进行整个Context的刷新，实际上就是整个Context的启动</li><li>Bean的加载会读到配置文件，解析成DOM对象，将DOM对象转换成<code>beanDeifnition</code><ul><li>obtainFreshBeanFactory()</li><li>refreshBeanFactory()</li><li>loadBeanDefinitions(beanFactory)</li></ul></li><li>将 beanDeifnition 存到 beanDeifnitionMap，完成这个Bean的注册<ul><li>DefaultListableBeanFactory#registerBeanDefinition</li></ul></li></ul><h4 id="注解方式下Bean的注册"><a href="#注解方式下Bean的注册" class="headerlink" title="注解方式下Bean的注册"></a>注解方式下Bean的注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigApplicationContext构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line"><span class="comment">//主要是scan方法完成bean的注册</span></span><br><span class="line">scan(basePackages);</span><br><span class="line"><span class="comment">//核心方法</span></span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationConfigApplicationContext#scan</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">//扫描包，进行Bean注册</span></span><br><span class="line">doScan(basePackages);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容器启动核心-AbstractApplicationContext-refresh"><a href="#容器启动核心-AbstractApplicationContext-refresh" class="headerlink" title="容器启动核心 AbstractApplicationContext#refresh()"></a>容器启动核心 AbstractApplicationContext#refresh()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext#refresh()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            <span class="comment">// 准备初始化容器工作，设置启动标志、记录启动时间等</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 beanFactory, 并加载bean定义等</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">            <span class="comment">// beanFactory注入一些标准组件，例如ApplicationContextAwareProcessor，ClassLoader等</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                <span class="comment">// 给实现类留的一个钩子，例如注入BeanPostProcessors，这里是个空方法 </span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">// 调用在上下文中注册为bean的工厂处理器。</span></span><br><span class="line">                <span class="comment">// 执行 BeanFactoryPostProcessor 实现类的 postProcessBeanFactory()方法</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">                <span class="comment">// 注册 BeanPostProcessor 实现类</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                <span class="comment">// 国际化资源处理</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                <span class="comment">// bean工厂注册一个key为applicationEventMulticaster的广播器 用于事件广播</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                <span class="comment">// 给实现类留的一钩子，可以执行其他refresh的工作，比如启动tomcat server</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                <span class="comment">// 注册事件监听器</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                <span class="comment">// 完成单例bean的初始化</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                <span class="comment">// 完成容器启动，发布容器启动事件</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line"><span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean是如何从IOC容器中被获取到的"><a href="#Bean是如何从IOC容器中被获取到的" class="headerlink" title="Bean是如何从IOC容器中被获取到的"></a>Bean是如何从IOC容器中被获取到的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo#applicationContext.getBean</span></span><br><span class="line">ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">User user = (User) applicationContext.getBean(<span class="string">&quot;userBean&quot;</span>);</span><br><span class="line">System.out.println(user.getUserName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractApplicationContext#getBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanFactory#getBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanFactory#doGetBean</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理别名BeanName、处理带&amp;符的工厂BeanName</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从单例缓存中获取对象</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果 sharedInstance 是普通的 Bean 实例，则下面的方法会直接返回</span></span><br><span class="line">        <span class="comment">// 2. 如果 sharedInstance 是 FactoryBean 类型，则需要获取 getObject 方法，可以参考关于 FactoryBean 的实现类 </span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 循环依赖有三种，setter注入、多实例和构造函数，Spring 只能解决 setter 注入，所以这里是 Prototype 则会抛出异常</span></span><br><span class="line"><span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 父 bean 工厂存在</span></span><br><span class="line">        <span class="comment">// 2. 当前 bean 不存在于当前bean工厂，则到父工厂查找 bean 实例</span></span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line"><span class="comment">// 获取 name 对应的 beanName，如果 name 是以 &amp; 开头，则返回 &amp; + beanName</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. typeCheckOnly，用于判断调用 getBean 方法时，是否仅是做类型检查</span></span><br><span class="line">        <span class="comment">// 2. 如果不是只做类型检查，就会调用 markBeanAsCreated 进行记录</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//这里通过beanName获取相关信息来组装RootBeanDefinition</span></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// 检查当前创建的 bean 定义是否为抽象 bean 定义</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前Bean的依赖项</span></span><br><span class="line"><span class="comment">// 在实例化自己之前，需要先实例化自己依赖的bean</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="comment">// 监测是否存在 depends-on 循环依赖，若存在则会抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册依赖记录</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加载 depends-on 依赖（dep 是 depends-on 缩写）</span></span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处开始创建实例对象</span></span><br><span class="line"><span class="comment">// 单例的对象创建</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 把 beanName 和 new ObjectFactory 匿名内部类传入回调</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建 bean</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line"><span class="comment">// 创建失败则销毁</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">// prototype 原型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line"><span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"><span class="comment">// 如果需要类型转换，这里会进行操作</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line"><span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> convertedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>doGetBean()方法基本上概括了整个Bean的获取过程</p><ul><li>首先通过BeanName从容器中获取Bean相关的信息，并组装成RootBeanDefinition</li><li>通过RootBeanDefinition来创建实例对象，这里需要根据单例、多例来分别进行创建</li><li>将创建或者获取到的对象返回<br>  单例对象是容器启动的时候就已经实例化好了，可以直接拿来用，当然也可以设置延迟加载</li></ul><h3 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h3><p><img src="/2023/02/05/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/getbean-createbean.png"></p><p>在判断 mbd.isSingleton() 单例以后，开始使用基于 ObjectFactory 包装的方式创建 createBean，进入后核心逻辑是开始执行 doCreateBean 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#doCreateBean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanWrapper封装了具体的Bean实例，然后可以很方便地通过调用getPropertyValue和setPropertyValue等方法反射读写Bean的具体属性</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 先尝试从缓存中取</span></span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 调用构造方法创建一个空实例对象，并用BeanWrapper进行包装</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的后置处理器，如果后置处理器实现了MergedBeanDefinitionPostProcessor接口，则一次调用其postProcessMergedBeanDefinition方法</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果满足循环依赖缓存条件，先缓存具体对象</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环依赖处理逻辑：将已完成实例化，但是未完成属性赋值和相关的初始化的一个不完整的 bean 添加到三级缓存 singletonFactories 中</span></span><br><span class="line"><span class="comment">// 具体内部会遍历后置处理器，判断是否有SmartInstantiationAwareBeanPostProcessor的实现类，然后调用里面getEarlyBeanReference覆盖当前Bean</span></span><br><span class="line"><span class="comment">// 默认不做任何操作返回当前Bean，作为拓展，这里比如可以供AOP来创建代理类</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始对Bean实例进行初始化</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 对bean进行属性填充，在这里面完成依赖注入的相关内容</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 完成属性依赖注入后，进一步初始化Bean</span></span><br><span class="line"><span class="comment">// 具体进行了以下操作：</span></span><br><span class="line"><span class="comment">// 1.若实现了BeanNameAware， BeanClassLoaderAware，BeanFactoryAwareAware等接口，则注入相关对象</span></span><br><span class="line"><span class="comment">// 2.遍历后置处理器，调用实现的postProcessBeforeInitialization方法，</span></span><br><span class="line"><span class="comment">// 3.如果实现了initialzingBean，调用实现的 afterPropertiesSet()</span></span><br><span class="line"><span class="comment">// 4.如果配置了init-mothod，调用相应的init方法</span></span><br><span class="line"><span class="comment">// 5.遍历后置处理器，调用实现的postProcessAfterInitialization</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果实现了Disposable接口，会在这里进行注册，最后在销毁的时候调用相应的destroy方法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 bean 实例</span></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 doCreateBean 方法中包括的内容较多，但核心主要是创建实例、加入缓存以及最终进行属性填充，属性填充就是把一个 bean 的各个属性字段涉及到的类填充进去。</li><li>createBeanInstance，创建 bean 实例，并将 bean 实例包装到 BeanWrapper 对象中返回</li><li>addSingletonFactory，添加 bean 工厂对象到 singletonFactories 缓存中</li><li>getEarlyBeanReference，获取原始对象的早期引用，在 getEarlyBeanReference 方法中，会执行 AOP 相关逻辑。若 bean 未被 AOP 拦截，getEarlyBeanReference 原样返回 bean。</li><li>populateBean，填充属性，解析依赖关系。也就是从这开始去找寻 A 实例中属性 B，紧接着去创建 B 实例，最后在返回回来。</li><li>initializeBean(beanName, exposedObject, mbd)：完成 bean 的属性填充注入后，进一步初始化 bean，在此过程中产生代理对象。此时 bean 的创建工作正式完成，已经可以在项目中使用了</li></ul><h4 id="bean属性填充-populateBean"><a href="#bean属性填充-populateBean" class="headerlink" title="bean属性填充 populateBean"></a>bean属性填充 populateBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory#populateBean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line"><span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line"><span class="comment">// to support styles of field injection.</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="comment">// 根据bean的依赖注入方式：即是否标注有 @Autowired 注解或 autowire=“byType/byName” 的标签</span></span><br><span class="line">    <span class="comment">// 会遍历bean中的属性，根据类型或名称来完成相应的注入</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line"><span class="comment">// 深拷贝当前已有的配置</span></span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据名称进行注入</span></span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据类型进行注入</span></span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合注入后的配置，覆盖当前配置</span></span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器是否注册了InstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="keyword">if</span> (hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否进行依赖检查</span></span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 将pvs上所有的属性填充到BeanWrapper对应的Bean实例中</span></span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean的存储及Spring-bean的三级缓存"><a href="#Bean的存储及Spring-bean的三级缓存" class="headerlink" title="Bean的存储及Spring bean的三级缓存"></a>Bean的存储及Spring bean的三级缓存</h3><h4 id="Bean的存储"><a href="#Bean的存储" class="headerlink" title="Bean的存储"></a>Bean的存储</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>存储 bean 的 map 在<code>DefaultListableBeanFactory</code>类中。<br>通常叫BeanDefinition接口为 : bean的定义对象。<br>可以认为BeanDefinition是一个中转站，这个中转站中，存放了所有的class对应的信息，如果是初始化，就根据BeanDefinition的属性信息去初始化。</p><h4 id="Bean的三级缓存"><a href="#Bean的三级缓存" class="headerlink" title="Bean的三级缓存"></a>Bean的三级缓存</h4><p>采用三级缓存模式来解决循环依赖问题。<br>Spring只是解决了单例模式下属性依赖的循环问题；Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第几级缓存 对应的map 说明</p><ul><li>第1级  Map&lt;String, Object&gt; singletonObjects<br>  用来存放已经完全创建好的单例 beanbeanName -&gt; bean 实例<br>  最基础的缓存，创建完并初始化（createBean）后的bean实例会放入，项目启动完成后获取bean实例时从此获取</li><li>第3级  Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories<br>  用来存放单例 bean 的 ObjectFactorybeanName -&gt; ObjectFactory 实例<br>  创建bean过程中用于处理循环依赖的临时缓存，由于只有在初始化时才知道有没有循环依赖，所以通过ObjectFactory临时<code>存储</code>刚创建完的bean，并延迟触发循环依赖时被引用的bean需要赋值当前bean时去获取当前bean的逻辑，且获取对象会作为当前bean的最终对象</li><li>第2级  Map&lt;String, Object&gt; earlySingletonObjects<br>  用来存放早期的 beanbeanName -&gt; bean 实例<br>  创建bean过程中用于处理循环依赖的临时缓存，搭配第三层缓存，用于其ObjectFactory返回对象的缓存，保证多个关联对象对当前bean的引用为同一个</li></ul><p>一个bean在创建过程中可能会产生两个对象：</p><ul><li>一个是循环依赖时需要设值给与此bean相互引用的其他bean的对象（getEarlyBeanReference）</li><li>一个是初始化后的对象（initializeBean）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="代理对象生成过程"><a href="#代理对象生成过程" class="headerlink" title="代理对象生成过程"></a>代理对象生成过程</h3><h4 id="doCreateBean-gt-initializeBean"><a href="#doCreateBean-gt-initializeBean" class="headerlink" title="doCreateBean -&gt; initializeBean"></a>doCreateBean -&gt; initializeBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory#initializeBean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果实现了Aware接口，就对该bean进行一些设置</span></span><br><span class="line">       <span class="comment">// 比如实现了BeanNameAware接口，那么对其bean的属性beanName上设置对应的beanName</span></span><br><span class="line">       <span class="comment">// 如果实现了BeanFactoryAware接口，那么对其beanFactory属性设置上创建该bean使用的bean工厂</span></span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 如果bean实现了InitializingBean或者用户自定义的init方法方法，那么调用这些初始化方法对bean的属性进行一些个性化设置</span></span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 执行后置处理器的postProcessAfterInitialization方法。AOP的原理和实现就在其中</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="initializeBean-gt-applyBeanPostProcessorsAfterInitialization"><a href="#initializeBean-gt-applyBeanPostProcessorsAfterInitialization" class="headerlink" title="initializeBean -&gt; applyBeanPostProcessorsAfterInitialization"></a>initializeBean -&gt; applyBeanPostProcessorsAfterInitialization</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// 初始化返回结果为existingBean</span></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="comment">// 遍历该工厂创建的所有实现了 BeanPostProcessors 接口的列表的 bean</span></span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="comment">// 回调BeanPostProcessor#postProcessAfterInitialization来对现有的bean实例进行包装</span></span><br><span class="line">Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"><span class="comment">// 一般processor对不感兴趣的bean会回调直接返回result，使其能继续回调后续的BeanPostProcessor</span></span><br><span class="line"><span class="comment">// 但有些processor会返回null来中断其后续的BeanPostProcessor</span></span><br><span class="line"><span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 直接返回result，中断其后续的BeanPostProcessor处理</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator#postProcessAfterInitialization</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果是普通bean，则返回beanName，如果是FactoryBean,则返回加上前缀&amp;的&amp;beanName</span></span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">// earlyProxyReferences中缓存的是已经创建好的代理对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator#wrapIfNecessary</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 看看有没有缓存，有缓存对象就直接返回了</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果该bean不需要被代理，则直接返回原始的bean对象</span></span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 bean 的 advices（通知或增强器）</span></span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="comment">// 加入缓存中</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="comment">// 通过createProxy方法创建代理对象</span></span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator#createProxy</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buildProxy(beanClass, beanName, specificInterceptors, targetSource, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator#createProxyClass</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createProxyClass(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span><br><span class="line"><span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (Class&lt;?&gt;) buildProxy(beanClass, beanName, specificInterceptors, targetSource, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">buildProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource, <span class="keyword">boolean</span> classOnly)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory clbf) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass(clbf, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个ProxyFactory</span></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line"><span class="comment">// 初始化ProxyFactory</span></span><br><span class="line">proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定代理方式是使用JDK代理，还是使用Cglib</span></span><br><span class="line"><span class="keyword">if</span> (proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="comment">// Explicit handling of JDK proxy targets and lambdas (for introduction advice scenarios)</span></span><br><span class="line"><span class="keyword">if</span> (Proxy.isProxyClass(beanClass) || ClassUtils.isLambdaClass(beanClass)) &#123;</span><br><span class="line"><span class="comment">// Must allow for introductions; can&#x27;t just set interfaces to the proxy&#x27;s interfaces only.</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; ifc : beanClass.getInterfaces()) &#123;</span><br><span class="line">proxyFactory.addInterface(ifc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No proxyTargetClass flag enforced, let&#x27;s apply our default checks...</span></span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use original ClassLoader if bean class not locally loaded in overriding class loader</span></span><br><span class="line">ClassLoader classLoader = getProxyClassLoader();</span><br><span class="line"><span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader smartClassLoader &amp;&amp; classLoader != beanClass.getClassLoader()) &#123;</span><br><span class="line">classLoader = smartClassLoader.getOriginalClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (classOnly ? proxyFactory.getProxyClass(classLoader) : proxyFactory.getProxy(classLoader));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProxyFactory#getProxy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ProxyFactory#getProxyClass</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getProxyClass(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxyClass(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AopProxy#getProxy</span></span><br><span class="line"><span class="function">Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span></span>;</span><br><span class="line"><span class="comment">// JdkDynamicAopProxy#getProxy</span></span><br><span class="line"><span class="comment">// CglibAopProxy#getProxy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultAopProxyFactory implements AopProxyFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line"><span class="comment">// 获得被代理类的类型，以确定代理的方式</span></span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line"><span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果目标类有接口，或者本身就是一个代理类，或者是lambada表达式生成的类</span></span><br><span class="line"><span class="comment">//以上三种情况走jdk代理</span></span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则使用CGLIB生成代理对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spring-beans"><a href="#spring-beans" class="headerlink" title="spring-beans"></a>spring-beans</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>用于访问Springbean容器的根接口。<br>Bean工厂实现应该尽可能地支持标准的Bean生命周期接口。</p><p>整套初始化方法及其标准顺序为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanNameAware#setBeanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanClassLoaderAware#setBeanClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanFactoryAware#setBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.EnvironmentAware#setEnvironment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.EmbeddedValueResolverAware#setEmbeddedValueResolver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ResourceLoaderAware#setResourceLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationEventPublisherAware#setApplicationEventPublisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.MessageSourceAware#setMessageSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationContextAware#setApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.ServletContextAware#setServletContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getInitMethodName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DisposableBean#destroy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodName</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><h3 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h3><h2 id="spring-context"><a href="#spring-context" class="headerlink" title="spring-context"></a>spring-context</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码-ThreadLocal</title>
      <link href="/2023/01/31/Java%E6%BA%90%E7%A0%81-ThreadLocal/"/>
      <url>/2023/01/31/Java%E6%BA%90%E7%A0%81-ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h3 id="散列算法-斐波那契散列法"><a href="#散列算法-斐波那契散列法" class="headerlink" title="散列算法 - 斐波那契散列法"></a>散列算法 - 斐波那契散列法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 神秘数字 0x61c88647</span></span><br><span class="line"><span class="comment">// 黄金分割点：(√5 - 1) / 2 = 0.6180339887</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算哈希</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下标</span></span><br><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="withInitial"><a href="#withInitial" class="headerlink" title="withInitial"></a>withInitial</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SuppliedThreadLocal"><a href="#SuppliedThreadLocal" class="headerlink" title="SuppliedThreadLocal"></a>SuppliedThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line"></span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><h4 id="Entry-WeakReference弱引用"><a href="#Entry-WeakReference弱引用" class="headerlink" title="Entry - WeakReference弱引用"></a>Entry - WeakReference弱引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br></pre></td></tr></table></figure><h4 id="ThreadLocalMap类内部为什么用Entry数组，而不是Entry对象？"><a href="#ThreadLocalMap类内部为什么用Entry数组，而不是Entry对象？" class="headerlink" title="ThreadLocalMap类内部为什么用Entry数组，而不是Entry对象？"></a>ThreadLocalMap类内部为什么用Entry数组，而不是Entry对象？</h4><p>一个线程里，ThreadLocalMap是同一个，而不是多个，不管new几次ThreadLocal，ThreadLocalMap在一个线程里就一个。</p><p>ThreadLocalMap的引用是在Thread里的，所以它里面的Entry数组存放的是一个线程里new出来的多个ThreadLocal对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 判断是否扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>key.threadLocalHashCode &amp; (len-1);</code>，斐波那契散列，计算数组下标。</li><li><code>Entry</code>，是一个弱引用对象的实现类，<code>static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，所以在没有外部强引用下，会发生GC，删除key。</li><li>for循环判断元素是否存在，当前下标不存在元素时，直接设置元素 <code>tab[i] = new Entry(key, value);</code>。</li><li>如果元素存在，则会判断是否key值相等 <code>if (k == key)</code>，相等则更新值。</li><li>如果不相等，就到了 <code>replaceStaleEntry</code>，探测式清理过期元素。</li></ol><h4 id="元素清理"><a href="#元素清理" class="headerlink" title="元素清理"></a>元素清理</h4><h5 id="探测式清理-expungeStaleEntry"><a href="#探测式清理-expungeStaleEntry" class="headerlink" title="探测式清理 expungeStaleEntry"></a>探测式清理 expungeStaleEntry</h5><p>探测式清理，是以当前遇到的 GC 元素开始，向后不断的清理。直到遇到 null 为止，才停止 rehash 计算。</p><p><code>Rehash until we encounter null</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启发式清理-cleanSomeSlots"><a href="#启发式清理-cleanSomeSlots" class="headerlink" title="启发式清理 cleanSomeSlots"></a>启发式清理 cleanSomeSlots</h5><p>试探的扫描一些单元格，寻找过期元素，也就是被垃圾回收的元素。<br>当添加新元素或删除另一个过时元素时，将调用此函数。<br>它执行对数扫描次数，作为不扫描（快速但保留垃圾）和与元素数量成比例的扫描次数之间的平衡，这将找到所有垃圾，但会导致一些插入花费O（n）时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while 循环中不断的右移进行寻找需要被清理的过期元素，最终都会使用 <code>expungeStaleEntry</code> 进行处理，这里还包括元素的移位。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/2022/11/18/Elasticsearch/"/>
      <url>/2022/11/18/Elasticsearch/</url>
      
        <content type="html"><![CDATA[<p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎。</p><p>Kibana 是为 Elasticsearch设计的开源分析和可视化平台。</p><p>ES中的数据都是来自于MySQL , 用ES的目的不是来持久化数据的，而是因为它的数据检索、复杂数据分析的效率极高，用它来完成检索、分析的功能。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>服务端提供了 rest风格 api提供访问，简单来说，可以通过http请求访问 es</p><h3 id="Index-索引"><a href="#Index-索引" class="headerlink" title="Index(索引)"></a>Index(索引)</h3><h3 id="type-类型-table"><a href="#type-类型-table" class="headerlink" title="type(类型) == table"></a>type(类型) == table</h3><h3 id="document-一条数据（json格式的）"><a href="#document-一条数据（json格式的）" class="headerlink" title="document : == 一条数据（json格式的）"></a>document : == 一条数据（json格式的）</h3><ol><li>document的 key == mysql一条记录的 列（字段）</li><li>document的 value == mysql每个字段的值<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;:, 代表操作的哪个 index(库)</span><br><span class="line">    </span><br><span class="line">    &quot;_type&quot;:, 代表操作的哪个 type(表)</span><br><span class="line">    </span><br><span class="line">    &quot;_id&quot;:    , 每条记录 都有一个 唯一标识，当无法判断是更新，还是insert操作的时候，看展示的_id,有没有变化，</span><br><span class="line">                有就是insert了一条新记录，没有就是 更新操作</span><br><span class="line">                还有可能是 没有执行更新/insert操作</span><br><span class="line"></span><br><span class="line">    &quot;_version&quot;:    , 代表这条记录的版本号（根据版本号，可以得知此记录是否被修改过，修改一次，版本号就会变化一次）</span><br><span class="line"></span><br><span class="line">    &quot;_source&quot;:    , json记录本体信息</span><br><span class="line"></span><br><span class="line">    &quot;_seq_no&quot;:    , 并发控制字段，每次更新+1，用来做乐观锁</span><br><span class="line">            应用：在 更新请求后加上 ?if_seq_no = 此时记录的 seq_no &amp; if_primary_term = 此时记录的 primary_term</span><br><span class="line">            这时如果，更新操作的时候，如果记录的 _seq_no != if_seq_no 的值，那么无法更新</span><br><span class="line">            这样当两个请求，同时操作这条记录的时候，一个请求已经更新了记录，那么 _seq_no + 1，下一个请求就无法 完成更新操作了</span><br><span class="line">    </span><br><span class="line">    &quot;_primary&quot;:    , 集群，主分片重新分配，如重启，就会变化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8、JDK11、JDK17</title>
      <link href="/2022/11/08/Java-JDK8%E3%80%81JDK11%E3%80%81JDK17/"/>
      <url>/2022/11/08/Java-JDK8%E3%80%81JDK11%E3%80%81JDK17/</url>
      
        <content type="html"><![CDATA[<p>之前项目开发一直使用<code>JDK8</code>，最近碰到IDEA插件在<code>IDEA 2022.2</code>以上版本报错的问题后，把自己的IDEA升级到2022.2，发现2022.2版本的IDEA默认JDK17。<br>把插件基础intellij环境升级到2022.2，必须要JDK17才能编译通过，同时Gradle要求7以上。</p><p>于是，想要对于JDK的不同版本进行一些了解。</p><p>LTS，是 Long Term Support，也就是官方保证会长期支持的版本。</p><h2 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h2><h3 id="1、Lambda表达式"><a href="#1、Lambda表达式" class="headerlink" title="1、Lambda表达式"></a>1、Lambda表达式</h3><h3 id="2、接口增强"><a href="#2、接口增强" class="headerlink" title="2、接口增强"></a>2、接口增强</h3><ul><li>在1.8之前，接口中只能有：静态常量，抽象方法</li><li>在1.8之后，接口中可以有：静态常量，抽象方法，默认方法，静态方法</li></ul><p>默认方法可以被继承和重写。<br>静态方法只能通过<code>接口.方法名</code>调用，不能被继承和重写。</p><h3 id="3、函数式接口"><a href="#3、函数式接口" class="headerlink" title="3、函数式接口"></a>3、函数式接口</h3><h4 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h4><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><h3 id="4、Stream流"><a href="#4、Stream流" class="headerlink" title="4、Stream流"></a>4、Stream流</h3><h3 id="5、Optional类"><a href="#5、Optional类" class="headerlink" title="5、Optional类"></a>5、Optional类</h3><p>Optional 类是一个可以为null的容器对象。<br>如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。</p><h4 id="Optional对象的创建方式"><a href="#Optional对象的创建方式" class="headerlink" title="Optional对象的创建方式"></a>Optional对象的创建方式</h4><ul><li>ofNullable：允许一个可能为空的对象</li><li>of：需要一个不为空的对象</li></ul><h4 id="Optional常用方法"><a href="#Optional常用方法" class="headerlink" title="Optional常用方法"></a>Optional常用方法</h4><ul><li>empty：可以创建一个空的Optional对象</li><li>get：直接获取Optional内部对象，但是不建议单独使用</li><li>isPresent：判断内部对象是否为空，返回一个布尔值</li><li>ifPresent：一样判断内部对象是否为空，如果不为空会执行lambda表达式</li><li>filter：通过一定条件过滤对象</li><li>flatMap：和map的区别为lambda入参的对象封装入了Optional</li><li>orElse：如果值为空，返回一个对象</li><li>orElseGet：如果值为空，执行一段lambda并返回一个对象</li><li>orElseThrow：如果值为空，抛出一个异常</li></ul><h3 id="6、新时间日期API"><a href="#6、新时间日期API" class="headerlink" title="6、新时间日期API"></a>6、新时间日期API</h3><p>JDK8中新增加了一套全新的日期时间API，这套API设计合理，并且是线程安全的。</p><p>API位于java.time包下：</p><ul><li>LocalDate：表示日期，包含年月日，格式为2020-01-11。</li><li>LocalTime：表示时间，包含时分秒，格式为11:07:03.580。</li><li>LocalDateTime：表示日期和时间组合，包含年月日，时分秒，格式为2020-01-11T11:07:03.580</li><li>DateTimeFormatter：日期时间格式化类</li><li>Instant：时间戳，表示一个特定的时间瞬间</li><li>Duration：用于计算两个时间（LocalTime，时分秒）的距离</li><li>Period：用于计算2个日期（LocalDate，年月日）的距离</li><li>ZoneDateTime：包含时区的时间</li></ul><h3 id="7、Base64-工具"><a href="#7、Base64-工具" class="headerlink" title="7、Base64 工具"></a>7、Base64 工具</h3><p>Java 8 内置了 Base64 编码的编码器和解码器</p><h3 id="8、JVM的PermGen方法区被移除，取代它的是Metaspace（JEP-122）元空间"><a href="#8、JVM的PermGen方法区被移除，取代它的是Metaspace（JEP-122）元空间" class="headerlink" title="8、JVM的PermGen方法区被移除，取代它的是Metaspace（JEP 122）元空间"></a>8、JVM的PermGen方法区被移除，取代它的是Metaspace（JEP 122）元空间</h3><h2 id="JDK11"><a href="#JDK11" class="headerlink" title="JDK11"></a>JDK11</h2><h3 id="1、JVM"><a href="#1、JVM" class="headerlink" title="1、JVM"></a>1、JVM</h3><p>开销和时延更低的GC、TLS1.3加持</p><h3 id="2、变量类型推断"><a href="#2、变量类型推断" class="headerlink" title="2、变量类型推断"></a>2、变量类型推断</h3><p>从 Java10 开始变量不需要写具体类型，变量类型直接使用 var 定义，编译器能根据右边的表达式自动推断类型。</p><h3 id="3、官方HTTP-Client"><a href="#3、官方HTTP-Client" class="headerlink" title="3、官方HTTP Client"></a>3、官方HTTP Client</h3><p>Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化。<br>Java 11 中的新 Http Client API，提供了对 HTTP/2 等业界前沿标准的支持，同时也向下兼容 HTTP/1.1，精简而又友好的 API 接口，与主流开源 API（如：Apache HttpClient、Jetty、OkHttp 等）类似甚至拥有更高的性能。</p><h3 id="4、接口允许有私有方法"><a href="#4、接口允许有私有方法" class="headerlink" title="4、接口允许有私有方法"></a>4、接口允许有私有方法</h3><h3 id="5、try语句"><a href="#5、try语句" class="headerlink" title="5、try语句"></a>5、try语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String path = <span class="string">&quot;/home/nathan/test.sh&quot;</span>;</span><br><span class="line">    <span class="comment">//Java7 引入的 try-with-resource 机制</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> InputStreamReader(System.in)) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java9 可以在 try 中使用已初始化的资源</span></span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">    <span class="keyword">var</span> writer = <span class="keyword">new</span> OutputStreamWriter(System.out);</span><br><span class="line">    <span class="keyword">try</span> (reader; writer) &#123;</span><br><span class="line">        <span class="comment">//reader是final的，不可再被赋值</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、I-O流新特性"><a href="#6、I-O流新特性" class="headerlink" title="6、I/O流新特性"></a>6、I/O流新特性</h3><p>类 <code>java.io.InputStream</code> 中增加了新的方法来读取和复制 InputStream 中包含的数据。</p><ul><li>readAllBytes：读取 InputStream 中的所有剩余字节。</li><li>readNBytes： 从 InputStream 中读取指定数量的字节到数组中。</li><li>transferTo：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中。</li></ul><h2 id="JDK17"><a href="#JDK17" class="headerlink" title="JDK17"></a>JDK17</h2><ul><li>SpringBoot 3.0最低版本要求的JDK 17</li><li>JetBrains：Intelij项目的源代码迁移到了Java 17</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2022/10/27/MyBatis/"/>
      <url>/2022/10/27/MyBatis/</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ol><li>加载驱动 Class.forName(“com.mysql.jdbc.Driver”)</li><li>获取链接 Connection conn = (Connection) DriverManager.getConnection(url, username, password)</li><li>执行PreparedStatement</li></ol><h2 id="MyBatis流程"><a href="#MyBatis流程" class="headerlink" title="MyBatis流程"></a>MyBatis流程</h2><h3 id="Mybatis核心流程四大对象"><a href="#Mybatis核心流程四大对象" class="headerlink" title="Mybatis核心流程四大对象"></a>Mybatis核心流程四大对象</h3><p>MyBatis完成一次数据库操作需要经过的步骤，如下：</p><ol><li>加载配置文件</li><li>获取SqlSessionFactoryBuiler对象</li><li>通过SqlSessionFactoryBuiler和配置文件流来获取SqlSessionFactory对象</li><li>利用SqlSessionFactory对象来打开一个SqlSession</li><li>通过SqlSession来获得对应的Mapper对象</li><li>通过Mapper对象调用对应接口来封装执行sql并解析返回数据</li></ol><table><thead><tr><th align="left">对象</th><th align="center">生命周期</th></tr></thead><tbody><tr><td align="left">SqlSessionFactoryBuiler</td><td align="center">方法局部（Method）使用完成即可被丢弃</td></tr><tr><td align="left">SqlSessionFactory</td><td align="center">应用级别（Application），全局存在，是一个单例对象</td></tr><tr><td align="left">SqlSession</td><td align="center">请求或方法（Request / Method）</td></tr><tr><td align="left">Mapper</td><td align="center">方法（Method）</td></tr></tbody></table><h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><h3 id="Mapper执行流程"><a href="#Mapper执行流程" class="headerlink" title="Mapper执行流程"></a>Mapper执行流程</h3><p>Mapper执行一次sql需要经过的步骤，如下：</p><ol><li>通过MybatisMapperRegistry获取JDK动态代理对象MybatisMapperProxy</li><li>通过MybatisMapperProxy执行代理方法</li><li>通过MappedStatement和入参创建Executor并实际执行数据库操作</li></ol><h3 id="Executor执行流程"><a href="#Executor执行流程" class="headerlink" title="Executor执行流程"></a>Executor执行流程</h3><p>Executor执行过程需要经过的步骤，如下：</p><ol><li>创建Executor，然后利用StatementHandler执行数据库操作</li><li>执行数据库操作前，利用ParameterHandler做参数处理</li><li>执行数据库操作后，利用ResultSetHandler处理数据库返回结果</li></ol><h3 id="Mybatis参数及结果映射流程"><a href="#Mybatis参数及结果映射流程" class="headerlink" title="Mybatis参数及结果映射流程"></a>Mybatis参数及结果映射流程</h3><ol><li>将参数和执行sql解析封装成MetaObject</li><li>执行sql前后通过TypeHandler对java与数据库参数进行映射</li></ol><h2 id="MyBatis-Spring"><a href="#MyBatis-Spring" class="headerlink" title="MyBatis-Spring"></a>MyBatis-Spring</h2><p>MyBatis-Spring 帮助将 MyBatis 代码无缝地整合到 Spring 中。<br>它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean中。</p><h3 id="SqlSeeion与事务的关系"><a href="#SqlSeeion与事务的关系" class="headerlink" title="SqlSeeion与事务的关系"></a>SqlSeeion与事务的关系</h3><ol><li>同一事务中 不管调用多少次 mapper里的方法 ，最终都是用得同一个 sqlSession，即 一个事务中使用的是同一个sqlSession。</li><li>如果没有开启事务，调用一次mapper里的方法将会新建一个 sqlSession 来执行方法。</li></ol><h2 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于<code>同一个SqlSession</code>而言。</p><h4 id="一级缓存的生命周期"><a href="#一级缓存的生命周期" class="headerlink" title="一级缓存的生命周期"></a>一级缓存的生命周期</h4><ol><li>MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。</li><li>如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。</li><li>如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。</li><li>SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用。<h4 id="怎么判断某两次查询是完全相同的查询"><a href="#怎么判断某两次查询是完全相同的查询" class="headerlink" title="怎么判断某两次查询是完全相同的查询"></a>怎么判断某两次查询是完全相同的查询</h4>Mybatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询。</li><li>传入的statementId。</li><li>查询时要求的结果集中的结果范围。</li><li>这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）。</li><li>传递给java.sql.Statement要设置的参数值。</li></ol><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>MyBatis的二级缓存是Application级别的缓存。<br>范围是按照每个namepace缓存来存贮和维护，同一个namespace放到一个缓存对象中。<br>当这个namaspace中执行了insert、update和delete语句的时候，整个namespace中的缓存全部清除掉。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">        <span class="string">//</span> <span class="string">默认不开启二级缓存</span></span><br><span class="line">        <span class="attr">cache-enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h2><h3 id="执行模式与执行器-Executor"><a href="#执行模式与执行器-Executor" class="headerlink" title="执行模式与执行器 Executor"></a>执行模式与执行器 Executor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExecutorType</span> </span>&#123;</span><br><span class="line">    SIMPLE,</span><br><span class="line">    REUSE,</span><br><span class="line">    BATCH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h4><h4 id="ReuseExecutor"><a href="#ReuseExecutor" class="headerlink" title="ReuseExecutor"></a>ReuseExecutor</h4><h4 id="BatchExecutor"><a href="#BatchExecutor" class="headerlink" title="BatchExecutor"></a>BatchExecutor</h4><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>批处理执行模式 <code>ExecutorType.BATCH</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认批处理长度 1000</span></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_BATCH_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.saveBatch(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.saveOrUpdateBatch(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.updateBatchById(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">        String sqlStatement = <span class="keyword">this</span>.getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            sqlSession.insert(sqlStatement, entity);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">        TableInfo tableInfo = TableInfoHelper.getTableInfo(<span class="keyword">this</span>.entityClass);</span><br><span class="line">        Assert.notNull(tableInfo, <span class="string">&quot;error: can not execute. because can not find cache of TableInfo for entity!&quot;</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        String keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">        Assert.notEmpty(keyProperty, <span class="string">&quot;error: can not execute. because can not find column for id from entity!&quot;</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.saveOrUpdateBatch(<span class="keyword">this</span>.entityClass, <span class="keyword">this</span>.mapperClass, <span class="keyword">this</span>.log, entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            Object idVal = ReflectionKit.getFieldValue(entity, keyProperty);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.checkValNull(idVal) || CollectionUtils.isEmpty(sqlSession.selectList(<span class="keyword">this</span>.getSqlStatement(SqlMethod.SELECT_BY_ID), entity));</span><br><span class="line">        &#125;, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            ParamMap&lt;T&gt; param = <span class="keyword">new</span> ParamMap();</span><br><span class="line">            param.put(<span class="string">&quot;et&quot;</span>, entity);</span><br><span class="line">            sqlSession.update(<span class="keyword">this</span>.getSqlStatement(SqlMethod.UPDATE_BY_ID), param);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">        String sqlStatement = <span class="keyword">this</span>.getSqlStatement(SqlMethod.UPDATE_BY_ID);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            ParamMap&lt;T&gt; param = <span class="keyword">new</span> ParamMap();</span><br><span class="line">            param.put(<span class="string">&quot;et&quot;</span>, entity);</span><br><span class="line">            sqlSession.update(sqlStatement, param);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Consumer&lt;SqlSession&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.executeBatch(<span class="keyword">this</span>.entityClass, <span class="keyword">this</span>.log, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Collection&lt;E&gt; list, <span class="keyword">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.executeBatch(<span class="keyword">this</span>.entityClass, <span class="keyword">this</span>.log, list, batchSize, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Collection&lt;E&gt; list, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.executeBatch(list, <span class="number">1000</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Consumer&lt;SqlSession&gt; consumer)</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactory(entityClass);</span><br><span class="line">        SqlSessionHolder sqlSessionHolder = (SqlSessionHolder)TransactionSynchronizationManager.getResource(sqlSessionFactory);</span><br><span class="line">        <span class="keyword">boolean</span> transaction = TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line">        SqlSession sqlSession;</span><br><span class="line">        <span class="keyword">if</span> (sqlSessionHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sqlSession = sqlSessionHolder.getSqlSession();</span><br><span class="line">            sqlSession.commit(!transaction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ExecutorType.BATCH</span></span><br><span class="line">        sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line">        <span class="keyword">if</span> (!transaction) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;SqlSession [&quot;</span> + sqlSession + <span class="string">&quot;] was not registered for synchronization because DataSource is not transactional&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> var7;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer.accept(sqlSession);</span><br><span class="line">            sqlSession.commit(!transaction);</span><br><span class="line">            var7 = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var13) &#123;</span><br><span class="line">            sqlSession.rollback();</span><br><span class="line">            Throwable unwrapped = ExceptionUtil.unwrapThrowable(var13);</span><br><span class="line">            <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                MyBatisExceptionTranslator myBatisExceptionTranslator = <span class="keyword">new</span> MyBatisExceptionTranslator(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> (DataAccessException)Objects.requireNonNull(myBatisExceptionTranslator.translateExceptionIfPossible((RuntimeException)unwrapped));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtils.mpe(unwrapped);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="keyword">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, (sqlSession) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Iterator var6 = list.iterator(); var6.hasNext(); ++i) &#123;</span><br><span class="line">                E element = var6.next();</span><br><span class="line">                consumer.accept(sqlSession, element);</span><br><span class="line">                <span class="keyword">if</span> (i % batchSize == <span class="number">0</span> || i == size) &#123;</span><br><span class="line">                    sqlSession.flushStatements();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-主题maupassant目录优化解决方案</title>
      <link href="/2022/09/29/hexo-%E4%B8%BB%E9%A2%98maupassant%E7%9B%AE%E5%BD%95%E4%BC%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/09/29/hexo-%E4%B8%BB%E9%A2%98maupassant%E7%9B%AE%E5%BD%95%E4%BC%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><ul><li>文章内容过多之后，查阅不方便</li><li><code>maupassant</code>主题默认的目录显示在正文</li></ul><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>以下方法来自于 <a href="https://wiki.hushhw.cn/posts/5dd904ed.html">https://wiki.hushhw.cn/posts/5dd904ed.html</a></p><h3 id="1、-config-yml"><a href="#1、-config-yml" class="headerlink" title="1、_config.yml"></a>1、_config.yml</h3><p>在主题配置文件_config.yml中添加侧栏toc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">widgets: </span><br><span class="line">  - toc</span><br><span class="line">  - info</span><br><span class="line">  - search</span><br><span class="line">  - category</span><br><span class="line">  - tag</span><br><span class="line">  - recent_posts</span><br><span class="line">  - recent_comments</span><br><span class="line">  - links</span><br></pre></td></tr></table></figure><h3 id="2、base-pug"><a href="#2、base-pug" class="headerlink" title="2、base.pug"></a>2、base.pug</h3><p><code>themes/maupassant/layout/base.pug</code><br>mac注意tab间隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#layout.pure-g</span><br><span class="line">  .pure-u-1.pure-u-md-3-4: .content_container</span><br><span class="line">    block content</span><br><span class="line">  if page.toc != true</span><br><span class="line">    .pure-u-1.pure-u-md-1-4: #sidebar</span><br><span class="line">      each item in theme.widgets</span><br><span class="line">        != partial(&#x27;_widget/&#x27; + item + &#x27;.pug&#x27;, null, &#123;cache: !config.relative_link&#125;)</span><br><span class="line">  else</span><br><span class="line">    //- if theme.toc_on_small_screens</span><br><span class="line">    if theme.widgets_on_small_screens</span><br><span class="line">      .pure-u-1.pure-u-md-1-4: #sidebar-toc</span><br><span class="line">        div(id=&quot;sidebar-stoc&quot; class=&quot;stoc-article&quot;)</span><br><span class="line">          strong(class=&quot;stoc-title&quot;)</span><br><span class="line">            i(class=&#x27;fa&#x27;)= &#x27; Contents &#x27;</span><br><span class="line">          div(id=&quot;stoc&quot; class=&#x27;toc-nav&#x27;)</span><br><span class="line">            != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br><span class="line">          script(type=&#x27;text/javascript&#x27;, src=url_for(theme.js) + &#x27;/toc.js&#x27; + &#x27;?v=&#x27; + theme.version)</span><br><span class="line">    else </span><br><span class="line">      .pure-u-1-4.hidden_mid_and_down: #sidebar-toc</span><br><span class="line">        div(id=&quot;sidebar-stoc&quot; class=&quot;stoc-article&quot;)</span><br><span class="line">          strong(class=&quot;stoc-title&quot;)</span><br><span class="line">            i(class=&#x27;fa&#x27;)= &#x27; Contents &#x27;</span><br><span class="line">          div(id=&quot;stoc&quot; class=&#x27;toc-nav&#x27;)</span><br><span class="line">            != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br><span class="line">          script(type=&#x27;text/javascript&#x27;, src=url_for(theme.js) + &#x27;/toc.js&#x27; + &#x27;?v=&#x27; + theme.version)</span><br><span class="line">  .pure-u-1.pure-u-md-3-4</span><br><span class="line">    != partial(&#x27;_partial/footer.pug&#x27;)</span><br></pre></td></tr></table></figure><h3 id="3、toc-js"><a href="#3、toc-js" class="headerlink" title="3、toc.js"></a>3、toc.js</h3><p><code>themes/maupassant/source/js/toc.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toc = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;sidebar-stoc&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> HEADER_OFFSET = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">var</span> toclink = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;toc-link&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> headerlink = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;headerlink&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (toc != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, scrollcatelogHandler);</span><br><span class="line"><span class="keyword">var</span> tocPosition = toc.offsetTop;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollcatelogHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event,</span><br><span class="line">     target = event.target || event.srcElement;</span><br><span class="line"> <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line"> <span class="keyword">if</span> (scrollTop &gt;  tocPosition -<span class="number">60</span>) &#123;</span><br><span class="line">     toc.classList.add(<span class="string">&quot;stoc-fixed&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     toc.classList.remove(<span class="string">&quot;stoc-fixed&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;toclink.length; i++)&#123;</span><br><span class="line"><span class="comment">//console.log(i);</span></span><br><span class="line"><span class="keyword">var</span> currentHeaderTop = headerlink[i].offsetTop - HEADER_OFFSET,</span><br><span class="line">nextHeaderTop = i+<span class="number">1</span> === toclink.length ? <span class="literal">Infinity</span> : headerlink[i+<span class="number">1</span>].offsetTop - HEADER_OFFSET;</span><br><span class="line"><span class="keyword">if</span>(currentHeaderTop &lt; scrollTop &amp;&amp; scrollTop &lt;= nextHeaderTop)&#123;</span><br><span class="line">toclink[i].classList.add(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">toclink[i].classList.remove(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、style-scss"><a href="#4、style-scss" class="headerlink" title="4、style.scss"></a>4、style.scss</h3><p><code>themes/maupassant/source/css/style.scss</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// toc start</span><br><span class="line"><span class="selector-id">#sidebar-toc</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-article</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">1em</span> <span class="number">0</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="built_in">rgba</span>(<span class="number">88</span>,<span class="number">88</span>,<span class="number">88</span>,<span class="number">0.1</span>) <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-title</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">150%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar-stoc</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: inherit;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.9em</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-fixed</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">81%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.toc-nav</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.7em</span> <span class="number">0.7em</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#stoc</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="selector-class">.active</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#0085a1</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#F5F5F5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.toc</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0.5em</span>;</span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">1.8em</span>;</span><br><span class="line">      <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">list-style-type</span>: none;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.toc-child</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// toc end</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-从ReentrantLock的实现看AQS的原理及应用</title>
      <link href="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/main.png"></p><p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。<br>AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。</p><h2 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1 ReentrantLock"></a>1 ReentrantLock</h2><h3 id="1-1-ReentrantLock特性概览"><a href="#1-1-ReentrantLock特性概览" class="headerlink" title="1.1 ReentrantLock特性概览"></a>1.1 ReentrantLock特性概览</h3><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E5%AF%B9%E6%AF%94.png" alt="ReentrantLock VS Synchronized"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **************************Synchronized的使用方式**************************</span></span><br><span class="line"><span class="comment">// 1.用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 2.用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="comment">// 3.用于方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 4.可重入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **************************ReentrantLock的使用方式**************************</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> throw Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1.初始化选择公平锁、非公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 2.可用于代码块</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span></span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.手动释放锁</span></span><br><span class="line">lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-ReentrantLock与AQS的关联"><a href="#1-2-ReentrantLock与AQS的关联" class="headerlink" title="1.2 ReentrantLock与AQS的关联"></a>1.2 ReentrantLock与AQS的关联</h3><p>ReentrantLock支持公平锁和非公平锁，并且ReentrantLock的底层就是由AQS来实现的。<br>那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 从这两者的加锁过程来理解一下它们与AQS之间的关系。</p><h4 id="非公平锁加锁"><a href="#非公平锁加锁" class="headerlink" title="非公平锁加锁"></a>非公平锁加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#NonfairSync</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码的含义为：</p><ol><li>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</li><li>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</li></ol><p>第二步获取锁失败后，后续的处理策略是怎么样的？</p><ul><li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：<ol><li>将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</li><li>存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</li></ol></li><li>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</li><li>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</li><li>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</li></ul><h4 id="公平锁加锁"><a href="#公平锁加锁" class="headerlink" title="公平锁加锁"></a>公平锁加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#FairSync</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  ...  </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p><p>对于上边提到的问题，其实在ReentrantLock源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。<br>下面对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。</p><h2 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2 AQS"></a>2 AQS</h2><p><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS.png"></p><ul><li>上图中有颜色的为Method，无颜色的为Attribution。</li><li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li><li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li></ul><p>下面从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B.png"></p><h3 id="2-1-原理概览"><a href="#2-1-原理概览" class="headerlink" title="2.1 原理概览"></a>2.1 原理概览</h3><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</p><p>这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。<br>主要原理图如下：<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-CLH%E9%98%9F%E5%88%97.png"></p><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><h4 id="2-1-1-AQS数据结构"><a href="#2-1-1-AQS数据结构" class="headerlink" title="2.1.1 AQS数据结构"></a>2.1.1 AQS数据结构</h4><p>AQS中最基本的数据结构——Node，Node即为上面<code>CLH变体队列</code>中的节点。<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-Node.png"></p><p>解释一下几个方法和属性值的含义：</p><table><thead><tr><th align="left">方法和属性值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">volatile int waitStatus</td><td align="left">当前节点在队列中的状态</td></tr><tr><td align="left">volatile Thread thread</td><td align="left">表示处于该节点的线程</td></tr><tr><td align="left">volatile Node prev</td><td align="left">前驱指针</td></tr><tr><td align="left">Node nextWaiter</td><td align="left">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td></tr><tr><td align="left">volatile Node next</td><td align="left">后继指针</td></tr><tr><td align="left">final Node predecessor()</td><td align="left">返回前驱节点，没有的话抛出npe</td></tr></tbody></table><p>线程两种锁的模式：</p><ul><li>SHARED    表示线程以共享的模式等待锁</li><li>EXCLUSIVE    表示线程正在以独占的方式等待锁</li></ul><p>waitStatus有下面几个枚举值：</p><ul><li>0 当一个Node被初始化的时候的默认值</li><li>CANCELLED 为1，表示线程获取锁的请求已经取消了</li><li>CONDITION 为-2，表示节点在等待队列中，节点线程等待唤醒</li><li>PROPAGATE 为-3，当前线程处在SHARED情况下，该字段才会使用</li><li>SIGNAL 为-1，表示线程已经准备好了，就等资源释放了</li></ul><h4 id="2-1-2-同步状态State"><a href="#2-1-2-同步状态State" class="headerlink" title="2.1.2 同步状态State"></a>2.1.2 同步状态State</h4><p>AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>下面提供了几个访问这个字段的方法：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected final int getState()</td><td align="left">获取State的值</td></tr><tr><td align="left">protected final void setState(int newState)</td><td align="left">设置State的值</td></tr><tr><td align="left">protected final boolean compareAndSetState(int expect, int update)</td><td align="left">使用CAS方式更新State</td></tr></tbody></table><p>这几个方法都是Final修饰的，说明子类中无法重写它们。<br>我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-%E7%8B%AC%E5%8D%A0&%E5%85%B1%E4%BA%AB.png"></p><p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p><h3 id="2-2-AQS重要方法与ReentrantLock的关联"><a href="#2-2-AQS重要方法与ReentrantLock的关联" class="headerlink" title="2.2 AQS重要方法与ReentrantLock的关联"></a>2.2 AQS重要方法与ReentrantLock的关联</h3><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。<br>自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。</p><p>自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected boolean isHeldExclusively()</td><td align="left">该线程是否正在独占资源。只有用到Condition才需要去实现它。</td></tr><tr><td align="left">protected boolean tryAcquire(int arg)</td><td align="left">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td></tr><tr><td align="left">protected boolean tryRelease(int arg)</td><td align="left">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td></tr><tr><td align="left">protected int tryAcquireShared(int arg)</td><td align="left">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td></tr><tr><td align="left">protected boolean tryReleaseShared(int arg)</td><td align="left">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td></tr></tbody></table><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。<br>AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。<br>ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p><p>以<code>非公平锁</code>为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png"></p><p>为了更好地理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81&%E8%A7%A3%E9%94%81.png"></p><p>加锁：</p><ul><li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li><li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</li><li>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li><li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li></ul><p>解锁：</p><ul><li>通过ReentrantLock的解锁方法Unlock进行解锁。</li><li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li><li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li><li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li></ul><p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-ReentrantLock-API%E5%B1%82.png"></p><h3 id="2-3-通过ReentrantLock理解AQS"><a href="#2-3-通过ReentrantLock理解AQS" class="headerlink" title="2.3 通过ReentrantLock理解AQS"></a>2.3 通过ReentrantLock理解AQS</h3><p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p><p>在非公平锁中，有一段这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下这个Acquire是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下tryAcquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。<br>如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。<br>下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p><h4 id="2-3-1-线程加入等待队列"><a href="#2-3-1-线程加入等待队列" class="headerlink" title="2.3.1 线程加入等待队列"></a>2.3.1 线程加入等待队列</h4><h5 id="2-3-1-1-加入队列的时机"><a href="#2-3-1-1-加入队列的时机" class="headerlink" title="2.3.1.1 加入队列的时机"></a>2.3.1.1 加入队列的时机</h5><p>当执行Acquire(1)时，会通过tryAcquire获取锁。<br>在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p><h5 id="2-3-1-2-如何加入队列"><a href="#2-3-1-2-如何加入队列" class="headerlink" title="2.3.1.2 如何加入队列"></a>2.3.1.2 如何加入队列</h5><p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列。<br>具体实现方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的流程如下：</p><ul><li><p>通过当前的线程和锁模式新建一个节点。</p></li><li><p>Pred指针指向尾节点Tail。</p></li><li><p>将New中Node的Prev指针指向Pred。</p></li><li><p>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。<br>  tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。<br>  同时，由于是双向链表，也需要将前一个节点指向尾节点。</p></li><li><p>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Node t = tail;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.prev = t;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next = node;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果没有被初始化，需要进行初始化一个头结点出来。<br>  但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。<br>  其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p></li></ul><h5 id="2-3-1-3-等待队列中线程出队列时机"><a href="#2-3-1-3-等待队列中线程出队列时机" class="headerlink" title="2.3.1.3 等待队列中线程出队列时机"></a>2.3.1.3 等待队列中线程出队列时机</h5><p>回到最初的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。<br>acquireQueued方法可以对排队中的线程进行“获锁”操作。</p><p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p><p>下面从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 标记是否成功拿到资源</span></span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 标记等待过程中是否中断过</span></span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 开始自旋，要么获取锁，要么中断</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span></span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"><span class="comment">// 获取锁成功，头指针移动到当前node</span></span><br><span class="line">setHead(node);</span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span></span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">head = node;</span><br><span class="line">node.thread = <span class="keyword">null</span>;</span><br><span class="line">node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 靠前驱节点判断当前线程是否应该被阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取头结点的节点状态</span></span><br><span class="line"><span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line"><span class="comment">// 说明头结点处于唤醒状态</span></span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line"><span class="comment">// 通过枚举值我们知道waitStatus&gt;0是取消状态</span></span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 循环向前查找取消节点，把取消节点从队列中剔除</span></span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">pred.next = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 设置前任节点等待状态为SIGNAL</span></span><br><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法的流程图如下：<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%87%BA%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95.png"><br>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。</p><p>为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起。<br>具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-%E6%B5%81%E7%A8%8B%E5%9B%BE-shouldParkAfterFailedAcquire.png"></p><p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p><ol><li>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</li><li>是在什么时间释放节点通知到被挂起的线程呢？</li></ol><h4 id="2-3-2-CANCELLED状态节点生成"><a href="#2-3-2-CANCELLED状态节点生成" class="headerlink" title="2.3.2 CANCELLED状态节点生成"></a>2.3.2 CANCELLED状态节点生成</h4><p>acquireQueued方法中的Finally代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">...</span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将无效节点过滤</span></span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 设置该节点不关联任何线程，也就是虚节点</span></span><br><span class="line">node.thread = <span class="keyword">null</span>;</span><br><span class="line">Node pred = node.prev;</span><br><span class="line">  <span class="comment">// 通过前驱节点，跳过取消状态的node</span></span><br><span class="line"><span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">  <span class="comment">// 获取过滤后的前驱节点的后继节点</span></span><br><span class="line">Node predNext = pred.next;</span><br><span class="line">  <span class="comment">// 把当前node的状态设置为CANCELLED</span></span><br><span class="line">node.waitStatus = Node.CANCELLED;</span><br><span class="line">  <span class="comment">// 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span></span><br><span class="line">  <span class="comment">// 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span></span><br><span class="line"><span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ws;</span><br><span class="line">    <span class="comment">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span></span><br><span class="line">    <span class="comment">// 如果1和2中有一个为true，再判断当前节点的线程是否为null</span></span><br><span class="line">    <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span></span><br><span class="line"><span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">Node next = node.next;</span><br><span class="line"><span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">compareAndSetNext(pred, predNext, next);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span></span><br><span class="line">unparkSuccessor(node);</span><br><span class="line">&#125;</span><br><span class="line">node.next = node; <span class="comment">// help GC</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的流程：</p><ul><li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li><li>根据当前节点的位置，考虑以下三种情况：<ol><li>当前节点是尾节点。</li><li>当前节点是Head的后继节点。</li><li>当前节点不是Head的后继节点，也不是尾节点。</li></ol></li></ul><p>根据上述第二条，我们来分析每一种情况的流程。<br>当前节点是尾节点。<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-CANCELLED-1.png"></p><p>当前节点是Head的后继节点。<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-CANCELLED-2.png"></p><p>当前节点不是Head的后继节点，也不是尾节点。<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS-CANCELLED-3.png"></p><p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p><blockquote><p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。<br>shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-3-3-如何解锁"><a href="#2-3-3-如何解锁" class="headerlink" title="2.3.3 如何解锁"></a>2.3.3 如何解锁</h4><p>剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。<br>由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质释放锁的地方，是通过框架来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">Node h = head;</span><br><span class="line"><span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法返回当前锁是不是没有被线程持有</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 减少可重入次数</span></span><br><span class="line"><span class="keyword">int</span> c = getState() - releases;</span><br><span class="line"><span class="comment">// 当前线程不是持有锁的线程，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"><span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">free = <span class="keyword">true</span>;</span><br><span class="line">setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">setState(c);</span><br><span class="line"><span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来解释下述源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"><span class="comment">// 获取头结点</span></span><br><span class="line">Node h = head;</span><br><span class="line"><span class="comment">// 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span></span><br><span class="line"><span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的判断条件为什么是<code>h != null &amp;&amp; h.waitStatus != 0</code>？</p><blockquote><p>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。<br>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。<br>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p></blockquote><p>再看一下unparkSuccessor方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取头结点waitStatus</span></span><br><span class="line"><span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">Node s = node.next;</span><br><span class="line"><span class="comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span></span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span></span><br><span class="line"><span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line"><span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">s = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把当前节点unpark</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。<br>之前的addWaiter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，<code>node.prev = pred; compareAndSetTail(pred, node)</code>这两个地方可以看作Tail入队的原子操作，但是此时<code>pred.next = node;</code>还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。<br>还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。<br>继续执行acquireQueued方法以后，中断如何处理？</p><h4 id="2-3-4-中断恢复后的执行流程"><a href="#2-3-4-中断恢复后的执行流程" class="headerlink" title="2.3.4 中断恢复后的执行流程"></a>2.3.4 中断恢复后的执行流程</h4><p>唤醒后，会执行<code>return Thread.interrupted();</code>，这个函数返回的是当前执行线程的中断状态，并清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">setHead(node);</span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果acquireQueued为True，就会执行selfInterrupt方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容。这里简单介绍一下：</p><ol><li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li><li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li></ol><p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，可以看下ThreadPoolExecutor源码。</p><h4 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h4><blockquote><p>Q：某个线程获取锁失败的后续流程是什么呢？<br>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？<br>A：是CLH变体的FIFO双端队列。</p><p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？<br>A：可以详细看下2.3.1.3小节。</p><p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？<br>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p><p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？<br>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p></blockquote><h3 id="3-AQS应用"><a href="#3-AQS应用" class="headerlink" title="3 AQS应用"></a>3 AQS应用</h3><h4 id="3-1-ReentrantLock的可重入应用"><a href="#3-1-ReentrantLock的可重入应用" class="headerlink" title="3.1 ReentrantLock的可重入应用"></a>3.1 ReentrantLock的可重入应用</h4><p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，很容易得知ReentrantLock实现可重入的方法。<br>在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p><h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires))&#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。<br>State是Volatile修饰的，用于保证一定的可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>接下来看State这个字段主要的过程：</p><ol><li>State初始化的时候为0，表示没有任何线程持有锁。</li><li>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</li><li>解锁也是对这个字段-1，一直到0，此线程对锁释放。</li></ol><h4 id="3-2-JUC中的应用场景"><a href="#3-2-JUC中的应用场景" class="headerlink" title="3.2 JUC中的应用场景"></a>3.2 JUC中的应用场景</h4><table><thead><tr><th align="left">同步工具</th><th align="left">同步工具与AQS的关联</th></tr></thead><tbody><tr><td align="left">ReentrantLock</td><td align="left">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td align="left">Semaphore</td><td align="left">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td align="left">CountDownLatch</td><td align="left">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td align="left">ReentrantReadWriteLock</td><td align="left">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td align="left">ThreadPoolExecutor</td><td align="left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table><h4 id="3-3-自定义同步工具"><a href="#3-3-自定义同步工具" class="headerlink" title="3.3 自定义同步工具"></a>3.3 自定义同步工具</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-asset-image</title>
      <link href="/2022/09/28/hexo-asset-image/"/>
      <url>/2022/09/28/hexo-asset-image/</url>
      
        <content type="html"><![CDATA[<ol><li>/node_modules/hexo-asset-image/index.js</li><li><code>post_asset_folder: true</code></li><li><code>![](/example.jpg)</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">      <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">  <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">     <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">  <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">      <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">      <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">         !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">        <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">        <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">        <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">        srcArray.shift();</span><br><span class="line">        src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-锁</title>
      <link href="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/"/>
      <url>/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/main.png"></p><h2 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。<br>在Java和数据库中都有此概念对应的实际应用。</p><p>对于同一个数据的并发操作，<code>悲观锁</code>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<br>Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p><code>乐观锁</code>认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。<br>如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。<br>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/%E4%B9%90%E8%A7%82%E9%94%81vs%E6%82%B2%E8%A7%82%E9%94%81.png"></p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><blockquote><p>如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。<br>资金相关的金融敏感信息，使用悲观锁策略。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized 同步关键字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock 加锁</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。<br>那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？</p><h3 id="CAS技术原理"><a href="#CAS技术原理" class="headerlink" title="CAS技术原理"></a>CAS技术原理</h3><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。<br>在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。<br>java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><h4 id="AtomicInteger的源码"><a href="#AtomicInteger的源码" class="headerlink" title="AtomicInteger的源码"></a>AtomicInteger的源码</h4><p>jdk11</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This class intended to be implemented using VarHandles, but there</span></span><br><span class="line"><span class="comment">     * are unresolved cyclic startup dependencies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><p>AtomicInteger的自增函数incrementAndGet() -&gt; unsafe.getAndAddInt()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicInteger的自增函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>根据OpenJDK 8的源码可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><h4 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h4><ol><li><code>ABA问题。</code>CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。<ul><li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li></ul></li><li><code>循环时间长开销大。</code>CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li><code>只能保证一个共享变量的原子操作。</code>对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。<ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul></li></ol><h2 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h2><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。<br>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/%E8%87%AA%E6%97%8B%E9%94%81vs%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81.png"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适应性"><a href="#适应性" class="headerlink" title="适应性"></a>适应性</h4><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock。</p><h2 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。</p><h3 id="为什么Synchronized能实现线程同步？"><a href="#为什么Synchronized能实现线程同步？" class="headerlink" title="为什么Synchronized能实现线程同步？"></a>为什么Synchronized能实现线程同步？</h3><p>在回答这个问题之前需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？<br>以<code>Hotspot虚拟机</code>为例，Hotspot的对象头主要包括两部分数据：<code>Mark Word（标记字段）</code>、<code>Klass Pointer（类型指针）</code>。</p><ul><li><code>Mark Word</code>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</li><li><code>Klass Point</code>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。<br>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><blockquote><p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p></blockquote><p>在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为<code>重量级锁</code>。<br>JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了<code>偏向锁</code>和<code>轻量级锁</code>。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><table><thead><tr><th align="left">锁状态</th><th align="center">Mark Word内容</th><th align="right">标志位</th></tr></thead><tbody><tr><td align="left">无锁</td><td align="center">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td align="right">01</td></tr><tr><td align="left">偏向锁</td><td align="center">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td align="right">01</td></tr><tr><td align="left">轻量级锁</td><td align="center">指向栈中锁记录的指针</td><td align="right">00</td></tr><tr><td align="left">重量级锁</td><td align="center">指向互斥量（重量级锁）的指针</td><td align="right">10</td></tr><tr><td align="left">可GC</td><td align="center">～</td><td align="right">11</td></tr></tbody></table><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。<br>如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p><p>CAS原理及应用即是无锁的实现。<br>无锁无法全面代替有锁，但无锁在某些场合下（读多写少）的性能是非常高的。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。<br>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。<br>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，关闭之后程序默认会进入轻量级锁状态。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>升级为重量级锁时，锁标志的状态值变为<code>10</code>，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><ul><li><code>偏向锁</code>通过对比Mark Word解决加锁问题，避免执行CAS操作。</li><li><code>轻量级锁</code>是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</li><li><code>重量级锁</code>是将除了拥有锁的线程以外的线程都阻塞。</li></ul><h2 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h2><p><code>公平锁</code>是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。<br>公平锁的优点是等待锁的线程不会饿死。<br>缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p><code>非公平锁</code>是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。<br>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。<br>缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>通过ReentrantLock的源码来看看公平锁和非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">     * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">     * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">     * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。<br>它有公平锁FairSync和非公平锁NonfairSync两个子类。<br>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p>公平锁与非公平锁的加锁方法的源码:<br><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%96%B9%E6%B3%95.png" alt="公平锁和非公平锁的加锁方法"></p><p>通过上图中的源代码对比，可以看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">            <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">            <span class="comment">// thread is first in queue.</span></span><br><span class="line">            Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            Node s;</span><br><span class="line">            <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。<br>Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><p>下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。<br>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><h3 id="为什么可重入锁就可以在嵌套调用时可以自动获得锁"><a href="#为什么可重入锁就可以在嵌套调用时可以自动获得锁" class="headerlink" title="为什么可重入锁就可以在嵌套调用时可以自动获得锁"></a>为什么可重入锁就可以在嵌套调用时可以自动获得锁</h3><p><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81vs%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png"></p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。<br>非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。<br>非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><h2 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h2><p>独享锁和共享锁同样是一种概念。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。<br>JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>ReentrantReadWriteLock的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6992448646407690164L</span>;</span><br><span class="line">    <span class="comment">/** Inner class providing readlock */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** Inner class providing writelock */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">/** Performs all synchronization mechanics */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">     * default (nonfair) ordering properties.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">     * the given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructor for use by subclasses.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> lock the outer lock object</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> NullPointerException if the lock is null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructor for use by subclasses.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> lock the outer lock object</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> NullPointerException if the lock is null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。<br>ReadLock和WriteLock是靠内部类Sync实现的锁。<br>Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。<br>读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><h3 id="读锁和写锁的具体加锁方式"><a href="#读锁和写锁的具体加锁方式" class="headerlink" title="读锁和写锁的具体加锁方式"></a>读锁和写锁的具体加锁方式</h3><p>AQS中的<code>waitStatus</code>字段（int类型，32位），该字段用来描述有多少线程获持有锁。<br>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数）。<br>在共享锁中state就是持有锁的数量。<br>但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。<br><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/waitStatus.png"></p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line"><span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"><span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock中公平锁和非公平锁添加的都是独享锁"><a href="#ReentrantLock中公平锁和非公平锁添加的都是独享锁" class="headerlink" title="ReentrantLock中公平锁和非公平锁添加的都是独享锁"></a>ReentrantLock中公平锁和非公平锁添加的都是独享锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。<br>所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-synchronized、volatile、final关键字</title>
      <link href="/2022/09/27/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2022/09/27/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized中文意思是同步，也称之为”同步锁“。<br>Synchronized关键字解决的是多个线程之间访问资源的同步性<br>synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。<br>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</p><p>synchronized的3种使用方式：</p><ul><li>类锁<br>  修饰静态方法：其作用的范围是整个静态方法，锁对象为Class对象<br>  修饰代码块：synchronized指定锁对象为Class对象</li><li>对象锁<br>  修饰实例方法：其作用的范围是整个方法，锁对象为this,当前实例对象<br>  修饰代码块：其作用的范围是大括号{}括起来的代码，自己指定锁对象</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="加锁和释放锁的原理：Monitor"><a href="#加锁和释放锁的原理：Monitor" class="headerlink" title="加锁和释放锁的原理：Monitor"></a>加锁和释放锁的原理：Monitor</h4><p>JVM 是通过进入、退出<code>对象监视器(Monitor)</code>来实现对方法、同步块的同步的，而对象监视器的本质依赖于底层操作系统的<code>互斥锁(Mutex Lock)</code>实现。</p><p>具体实现是在编译之后在同步方法调用前加入一个<code>monitor.enter</code>指令，在退出方法和异常处插入<code>monitor.exit</code>的指令。<br>对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程<code>monitor.exit</code>之后才能尝试继续获取锁。</p><h4 id="可重入原理：加锁次数计数器"><a href="#可重入原理：加锁次数计数器" class="headerlink" title="可重入原理：加锁次数计数器"></a>可重入原理：加锁次数计数器</h4><p>在同一锁程中，每个对象拥有一个monitor计数器，当线程获取该对象锁后，monitor计数器就会加一，释放锁后就会将monitor计数器减一，线程不需要再次获取同一把锁。</p><h4 id="保证可见性的原理：内存模型和happens-before规则"><a href="#保证可见性的原理：内存模型和happens-before规则" class="headerlink" title="保证可见性的原理：内存模型和happens-before规则"></a>保证可见性的原理：内存模型和happens-before规则</h4><p>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。</p><p>如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。</p><h3 id="JVM中锁的优化"><a href="#JVM中锁的优化" class="headerlink" title="JVM中锁的优化"></a>JVM中锁的优化</h3><p>简单来说在 JVM中 monitorenter 和 monitorexit 字节码依赖于底层的操作系统的 Mutex Lock 来实现的，但是由于使用 Mutex Lock 需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。<br>然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用 Mutex Lock 那么将严重的影响程序的性能。</p><p>在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。</p><h4 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁 偏向锁 轻量级锁 重量级锁"></a>无锁 偏向锁 轻量级锁 重量级锁</h4><h4 id="自旋与自适应自旋"><a href="#自旋与自适应自旋" class="headerlink" title="自旋与自适应自旋"></a>自旋与自适应自旋</h4><p>自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态，同时在JDK 1.6中引入了自适应自旋锁。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p><p>锁消除的主要判定依据来源于逃逸分析的数据支持。<br>意思就是：JVM会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p><p>​大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test04</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述的连续append()操作中就属于这类情况。StringBuffer的每个方法都是synchronized修饰的。<br>JVM会检测到这样一连串的操作都是对同一个对象加锁，那么JVM会将加锁同步的范围扩展(粗化)到整个一系列操作的外部，使整个一连串的append()操作只需要加锁一次就可以了。</p><h3 id="syncorinized与Lock"><a href="#syncorinized与Lock" class="headerlink" title="syncorinized与Lock"></a>syncorinized与Lock</h3><h4 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h4><ul><li>效率低<br>  锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程；<br>  相对而言，Lock可以中断和设置获取超时</li><li>不够灵活<br>  加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，<br>  相对而言，读写锁更加灵活</li><li>无法知道是否成功获得锁<br>  相对而言，Lock可以拿到状态，如果成功获取锁，….，如果获取失败，…..<h4 id="Lock解决相应的问题"><a href="#Lock解决相应的问题" class="headerlink" title="Lock解决相应的问题"></a>Lock解决相应的问题</h4></li><li>lock(): 加锁</li><li>unlock(): 解锁</li><li>tryLock(): 尝试获取锁，返回一个boolean值</li><li>tryLock(long,TimeUtil): 尝试获取锁，可以设置超时</li></ul><p>Synchronized加锁只与一个条件(是否获取锁)相关联，不灵活，后来Condition与Lock的结合解决了这个问题。</p><p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断，高并发的情况下会导致性能下降。<br>ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。<br>一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。</p><h3 id="syncorinized使用问题"><a href="#syncorinized使用问题" class="headerlink" title="syncorinized使用问题"></a>syncorinized使用问题</h3><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li><li>synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h4 id="volatile-的-happens-before-关系"><a href="#volatile-的-happens-before-关系" class="headerlink" title="volatile 的 happens-before 关系"></a>volatile 的 happens-before 关系</h4><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><h4 id="volatile-禁止重排序"><a href="#volatile-禁止重排序" class="headerlink" title="volatile 禁止重排序"></a>volatile 禁止重排序</h4><p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。<br>JMM 提供了内存屏障阻止这种重排序。<br>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。<br>JMM 会针对编译器制定 volatile 重排序规则表。</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。<br>  禁止上面的普通写和下面的 volatile 写重排序。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。<br>  防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。<br>  禁止下面所有的普通读操作和上面的 volatile 读重排序。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。<br>  禁止下面所有的普通写操作和上面的 volatile 读重排序。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码-ConcurrentHashMap</title>
      <link href="/2022/09/21/Java%E6%BA%90%E7%A0%81-ConcurrentHashMap/"/>
      <url>/2022/09/21/Java%E6%BA%90%E7%A0%81-ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="为什么会有ConcurrentHashMap"><a href="#为什么会有ConcurrentHashMap" class="headerlink" title="为什么会有ConcurrentHashMap"></a>为什么会有ConcurrentHashMap</h3><p>HashMap线程不安全，HashTable线程安全但效率低下。</p><h4 id="为什么HashMap线程不安全"><a href="#为什么HashMap线程不安全" class="headerlink" title="为什么HashMap线程不安全"></a>为什么HashMap线程不安全</h4><p>1.7中transfer()链表使用头插法，多线程情况下，会成环；<br>1.8中putVal()，多线程操作，值会出现覆盖情况。</p><h4 id="为什么HashTable效率低下"><a href="#为什么HashTable效率低下" class="headerlink" title="为什么HashTable效率低下"></a>为什么HashTable效率低下</h4><p>用synchronized锁住整个表来同步。<br>线程竞争激烈时，一个线程访问HashTable同步方法，其他线程访问会处于阻塞或轮询状态。</p><h3 id="ConcurrentHashMap加锁原理"><a href="#ConcurrentHashMap加锁原理" class="headerlink" title="ConcurrentHashMap加锁原理"></a>ConcurrentHashMap加锁原理</h3><h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><p>1.8只有1个table(Map.Entry数组)，同步机制为<code>CAS + synchronized</code>保证并发更新。<br>锁的粒度更细，减少了冲突，提高了并发度。</p><p>1.8放弃了Segment，直接用<code>Node数组+链表+红黑树</code>的数据结构来实现，并发控制使用<code>Synchronized + CAS</code>来实现更细粒度的锁保护，整个看起来就像是优化过且线程安全的HashMap。<br>这里的更细粒度的锁是指锁table的首个Node节点。<br>在添加数据putVal的时候，根据 key 的 hash 值 定位到 Node节点，如果Node节点为空的话，则会使用CAS去赋值；不为空并且发生hash冲突则进入锁代码块，用 synchronized 去锁住首节点，执行插入链表或红黑树或转红黑树操作。</p><blockquote><p>取消segments字段，采用table数组元素作为锁（使用synchronized锁住），从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。<br>可以说将segment和数组合二为一</p></blockquote><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><p>1.7是使用segements(16个segement)，每个segement都有一个table(Map.Entry数组)，相当于16个HashMap，同步机制为分段锁，每个segment继承ReentrantLock。<br>默认并发是16，一旦初始化，Segment 数组大小就固定，后面不能扩容。</p><p>ConcurrentHashMap 是由<code>Segment 数组结构 + HashEntry 数组结构 + 链表</code>组成。<br>Segment 是一种可重入锁 ReentrantLock（Segment 继承了ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色。<br>HashEntry 则用于存储键值对数据。</p><p>put操作时，先获取锁 <code>tryLock()</code>，根据 key 的 hash 值 定位到 Segment ，再根据 key 的 hash 值 找到具体的 HashEntry ，再进行插入或覆盖，最后释放锁。</p><p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是<code>HashEntry数组+链表</code>，这个和HashMap的数据存储结构一样。<br><img src="/2022/09/21/Java%E6%BA%90%E7%A0%81-ConcurrentHashMap/%E5%8A%A0%E9%94%81%E5%8E%9F%E7%90%86-1.7.png"></p><h3 id="什么时候链表转为红黑树？"><a href="#什么时候链表转为红黑树？" class="headerlink" title="什么时候链表转为红黑树？"></a>什么时候链表转为红黑树？</h3><p>和 HashMap 一模一样：</p><ul><li>链表长度超过 8</li><li>数组（桶）的长度超过 64</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>基于JDK1.8</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 散列表最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 散列表默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大数组长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 默认并发级别 jdk1.7 之前遗留的 1.8只用于初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表树化条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 取消树化条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 结点树化条件 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 线程迁移数据最小步长 控制线程迁移任务最小区间的一个值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//  扩容用  计算扩容生成一个标识戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 65535 标识并发扩容最大线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 扩容相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node 结点的hash 是-1 表示 当前结点是forwardingNode结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"><span class="comment">// 红黑树的代理结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"><span class="comment">// 临时保留的散列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="comment">// 0x7fffffff = 31个1  用于将一个负数变成一个正数 但是不是取绝对值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统CPu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// 散列表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容用的临时散列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// LongAdder 的baseCount </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">sizeCtl &lt;0 </span></span><br><span class="line"><span class="comment">1. -1 的时候 表示table正在初始化(有线程正在初始化 ， 当前线程应该自旋等待)</span></span><br><span class="line"><span class="comment">2. 其他情况 表示当前map正在进行扩容 高16位表示 扩容的标识戳 ， 低16位表示 扩容线程数量</span></span><br><span class="line"><span class="comment">sizeCtl = 0 </span></span><br><span class="line"><span class="comment">表示创建数组 使用默认容量 16</span></span><br><span class="line"><span class="comment">sizeCtl &gt;0</span></span><br><span class="line"><span class="comment">1. 如果table 未初始化 表示 初始化大小</span></span><br><span class="line"><span class="comment">2. 如果table 已经初始化 表示下次扩容的阈值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容过程中，记录当前进度，所有线程都需要从transferIndex中分配区间任务，去执行自己的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"><span class="comment">// 0 表示 无锁 1 表示加锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"> <span class="comment">// LongAdder 中的cells 数组 当baseCount发生竞争后 会创建cells 数组</span></span><br><span class="line"> <span class="comment">// 线程会通过计算hash值 取到自己的cell中</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.ConcurrentHashMap#get</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.ConcurrentHashMap#tabAt</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK-1-8-ConcurrentHashMap-读操作为什么不用加锁？"><a href="#JDK-1-8-ConcurrentHashMap-读操作为什么不用加锁？" class="headerlink" title="JDK 1.8 ConcurrentHashMap 读操作为什么不用加锁？"></a>JDK 1.8 ConcurrentHashMap 读操作为什么不用加锁？</h4><p>读的时候如果不是恰好读到写线程写入相同Hash值的位置(可以认为我们的操作一般是读多写少，这种几率也比较低)<br>ConcurrentHashMap 的 <code>get</code> 方法会调用 <code>tabAt</code> 方法，这是一个Unsafe类volatile的操作，保证每次获取到的值都是最新的。（强制将修改的值立即写入主存）</p><h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onlyIfAbsent --&gt; ture 表示如果遇到相同的key 进行不进行置换；false 表示置换</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无论key还是value,不允许空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//此处获取hash值的方法与HashTable类似，通过扰动函数 计算出hash 高16位也参与运算</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//  binCount 表示当前k-v封装成node后插入到指定桶位后，在桶位中所属链表的下标位置</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            f -&gt;头结点 </span></span><br><span class="line"><span class="comment">            n-&gt;代表table的长度 </span></span><br><span class="line"><span class="comment">            i-&gt;索引 </span></span><br><span class="line"><span class="comment">            fh-&gt;头结点hash</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//1. 如果节点数组为null，或者长度为0，初始化节点数组</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//2. 如果节点数组的某个节点为null，则put的时候就会采用无锁竞争来获取该节点的头把交椅</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//以cas方式进行替换，替换成功就中断循环，替换失败则进行下一次循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 表已经创建 &amp;&amp; 头结点不是空 </span></span><br><span class="line">        <span class="comment">// 判断头结点的hash 是不是等于-1  看是不是forwardingNode结点 如果是 说明哈希表正在处于扩容的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮助进行扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//4. 表已经创建 &amp;&amp; 头结点不是空 &amp;&amp; 不处于扩容中 &amp;&amp; 头结点不是key相同的结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//如果hash冲突的时候，即多线程操作时，大家都有一样的hash值</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//锁定节点数组的头节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; </span><br><span class="line">                <span class="comment">// 再次查询头结点是不是等于f </span></span><br><span class="line">            <span class="comment">// 防止你加锁的过程中 别人已经修改了头结点的值，导致操作出现问题</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//如果当前该节点为链表形态</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//1. 链表中存在相同的key，把新value替代老value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//2. 如果不存在相同的key，就添加到链表到末尾</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果当前为红黑树形态，进行红黑树到查找和替代(存在相同的key)，或者放入红黑树到新叶节点上(key不存在)</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果一个节点中的数量大于1（只有大于1的才会有binCount）</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果链表长度超过了8，链表转红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//进行转换成红黑树处理</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计节点个数，检查是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-8-中-ConcurrentHashMap-put操作为什么用synchronized？"><a href="#1-8-中-ConcurrentHashMap-put操作为什么用synchronized？" class="headerlink" title="1.8 中 ConcurrentHashMap put操作为什么用synchronized？"></a>1.8 中 ConcurrentHashMap put操作为什么用synchronized？</h4><p>有两个原因：</p><ol><li>减少内存开销<br> 假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</li><li>获得JVM的支持<br> 可重入锁毕竟是API这个级别的，后续的性能优化空间很小。<br> synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-线程池在业务中的实践</title>
      <link href="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。<br>通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。</p><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><h3 id="场景1：快速响应用户请求"><a href="#场景1：快速响应用户请求" class="headerlink" title="场景1：快速响应用户请求"></a>场景1：快速响应用户请求</h3><p><strong>描述：</strong>用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p><p><strong>分析：</strong>从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p><p><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/%E5%BF%AB%E9%80%9F%E5%93%8D%E5%BA%94%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82.png"></p><h3 id="场景2：快速处理批量任务"><a href="#场景2：快速处理批量任务" class="headerlink" title="场景2：快速处理批量任务"></a>场景2：快速处理批量任务</h3><p><strong>描述：</strong>离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p><p><strong>分析：</strong>这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p><p><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E6%89%B9%E9%87%8F%E4%BB%BB%E5%8A%A1.png"></p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><ol><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li><li>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</li></ol><h3 id="如何合理配置线程池的大小"><a href="#如何合理配置线程池的大小" class="headerlink" title="如何合理配置线程池的大小"></a>如何合理配置线程池的大小</h3><h4 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h4><h4 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h4><h2 id="实际问题及方案思考"><a href="#实际问题及方案思考" class="headerlink" title="实际问题及方案思考"></a>实际问题及方案思考</h2><p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>。<br>一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大。<br>IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。</p><p>关于线程池配置不合理引发的故障，举例：</p><h3 id="故障实例"><a href="#故障实例" class="headerlink" title="故障实例"></a>故障实例</h3><h4 id="线程数核心设置过小引发RejectExecutionException"><a href="#线程数核心设置过小引发RejectExecutionException" class="headerlink" title="线程数核心设置过小引发RejectExecutionException"></a>线程数核心设置过小引发RejectExecutionException</h4><p>某服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件。<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/Exception-case1.png" alt="线程数核心设置过小引发RejectExecutionException"></p><h4 id="线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低"><a href="#线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低" class="headerlink" title="线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低"></a>线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低</h4><p>某服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/Exception-case2.png" alt="线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低"></p><h3 id="动态化线程池"><a href="#动态化线程池" class="headerlink" title="动态化线程池"></a>动态化线程池</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-线程池ThreadPoolExecutor</title>
      <link href="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。<br>J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。<br>了解并合理使用线程池，是一个开发人员必修的基本功。</p><h2 id="线程池基础参数"><a href="#线程池基础参数" class="headerlink" title="线程池基础参数"></a>线程池基础参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>corePoolSize - 核心池大小。<br>  需要注意的是在初创建线程池时线程不会立即启动，直到有任务提交才开始启动线程并逐渐使线程数目达到corePoolSize。<br>  若想一开始就创建所有核心线程需调用<code>prestartAllCoreThreads</code>方法。</li><li>maximumPoolSize - 池中允许的最大线程数。<br>  需要注意的是<code>当核心线程满且阻塞队列也满时</code>才会判断当前线程数是否小于最大线程数，并决定是否创建新线程。</li><li>keepAliveTime - 当线程数大于核心时，多余的空闲线程最多存活时间</li><li>unit - keepAliveTime参数的时间单位。</li><li>workQueue - 当线程数目超过核心线程数时用于保存任务的队列。<br>  主要有3种类型的BlockingQueue可供选择：无界队列，有界队列和同步移交。<br>  从参数中可以看到，此队列仅保存实现Runnable接口的任务。<br>  别看这个参数位置很靠后，但是真的很重要，这些细节有必要仔细了解清楚。</li><li>threadFactory - 执行程序创建新线程时使用的工厂。</li><li>handler - 阻塞队列已满且线程数达到最大值时所采取的拒绝策略。<br>  java提供了4种拒绝策略的实现方式：中止、抛弃、抛弃最旧的、调用者运行。<br>  默认为AbortPolicy。</li></ul><h3 id="可选择的阻塞队列BlockingQueue详解"><a href="#可选择的阻塞队列BlockingQueue详解" class="headerlink" title="可选择的阻塞队列BlockingQueue详解"></a>可选择的阻塞队列BlockingQueue详解</h3><h4 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h4><p>队列大小无限制，常用的为<code>LinkedBlockingQueue</code>，如果不指定长度的话，默认长度为Integer.MAX_VALUE。</p><p>使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。<br>阅读代码发现，Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue 中，导致cpu和内存飙升服务器挂掉。</p><h4 id="有界队列"><a href="#有界队列" class="headerlink" title="有界队列"></a>有界队列</h4><p>常用的有两类。<br>一类是遵循FIFO原则的队列如ArrayBlockingQueue。<br>另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。 </p><p>使用有界队列时队列大小需和线程池大小互相配合，线程池较小、有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。</p><h4 id="同步移交队列"><a href="#同步移交队列" class="headerlink" title="同步移交队列"></a>同步移交队列</h4><p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。</p><p>SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。<br>只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p><h3 id="可选择的拒绝策略RejectedExecutionHandler详解"><a href="#可选择的拒绝策略RejectedExecutionHandler详解" class="headerlink" title="可选择的拒绝策略RejectedExecutionHandler详解"></a>可选择的拒绝策略RejectedExecutionHandler详解</h3><p>JDK主要提供了4种拒绝策略供选择。4种策略都做为静态内部类在ThreadPoolExcutor中进行实现。</p><h4 id="AbortPolicy中止策略"><a href="#AbortPolicy中止策略" class="headerlink" title="AbortPolicy中止策略"></a>AbortPolicy中止策略</h4><p>使用该策略时在饱和时会抛出RejectedExecutionException（继承自RuntimeException），调用者可捕获该异常</p><h4 id="DiscardPolicy抛弃策略"><a href="#DiscardPolicy抛弃策略" class="headerlink" title="DiscardPolicy抛弃策略"></a>DiscardPolicy抛弃策略</h4><p>不做任何处理直接抛弃任务</p><h4 id="DiscardOldestPolicy抛弃旧任务策略"><a href="#DiscardOldestPolicy抛弃旧任务策略" class="headerlink" title="DiscardOldestPolicy抛弃旧任务策略"></a>DiscardOldestPolicy抛弃旧任务策略</h4><p>先将阻塞队列中的头元素出队抛弃，再尝试提交任务。<br>如果此时阻塞队列使用PriorityBlockingQueue优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。</p><h4 id="CallerRunsPolicy调用者运行"><a href="#CallerRunsPolicy调用者运行" class="headerlink" title="CallerRunsPolicy调用者运行"></a>CallerRunsPolicy调用者运行</h4><p>既不抛弃任务也不抛出异常，直接运行任务的run方法，换言之将任务回退给调用者来直接运行。<br>使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。</p><h3 id="Java提供的四种常用线程池解析"><a href="#Java提供的四种常用线程池解析" class="headerlink" title="Java提供的四种常用线程池解析"></a>Java提供的四种常用线程池解析</h3><h4 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>核心线程数为零</li><li>最大线程数为无限</li><li>无任务时，线程存活的最大时间为60s</li><li>任务队列为同步移交队列，该队列没有缓冲区，即不会有任务会在该队列中排队，每当有任务要入队时，队列都会将任务移交给一个可用的线程</li></ol><h4 id="Executors-newFixedThreadPool-int"><a href="#Executors-newFixedThreadPool-int" class="headerlink" title="Executors.newFixedThreadPool(int)"></a>Executors.newFixedThreadPool(int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程数量固定，使用无限大的队列</p><h4 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor()"></a>Executors.newSingleThreadExecutor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Executors-newScheduledThreadPool"><a href="#Executors-newScheduledThreadPool" class="headerlink" title="Executors.newScheduledThreadPool"></a>Executors.newScheduledThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors#newScheduledThreadPool</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ScheduledThreadPoolExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Executors-newSingleThreadScheduledExecutor"><a href="#Executors-newSingleThreadScheduledExecutor" class="headerlink" title="Executors.newSingleThreadScheduledExecutor()"></a>Executors.newSingleThreadScheduledExecutor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors.newSingleThreadScheduledExecutor()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors#DelegatedScheduledExecutorService</span></span><br><span class="line"><span class="comment">// static class DelegatedScheduledExecutorService</span></span><br><span class="line"><span class="comment">//        extends DelegatedExecutorService</span></span><br><span class="line"><span class="comment">//        implements ScheduledExecutorService </span></span><br><span class="line">DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line">    <span class="keyword">super</span>(executor);</span><br><span class="line">    e = executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors#DelegatedExecutorService</span></span><br><span class="line"><span class="comment">// static class DelegatedExecutorService extends AbstractExecutorService</span></span><br><span class="line">DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ScheduledThreadPoolExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池使用规范"><a href="#线程池使用规范" class="headerlink" title="线程池使用规范"></a>线程池使用规范</h3><p>【强制】线程池不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code>的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </p><p>Executors返回的线程池对象的弊端如下：</p><ol><li>FixedThreadPool 和 SingleThreadPool : 允许的请求队列长度为 Integer.MAX_VALUE ，<code>可能会堆积大量的请求</code>，从而导致 OOM 。</li><li>CachedThreadPool 和 ScheduledThreadPool : 允许的创建线程数量为 Integer.MAX_VALUE ，<code>可能会创建大量的线程</code>，从而导致 OOM 。</li></ol><h2 id="关于线程池"><a href="#关于线程池" class="headerlink" title="关于线程池"></a>关于线程池</h2><h3 id="1-1-线程池是什么"><a href="#1-1-线程池是什么" class="headerlink" title="1.1 线程池是什么"></a>1.1 线程池是什么</h3><p>线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具。</p><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p><p>线程过多会带来额外的开销，其中包括创建/销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。</p><p>线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建/销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><p>使用线程池可以带来一系列的好处：</p><ul><li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>可拓展性</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><h3 id="1-2-线程池解决的问题是什么"><a href="#1-2-线程池解决的问题是什么" class="headerlink" title="1.2 线程池解决的问题是什么"></a>1.2 线程池解决的问题是什么</h3><p>线程池解决的核心问题是资源管理问题。</p><p>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li></ol><p>为解决资源分配这个问题，线程池采用了<code>池化（Pooling）</code>思想。池化，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p><p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。<br>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p><ul><li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li><li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li></ul><h2 id="线程池核心设计与实现"><a href="#线程池核心设计与实现" class="headerlink" title="线程池核心设计与实现"></a>线程池核心设计与实现</h2><p>在Java中的体现是<code>ThreadPoolExecutor</code>类。</p><h3 id="2-1-总体设计"><a href="#2-1-总体设计" class="headerlink" title="2.1 总体设计"></a>2.1 总体设计</h3><p>Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-UML.png" alt="ThreadPoolExecutor UML类图"></p><p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。</p><p>ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</p><p>AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</p><p>最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p><p>ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-process.png" alt="ThreadPoolExecutor运行流程"></p><p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。<br>线程池的运行主要分成两部分：任务管理、线程管理。<br>任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。<br>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p><p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p><ol><li>线程池如何维护自身状态。</li><li>线程池如何管理任务。</li><li>线程池如何管理线程。</li></ol><h3 id="2-2-线程池生命周期管理"><a href="#2-2-线程池生命周期管理" class="headerlink" title="2.2 线程池生命周期管理"></a>2.2 线程池生命周期管理</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。<br>线程池内部使用一个变量维护两个值：运行状态（runState）和线程数量（workerCount）。<br>在具体实现中，线程池将运行状态（runState）和线程数量（workerCount）两个关键参数的维护放在了一起，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。<br>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。<br>通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。<br>线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p><p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">//计算当前运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;  <span class="comment">//计算当前线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;   <span class="comment">//通过状态和线程数生成ctl</span></span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的运行状态有5种，分别为：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-runState.png" alt="ThreadPoolExecutor运行状态"></p><p>其生命周期转换如下入所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-lifecycle.png" alt="线程池生命周期"></p><h3 id="2-3-任务执行机制"><a href="#2-3-任务执行机制" class="headerlink" title="2.3 任务执行机制"></a>2.3 任务执行机制</h3><h4 id="2-3-1-任务调度-分配"><a href="#2-3-1-任务调度-分配" class="headerlink" title="2.3.1 任务调度/分配"></a>2.3.1 任务调度/分配</h4><p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p><p>所有任务的调度都是由<code>execute</code>方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。<br>其执行过程如下：</p><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; 线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize &amp;&amp; 线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize &amp;&amp; 线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是AbortPolicy直接抛异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6.png" alt="任务调度流程"></p><h4 id="2-3-2-任务缓冲"><a href="#2-3-2-任务缓冲" class="headerlink" title="2.3.2 任务缓冲"></a>2.3.2 任务缓冲</h4><p>任务缓冲模块是线程池能够管理任务的核心部分。<br>线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解藕，不让两者直接关联，才可以做后续的分配工作。<br>线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。<br>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-blockingQueue.png" alt="阻塞队列"></p><p>使用不同的队列可以实现不一样的任务存取策略。<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-bqType.png" alt="阻塞队列类型"></p><h4 id="2-3-3-任务申请"><a href="#2-3-3-任务申请" class="headerlink" title="2.3.3 任务申请"></a>2.3.3 任务申请</h4><p>由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。<br>第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p><p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-task.png"></p><p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-4-任务拒绝"><a href="#2-3-4-任务拒绝" class="headerlink" title="2.3.4 任务拒绝"></a>2.3.4 任务拒绝</h4><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p><p>拒绝策略是一个接口，其设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-reject.png"></p><h3 id="2-4-Worker线程管理"><a href="#2-4-Worker线程管理" class="headerlink" title="2.4 Worker线程管理"></a>2.4 Worker线程管理</h3><h4 id="2-4-1-Worker线程"><a href="#2-4-1-Worker线程" class="headerlink" title="2.4.1 Worker线程"></a>2.4.1 Worker线程</h4><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line">    Runnable firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。<br><code>thread</code>是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务。<br><code>firstTask</code>用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p><p>Worker执行任务的模型如下图所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-worker.png"></p><p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p><p>Worker是通过继承<code>AQS</code>，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p><ol><li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 </li><li>如果正在执行任务，则不应该中断线程。 </li><li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 </li><li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</li></ol><p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-%E5%9B%9E%E6%94%B6.png"></p><h4 id="2-4-2-Worker线程增加"><a href="#2-4-2-Worker线程增加" class="headerlink" title="2.4.2 Worker线程增加"></a>2.4.2 Worker线程增加</h4><p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。</p><p>addWorker方法有两个参数：firstTask、core。<br><code>firstTask</code>参数用于指定新增的线程执行的第一个任务，该参数可以为空；<br><code>core</code>参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize。</p><p>其执行流程如下图所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-addWorker.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = ctl.get();;) &#123;</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="keyword">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.getState() != Thread.State.NEW)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-Worker线程回收"><a href="#2-4-3-Worker线程回收" class="headerlink" title="2.4.3 Worker线程回收"></a>2.4.3 Worker线程回收</h4><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。<br>Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p><p>线程回收的工作是在<code>processWorkerExit</code>方法完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p><h4 id="2-4-4-Worker线程执行任务"><a href="#2-4-4-Worker线程执行任务" class="headerlink" title="2.4.4 Worker线程执行任务"></a>2.4.4 Worker线程执行任务</h4><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p><ol><li>while循环不断地通过getTask()方法获取任务。 </li><li>getTask()方法从阻塞队列中取任务。 </li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 </li><li>执行任务。 </li><li>如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</li></ol><p><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-runWorker.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                    afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly); <span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2022/08/31/SpringBoot/"/>
      <url>/2022/08/31/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot集成"><a href="#SpringBoot集成" class="headerlink" title="SpringBoot集成"></a>SpringBoot集成</h2><h3 id="SpringBoot集成Tomcat"><a href="#SpringBoot集成Tomcat" class="headerlink" title="SpringBoot集成Tomcat"></a>SpringBoot集成Tomcat</h3><p>Spring Boot 能支持的最大并发量主要看其对Tomcat的设置，可以在配置文件中对其进行更改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 最大工作线程数，默认200。</span><br><span class="line">server.tomcat.max-threads=200</span><br><span class="line"># 最大连接数默认是10000</span><br><span class="line">server.tomcat.max-connections=10000</span><br><span class="line"># 等待队列长度，默认100。</span><br><span class="line">server.tomcat.accept-count=100</span><br><span class="line"># 最小工作空闲线程数，默认10。tomcat启动时的初始化的线程数</span><br><span class="line">server.tomcat.min-spare-threads=100</span><br><span class="line">#请求头最大长度kb</span><br><span class="line">server.tomcat.max-http-header-size: 1048576</span><br><span class="line">#请请求体最大长度kb</span><br><span class="line">server.tomcat.#max-http-post-size: 2097152</span><br></pre></td></tr></table></figure><p>对应application.yml配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">uri-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">max-threads:</span> <span class="number">800</span> <span class="comment">#最大工作线程数量</span></span><br><span class="line">    <span class="attr">min-spare-threads:</span> <span class="number">20</span> <span class="comment">#最小工作线程数量</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">10000</span> <span class="comment">#一瞬间最大支持的并发的连接数</span></span><br><span class="line">    <span class="attr">accept-count:</span> <span class="number">200</span> <span class="comment">#等待队列长度</span></span><br></pre></td></tr></table></figure><ul><li>线程数的经验值为：1核2G内存，线程数经验值200；4核8G内存， 线程数经验值800。<br>（4核8G内存单进程调度线程数800-1000，超过这个并发数之后，将会花费巨大的时间在CPU调度上）</li><li>等待队列长度：队列做缓冲池用，但也不能无限长，消耗内存，出入队列也耗CPU。</li><li>maxThreads规定的是Tomcat线程池最多能起的线程数目，并不是实际running的CPU数量；实际上，maxThreads的大小比CPU核心数量要大得多。这是因为，处理请求的线程真正用于计算的时间可能很少，大多数时间可能在阻塞，如等待数据库返回数据、等待硬盘读写数据等。因此，在某一时刻，只有少数的线程真正的在使用物理CPU，大多数线程都在等待；因此线程数远大于物理核心数才是合理的。也就是说，Tomcat通过使用比CPU核心数量多得多的线程数，可以使CPU忙碌起来，大大提高CPU的利用率。</li><li>maxConnections则是Tomcat一瞬间最多能够处理的并发连接数。</li><li>maxConnections 和acceptCount的关系为:当连接数达到最大值maxConnections后,系统会继续接收连接,进行排队，但不会超过acceptCount的值。</li></ul><p>Tomcat最大连接数取决于maxConnections这个值加上acceptCount这个值，在连接数达到了maxConenctions之后，Tomcat仍会保持住连接，但是不处理，等待其它请求处理完毕之后才会处理这个请求。</p><h4 id="针对4C8G配置，可以参考建议值："><a href="#针对4C8G配置，可以参考建议值：" class="headerlink" title="针对4C8G配置，可以参考建议值："></a>针对4C8G配置，可以参考建议值：</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat:</span></span><br><span class="line"><span class="attr">accept-count:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">max-connections:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">max-threads:</span> <span class="number">800</span></span><br><span class="line"><span class="attr">min-spare-threads:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="SpringBoot集成Redis"><a href="#SpringBoot集成Redis" class="headerlink" title="SpringBoot集成Redis"></a>SpringBoot集成Redis</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>spring-boot-starter</li><li>spring-data-redis<br> spring对redis相关操作的人性化封装，使得redis的操作只需简单的调用接口即可。<br> redis的操作的实现过程则有lettuce或jedis驱动(客户端)实现，spring-data-redis只是在接口层对他们做了统一。</li><li>io.lettuce.lettuce-core<br> spring-boot-starter-data-redis选择的默认驱动<h4 id="Lettuce和Jedis的区别"><a href="#Lettuce和Jedis的区别" class="headerlink" title="Lettuce和Jedis的区别"></a>Lettuce和Jedis的区别</h4>从 Spring Boot 2.x 开始 Lettuce 已取代 Jedis 成为首选 Redis 的客户端。</li></ul><p>Lettuce 是一个可伸缩的线程安全的 Redis 客户端，支持同步、异步和响应式模式。<br>多个线程可以共享一个连接实例，而不必担心多线程并发问题。<br>它基于优秀 Netty NIO 框架构建，支持 Redis 的高级功能，如 Sentinel，集群，流水线，自动重新连接和 Redis 数据模型</p><p>Jedis在实现上是直接连接的redis server，如果在多线程环境下是非线程安全的。</p><h4 id="修改RedisTemplate的序列化器"><a href="#修改RedisTemplate的序列化器" class="headerlink" title="修改RedisTemplate的序列化器"></a>修改RedisTemplate的序列化器</h4><p>RedisTemplate间接实现了InitializingBean，故在Bean的生命周期内会被回调其afterPropertiesSet方法，此方法用来初始化key和value的序列化器，默认是JDK序列化器，但该序列化器需要数据对象实现Serializable接口，最后显示声明序列化ID，容易出错。<br>可以修改利用json的序列化与反序列化能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot集成WebSocket"><a href="#SpringBoot集成WebSocket" class="headerlink" title="SpringBoot集成WebSocket"></a>SpringBoot集成WebSocket</h3><ol><li>添加 starter 依赖</li><li>添加 WebSocket 配置：<ul><li>实现接口<code>WebSocketConfigurer</code>，并重写相应方法</li></ul></li><li>添加处理器，作用类似 SpringMVC 的处理器映射：<ul><li>实现接口 <code>WebSocketHandler</code>，并重写相应方法</li></ul></li><li>添加拦截器（可选），可在 websocket 握手阶段做一些处理，例如校验、保存用户信息。<ul><li>实现接口：<code>HandshakeInterceptor</code>，并重写相应方法</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="/2022/08/31/Tomcat/"/>
      <url>/2022/08/31/Tomcat/</url>
      
        <content type="html"><![CDATA[<h2 id="Web容器基础认知"><a href="#Web容器基础认知" class="headerlink" title="Web容器基础认知"></a>Web容器基础认知</h2><h3 id="如何实现服务器和浏览器的交互"><a href="#如何实现服务器和浏览器的交互" class="headerlink" title="如何实现服务器和浏览器的交互"></a>如何实现服务器和浏览器的交互</h3><p>客户端和服务器端之间的交互式通过Socket来实现的，它属于应用层的协议。</p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>Socket是网络连接的一个端点。套接字使得一个应用可以从网络中读取和写入数据。<br>放在两个不同计算机上的两个应用可以通过<strong>连接</strong>发送和接受字节流。为了从你的应用发送一条信息到另一个应用，你需要知道另一个应用的 IP 地址和套接字端口。<br>在 Java 里边，套接字指的是<strong>java.net.Socket</strong>类。</p><h4 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h4><p>Socket 类代表一个客户端套接字，即任何时候你想连接到一个远程服务器应用的时候你构造的套接字。<br>现在，假如你想实施一个服务器应用，例如一个 HTTP 服务器或者 FTP 服务器，你需要一种不同的做法。这是因为你的服务器必须随时待命，因为它不知道一个客户端应用什么时候会尝试去连接它。<br>为了让你的应用能随时待命，你需要使用<strong>java.net.ServerSocket</strong>类。这是<strong>服务器套接字</strong>的实现。</p><p>ServerSocket 和 Socket 不同，服务器套接字的角色是等待来自客户端的连接请求。<strong>一旦服务器套接字获得一个连接请求，它创建一个 Socket 实例来与客户端进行通信。</strong></p><h3 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h3><blockquote><p>所谓Servlet，其实就是Sun为了让Java能实现动态可交互的网页，从而进入Web编程领域而制定的一套标准！</p></blockquote><p>一个Servlet主要做下面三件事情：</p><ol><li>创建并填充Request对象，包括：URI、参数、method、请求头信息、请求体信息等</li><li>创建Response对象</li><li>执行业务逻辑，将结果通过Response的输出流输出到客户端</li></ol><p>Servlet没有main方法，所以，如果要执行，则需要在一个容器里面才能执行，这个容器就是为了支持Servlet的功能而存在。<br>Tomcat其实就是一个Servlet容器的实现。</p><h2 id="Tomcat和Spring、Spring-MVC的关系"><a href="#Tomcat和Spring、Spring-MVC的关系" class="headerlink" title="Tomcat和Spring、Spring MVC的关系"></a>Tomcat和Spring、Spring MVC的关系</h2><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p><img src="/2022/08/31/Tomcat/springmvc-%E7%BB%84%E6%88%90.png"></p><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。<br>DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Tomcat是HTTP服务器和Servlet容器，负责给类似Spring这种servlet提供一个运行的环境。<ul><li>Http服务器，可以把HTTP服务器想象成前台的接待，负责网络通信和解析请求；</li><li>Servlet容器是业务部门，负责处理业务请求。</li></ul></li><li>Tomcat作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。<ul><li>Servlet是规范。</li><li>HttpServletRequest对象是Tomcat提供的，Tomcat是实现规范的Servlet容器。</li><li>SpringMVC是处理Servlet请求的应用，其中DispatcherServlet实现了Servlet接口，Tomcat负责加载和调用DispatcherServlet。</li><li>DispatcherServlet有自己的容器-Spring MVC容器（子容器），这个容器负责管理Spring MVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean，比如Service和DAO等，这些由全局的Spring IOC容器（父容器）管理。</li></ul></li><li>如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</li><li>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</li></ol><h2 id="Tomcat架构设计"><a href="#Tomcat架构设计" class="headerlink" title="Tomcat架构设计"></a>Tomcat架构设计</h2><blockquote><p>Tomcat的前身为Catalina，Catalina又是一个轻量级的Servlet容器<br>在美国，catalina是一个很美的小岛。所以Tomcat作者的寓意可能是想把Tomcat设计成一个优雅美丽且轻量级的web服务器。<br>Tomcat从4.x版本开始除了作为支持Servlet的容器外，额外加入了很多的功能，比如：jsp、el、naming等等，所以说Tomcat不仅仅是Catalina。</p></blockquote><p><img src="/2022/08/31/Tomcat/tomcat-%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg"></p><h3 id="从组件的角度看"><a href="#从组件的角度看" class="headerlink" title="从组件的角度看"></a>从组件的角度看</h3><p>Tomcat 要实现 2 个核心功能：</p><ul><li>处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。</li><li>加载和管理 Servlet，以及具体处理 Request 请求。</li></ul><p><strong>Connector 连接器</strong>和<strong>Container 容器</strong>可以说是 Tomcat 架构里最重要的两部分。</p><ul><li>Server<br>  表示服务器，它提供了一种优雅的方式来启动和停止整个系统，不必单独启停连接器和容器。<br>  它是Tomcat构成的顶级构成元素，所有一切均包含在Server中。</li><li>Service<br>  表示服务，Server可以运行多个服务。比如一个Tomcat里面可运行订单服务、支付服务、用户服务等等；<br>  Server的实现类StandardServer可以包含一个到多个Services, Service的实现类为StandardService调用了容器(Container)接口，其实是调用了Servlet Engine(引擎)，而且StandardService类中也指明了该Service归属的Server。</li><li><strong>Container</strong><br>  表示容器，可以看做Servlet容器。<br>  引擎(Engine)、主机(Host)、上下文(Context)和Wraper均继承自Container接口，所以它们都是容器。<ul><li>Engine – 引擎</li><li>Host – 主机</li><li>Context – 上下文</li><li>Wrapper – 包装器</li></ul></li><li><strong>Connector</strong><br>  表示连接器, <strong>它将Service和Container连接起来</strong>。<br>  注册在Service中，指定要监听的端口port。<br>  用于监听端口，接受来自客户端的请求，并将请求转交给Engine处理，同时将来自Engine的答复返回给客户端。</li><li>Service内部组件<br>  Manager – 管理器，用于管理会话Session<br>  Logger – 日志器，用于管理日志<br>  Loader – 加载器，和类加载有关，只会开放给Context所使用<br>  Pipeline – 管道组件，配合Valve实现过滤器功能<br>  Valve – 阀门组件，配合Pipeline实现过滤器功能<br>  Realm – 认证授权组件</li></ul><h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h4><p><img src="/2022/08/31/Tomcat/tomcat-webxml.jpeg"></p><h3 id="从一个完整请求的角度看"><a href="#从一个完整请求的角度看" class="headerlink" title="从一个完整请求的角度看"></a>从一个完整请求的角度看</h3><p>假设来自客户的请求为：<a href="http://localhost:8080/test/index.jsp">http://localhost:8080/test/index.jsp</a> </p><ul><li>请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得</li><li>Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应</li><li>Engine获得请求localhost:8080/test/index.jsp，匹配它所有虚拟主机Host</li><li>Engine匹配到名为localhost的Host(即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机)</li><li>localhost Host获得请求/test/index.jsp，匹配它所拥有的所有Context</li><li>Host匹配到路径为/test的Context(如果匹配不到就把该请求交给路径名为””的Context去处理)</li><li>path=”/test”的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet</li><li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类，构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法</li><li>Context把执行完了之后的HttpServletResponse对象返回给Host</li><li>Host把HttpServletResponse对象返回给Engine</li><li>Engine把HttpServletResponse对象返回给Connector</li><li>Connector把HttpServletResponse对象返回给客户browser</li></ul><p>简而言之，Connector 连接器接收连接请求，创建Request和Response对象用于和请求端交换数据，然后分配线程让Engine（也就是Servlet容器）来处理这个请求，并把产生的Request和Response对象传给Engine。当Engine处理完请求后，通过Connector将响应返回给客户端。</p><h4 id="Tomcat如何接收到一个http请求"><a href="#Tomcat如何接收到一个http请求" class="headerlink" title="Tomcat如何接收到一个http请求"></a>Tomcat如何接收到一个http请求</h4><p>Connector组件的Endpoint中的Acceptor监听客户端套接字连接并接收Socket。</p><h2 id="Tomcat的网络模型"><a href="#Tomcat的网络模型" class="headerlink" title="Tomcat的网络模型"></a>Tomcat的网络模型</h2><h2 id="Tomcat-类加载机制"><a href="#Tomcat-类加载机制" class="headerlink" title="Tomcat 类加载机制"></a>Tomcat 类加载机制</h2><h3 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h3><p><strong>为什么Tomcat的类加载器不是双亲委派模型</strong><br>Java默认的类加载机制是通过双亲委派模型来实现的，而Tomcat实现的方式又和双亲委派模型有所区别。</p><p>原因在于一个Tomcat容器允许同时运行多个Web程序，每个Web程序依赖的类又必须是相互隔离的。<br>因此，如果Tomcat使用双亲委派模式来加载类的话，将导致Web程序依赖的类变为共享的。</p><p>举个例子，假如我们有两个Web程序，一个依赖A库的1.0版本，另一个依赖A库的2.0版本，他们都使用了类xxx.xx.Clazz，其实现的逻辑因类库版本的不同而结构完全不同。那么这两个Web程序的其中一个必然因为加载的Clazz不是所使用的Clazz而出现问题！而这对于开发来说是非常致命的！</p><p><img src="/2022/08/31/Tomcat/tomcat-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9B%BE.png"></p><ul><li>Common类加载器，负责加载Tomcat和Web应用都复用的类 <ul><li>Catalina类加载器，负责加载Tomcat专用的类，而这些被加载的类在Web应用中将不可见</li><li>Shared类加载器，负责加载Tomcat下所有的Web应用程序都复用的类，而这些被加载的类在Tomcat中将不可见 <ul><li>WebApp类加载器，负责加载具体的某个Web应用程序所使用到的类，而这些被加载的类在Tomcat和其他的Web应用程序都将不可见</li><li>Jsp类加载器，每个jsp页面一个类加载器，不同的jsp页面有不同的类加载器，方便实现jsp页面的热插拔</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——Apache Pulsar</title>
      <link href="/2022/08/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Apache%20Pulsar/"/>
      <url>/2022/08/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Apache%20Pulsar/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-介绍</title>
      <link href="/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><ul><li>多线程的出现是要解决什么问题的?</li><li>线程不安全是指什么? 举例说明</li><li>并发出现线程不安全的本质什么? 可见性，原子性和有序性。</li><li>Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before</li><li>线程安全是不是非真即假? 不是</li><li>线程安全有哪些实现思路?</li><li>如何理解并发和并行的区别?</li></ul><h3 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h3><p>CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致<code>可见性</code>问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致<code>原子性</code>问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致<code>有序性</code>问题</li></ul><p>优点</p><ul><li>资源利用率更好</li><li>程序设计在某些情况下更简单</li><li>程序响应更快<br>缺点</li><li>设计更复杂</li><li>上下文切换的开销</li><li>增加资源消耗</li></ul><h3 id="线程不安全是指什么"><a href="#线程不安全是指什么" class="headerlink" title="线程不安全是指什么"></a>线程不安全是指什么</h3><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>例如，1000个线程同时对 一个int变量 执行自增操作，操作结束之后它的值有可能小于1000。</p><h3 id="并发出现问题的根源-并发三要素"><a href="#并发出现问题的根源-并发三要素" class="headerlink" title="并发出现问题的根源: 并发三要素"></a>并发出现问题的根源: 并发三要素</h3><p>上述示例输出为什么不是1000? 并发出现问题的根源是什么?</p><ul><li>可见性 CPU缓存引起</li><li>原子性 分时复用引起</li><li>有序性 重排序引起</li></ul><h3 id="JAVA是怎么解决并发问题的-JMM-Java内存模型"><a href="#JAVA是怎么解决并发问题的-JMM-Java内存模型" class="headerlink" title="JAVA是怎么解决并发问题的: JMM(Java内存模型)"></a>JAVA是怎么解决并发问题的: JMM(Java内存模型)</h3><h3 id="竞态条件与临界区"><a href="#竞态条件与临界区" class="headerlink" title="竞态条件与临界区"></a>竞态条件与临界区</h3><p>在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源，如，同一内存区（变量，数组，或对象）、系统（数据库，web service等）。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化，多个线程读取相同的资源就是安全的。</p><ul><li>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件</li><li>导致竞态条件发生的代码区称作临界区</li></ul><p>在临界区中使用适当的同步可以避免竞态条件。</p><h3 id="线程安全与共享资源"><a href="#线程安全与共享资源" class="headerlink" title="线程安全与共享资源"></a>线程安全与共享资源</h3><p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。</p><ul><li>局部变量</li><li>局部的对象引用</li><li>对象成员</li></ul><h4 id="线程控制逃逸规则"><a href="#线程控制逃逸规则" class="headerlink" title="线程控制逃逸规则"></a>线程控制逃逸规则</h4><p>如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</p><h3 id="线程安全及不可变性"><a href="#线程安全及不可变性" class="headerlink" title="线程安全及不可变性"></a>线程安全及不可变性</h3><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型，即Java内存模型。</p><p>Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p><p>原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中使用。</p><h4 id="Java内存模型和硬件内存架构之间的桥接"><a href="#Java内存模型和硬件内存架构之间的桥接" class="headerlink" title="Java内存模型和硬件内存架构之间的桥接"></a>Java内存模型和硬件内存架构之间的桥接</h4><p>所有的线程栈和堆都分布在主存中，部分线程栈和堆可能有时候会出现在CPU缓存和CPU内部的寄存器中。<br><img src="/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/java-memory-model-5.png"></p><p>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题，主要包括如下两个方面：</p><ul><li>线程对共享变量修改的可见性</li><li>当读/写和检查共享变量时出现<code>race condition 竞态条件</code></li></ul><h4 id="共享对象可见性"><a href="#共享对象可见性" class="headerlink" title="共享对象可见性"></a>共享对象可见性</h4><p>如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不可见的。</p><p>想象一下，共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。</p><p><img src="/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/java-memory-model-6.png"></p><p>解决这个问题你可以使用Java中的volatile关键字。volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。</p><h4 id="race-condition"><a href="#race-condition" class="headerlink" title="race condition"></a>race condition</h4><p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p><p>想象一下，如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次。</p><p>如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。</p><p>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。<br><img src="/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/java-memory-model-7.png"></p><p>解决这个问题可以使用Java同步块。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p><h3 id="Java同步块"><a href="#Java同步块" class="headerlink" title="Java同步块"></a>Java同步块</h3><p>Java 同步块（synchronized block）用来标记方法或者代码块是同步的。Java同步块用来避免竞争。</p><ul><li>Java同步关键字（synchronized）</li><li>实例方法同步</li><li>静态方法同步</li><li>实例方法中同步块</li><li>静态方法中同步块</li></ul><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h3 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h3><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h3 id="非阻塞算法-vs-阻塞算法"><a href="#非阻塞算法-vs-阻塞算法" class="headerlink" title="非阻塞算法 vs 阻塞算法"></a>非阻塞算法 vs 阻塞算法</h3><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><table><thead><tr><th align="left">状态</th><th align="center">释义</th></tr></thead><tbody><tr><td align="left">NEW</td><td align="center">一个创建了但还没有开始启动的线程</td></tr><tr><td align="left">RUNNABLE</td><td align="center">线程start后变为可执行状态，具体是否执行取决于系统cpu调度，ready/running</td></tr><tr><td align="left">BLOCKED</td><td align="center">阻塞，等待锁，比如等待进入synchronized代码块</td></tr><tr><td align="left">WAITING</td><td align="center">线程里调用了wait/join等方法后进入等待状态</td></tr><tr><td align="left">TIMED_WAITING</td><td align="center">超时等待，类似WAITING，但是有时间限制，时间到了，自动进入RUNNABLE状态</td></tr><tr><td align="left">TERMINATED</td><td align="center">结束</td></tr></tbody></table><p><img src="/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"></p><h4 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread.sleep()"></a>Thread.sleep()</h4><p>当前线程调用Thread.sleep(1000)陷入休眠，进入TIMED_WAITING状态，同时系统内核中会根据sleep中的参数设置一个定时器，定时器倒计时结束后，内核会重新唤醒线程，线程状态进入RUNNABLE状态；</p><h4 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield()"></a>Thread.yield()</h4><p>线程状态在RUNNABLE状态下，由系统cpu决定是否执行，所以该状态下，线程在内核中实际有“运行中”和“就绪”两种状态。</p><p>当前线程在“运行中”时，调用Thread.yield()，会立即让出cpu的使用权，让cpu执行优先级更高的或其它同优先级的线程，线程从RUNNABLE状态下的“运行中”变为“就绪”。</p><h4 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h4><p>内部其实就是wait方法，不同于wait的是，它会主动等使用了Object的锁对象的线程彻底执行结束后，自动从WAITING状态进入RUNNABLE状态。</p><h4 id="Object-wait"><a href="#Object-wait" class="headerlink" title="Object.wait()"></a>Object.wait()</h4><p>当前线程获取Object锁后，调用Object的wait方法，则会使当前线程进入WAITING或TIMED_WAITING状态，并释放Object的持有锁，当前线程会被放入等待队列中，直到超时或者被其他线程调用锁对象的notify方法唤醒。</p><h4 id="Object-notify-notifyAll"><a href="#Object-notify-notifyAll" class="headerlink" title="Object.notify()/notifyAll()"></a>Object.notify()/notifyAll()</h4><p>当前线程获取Object锁后，调用Object的notify/notifyAll方法，会使此前调用了该Object的wait线程从WAITING状态进入RUNNABLE状态。<br>notify只会唤醒一个线程，而notifyAll方法可以唤醒所有线程。</p><h3 id="线程使用方式"><a href="#线程使用方式" class="headerlink" title="线程使用方式"></a>线程使用方式</h3><ol><li>继承Thread类，重写run()方法，调用start()方法</li><li>实现Runnable接口并实现run()方法，在Thread类的构造函数中传入实现Runnable接口的类的实例对象</li><li>实现Callable接口并实现run()方法<br> 与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>线程池</li></ol><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><h4 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h4><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞block、限期等待time_waiting或者无限期等待waiting状态，那么就会抛出 InterruptedException，从而提前结束该线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$<span class="number">0</span>(InterruptExample.java:<span class="number">5</span>)</span><br><span class="line">    at InterruptExample$$Lambda$<span class="number">1</span>/<span class="number">713338599.</span>run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h4><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等能够抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。<br>但是调用 <code>interrupt()</code> 方法会设置线程的中断标记，此时调用 <code>interrupted()</code> 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized-VS-ReentrantLock"><a href="#synchronized-VS-ReentrantLock" class="headerlink" title="synchronized VS ReentrantLock"></a>synchronized VS ReentrantLock</h3><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ol><li>锁的实现<br> synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li><li>性能<br> 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</li><li>等待可中断<br> 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br> ReentrantLock 可中断，而 synchronized 不行。</li><li>公平锁<br> 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br> synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</li><li>锁绑定多个条件<br> 一个 ReentrantLock 可以同时绑定多个 Condition 对象。</li></ol><h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。<br>这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。<br>并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDE插件开发-VS Code</title>
      <link href="/2022/08/05/IDE%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-vscode/"/>
      <url>/2022/08/05/IDE%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-vscode/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDE插件开发-IntelliJ平台</title>
      <link href="/2022/08/05/IDE%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-IntelliJ%E5%B9%B3%E5%8F%B0/"/>
      <url>/2022/08/05/IDE%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-IntelliJ%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h2><h2 id="plugin-xml"><a href="#plugin-xml" class="headerlink" title="plugin.xml"></a>plugin.xml</h2><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><h2 id="applicationService"><a href="#applicationService" class="headerlink" title="applicationService"></a>applicationService</h2><h2 id="applicationConfigurable"><a href="#applicationConfigurable" class="headerlink" title="applicationConfigurable"></a>applicationConfigurable</h2><h2 id="toolWindow"><a href="#toolWindow" class="headerlink" title="toolWindow"></a>toolWindow</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码-Object</title>
      <link href="/2022/06/29/Java%E6%BA%90%E7%A0%81-Object/"/>
      <url>/2022/06/29/Java%E6%BA%90%E7%A0%81-Object/</url>
      
        <content type="html"><![CDATA[<p>Object类是一切类的超类，在类继承的树形结构上，Object是所有类的根节点。所有的对象，包括数据，都继承了Object类的方法。</p><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives"></a>registerNatives</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol><li>hashCode 表示对象在 hash 表中的位置，对于同一个对象来说，多次调用，返回相同的 hashCode。</li><li>如果 Object.equal () 相等，Object.hashCode () 也必然相等。重写时也建议保证此特性。</li><li>如果 Object.equal () 相等，这并不要求 Object.hashCode () 也返回不同值。如果真出现这种情况，最好优化代码，充分利用 hash 表的性能。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">intptr_t</span> <span class="title">get_next_hash</span><span class="params">(Thread * Self, oop obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> value = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">     <span class="comment">// so it&#x27;s possible for two threads to race and generate the same RNG.</span></span><br><span class="line">     <span class="comment">// On MP system we&#x27;ll have lots of RW access to a global, so the</span></span><br><span class="line">     <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">     value = os::<span class="built_in">random</span>() ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">     <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">     <span class="comment">// synchronization schemes.</span></span><br><span class="line">     <span class="keyword">intptr_t</span> addrBits = <span class="built_in">intptr_t</span>(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">     value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">     value = <span class="number">1</span> ;            <span class="comment">// for sensitivity testing</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">     value = ++GVars.hcSequence ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">     value = <span class="built_in">intptr_t</span>(obj) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Marsaglia&#x27;s xor-shift scheme with thread-specific state</span></span><br><span class="line">     <span class="comment">// This is probably the best overall implementation -- we&#x27;ll</span></span><br><span class="line">     <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">     <span class="keyword">unsigned</span> t = Self-&gt;_hashStateX ;</span><br><span class="line">     t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">     <span class="keyword">unsigned</span> v = Self-&gt;_hashStateW ;</span><br><span class="line">     v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">     Self-&gt;_hashStateW = v ;</span><br><span class="line">     value = v ;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  value &amp;= markOopDesc::hash_mask;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="number">0</span>) value = <span class="number">0xBAD</span> ;</span><br><span class="line">  <span class="built_in">assert</span> (value != markOopDesc::no_hash, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">TEVENT</span> (hashCode: GENERATE) ;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中的 hashCode 其实就是 JVM 启动的一个参数，每一个分支对应一个生成策略。通过 -XX:hashCode，可以任意切换 hashCode 的生成策略。</p><p>首先解释一下入参 oop obj 就是对象的逻辑地址。所以与地址相关的生成策略有两条，在 hashCode 等于 1 或 4 的时候。</p><ul><li>hashCode==1：这种方式具有幂等的性质，在 STW（stop-the-world）操作中，这种策略通常用于同步方案中。利用对象地址计算，使用不经常更新的随机数参与运算。</li><li>hashCode==4：与创建对象的内存位置有关，原样输出。</li></ul><p>其他情况：</p><ul><li>hashCode==0：简单地返回随机数，与对象的内存地址没有联系。然而根据随机数生成并全局地读写在多处理器下并不占优势。</li><li>hashCode==2：始终返回完全相同的标识，即 hashCode=1。这可用于测试依赖对象标识的代码。</li><li>hashcode==3：从零开始计算哈希代码值。它看起来不是线程安全的，因此多个线程可以生成具有相同哈希代码的对象。</li><li>hashCode&gt;=5（默认）：在 jdk1.8 中，这是默认的 hashCode 生成算法，支持多线程生成。使用了 Marsaglia 的 xor-shift 算法产生伪随机数。</li></ul><h4 id="xor-shift-算法"><a href="#xor-shift-算法" class="headerlink" title="xor-shift 算法"></a>xor-shift 算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint32_t xor128(void) &#123;</span><br><span class="line"> static uint32_t x = 123456789;</span><br><span class="line"> static uint32_t y = 362436069;</span><br><span class="line"> static uint32_t z = 521288629;</span><br><span class="line"> static uint32_t w = 88675123;</span><br><span class="line"> uint32_t t;</span><br><span class="line"> </span><br><span class="line"> t = x ^ (x &lt;&lt;11);</span><br><span class="line"> x = y; y = z; z = w;</span><br><span class="line"> return w = w ^ (w&gt;&gt; 19) ^ (t ^ (t&gt;&gt; 8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String重写hashCode"><a href="#String重写hashCode" class="headerlink" title="String重写hashCode"></a>String重写hashCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相同的字符串调用hashCode()方法，得到的值是一样的，与内存地址、进程、及其无关。</p><p>为什么计算时选择<code>31</code>？</p><ol><li>31 是个奇质数，不大不小，一般质数非常适合 hash 计算。<br> 偶数相当于移位运算，容易溢出，数据信息丢失。<br> 如果太小，则产生的哈希值区间小；太大则容易溢出，数据信息丢失。</li><li>31 * i == (i &lt;&lt; 5) - i。非常易于维护，将移位代替乘除，会有性能的提升，并且 JVM 执行时能够自动优化成这个样子。</li><li>通过实验计算，选用 31 后出现 hash 冲突的概率相比于其他数字要小。</li></ol><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当重写hashCode方法的时候，通常都需要重写该方法，以便维护hashCode方法的常规约定，该方法申明相等的对象必须具有相同的hashCode。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码-HashMap</title>
      <link href="/2022/06/28/Java%E6%BA%90%E7%A0%81-HashMap/"/>
      <url>/2022/06/28/Java%E6%BA%90%E7%A0%81-HashMap/</url>
      
        <content type="html"><![CDATA[<p>HashMap 1.7及以前，底层数据结构使用 [数组+链表]，1.8 后使用 [数组+链表/红黑树] ，使用数组存储元素是因为查找快，链表是为了解决哈希冲突存在的，而红黑树是为了解决链表中查询速度慢对链表进行优化的一种数据结构。</p><p>HashMap 是非线程安全的，如果需要线程安全，使用 ConcurrentHashMap 或者 Collections.synchronizedMap() 包裹 HashMap 达到线程安全的目的。</p><p><img src="/2022/06/28/Java%E6%BA%90%E7%A0%81-HashMap/java7hashmap.png"><br><img src="/2022/06/28/Java%E6%BA%90%E7%A0%81-HashMap/java8hashmap.png"></p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="1、HashMap为什么线程不安全"><a href="#1、HashMap为什么线程不安全" class="headerlink" title="1、HashMap为什么线程不安全"></a>1、HashMap为什么线程不安全</h3><h4 id="初始化懒加载"><a href="#初始化懒加载" class="headerlink" title="初始化懒加载"></a>初始化懒加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个HashMap的时候，其实只是定义了initialCapacity和loadFactor这两个值，</span></span><br><span class="line"><span class="comment">// 并没有初始化数组，而是懒加载的思想，在第一次put时候通过resize()方法去加载。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次个线程不安全的地方</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在jdk1-8中，在多线程环境下，在并发执行put操作时会发生数据覆盖的情况。"><a href="#在jdk1-8中，在多线程环境下，在并发执行put操作时会发生数据覆盖的情况。" class="headerlink" title="在jdk1.8中，在多线程环境下，在并发执行put操作时会发生数据覆盖的情况。"></a>在jdk1.8中，在多线程环境下，在并发执行put操作时会发生数据覆盖的情况。</h4><p>JDK1.7出现的问题，在JDK1.8中已经得到了很好的解决，JDK1.8直接在resize函数中完成了数据迁移。在进行元素插入时使用的是尾插法然后在扩容。</p><p>但是在1.8中仍会有数据覆盖这样的问题，先看put源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//判断是否出现hash碰撞,如果没有hash碰撞则直接插入元素，此处线程不安全</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//++size此处线程不安全</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中代码<code>if ((p = tab[i = (n - 1) &amp; hash]) == null) </code>是判断是否出现hash碰撞：<br>比如两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</p><p>还有一种情况就是代码<code>if (++size &gt; threshold)</code>中的++size：<br>同样还是线程A、B，这两个线程同时进行put操作时，假设当前HashMap的zise大小为10，当线程A执行到此行代码时，从主内存中获得size的值为10后准备进行+1操作，但是由于时间片耗尽只好让出CPU，线程B快乐的拿到CPU还是从主内存中拿到size的值10进行+1操作，完成了put操作并将size=11写回主内存，然后线程A再次拿到CPU并继续执行(此时size的值仍为10)，当执行完put操作后，还是将size=11写回内存，此时线程A、B都执行了一次put操作，但是size的值只增加了1，所有说还是由于数据覆盖又导致了线程不安全。</p><h4 id="在jdk1-7中，在多线程环境下，当并发执行扩容时会造成死循环-环形链-或数据丢失。"><a href="#在jdk1-7中，在多线程环境下，当并发执行扩容时会造成死循环-环形链-或数据丢失。" class="headerlink" title="在jdk1.7中，在多线程环境下，当并发执行扩容时会造成死循环(环形链)或数据丢失。"></a>在jdk1.7中，在多线程环境下，当并发执行扩容时会造成死循环(环形链)或数据丢失。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>JDK1.7中HashMap的transfer函数如上，扩容操作（先扩容再头插法插入）会重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。头插法会将链表的顺序翻转，这也是造成死循环和数据丢失的关键。</p><h3 id="2、HashMap为什么选用红黑树这种数据结构优化链表"><a href="#2、HashMap为什么选用红黑树这种数据结构优化链表" class="headerlink" title="2、HashMap为什么选用红黑树这种数据结构优化链表"></a>2、HashMap为什么选用红黑树这种数据结构优化链表</h3><p>在JDK1.8之后，Java对HashMap做了改进，在链表长度大于<code>8</code>的时候，将后面的数据存到<code>红黑树</code>中，以<code>加快检索速度</code>。</p><p>红黑树也是一种平衡二叉树，每个节点有一个储存位表示节点的颜色，可以是红色或者黑色。通过对任意一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有任意一条从根到叶子的路径超过最短路径的两倍，因此红黑树是一种弱平衡二叉树。</p><p>相对于AVL树来说，红黑树的旋转次数少，对于搜索、插入、删除多的操作下用红黑树。</p><h4 id="HashMap中链表转为红黑树的条件"><a href="#HashMap中链表转为红黑树的条件" class="headerlink" title="HashMap中链表转为红黑树的条件"></a>HashMap中链表转为红黑树的条件</h4><p>在JDK1.8之后，HashMap中的链表在满足以下两个条件时，将会转化为红黑树(即自平衡的排序二叉树)：</p><ol><li>条件一<br> 数组 arr[i] 处存放的链表长度大于8；</li><li>条件二<br> 数组长度大于等于64。</li></ol><p>满足以上两个条件，数组 arr[i] 处的链表将自动转化为红黑树，其他位置如 arr[i+1] 处的数组元素仍为链表，不受影响</p><h3 id="3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲-HashMap-扰动函数？"><a href="#3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲-HashMap-扰动函数？" class="headerlink" title="3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲 HashMap 扰动函数？"></a>3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲 HashMap 扰动函数？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 如果没有hash碰撞则直接插入元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n 为 2次幂，可以保证数据的均匀插入，降低哈希冲突的概率，毕竟冲突越大，代表数组中的链表/红黑树越大，从而降低Hashmap 的性能。</p><p>不管是规定 Hashmap 的 n 为 2次幂，还是扰动函数，都是为了一个目标，降低哈希冲突的概率，从而使 HashMap 性能得到优化。<br>规定 n 为 2次幂，是在新建 Hashmap对象初始化时，规定其容量大小的角度来优化。<br>扰动函数是插入 key 值时改变 key 的散列值，增大key的散列程度，降低哈希碰撞的概率来达到优化效果。</p><h3 id="4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）"><a href="#4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）" class="headerlink" title="4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）"></a>4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算索引下标，key的hashCode的高16位与低16位异或 对数组的长度取余</span></span><br><span class="line">   tab[i = (n -<span class="number">1</span>) &amp; hash]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>hash值是一个int类型，二进制位为32位，而HashMap的table数组初始化size为16，计算索引下标的取余操作为<code>hash &amp; (length - 1) ==&gt; hash &amp; 1111</code>，这里面的问题是，1111只会与hashCode的低4位进行与操作，hashCode的高位并没有参与运算，会导致很多hashCode值不同而高位有区别的数最后算出来的索引是一样的。</p><p>举个例子，假设hashCode为1111110001，那么<code>1111110001 &amp; 1111 = 0001</code>，高位发生变化时<code>1011110001 &amp; 1111 = 0001</code>，<code>1001110001 &amp; 1111 = 0001</code>，也就是说在高位发生变化时，你最后算出来的索引都一样了，这样就会导致很多数据都被放到一个数组里面了，造成性能退化。</p><p>为了避免这种情况，HashMap将 key 的<code>高16位与低16位进行异或</code>，这样可以保证高位的数据也参与到与运算中来，以增大索引的散列程度，让数据分布得更为均匀 (个人觉得很多博客说的减小哈希碰撞是错误的说法，因为hash碰撞指的是两个hashCode相同，这里显然不是)。</p><p>主要原因是保留高16位与低16位的特性，增大散列程度。</p><p>为什么用异或，不用<code>&amp;</code>或者<code>|</code>操作。因为异或可以保证两个数值的特性，<code>&amp;</code>运算使得结果向0靠近， <code>|</code>运算使得结果向1靠近。</p><h4 id="Object类中的hashCode方法"><a href="#Object类中的hashCode方法" class="headerlink" title="Object类中的hashCode方法"></a>Object类中的hashCode方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法不是抽象方法，带有native关键字，底层调用C++程序。</p><p>hashCode()方法返回的是哈希码：实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值。所以hashCode()方法的执行结果可以等同看做一个java对象的内存地址。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>基于jdk1.8</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16, 默认初始化容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//负载系数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;   <span class="comment">// 取消树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 最小树化数组容量，转换为红黑树的最小数组长度为64</span></span><br></pre></td></tr></table></figure><h3 id="影响HashMap性能的两个因素"><a href="#影响HashMap性能的两个因素" class="headerlink" title="影响HashMap性能的两个因素"></a>影响HashMap性能的两个因素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>初始容量。创建哈希表时的容量。</li><li>负载系数。衡量哈希表在自动增加容量之前的填充程度的容量，当哈希表中的数据数量超过 (负载因子 * 当前容量) 时，哈希表将被扩容、重建。</li></ol><p>loadFactor的默认值为<code>0.75f</code> 是官方给出的一个比较好的临界值，这个值是经过多次推测得出的</p><h3 id="防蠢货能力"><a href="#防蠢货能力" class="headerlink" title="防蠢货能力"></a>防蠢货能力</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">// 1. 节点数组为空</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">// 2. 节点为空</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">// 3. 节点不为空，发生冲突</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用HashMap的put方法，实际上调用了HashMap的putVal方法。<br>首先putVal()先用<code>hash(key)</code>函数计算键值对key的hash。hash(key)与数组长度做取余的位运算，得到这个键值对节点在数组中的具体下标。<br>进入putVal()方法，如果第一次插入元素，会调用resize()方法，初始化数组长度以及负载因子。<br>如果不是第一次插入，先看这个下标有没有元素，如果没有的话，直接放在这个下标。<br>如果这个下标已经有元素了，就会发生哈希冲突，遍历这个下标的链表，如果key值相等，就替换value；如果key值不相等，就继续向下遍历，如果遍历完成仍然key不相等，就用尾插法将元素插入到链表中，然后判断链表是否要转化成红黑树。<br>插入完成后，HashMap的size++，如果size大于阈值就进行数组的扩容操作。（先插入，再扩容）</p><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化或增加表的大小，如果表为空，根据初始容量分配。扩容表，2次幂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 获取旧元素数组的各种信息</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧数组长度 </span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧数组临界值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 定义新数组的长度及扩容的临界值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果原 table 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组长度达到最大值,修改临界值为最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容操作(2倍)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 新数组初始容量和阈值使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;  <span class="comment">// 16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 16 * 0.75 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 临界值还为0，设置临界值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新负载因子</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 红黑树调整</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表调整</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="treeifyBin方法"><a href="#treeifyBin方法" class="headerlink" title="treeifyBin方法"></a>treeifyBin方法</h3><ol><li>判断是否真的需要转换红黑树，如果数组长度小于<code>MIN_TREEIFY_CAPACITY = 64</code> 将会扩容resize()</li><li>如果符合转换的条件，<code>数组长度大于等于MIN_TREEIFY_CAPACIT(64) &amp;&amp; 链表长度大于TREEIFY_THRESHOLD(8)</code>。将该槽中所有的链表节点转换成树形节点，并且构造成双链表，为 treeify 转换成红黑树准备</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="comment">//如果table为null  或者table数组的长度小于MIN_TREEIFY_CAPACITY  64</span></span><br><span class="line">     <span class="comment">//MIN_TREEIFY_CAPACITY这个其实是转化成红黑树的另外一个条件，就是数组长度要大于64</span></span><br><span class="line">     <span class="comment">//如果小于64 就可以通过扩容的方法，来减小冲突，没有必要转换成红黑树，因为红黑树的转换也是需要很大是 时间和空间的代价</span></span><br><span class="line">     <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">     <span class="comment">//进行扩容</span></span><br><span class="line">         resize();</span><br><span class="line">      <span class="comment">//获得需要树形化的 链表的第一个节点 也就是数组对应的数组节点table[i]</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">         <span class="comment">//将普通的node节点 构造成TreeNode  拥有更多的属性</span></span><br><span class="line">             <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * parent</span></span><br><span class="line"><span class="comment">     * right</span></span><br><span class="line"><span class="comment">     * left</span></span><br><span class="line"><span class="comment">     * red</span></span><br><span class="line"><span class="comment">     * key</span></span><br><span class="line"><span class="comment">     * value</span></span><br><span class="line"><span class="comment">     * next</span></span><br><span class="line"><span class="comment">     * prev</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">             TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">             <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                 hd = p;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//构造成双链表形式</span></span><br><span class="line">                 p.prev = tl;</span><br><span class="line">                 tl.next = p;</span><br><span class="line">             &#125;</span><br><span class="line">             tl = p;</span><br><span class="line">         &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">         <span class="comment">//替换成 构造成双链表的节点</span></span><br><span class="line">         <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">         <span class="comment">//进行红黑树转换</span></span><br><span class="line">             hd.treeify(tab);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="treeify方法"><a href="#treeify方法" class="headerlink" title="treeify方法"></a>treeify方法</h3><p>该方法的主要作用就是，将链表的元素一个一个的插入到树中，并且保持排序树的特性：当左、右子树不为空的时候 左子树小于根节点 右子树大于根节点。<br>这里的大小通过comparable方法比较key的大小。如果key没有实现该接口，那么通过比较hash值来判定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将链表中每个值进行红黑树插入操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K, V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K, V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K, V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        <span class="comment">//根据链表进行遍历</span></span><br><span class="line">        next = (TreeNode&lt;K, V&gt;) x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果根节点还没设置则当前节点设置为根节点root</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//根节点一定是黑色的</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前循环节点的key和哈希值</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//每次都从根节点开始循环</span></span><br><span class="line">            TreeNode&lt;K, V&gt; p = root;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="comment">//遍历当前红黑树</span></span><br><span class="line">                <span class="keyword">int</span> dir;</span><br><span class="line">                <span class="comment">//获得p的hash值和key</span></span><br><span class="line">                <span class="keyword">int</span> ph = p.hash;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="comment">//比较hash值，然后根据比较值dir决定插入左边还是右边</span></span><br><span class="line">                <span class="keyword">if</span> (ph &gt; h) &#123;</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) &#123;</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//k不是不是课比较类或者比较结果为0，使用tieBreakOrder方法比较</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line">                TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">                p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right;</span><br><span class="line">                <span class="comment">//仅当当前要插入的位置上没有节点时才进行插入，否则继续向下遍历</span></span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置父节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//根据dir值设置为父节点的左右子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//插入成功后平衡红黑树</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="comment">//跳出当前循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保当前的root是直接落在table数组上的</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2022/05/10/Maven/"/>
      <url>/2022/05/10/Maven/</url>
      
        <content type="html"><![CDATA[<h3 id="MVN常用参数"><a href="#MVN常用参数" class="headerlink" title="MVN常用参数"></a>MVN常用参数</h3><ul><li>mvn -e 显示详细错误</li><li>mvn -U 强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖）</li><li>mvn -o 运行offline模式，不联网更新依赖</li><li>mvn -N 仅在当前项目模块执行命令，关闭reactor</li><li>mvn -pl module_name在指定模块上执行命令</li><li>mvn -ff 在递归执行命令过程中，一旦发生错误就直接退出</li><li>mvn -Dxxx=yyy 指定java全局属性</li><li>mvn -Pxxx 引用profile xxx</li><li>mvn -s setting.xml  -gs setting.xml -Dmaven.repo.local=$(pwd)/repos package -Dmaven.test.skip=true</li></ul><h3 id="Maven打包命令"><a href="#Maven打包命令" class="headerlink" title="Maven打包命令"></a>Maven打包命令</h3><h4 id="mvn-package"><a href="#mvn-package" class="headerlink" title="mvn package"></a>mvn package</h4><p>完成项目编译、单元测试、打包功能，打包到本项目，一般在项目target目录下。</p><p>打包文件未部署到本地Maven仓库和远程Maven仓库。</p><h4 id="mvn-install"><a href="#mvn-install" class="headerlink" title="mvn install"></a>mvn install</h4><p>完成项目编译、单元测试、打包功能，同时把打包文件部署到本地Maven仓库，但未部署到远程Maven仓库。</p><h4 id="mvn-deploy"><a href="#mvn-deploy" class="headerlink" title="mvn deploy"></a>mvn deploy</h4><p>完成项目编译、单元测试、打包功能，同时把打包文件部署到本地Maven仓库和远程Maven仓库。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nexus升级https过程</title>
      <link href="/2022/04/26/nexus%E5%8D%87%E7%BA%A7https%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/04/26/nexus%E5%8D%87%E7%BA%A7https%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>maven 3.8.1 版本之后，在 settings.xml 中通过配置 mirror 禁用了不安全的 http 链接，默认情况下必须使用 https 的仓库地址。</li></ul><p>10.200.17.45 测试机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8093:8081  -u root --name=nexus-lcf --privileged=true -v /data/nexus-https-lcf:/nexus-data -e INSTALL4J_ADD_VM_PARAMS=&quot;-Xms256m -Xmx512m -XX:MaxDirectMemorySize=1024m&quot; sonatype/nexus3:latest</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8443:8443 -p 8094:8081  -u root --name=nexus-lcf-https --privileged=true -v r/data/nexus-https-lcf:/nexus-data -e INSTALL4J_ADD_VM_PARAMS=&quot;-Xms256m -Xmx512m -XX:MaxDirectMemorySize=1024m&quot; nexus-https:latest</span><br></pre></td></tr></table></figure><ul><li>-d</li><li>-u root –privileged=true</li><li>-p 8093:8081</li><li>–name=nexus-lcf</li><li>-v /data/nexus-https-lcf:/nexus-data</li><li>-e INSTALL4J_ADD_VM_PARAMS=”-Xms256m -Xmx512m -XX:MaxDirectMemorySize=1024m”</li></ul><p>10.163.204.79</p><h2 id="Nexus部署"><a href="#Nexus部署" class="headerlink" title="Nexus部署"></a>Nexus部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/sonatype/nexus3    // 拉取最新nexus镜像</span><br><span class="line">docker stop 7d6824229a9a &amp;&amp; docker rm 7d6824229a9a   // 停掉旧容器</span><br></pre></td></tr></table></figure><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d        </span></span><br><span class="line"> -p <span class="number">80</span>:<span class="number">8081</span>        </span><br><span class="line"> --name=nexus         </span><br><span class="line">--restart=always         </span><br><span class="line">--ulimit nofile=<span class="number">655360</span>         </span><br><span class="line">--ulimit memlock=-<span class="number">1</span>         </span><br><span class="line">--memory=<span class="number">16</span>G         </span><br><span class="line">--memory-swap=-<span class="number">1</span>         </span><br><span class="line">--cpuset-cpus=<span class="string">&#x27;0-7&#x27;</span>         </span><br><span class="line">-eINSTALL4J_ADD_VM_PARAMS=<span class="string">&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;</span>         </span><br><span class="line">-v /etc/localtime:/etc/localtime         </span><br><span class="line">-v /data/nexus:/nexus-data         </span><br><span class="line">sonatype/nexus3:latest</span><br></pre></td></tr></table></figure><h2 id="升级https"><a href="#升级https" class="headerlink" title="升级https"></a>升级https</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv _.haier.net.* ~/</span><br><span class="line"></span><br><span class="line">// 这里需要输入密码  用password，如果不用这个，需要修改镜像里的$&#123;jetty.etc&#125;/jetty-https.xml，具体操作参考百度。</span><br><span class="line">openssl pkcs12 -export -out keystore.pkcs12 -inkey _.haier.net.key -in _.haier.net.crt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM sonatype/nexus3</span><br><span class="line">USER root</span><br><span class="line">COPY keystore.pkcs12 /keystore.pkcs12</span><br><span class="line">RUN keytool -v -importkeystore -srckeystore keystore.pkcs12 -srcstoretype PKCS12 -destkeystore keystore.jks -deststoretype JKS -storepass password -srcstorepass password  &amp;&amp;\</span><br><span class="line">    cp keystore.jks /opt/sonatype/nexus/etc/ssl/</span><br><span class="line">USER nexus</span><br></pre></td></tr></table></figure><p>基于此nexus镜像<code>docker.io/sonatype/nexus3 b7c023b6a9b9 655 MB</code></p><h3 id="在最新的nexus镜像的基础上构建，找不到keystore-pkcs12"><a href="#在最新的nexus镜像的基础上构建，找不到keystore-pkcs12" class="headerlink" title="在最新的nexus镜像的基础上构建，找不到keystore.pkcs12"></a>在最新的nexus镜像的基础上构建，找不到keystore.pkcs12</h3><p>8da03e408fae<br><img src="/2022/04/26/nexus%E5%8D%87%E7%BA%A7https%E8%BF%87%E7%A8%8B/nexus-keytool-error.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t nexus-https -f jdk_dockerfile</span><br><span class="line">docker build . -t nexus-https-2022 -f jdk_dockerfile</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d         -p 80:8081         --name=nexus         --restart=always         --ulimit nofile=655360         --ulimit memlock=-1         --memory=16G     --memory-swap=-1         --cpuset-cpus=&#x27;0-7&#x27;         -eINSTALL4J_ADD_VM_PARAMS=&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;         -v /etc/localtime:/etc/localtime         -v /data/nexus:/nexus-data         sonatype/nexus3:latest</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d         -p 80:8081     -p 443:8443    --name=nexus         --restart=always         --ulimit nofile=655360         --ulimit memlock=-1         --memory=16G         --memory-swap=-1         --cpuset-cpus=&#x27;0-7&#x27;         -eINSTALL4J_ADD_VM_PARAMS=&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;         -v /etc/localtime:/etc/localtime         -v /data/nexus:/nexus-data         nexus-https:latest</span><br><span class="line"></span><br><span class="line">docker run -d         -p 80:8081     -p 443:8443    --name=nexus         --restart=always         --ulimit nofile=655360         --ulimit memlock=-1         --memory=16G         --memory-swap=-1         --cpuset-cpus=&#x27;0-7&#x27;         -eINSTALL4J_ADD_VM_PARAMS=&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;         -v /etc/localtime:/etc/localtime         -v /data/nexus:/nexus-data         nexus-https-2022:latest</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Jetty section</span></span><br><span class="line"><span class="meta">application-port-ssl</span>=<span class="string">8443</span></span><br><span class="line"><span class="meta">application-port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">application-host</span>=<span class="string">0.0.0.0</span></span><br><span class="line"><span class="meta">nexus-args</span>=<span class="string">$&#123;jetty.etc&#125;/jetty.xml,$&#123;jetty.etc&#125;/jetty-http.xml,$&#123;jetty.etc&#125;/jetty-requestlog.xml,$&#123;jetty.etc&#125;/jetty-https.xml</span></span><br><span class="line"><span class="meta">nexus-context-path</span>=<span class="string">/$&#123;NEXUS_CONTEXT&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Nexus section</span></span><br><span class="line"><span class="meta">nexus-edition</span>=<span class="string">nexus-pro-edition</span></span><br><span class="line"><span class="meta">nexus-features</span>=<span class="string">\</span></span><br><span class="line"><span class="string"> nexus-pro-feature</span></span><br><span class="line"><span class="meta">nexus.clustered</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker run -d        </span><br><span class="line"> -p 80:8081        </span><br><span class="line"> -p 443:8443</span><br><span class="line"> --name=nexus         </span><br><span class="line">--restart=always         </span><br><span class="line">--ulimit nofile=655360         </span><br><span class="line">--ulimit memlock=-1         </span><br><span class="line">--memory=16G         </span><br><span class="line">--memory-swap=-1         </span><br><span class="line">--cpuset-cpus=&#x27;0-7&#x27;         </span><br><span class="line">-e INSTALL4J_ADD_VM_PARAMS=&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;         </span><br><span class="line">-v /etc/localtime:/etc/localtime         </span><br><span class="line">-v /data/nexus:/nexus-data         </span><br><span class="line">nexus-https:latest</span><br><span class="line"></span><br><span class="line">docker参数</span><br><span class="line">–name 指定docker容器的名称</span><br><span class="line">–net=host 使用host网络模式（和宿主机一个网络）</span><br><span class="line">–restart always docker 异常退出后自动重启</span><br><span class="line">–volume / -v 挂载本地目录，格式 /src:/dst</span><br><span class="line">-e 指定docker启动后环境变量（env）</span><br><span class="line">–privileged 让docker可以拥有root权限</span><br><span class="line">–ulimit nofile 系统文件句柄打开数量限制</span><br><span class="line">–ulimit memlock 最大锁定内存地址空间，-1表示不限制</span><br><span class="line">–memory 限制docker内存</span><br><span class="line">–memory-swap 限制docker虚拟内存，-1 为不限制，共用宿主机swap</span><br><span class="line">–cpuset-cpus 指定docker绑定的CPU</span><br><span class="line">TERM=dumb 让docker里面可以执行top命令</span><br></pre></td></tr></table></figure><h3 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h3><p>nexus挂载目录/data<br><img src="/2022/04/26/nexus%E5%8D%87%E7%BA%A7https%E8%BF%87%E7%A8%8B/df-Th.jpg"><br><img src="/2022/04/26/nexus%E5%8D%87%E7%BA%A7https%E8%BF%87%E7%A8%8B/xfs_growfs.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nexus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID</title>
      <link href="/2022/04/11/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
      <url>/2022/04/11/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
      
        <content type="html"><![CDATA[<h3 id="雪花算法-snowflake"><a href="#雪花算法-snowflake" class="headerlink" title="雪花算法 snowflake"></a>雪花算法 snowflake</h3><p>twitter开源的分布式id生成算法。<br>把一个64位的long型的id，1个bit是不用的，用其中的41 bit作为毫秒数，用10 bit作为工作机器id，12 bit作为序列号。<br>理论上最多支持1024台机器每秒生成4096000个序列号。</p><p><img src="/2022/04/11/%E5%88%86%E5%B8%83%E5%BC%8FID/snowflake.jpeg"></p><ul><li>1 bit：不用<br>  因为二进制里第一个bit为如果是1，那么都是负数，但是我们生成的id都是正数，所以第一个bit统一都是0</li><li>41 bit：表示的是时间戳，单位是ms<br>  41 bit可以表示的数字多达2^41 - 1，也就是可以标识2 ^ 41 - 1个毫秒值，换算成年就是表示69年的时间</li><li>10 bit：记录工作机器id<br>  代表的是这个服务最多可以部署在2^10台机器上哪，也就是1024台机器，但是10 bit里5个bit代表机房id，5个bit代表机器id。意思就是最多代表2 ^ 5个机房(32个机房)，每个机房里可以代表2 ^ 5个机器(32台机器)。</li><li>12 bit：记录同一个毫秒内产生的不同id<br>  12 bit可以代表的最大正整数是2 ^ 12 - 1 = 4096，也就是说可以用这个12bit代表的数字来区分同一个毫秒内的4096个不同的id</li></ul><p>缺点：</p><ul><li>依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成</li></ul><p>优点：</p><ul><li>此方案每秒能够产生409.6万个ID，性能快</li><li>时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增</li><li>灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2022/02/24/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2022/02/24/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2022/02/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/02/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2022/01/05/Nginx/"/>
      <url>/2022/01/05/Nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h3><p>轻量级的Web服务器、反向代理服务器。</p><h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><ul><li><p>正向代理<br><img src="/2022/01/05/Nginx/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.jpeg"><br>由于防火墙的原因，我们不能直接访问谷歌，可以借助VPN来实现，这是简单的正向代理的例子。<br>正向代理“代理”的是客户端，而且客户端是知道目标的，但是目标不知道客户端是通过VPN访问的。</p></li><li><p>反向代理<br><img src="/2022/01/05/Nginx/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.jpeg"><br>当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。</p></li></ul><h3 id="Nginx的Master-Worker模式"><a href="#Nginx的Master-Worker模式" class="headerlink" title="Nginx的Master-Worker模式"></a>Nginx的Master-Worker模式</h3><p><img src="/2022/01/05/Nginx/Nginx%E8%BF%9B%E7%A8%8B.jpeg"><br>启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</p><h4 id="Master进程"><a href="#Master进程" class="headerlink" title="Master进程"></a>Master进程</h4><ul><li>读取并验证配置文件nginx.conf</li><li>管理Worker进程</li></ul><h4 id="Worker进程"><a href="#Worker进程" class="headerlink" title="Worker进程"></a>Worker进程</h4><p>每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求。Worker进程的个数由配置文件决定，一般和CPU个数有关（利于进程切换）。</p><h3 id="Nginx如何做到热部署"><a href="#Nginx如何做到热部署" class="headerlink" title="Nginx如何做到热部署"></a>Nginx如何做到热部署</h3><h3 id="Nginx如何做到高并发下的高效处理"><a href="#Nginx如何做到高并发下的高效处理" class="headerlink" title="Nginx如何做到高并发下的高效处理"></a>Nginx如何做到高并发下的高效处理</h3><p>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。Worker进程只需要从epoll队列循环处理即可。</p><h4 id="epoll模型是什么"><a href="#epoll模型是什么" class="headerlink" title="epoll模型是什么"></a>epoll模型是什么</h4><h3 id="Nginx挂了怎么办"><a href="#Nginx挂了怎么办" class="headerlink" title="Nginx挂了怎么办"></a>Nginx挂了怎么办</h3><p>Keepalived+Nginx实现高可用。<br>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）<br>Keepalived+Nginx实现高可用的思路：</p><ol><li>请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</li><li>Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）<br><img src="/2022/01/05/Nginx/Keepalived+Nginx.jpeg"></li></ol><h3 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h3><h4 id="虚拟主机-server"><a href="#虚拟主机-server" class="headerlink" title="虚拟主机 server"></a>虚拟主机 server</h4><p><img src="/2022/01/05/Nginx/conf-server.jpeg"></p><h4 id="反向代理-proxy-pass"><a href="#反向代理-proxy-pass" class="headerlink" title="反向代理 proxy_pass"></a>反向代理 proxy_pass</h4><p>在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。</p><p>反向代理的过程是透明的，比如说request -&gt; Nginx -&gt; Tomcat，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER。</p><h4 id="负载均衡-upstream"><a href="#负载均衡-upstream" class="headerlink" title="负载均衡 upstream"></a>负载均衡 upstream</h4><p>上面的反向代理中，我们通过proxy_pass来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？</p><ol><li>通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</li><li>将proxy_pass替换成upstream指定的值即可。</li></ol><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存，是Nginx提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。</p><ol><li>定义缓存存储目录并指定共享内存空间</li><li>在location里指定共享内存空间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">user www;</span><br><span class="line">worker_processes auto;</span><br><span class="line">events &#123;</span><br><span class="line">worker_connections 4096;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">include mime.types;</span><br><span class="line">default_type application/octet-stream;</span><br><span class="line">sendfile on;</span><br><span class="line">gzip on;</span><br><span class="line">keepalive_timeout 65;</span><br><span class="line"></span><br><span class="line"># 以下是缓存相关配置</span><br><span class="line">proxy_cache_path /data/nginx/cache2 levels=1:2 keys_zone=mycache:1024m max_size=2048m inactive=1d ;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name localhost;</span><br><span class="line">#charset koi8-r;</span><br><span class="line">#access_log logs/host.access.log main;</span><br><span class="line">location /apis/test/img &#123;</span><br><span class="line">proxy_pass http://192.168.1.2/;</span><br><span class="line"></span><br><span class="line"># 以下三行是缓存相关配置</span><br><span class="line">proxy_cache mycache;</span><br><span class="line">proxy_cache_valid 200 1d;</span><br><span class="line">proxy_cache_use_stale error timeout invalid_header updating http_500 http_503 http_404;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 500 502 503 504 /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>proxy_cache_path:定义缓存目录，需要手动创建此目录；缓存数据存放至此。</li><li>/data/nginx/cache2：自定义的缓存目录，缓存中的文件名称是应用MD5的结果；另外，首先是将缓存响应写入临时文件，然后文件才被重命名；</li><li>levels=1:2：定义缓存的层次结构级别；这里表示缓存目录的第一级目录是1个字符，第二级目录是2个字符；</li><li>keys_zone=mycache:1024m：内核中建立的用于缓存数据原数据的共享内存空间；这里存放缓存数据的原数据；查找缓存的时候，先从这个内核空间中找到，缓存数据的原数据，然后再到对应目录中查找缓存；我这里定义的zone名称为‘mycache’;</li><li>max_size=2048m：设置缓存空间的最大值；</li><li>inactive=1d: 设置缓存的数据保留时间，这里自定义1天内没有被访问过就删除；</li><li>proxy_cache：在location里设置内存缓存源数据空间名字，对应我们前面的设定’mycache’;</li><li>proxy_cache_valid: 可以为不同的响应状态码设置不同的缓存时间，比如这里200状态码，设置为1天；</li><li>proxy_cache_use_stale：指定后端服务器出现状况时，nginx可以使用的过期缓存</li><li>另外可以设置proxy_cache_key：用来指定缓存所使用的key的组合字符串，然后用md5进行加密。如不指定默认使用：$scheme$proxy_host$request_uri;</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式缓存</title>
      <link href="/2021/12/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
      <url>/2021/12/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><h3 id="客户端缓存-浏览器缓存"><a href="#客户端缓存-浏览器缓存" class="headerlink" title="客户端缓存/浏览器缓存"></a>客户端缓存/浏览器缓存</h3><p>对于B/S架构的互联网应用来说客户端缓存主要分为页面缓存和浏览器缓存两种，对于APP而言主要是自身所使用的缓存。</p><p>客户端Client/Server是建立在局域网的基础上的。浏览器Browser/Server是建立在广域网的基础上的。</p><h3 id="网络中缓存"><a href="#网络中缓存" class="headerlink" title="网络中缓存"></a>网络中缓存</h3><ul><li>CDN缓存</li><li>代理服务器缓存</li></ul><h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><ul><li>本地缓存</li><li>分布式缓存，Redis、Memcached、MongoDB等NoSql</li><li>数据库缓存</li></ul><h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><h3 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h3><p><code>Content Delivery Network</code>，内容分发网络，是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。</p><p>CDN是将源站内容（image、html、js、css等）分发至全国所有的节点，从而缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性的技术。它能够有效解决网络带宽小、用户访问量大、网点分布不均等问题。</p><h2 id="代理服务器缓存"><a href="#代理服务器缓存" class="headerlink" title="代理服务器缓存"></a>代理服务器缓存</h2><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>Proxy Server，其功能就是代理网络用户去取得网络信息。<br>形象的说：它是网络信息的中转站。在一般情况下，我们使用网络浏览器直接去连接其他Internet站点取得网络信息时，须送出Request信号来得到回答，然后对方再把信息以bit方式传送回来。代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。</p><h4 id="代理功能"><a href="#代理功能" class="headerlink" title="代理功能"></a>代理功能</h4><ol><li>突破自身IP访问限制，访问国外站点。教育网、169网等网络用户可以通过代理访问国外网站。</li><li>访问一些单位或团体内部资源。如某大学FTP(前提是该代理地址在该资源 的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</li><li>突破中国电信的IP封锁。中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国外的代理服务器试试。</li><li>提高访问速度。通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li><li>隐藏真实IP。上网者也可以通过这种方法隐藏自己的IP，免受攻击。</li></ol><h2 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h2><ol><li>定义缓存存储目录并指定共享内存空间</li><li>在location里指定共享内存空间</li></ol><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>即内存，本地缓存是一级缓存，位于服务本机的内存中，读写速度快，缺点是不能持久化，一旦项目关闭，数据就会丢失，而且不能满足分布式系统的应用场景(比如数据不一致的问题)。<br>存在的问题：</p><ol><li>本读缓存数据直接保存在JVM中，需要考虑缓存数据的大小、JVM的垃圾回收性能消耗</li><li>单服务是集群部署的时候，应该考虑是否需要做集群中本地缓存的数据同步</li><li>无法进行持久化</li><li>无法保证多实例数据一致性</li></ol><h3 id="EhCache"><a href="#EhCache" class="headerlink" title="EhCache"></a>EhCache</h3><h3 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h3><h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>利用缓存数据库，最常见的就是Redis。Redis的访问速度同样很快，可以设置过期时间、设置持久化方法，缺点是会受到网络和并发访问的影响。</p><h3 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h3><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>Jedis 是直连模式，在多个线程间共享一个 Jedis 实例是线程不安全的，每个线程都去拿自己的 Jedis 实例，当连接数量增多时，物理连接成本就较高了。</p><p>底层使用阻塞的I/O，且其方法调用都是同步的，程序流需要等到sockets处理完I/O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。</p><h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p>相比较Jedis，Lettuce基于优秀Netty NIO框架构建，支持Redis的高级功能，如Sentinel，集群，流水线，自动重新连接和Redis数据模型，线程安全，适用于分布式缓存。</p><p>如果需要集群、读写分离、异步等特性支持需要使用Lettuce客户端。</p><h4 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h4><p>让使用者对Redis的关注分离，提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列，也是基于Netty框架的事件驱动的通信层。</p><h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><p>Spring Data Redis是Spring大家族的一部分，提供了在Srping应用中通过简单的配置访问Redis服务，对Reids底层开发包(Jedis, JRedis, RJC)进行了高度封装，RedisTemplate提供了Redis各种操作、异常处理及序列化，支持发布订阅。</p><h2 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h2><h2 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="FIFO-先进先出"><a href="#FIFO-先进先出" class="headerlink" title="FIFO 先进先出"></a>FIFO 先进先出</h4><h4 id="LRU-Least-Recently-Used"><a href="#LRU-Least-Recently-Used" class="headerlink" title="LRU(Least Recently Used)"></a>LRU(Least Recently Used)</h4><p>最近最少使用。淘汰最长时间没有被使用的，以时间作为参考。</p><h4 id="LFU-Least-Frequently-Used"><a href="#LFU-Least-Frequently-Used" class="headerlink" title="LFU(Least Frequently Used)"></a>LFU(Least Frequently Used)</h4><p>最不经常使用。淘汰一段时间内，使用次数最少的，以次数作为参考。</p><h3 id="Redis缓存淘汰策略"><a href="#Redis缓存淘汰策略" class="headerlink" title="Redis缓存淘汰策略"></a>Redis缓存淘汰策略</h3><ol><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li><li>volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。</li><li>allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。</li><li>no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。</li></ol><p>总体上分为4种：</p><ul><li>lru</li><li>lfu</li><li>random</li><li>ttl</li></ul><h2 id="缓存、数据库-最终-一致性"><a href="#缓存、数据库-最终-一致性" class="headerlink" title="缓存、数据库(最终)一致性"></a>缓存、数据库(最终)一致性</h2><p>主要有两种情况，会导致缓存和DB的一致性问题：</p><ol><li>并发的场景下，导致读取老的DB数据，更新到缓存中</li><li>缓存和DB的操作，不在一个事务中，可能只有一个操作成功，而另一个操作失败，导致不一致</li><li>数据库主从结构，主从同步不及时带来的缓存、数据库数据不一致<h3 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h3>数据更新前后双删除缓存策略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line"></span><br><span class="line">redis.del(key);</span><br><span class="line"></span><br><span class="line">db.update(data);</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">redis.del(key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>先淘汰缓存</li><li>写数据库</li><li>休眠1秒，再次淘汰缓存。高并发情况下确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<h4 id="延迟双删-同步删除，吞吐量降低如何处理"><a href="#延迟双删-同步删除，吞吐量降低如何处理" class="headerlink" title="延迟双删 - 同步删除，吞吐量降低如何处理"></a>延迟双删 - 同步删除，吞吐量降低如何处理</h4>将第二次删除作为异步的，提交一个延迟的执行任务<h4 id="延迟双删-解决删除失败的方式"><a href="#延迟双删-解决删除失败的方式" class="headerlink" title="延迟双删 - 解决删除失败的方式"></a>延迟双删 - 解决删除失败的方式</h4>添加重试机制，例如：将删除失败的key，写入消息队列；但对业务耦合有些严重；</li></ol><h2 id="一二级缓存一致性"><a href="#一二级缓存一致性" class="headerlink" title="一二级缓存一致性"></a>一二级缓存一致性</h2><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p><p>这就是缓存雪崩。<br><img src="/2021/12/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li><li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。<br><img src="/2021/12/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3><p>对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。<br>黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。<br>举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。<br><img src="/2021/12/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png"></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>缓存空值，并设置过期时间。</p><p>每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p><h2 id="热数据"><a href="#热数据" class="headerlink" title="热数据"></a>热数据</h2><h2 id="数据并发竞争"><a href="#数据并发竞争" class="headerlink" title="数据并发竞争"></a>数据并发竞争</h2><h3 id="redis的并发竞争问题是什么"><a href="#redis的并发竞争问题是什么" class="headerlink" title="redis的并发竞争问题是什么"></a>redis的并发竞争问题是什么</h3><p>多客户端同时并发写一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>某个时刻，多个系统实例都去更新某个 key。可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。</p><h3 id="redis事务的CAS方案"><a href="#redis事务的CAS方案" class="headerlink" title="redis事务的CAS方案"></a>redis事务的CAS方案</h3><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><h2 id="缓存的数据结构"><a href="#缓存的数据结构" class="headerlink" title="缓存的数据结构"></a>缓存的数据结构</h2><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2021/12/15/Java-%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/12/15/Java-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h3><p><img src="/2021/12/15/Java-%E5%9F%BA%E7%A1%80/JDK-JRE-JVM.png"></p><h3 id="重载（Overload）和重写（Override）的区别？"><a href="#重载（Overload）和重写（Override）的区别？" class="headerlink" title="重载（Overload）和重写（Override）的区别？"></a>重载（Overload）和重写（Override）的区别？</h3><p>方法的重载和重写都是实现多态的方式，区别在于重载实现的事编译时的多态性，重写实现的是运行时的多态性。<br>重载发生在一个类中，同名方法的参数列表（参数类型、参数个数、参数顺序）不同，与返回值类型无关。<br>重写发生在子类与父类之间，要求方法名、参数列表、返回类型必须相同，访问修饰符的限制要大于被重写方法，不能抛出比被重写方法更宽泛的异常。</p><h3 id="String-和-StringBuffer、StringBuilder-的区别？"><a href="#String-和-StringBuffer、StringBuilder-的区别？" class="headerlink" title="String 和 StringBuffer、StringBuilder 的区别？"></a>String 和 StringBuffer、StringBuilder 的区别？</h3><p>java.lang.String/StringBuffer/StringBuilder，三者的共同之处都是final类，不允许被继承。</p><ul><li>String implements java.io.Serializable, Comparable<String>, CharSequence</String></li><li>StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A cache of the last value returned by toString. </span></span><br><span class="line"><span class="comment">    * Cleared whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure>StringBuffer中的许多方法是用<code>synchronized</code>关键字修饰的。</li><li>StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence</li></ul><h3 id="String-为什么是不可变的？"><a href="#String-为什么是不可变的？" class="headerlink" title="String 为什么是不可变的？"></a>String 为什么是不可变的？</h3><p>不可变的对象：一个对象在它创建完成之后，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><p>String 用 <code>value[]</code> 来保存字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><p><code>value[]</code>是final修饰的，不能再指向其他数组对象，但是可以通过反射，反射出String对象的value属性，进而通过获得的value引用改变数组的结构。</p><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>基本数据类型和其包装类型的自动转换。<br>自动装箱都是通过包装类的valueOf()方法来实现的。<br>自动拆箱都是通过包装类对象的xxxValue()来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装箱</span></span><br><span class="line">Integer integer = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//反编译结果</span></span><br><span class="line">Integer integer = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆箱</span></span><br><span class="line"><span class="keyword">int</span> i = integer; </span><br><span class="line"><span class="comment">// 反编译结果</span></span><br><span class="line"><span class="keyword">int</span> i = integer.valueOf;</span><br></pre></td></tr></table></figure><h4 id="自动拆装箱与缓存"><a href="#自动拆装箱与缓存" class="headerlink" title="自动拆装箱与缓存"></a>自动拆装箱与缓存</h4><p>Integer的缓存机制：</p><ul><li>适用于整数值区间 -128到+127</li><li>只适用于自动装箱</li><li>使用构造函数创建对象不适用<br>当需要进行自动装箱时，如果数字在-128到+127之间，会直接使用缓存中的对象，而不是重新创建一个对象。</li></ul><h3 id="与-equals？"><a href="#与-equals？" class="headerlink" title="== 与 equals？"></a>== 与 equals？</h3><h3 id="Object类的常见方法？"><a href="#Object类的常见方法？" class="headerlink" title="Object类的常见方法？"></a>Object类的常见方法？</h3><ul><li>toString()<br>获取对象信息方法。将对象的信息变为字符串返回，默认输出对象地址。</li><li>equals(Object obj)<br>对象相等判断方法。用于比较对象是否相等，而且此方法必须被重写。基本数据类型没有equals()方法。</li><li>hashCode()<br>对象签名。用来返回该对象的物理地址(哈希码值)，常会和<code>equals()</code>方法同时重写，确保两个相等的对象拥有相等的hashcode。</li><li>getClass()<br>返回此Object的运行时类。常用于<code>反射</code>中。</li><li>wait()</li><li>notify()</li><li>notifyAll()</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h2 id="Java基础-注解"><a href="#Java基础-注解" class="headerlink" title="Java基础 - 注解"></a>Java基础 - 注解</h2><h2 id="Java基础-异常"><a href="#Java基础-异常" class="headerlink" title="Java基础 - 异常"></a>Java基础 - 异常</h2><h2 id="Java基础-反射"><a href="#Java基础-反射" class="headerlink" title="Java基础 - 反射"></a>Java基础 - 反射</h2><h2 id="Java基础-SPI机制"><a href="#Java基础-SPI机制" class="headerlink" title="Java基础 - SPI机制"></a>Java基础 - SPI机制</h2><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="描述一下-JVM-加载-Class-文件的原理机制？"><a href="#描述一下-JVM-加载-Class-文件的原理机制？" class="headerlink" title="描述一下 JVM 加载 Class 文件的原理机制？"></a>描述一下 JVM 加载 Class 文件的原理机制？</h3><h3 id="什么是tomcat类加载机制？"><a href="#什么是tomcat类加载机制？" class="headerlink" title="什么是tomcat类加载机制？"></a>什么是tomcat类加载机制？</h3><h3 id="类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？"><a href="#类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？" class="headerlink" title="类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？"></a>类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？</h3><h3 id="垃圾回收常见问题。"><a href="#垃圾回收常见问题。" class="headerlink" title="垃圾回收常见问题。"></a>垃圾回收常见问题。</h3><h3 id="什么是GC-为什么要有-GC？"><a href="#什么是GC-为什么要有-GC？" class="headerlink" title="什么是GC? 为什么要有 GC？"></a>什么是GC? 为什么要有 GC？</h3><h3 id="简述一下Java-垃圾回收机制？"><a href="#简述一下Java-垃圾回收机制？" class="headerlink" title="简述一下Java 垃圾回收机制？"></a>简述一下Java 垃圾回收机制？</h3><h3 id="如何判断一个对象是否存活？"><a href="#如何判断一个对象是否存活？" class="headerlink" title="如何判断一个对象是否存活？"></a>如何判断一个对象是否存活？</h3><h3 id="垃圾回收的优点和原理，并考虑-2-种回收机制？"><a href="#垃圾回收的优点和原理，并考虑-2-种回收机制？" class="headerlink" title="垃圾回收的优点和原理，并考虑 2 种回收机制？"></a>垃圾回收的优点和原理，并考虑 2 种回收机制？</h3><h3 id="Java-中垃圾收集的方法有哪些？"><a href="#Java-中垃圾收集的方法有哪些？" class="headerlink" title="Java 中垃圾收集的方法有哪些？"></a>Java 中垃圾收集的方法有哪些？</h3><h3 id="讲讲你理解的性能评价及测试指标？"><a href="#讲讲你理解的性能评价及测试指标？" class="headerlink" title="讲讲你理解的性能评价及测试指标？"></a>讲讲你理解的性能评价及测试指标？</h3><h3 id="常用的性能优化方式有哪些？"><a href="#常用的性能优化方式有哪些？" class="headerlink" title="常用的性能优化方式有哪些？"></a>常用的性能优化方式有哪些？</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Arraylist-与-LinkedList-异同。"><a href="#Arraylist-与-LinkedList-异同。" class="headerlink" title="Arraylist 与 LinkedList 异同。"></a>Arraylist 与 LinkedList 异同。</h3><h3 id="ArrayList-与-Vector-区别。"><a href="#ArrayList-与-Vector-区别。" class="headerlink" title="ArrayList 与 Vector 区别。"></a>ArrayList 与 Vector 区别。</h3><h3 id="HashMap的底层实现。"><a href="#HashMap的底层实现。" class="headerlink" title="HashMap的底层实现。"></a>HashMap的底层实现。</h3><h3 id="HashMap-和-Hashtable-的区别。"><a href="#HashMap-和-Hashtable-的区别。" class="headerlink" title="HashMap 和 Hashtable 的区别。"></a>HashMap 和 Hashtable 的区别。</h3><h3 id="HashMap-的长度为什么是2的幂次方。"><a href="#HashMap-的长度为什么是2的幂次方。" class="headerlink" title="HashMap 的长度为什么是2的幂次方。"></a>HashMap 的长度为什么是2的幂次方。</h3><h3 id="HashMap-多线程操作导致死循环问题。"><a href="#HashMap-多线程操作导致死循环问题。" class="headerlink" title="HashMap 多线程操作导致死循环问题。"></a>HashMap 多线程操作导致死循环问题。</h3><h3 id="HashSet-和-HashMap-区别。"><a href="#HashSet-和-HashMap-区别。" class="headerlink" title="HashSet 和 HashMap 区别。"></a>HashSet 和 HashMap 区别。</h3><h3 id="ConcurrentHashMap-和-Hashtable-的区别。"><a href="#ConcurrentHashMap-和-Hashtable-的区别。" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别。"></a>ConcurrentHashMap 和 Hashtable 的区别。</h3><ul><li>HashTable是线程安全的，原理和HashMap基本一样，差别在：<ul><li>HashTable不允许key和value为null</li><li>get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁，性能较差</li></ul></li><li>ConcurrentHashMap是线程安全的，但是它是分段锁，容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。</li></ul><h3 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现。"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现。" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现。"></a>ConcurrentHashMap线程安全的具体实现方式/底层具体实现。</h3><h2 id="JUC-多线程与并发"><a href="#JUC-多线程与并发" class="headerlink" title="JUC 多线程与并发"></a>JUC 多线程与并发</h2><h3 id="AQS-原理。"><a href="#AQS-原理。" class="headerlink" title="AQS 原理。"></a>AQS 原理。</h3><h3 id="AQS-对资源的共享方式。"><a href="#AQS-对资源的共享方式。" class="headerlink" title="AQS 对资源的共享方式。"></a>AQS 对资源的共享方式。</h3><h3 id="AQS底层使用了模板方法模式。"><a href="#AQS底层使用了模板方法模式。" class="headerlink" title="AQS底层使用了模板方法模式。"></a>AQS底层使用了模板方法模式。</h3><h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><h3 id="synchronized关键字。"><a href="#synchronized关键字。" class="headerlink" title="synchronized关键字。"></a>synchronized关键字。</h3><h3 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗？"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗？" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？</h3><h4 id="面试题：多线程循环打印ABC"><a href="#面试题：多线程循环打印ABC" class="headerlink" title="面试题：多线程循环打印ABC"></a>面试题：多线程循环打印ABC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抢占式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrintABC_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">0</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">1</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">2</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRINT_NUM = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CURRENT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (CURRENT &lt; PRINT_NUM) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (CURRENT &lt; PRINT_NUM &amp;&amp; CURRENT % <span class="number">3</span> == index) &#123;</span><br><span class="line"><span class="comment">//                    if (CURRENT % 3 == index) &#123;</span></span><br><span class="line">                        System.out.println(CURRENT + <span class="string">&quot; &quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + CURRENT % <span class="number">3</span>));</span><br><span class="line">                        CURRENT ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协作式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrintABC_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">0</span>,<span class="string">&#x27;A&#x27;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">1</span>,<span class="string">&#x27;B&#x27;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">2</span>,<span class="string">&#x27;C&#x27;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 打印控制变量计数器</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> COUNT = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 成员变量 每个线程打印次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sort;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> sort, <span class="keyword">char</span> name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sort = sort;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (COUNT % <span class="number">3</span> == sort) &#123;</span><br><span class="line"><span class="comment">//                        System.out.println(name);</span></span><br><span class="line">                        System.out.println((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + COUNT % <span class="number">3</span>));</span><br><span class="line">                        COUNT ++;</span><br><span class="line">                        num --;</span><br><span class="line">                        LOCK.notifyAll();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.feng.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock Condition CountDownLatch</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ABC</span></span><br><span class="line"><span class="comment"> * ABC</span></span><br><span class="line"><span class="comment"> * END</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrintABC_4</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock LOCK = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition cur;</span><br><span class="line">    <span class="keyword">private</span> Condition next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> aChar;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPrintABC_4</span><span class="params">(Condition cur, Condition next, <span class="keyword">char</span> aChar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cur = cur;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.aChar = aChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= COUNT; i ++) &#123;</span><br><span class="line">                System.out.print(aChar);</span><br><span class="line">                <span class="keyword">if</span> (aChar == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">                next.signal();</span><br><span class="line">                <span class="keyword">if</span> (i &lt; COUNT) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cur.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Condition a = LOCK.newCondition();</span><br><span class="line">        Condition b = LOCK.newCondition();</span><br><span class="line">        Condition c = LOCK.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ThreadPrintABC_4(a, b, <span class="string">&#x27;A&#x27;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> ThreadPrintABC_4(b, c, <span class="string">&#x27;B&#x27;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> ThreadPrintABC_4(c, a, <span class="string">&#x27;C&#x27;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="讲一下-synchronized-关键字的底层原理。"><a href="#讲一下-synchronized-关键字的底层原理。" class="headerlink" title="讲一下 synchronized 关键字的底层原理。"></a>讲一下 synchronized 关键字的底层原理。</h3><h3 id="说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"><a href="#说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？" class="headerlink" title="说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"></a>说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</h3><h3 id="谈谈-synchronized和ReenTrantLock-的区别。"><a href="#谈谈-synchronized和ReenTrantLock-的区别。" class="headerlink" title="谈谈 synchronized和ReenTrantLock 的区别。"></a>谈谈 synchronized和ReenTrantLock 的区别。</h3><h3 id="说说-synchronized-关键字和-volatile-关键字的区别。"><a href="#说说-synchronized-关键字和-volatile-关键字的区别。" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别。"></a>说说 synchronized 关键字和 volatile 关键字的区别。</h3><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><h3 id="实现Runnable接口和Callable接口的区别。"><a href="#实现Runnable接口和Callable接口的区别。" class="headerlink" title="实现Runnable接口和Callable接口的区别。"></a>实现Runnable接口和Callable接口的区别。</h3><h3 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a>执行execute()方法和submit()方法的区别是什么呢？</h3><h3 id="如何创建线程池。"><a href="#如何创建线程池。" class="headerlink" title="如何创建线程池。"></a>如何创建线程池。</h3><h3 id="介绍一下Atomic-原子类。"><a href="#介绍一下Atomic-原子类。" class="headerlink" title="介绍一下Atomic 原子类。"></a>介绍一下Atomic 原子类。</h3><h3 id="JUC-包中的原子类是哪4类？"><a href="#JUC-包中的原子类是哪4类？" class="headerlink" title="JUC 包中的原子类是哪4类？"></a>JUC 包中的原子类是哪4类？</h3><ol><li>基本类型: AtomicInteger, AtomicLong, AtomicBoolean ;</li><li>数组类型: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray ;</li><li>引用类型: AtomicReference, AtomicStampedRerence, AtomicMarkableReference ;</li><li>对象的属性修改类型: AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 。</li></ol><h3 id="讲讲-AtomicInteger-的使用。"><a href="#讲讲-AtomicInteger-的使用。" class="headerlink" title="讲讲 AtomicInteger 的使用。"></a>讲讲 AtomicInteger 的使用。</h3><h3 id="能不能给我简单介绍一下-AtomicInteger-类的原理？"><a href="#能不能给我简单介绍一下-AtomicInteger-类的原理？" class="headerlink" title="能不能给我简单介绍一下 AtomicInteger 类的原理？"></a>能不能给我简单介绍一下 AtomicInteger 类的原理？</h3><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul><li>懒汉式：在第一次调用的时候进行实例化。</li><li>饿汉式：在类初始化时，已经自行实例化。</li></ul><h4 id="饿汉式-直接静态初始化"><a href="#饿汉式-直接静态初始化" class="headerlink" title="饿汉式 - 直接静态初始化"></a>饿汉式 - 直接静态初始化</h4><ul><li>优点：简单，含有 final 关键字</li><li>缺点：程序运行直接加载，耗费资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObject1 instance = <span class="keyword">new</span> SingletonObject1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式-synchronized实现"><a href="#懒汉式-synchronized实现" class="headerlink" title="懒汉式 - synchronized实现"></a>懒汉式 - synchronized实现</h4><ul><li>优点：懒加载实现，即初次获取值时才会初始化</li><li>缺点：synchronized 实现，初始化后每次读操作也会加锁，耗费资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObject3 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonObject3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">           instance = <span class="keyword">new</span> SingletonObject3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式-双重检查"><a href="#懒汉式-双重检查" class="headerlink" title="懒汉式 - 双重检查"></a>懒汉式 - 双重检查</h4><ul><li>优点：懒加载 + 双重检查，确保初始化一次，同时优化性能</li><li>缺点：实现较复杂，同时 volatile 也有性能损耗</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonObject4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(SingletonObject4.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonObject4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>加载一个类时，其内部类不会同时被加载。<br>一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。<br>由于在调用 SingletonObject5.getInstance() 的时候，才会对单例进行初始化，而且通过反射，是不能从外部类获取内部类的属性的；由于静态内部类的特性，只有在其被第一次引用的时候才会被加载，所以可以保证其线程安全性。</p><ul><li>优点：使用内部类机制实现懒加载，最佳实践之一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObject5 INSTANCE = <span class="keyword">new</span> SingletonObject5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h4><p>单元素的枚举类型已经成为实现Singleton的最佳方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EnumSingleton.INSTANCE.test();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愛彌留</title>
      <link href="/2021/11/25/%E6%B8%AF%E4%B9%90-%E6%84%9B%E5%BD%8C%E7%95%99/"/>
      <url>/2021/11/25/%E6%B8%AF%E4%B9%90-%E6%84%9B%E5%BD%8C%E7%95%99/</url>
      
        <content type="html"><![CDATA[<p>爱弥留 - 达明一派<br>词：周耀辉<br>曲：刘以达</p><p>请收起你的温柔<br>浮在水仙中的杀手<br>请收起你的风流<br>垂在钟摆间的借口<br>明白我始终必须远走<br>但请不要为我忧愁<br>蝴蝶总比沙丘永久<br>但请相信我的荒谬<br>纵使真的不想远走<br>明白我始终必须远走<br>象我这永没法解释的苍白<br>象永远盖着扑克<br>象永远在转圈圈的笔画<br>一生不过揣测<br>象我这永没法青春的生命<br>象永远转换布景<br>象永远在转圈圈的花瓶<br>一生不过一声<br>没一刻可以安静</p><p>请不要问我今后<br>藏在死水中的缺口<br>请相信我的恳求<br>忘掉总比思忆永久<br>明白我始终必须远走<br>象我这永没法解释的苍白<br>象永远盖着扑克<br>象永远在转圈圈的笔画<br>一生不过揣测<br>象我这永没法青春的生命<br>象永远转换布景<br>象永远在转圈圈的花瓶<br>一生不过一声<br>没一刻可以安静</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 港乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天起的每晚 你要珍惜岁月</title>
      <link href="/2021/11/21/%E9%9A%8F%E7%AC%94-%E4%BB%8A%E5%A4%A9%E8%B5%B7%E7%9A%84%E6%AF%8F%E6%99%9A-%E4%BD%A0%E8%A6%81%E7%8F%8D%E6%83%9C%E5%B2%81%E6%9C%88/"/>
      <url>/2021/11/21/%E9%9A%8F%E7%AC%94-%E4%BB%8A%E5%A4%A9%E8%B5%B7%E7%9A%84%E6%AF%8F%E6%99%9A-%E4%BD%A0%E8%A6%81%E7%8F%8D%E6%83%9C%E5%B2%81%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<p>今天花了几个小时的时间把hexo从windows迁到mac上。<br>上一次的记录时间是<code>2019-11-24</code>，今天是<code>2021-11-21</code>。<br>两年了，重新出发吧。</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2020/10/27/Spring/"/>
      <url>/2020/10/27/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="谈谈对Spring的理解"><a href="#谈谈对Spring的理解" class="headerlink" title="谈谈对Spring的理解"></a>谈谈对Spring的理解</h2><p>Spring是一个轻量级的IoC和AOP容器框架，是为Java应用程序提供基础性服务的一套框架。</p><p>目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。</p><p>轻量级是相对于重量级而言的，轻量级一般就是非侵入式的、所依赖的东西少、资源占用少、部署简单，容易使用。</p><ul><li>Spring Core：核心类库，提供IOC服务；</li><li>Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</li><li>Spring AOP：AOP服务；</li><li>Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；</li><li>Spring ORM：对现有的ORM框架的支持；</li><li>Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；</li><li>Spring MVC：提供面向Web应用的Model-View-Controller实现。</li></ul><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>IOC，Inversion of Control就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。</p><p>DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</p><h3 id="IOC的工作原理"><a href="#IOC的工作原理" class="headerlink" title="IOC的工作原理"></a>IOC的工作原理</h3><p>IoC 底层通过工厂模式、Java 的反射机制、XML 解析等技术，将代码的耦合度降低到最低限度，其主要步骤如下。</p><ol><li>在配置文件（例如 Bean.xml）中，对各个对象以及它们之间的依赖关系进行配置；</li><li>我们可以把 IoC 容器当做一个工厂，这个工厂的产品就是 Spring Bean；</li><li>容器启动时会加载并解析这些配置文件，得到对象的基本信息以及它们之间的依赖关系；</li><li>IoC 利用 Java 的反射机制，根据类名生成相应的对象（即 Spring Bean），并根据依赖关系将这个对象注入到依赖它的对象中。</li></ol><p>由于对象的基本信息、对象之间的依赖关系都是在配置文件中定义的，并没有在代码中紧密耦合，因此即使对象发生改变，我们也只需要在配置文件中进行修改即可，而无须对 Java 代码进行修改，这就是 Spring IoC 实现解耦的原理。</p><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><p>IoC 思想基于 IoC 容器实现的，IoC 容器底层其实就是一个 Bean 工厂。<br>Spring 框架为我们提供了两种不同类型 IoC 容器，它们分别是 BeanFactory 和 ApplicationContext。</p><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BeanFactory 是 IoC 容器的基本实现，也是 Spring 提供的最简单的 IoC 容器，它提供了 IoC 容器最基本的功能，由 org.springframework.beans.factory.BeanFactory 接口定义。</p><p>BeanFactory 采用懒加载（lazy-load）机制，容器在加载配置文件时并不会立刻创建 Java 对象，只有程序中获取（使用）这个对对象时才会创建。</p><blockquote><p>BeanFactory 是 Spring 内部使用接口，通常情况下不提供给开发人员使用。 </p></blockquote><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>ApplicationContext 是 BeanFactory 接口的子接口，是对 BeanFactory 的扩展。<br>ApplicationContext 在 BeanFactory 的基础上增加了许多企业级的功能，例如 AOP（面向切面编程）、国际化、事务支持等。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>OOP面向对象，允许开发者定义纵向的关系，但并不适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。<br>静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>AspectJ是静态代理的增强。</p><p>所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><h4 id="Spring-AOP使用的动态代理"><a href="#Spring-AOP使用的动态代理" class="headerlink" title="Spring AOP使用的动态代理"></a>Spring AOP使用的动态代理</h4><p>所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>Spring AOP中的动态代理主要有两种方式：</p><ul><li>JDK动态代理</li><li>CGLIB动态代理</li></ul><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>只提供接口的代理，不支持类的代理。</p><p>核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;clazz&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method.getName() + <span class="string">&quot; 你被代理了，By JDKProxy！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;JDKProxy&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_JDKProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    IUserApi userApi = JDKProxy.getProxy(IUserApi.class);</span><br><span class="line">    String invoke = userApi.queryUserInfo();</span><br><span class="line">    logger.info(<span class="string">&quot;测试结果：&#123;&#125;&quot;</span>, invoke);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p>如果目标类没有实现接口，那么Spring AOP会选择使用<code>CGLIB</code>来动态代理目标类。</p><p>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。<br>CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstall</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enhancer.create(object.getClass(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被CglibProxy代理了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_CglibProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">    UserApi userApi = (UserApi) cglibProxy.newInstall(<span class="keyword">new</span> UserApi());</span><br><span class="line">    String invoke = userApi.queryUserInfo();</span><br><span class="line">    logger.info(<span class="string">&quot;测试结果：&#123;&#125;&quot;</span>, invoke);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他代理方式-Java字节码操作框架"><a href="#其他代理方式-Java字节码操作框架" class="headerlink" title="其他代理方式 - Java字节码操作框架"></a>其他代理方式 - Java字节码操作框架</h4><h5 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h5><h5 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h5><h5 id="Byte-Buddy"><a href="#Byte-Buddy" class="headerlink" title="Byte-Buddy"></a>Byte-Buddy</h5><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。<br>真正的数据库层的事务提交和回滚是通过binlog或者redo log/undo log实现的。</p><p>Spring的核心事务管理抽象是<code>TransactionManager</code>，管理封装了一组独立于技术的方法，无论使用Spring的哪种事务管理策略（编程式或声明式），事务管理器都是必须的。</p><h3 id="事务的种类"><a href="#事务的种类" class="headerlink" title="事务的种类"></a>事务的种类</h3><h4 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h4><p>通过 TransactionTemplate或者TransactionManager手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</p><h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p>推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）。</p><h3 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h3><ul><li>隔离级别</li><li>传播行为</li><li>回滚规则</li><li>是否只读</li><li>事务超时</li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><h4 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h4><h4 id="是否只读"><a href="#是否只读" class="headerlink" title="是否只读"></a>是否只读</h4><h4 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h4><h3 id="Transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a>@Transactional 注解使用详解</h3><h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><ul><li>方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。</li><li>类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li><li>接口 ：不推荐在接口上使用。</li></ul><h4 id="常用配置参数"><a href="#常用配置参数" class="headerlink" title="常用配置参数"></a>常用配置参数</h4><ul><li>propagation 事务的传播行为，默认值为 REQUIRED</li><li>isolation 事务的隔离级别，默认值采用 DEFAULT</li><li>timeout 事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li><li>readOnly 指定事务是否为只读事务，默认值为 false。</li><li>rollbackFor 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</li></ul><h4 id="Transactional事务注解原理"><a href="#Transactional事务注解原理" class="headerlink" title="@Transactional事务注解原理"></a>@Transactional事务注解原理</h4><p><code>@Transactional</code>的工作机制是基于AOP实现的，Spring AOP又是使用动态代理实现的。<br>如果目标对象实现了接口，默认情况下会采用JDK的动态代理，如果目标对象没有实现接口，会使用CGLIB动态代理。</p><p><code>createAopProxy()</code>决定了是使用 JDK 还是 CGLIB 来做动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line"><span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类或者一个类中的 public 方法上被标注 @Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。<br>这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p><h4 id="Spring-AOP自调用问题"><a href="#Spring-AOP自调用问题" class="headerlink" title="Spring AOP自调用问题"></a>Spring AOP自调用问题</h4><p>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有 @Transactional 注解的方法的事务会失效。</p><p>这是由于 Spring AOP 代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring事务管理才生效。</p><p>MyService 类中的method1()调用method2()就会导致method2()的事务失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     method2();</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法就是避免同一类中自调用或者使用AspectJ静态代理取代Spring AOP代理。</p><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引原理及慢查询优化</title>
      <link href="/2019/11/22/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2019/11/22/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>基于MySQL InnoDB</p><p>索引对查询的速度有着至关重要的的影响，理解索引也是进行数据库性能调优的起点。<br>索引就是提高数据查询的效率的一种数据结构。</p><h2 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h2><h3 id="索引目的"><a href="#索引目的" class="headerlink" title="索引目的"></a>索引目的</h3><p>索引的目的在于提高查询效率。</p><p>可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。<br>如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p><h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。<br>它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p><p>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。</p><p>数据库应该选择怎么样的方式来应对所有的问题呢？<br>我们回想字典的例子，能不能把数据分成段，然后分段查询呢？<br>最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。<br>但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。</p><p>但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p><h3 id="磁盘IO与预读"><a href="#磁盘IO与预读" class="headerlink" title="磁盘IO与预读"></a>磁盘IO与预读</h3><p>前面提到了访问磁盘，那么这里先简单介绍一下磁盘IO和预读。</p><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。<br>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；<br>旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；<br>传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</p><p>那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p><p>下图是计算机硬件延迟的对比图，供大家参考：<br><a href="mysql-index-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%BB%B6%E8%BF%9F%E5%AF%B9%E6%AF%94%E5%9B%BE"></a></p><p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为<code>局部预读性原理</code>告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。<br>每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。<br>那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？<br>就这样，b+树应运而生。</p><h2 id="MySQL为什么使用B-TRee"><a href="#MySQL为什么使用B-TRee" class="headerlink" title="MySQL为什么使用B+TRee"></a>MySQL为什么使用B+TRee</h2><p>文件系统及数据库系统普通采用<code>B-/+Tree</code>作为索引结构。<br>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。<br>这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。<br>换句话说，<code>索引的结构要尽量减少查找过程中磁盘I/O的存取次数</code>。</p><h3 id="B树-VS-B-树"><a href="#B树-VS-B-树" class="headerlink" title="B树 VS B+树"></a>B树 VS B+树</h3><ul><li>B树<ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li></ol></li><li>B+树<ol><li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)。B+树只有叶子节点保存了data，时间复杂度固定为 O(log n)。</li><li>为所有叶子结点增加了一个链指针</li></ol></li></ul><h4 id="InnoDB-B-树的存储结构"><a href="#InnoDB-B-树的存储结构" class="headerlink" title="InnoDB B+树的存储结构"></a>InnoDB B+树的存储结构</h4><p>B+树的叶子节点和非叶子节点的大小为一页，16K。</p><ul><li>叶子节点存放<code>数据</code>，非叶子节点存放<code>指针和键值</code></li><li>主键索引：叶子节点存放真正的数据</li><li>二级索引：叶子节点存放主键索引的值</li></ul><p><img src="/2019/11/22/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/innodb-b+.jpg"></p><h4 id="B-树如何检索记录"><a href="#B-树如何检索记录" class="headerlink" title="B+树如何检索记录"></a>B+树如何检索记录</h4><ul><li>首先找到根页，你怎么知道一张表的根页在哪呢？</li><li>其实每张表的根页位置在表空间文件中是固定的，即上图中page number=3的页</li><li>找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中</li><li>然后再去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录</li></ul><p>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据。</p><h3 id="MySQL-InnoDB存储引擎中B-树一个节点有多大？一千万条数据，B-树多高？"><a href="#MySQL-InnoDB存储引擎中B-树一个节点有多大？一千万条数据，B-树多高？" class="headerlink" title="MySQL InnoDB存储引擎中B+树一个节点有多大？一千万条数据，B+树多高？"></a>MySQL InnoDB存储引擎中B+树一个节点有多大？一千万条数据，B+树多高？</h3><h4 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h4><ol><li>数据持久化存储磁盘里，磁盘的最小单元是扇区，一个扇区的大小是 512个字节</li><li>文件系统的最小单元是块，一个块的大小是 4K</li><li>InnoDB存储引擎，有自己的最小单元，称之为页，一个页的大小是 16K</li></ol><h4 id="InnoDB引擎的页大小"><a href="#InnoDB引擎的页大小" class="headerlink" title="InnoDB引擎的页大小"></a>InnoDB引擎的页大小</h4><p>InnoDB存储引擎的最小存储单位是页，页的大小为<code>16K = 16384Byte</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_page_size&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/22/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/innodb-pagesize.jpg"></p><h4 id="叶子节点可以存放多少行数据"><a href="#叶子节点可以存放多少行数据" class="headerlink" title="叶子节点可以存放多少行数据"></a>叶子节点可以存放多少行数据</h4><p>单个叶子节点（也就是一页）的大小为16K。<br>一行记录的数据大小为数据表各字段的大小的和，假设为1K，叶子结点一页可以存放16行记录。</p><h4 id="非叶子节点可以存放多少指针"><a href="#非叶子节点可以存放多少指针" class="headerlink" title="非叶子节点可以存放多少指针"></a>非叶子节点可以存放多少指针</h4><p>单个非叶子节点的大小也为一页，16K。<br>非叶子节点存储<code>指针和键值</code>，假设主键为bigint类型，长度为8字节，指针大小在InnoDB中的大小为6字节，指针+键值一共14字节。<br>一个页中能够存放<code>16384 / 14 = 1170</code>个单元，这也是指针的个数。</p><h4 id="一颗B-树可以存放多少行记录"><a href="#一颗B-树可以存放多少行记录" class="headerlink" title="一颗B+树可以存放多少行记录"></a>一颗B+树可以存放多少行记录</h4><p>假设树高为k，B+树可存储的记录行数 = （非叶子节点的指针个数）的k-1次方 * 叶子节点的记录行数。</p><p>一行记录的数据大小为数据表各字段的大小的和，假设为1K；主键类型假设为bigint，长度为8字节。<br>三层高的B+树可以存储的记录行数为<code>1170 * 1170 * 16 = 21902400</code>，千万级。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="主键索引-VS-唯一索引-VS-普通索引"><a href="#主键索引-VS-唯一索引-VS-普通索引" class="headerlink" title="主键索引 VS 唯一索引 VS 普通索引"></a>主键索引 VS 唯一索引 VS 普通索引</h3><p>同一个叶子节点(大小为一个内存页或磁盘页，MySQL一页16KB)内的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到<code>装载因子(InnoDB默认为15/16)</code>，则开辟一个新的页(节点)。</p><ul><li><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。<br>这样就会形成一个紧凑的索引结构，近似顺序填满。<br>由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p></li><li><p>如果使用非自增主键(如果身份证号或uuid等)，由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置<br>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，<br>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，<br>后续不得不通过OPTIMIZE TABLE语句来重建表并优化填充页面。因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p></li></ul><h3 id="聚簇索引-VS-非聚簇索引"><a href="#聚簇索引-VS-非聚簇索引" class="headerlink" title="聚簇索引 VS 非聚簇索引"></a>聚簇索引 VS 非聚簇索引</h3><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>当某个索引的索引列覆盖了select的所有字段时，会使用到覆盖索引。<br>覆盖索引能够只通过索引就获取到所需要的数据而不需要在回表一条条的查询，同时由于索引是有顺序的，这样对于I/O密集型的范围查询效率也很高。</p><p>但是，往往我们很少能够遇到覆盖索引的情况，一般情况都是select的列会多于索引列，这样就无法使用到覆盖索引。</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引条件下推（Index Condition Pushdown，ICP），就是过滤的动作由下层的存储引擎层通过使用索引来完成，而不需要上推到Server层进行处理。<br>ICP是在 MySQL5.6 之后完善的功能，它能减少回表查询次数，提高查询效率。</p><p>MySQL Server层负责SQL语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。<br>索引下推的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。</p><p>索引下推一定是在<strong>联合索引</strong>的情况下，根据联合索引本身就有的数据直接做一次过滤，而不用再进行多次无用的回表再到Server层进行过滤。</p><h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><h3 id="建索引的原则"><a href="#建索引的原则" class="headerlink" title="建索引的原则"></a>建索引的原则</h3><ol><li><p>最左前缀匹配原则<br> mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配。<br> 比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p></li><li><p>=和in可以乱序<br> 比如<code>a = 1 and b = 2 and c = 3</code>，建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p></li><li><p>尽量选择区分度高的列作为索引<br> 区分度的公式是<code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少。<br> 唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0。<br> 那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p></li><li><p>索引列不能参与计算，保持列“干净”<br> 比如<code>from_unixtime(create_time) = ’2014-05-29’</code>就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</p></li><li><p>尽量的扩展索引，不要新建索引<br> 比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p></li></ol><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li><code>or</code>会导致索引失效，但是单列索引是有效的</li><li>不符合左前缀原则会失效</li><li>模糊查询%开头会导致失效</li><li>隐式类型转换会导致失效</li><li>条件中使用函数会失效</li><li>IN肯定会走索引，但是当IN的取值范围较大时会导致索引失效，走全表扫描</li></ul><h3 id="如何定位并优化慢查询sql"><a href="#如何定位并优化慢查询sql" class="headerlink" title="如何定位并优化慢查询sql"></a>如何定位并优化慢查询sql</h3><ul><li>第一步根据慢日志定位慢查询sql。慢日志是用来记录执行比较慢的sql。</li><li>第二步使用explain等工具分析sql。<br>  explain关键字段：rows、type、extra</li><li>第三步修改sql或者尽量让sql走索引。</li></ul><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><ul><li>id<br>  select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序：<ul><li>如果id相同，那么执行顺序从上到下</li><li>如果id不同，id值越大优先级越高，越先被执行</li></ul></li><li>select_type<br>  主要用来分辨查询的类型，是普通查询还是联合查询还是子查询<ul><li>SIMPLE    简单的 select 查询,查询中不包含子查询或者UNION</li><li>PRIMARY    查询中若包含任何复杂的子部分，最外层查询则被标记为Primary</li><li>SUBQUERY    在SELECT或WHERE列表中包含了子查询</li><li>DERIVED    在FROM列表中包含的子查询被标记为DERIVED(衍生);MySQL会递归执行这些子查询, 把结果放在临时表里。</li><li>UNION    若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</li><li>UNION RESULT    从UNION表获取结果的SELECT</li><li>DEPENDENT SUBQUERY    在SELECT或WHERE列表中包含了子查询,子查询基于外层</li><li>UNCACHEABLE SUBQUREY    无法被缓存的子查询</li></ul></li><li>table<br>  对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集<ul><li>如果是具体的表名，则表明从实际的物理表中获取数据</li><li>表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</li><li>当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</li></ul></li><li>partitions</li><li>type （2）<br>  访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下。<br>  访问的类型有很多，效率从最好到最坏依次是：<br>  <code>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code><br>  必须记住<code>const &gt; ref &gt; range &gt; index &gt; all</code>。<br>  一般情况下，得保证查询至少达到range级别，最好能达到ref。<ul><li>ALL                全表扫描</li><li>index              索引树全扫描</li><li>range              索引范围扫描，常用语&lt;,&lt;=,&gt;=,between等操作</li><li>ref                使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</li><li>eq_ref             类似ref，区别在于使用的是唯一索引，使用主键的关联查询</li><li>const/system       单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询</li><li>null               MySQL不访问任何表或索引，直接返回结果</li></ul></li><li>possible_keys<br>  显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</li><li>key （4）<br>  实际使用的索引。<br>  如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</li><li>key_len<br>  表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</li><li>ref<br>  显示索引的哪一列被使用了，如果可能的话，是一个常数</li><li>rows （1）<br>  根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好。<br>  rows是核心指标，绝大部分rows小的语句执行一定很快，所以优化语句基本上都是在优化rows。</li><li>filtered</li><li>extra （3）<br>  包含额外的信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8—Lambda表达式及函数式接口</title>
      <link href="/2019/11/07/Java8%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/11/07/Java8%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="java8新特性"><a href="#java8新特性" class="headerlink" title="java8新特性"></a>java8新特性</h3><ol><li>Lambda表达式（重要）</li><li>函数式接口</li><li>方法引用与构造器引用</li><li>stream API（重要）</li><li>接口中的默认方法和静态方法</li><li>新时间日期</li></ol><h2 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h2><h3 id="1-为什么要使用Lambda表达式"><a href="#1-为什么要使用Lambda表达式" class="headerlink" title="1.为什么要使用Lambda表达式"></a>1.为什么要使用Lambda表达式</h3><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)，可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使得java的语言表达能力得到提升。<br>Lambda表达式需要函数式接口的支持，接口中只有一个抽象方法的接口叫做函数式接口，使用@FunctionalInterface修饰，来检查是否是函数式接口。</p><h3 id="2-Lambda表达式基础语法"><a href="#2-Lambda表达式基础语法" class="headerlink" title="2.Lambda表达式基础语法"></a>2.Lambda表达式基础语法</h3><p>java8中新增了一个操作符，“-&gt;”箭头表达式，也叫Lambda操作符。<br>Lambda表达式左侧为Lambda表达式的参数列表，右侧为操作步骤与逻辑，也叫Lambda体。</p><ol><li>无参数，无返回值（ () -&gt; 接口的功能 ）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 语法一：无参数，无返回值（（）-&gt; 执行的代码 ）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//java8实现Runnable方法</span></span><br><span class="line">    Runnable run = () -&gt; System.out.println(<span class="string">&quot;Hello Lambda&quot;</span>);</span><br><span class="line">    run.run();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//java8以前得写法</span></span><br><span class="line">    Runnable run1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    run1.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一个参数，无返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 语法二：一个参数，无返回值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Consumer&lt;String&gt; t1 = (x) -&gt; System.out.println(x);</span><br><span class="line">      t1.accept(<span class="string">&quot;Hello Lambda&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有一个参数，小括号可以不写</span></span><br><span class="line">      Consumer&lt;String&gt; t2 = x -&gt; System.out.println(x);</span><br><span class="line">      t2.accept(<span class="string">&quot;Hello Lambda&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>多个参数，多条语句，有返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语法三：多个参数，多条语句，有返回值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(y);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(com.compare(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多个参数，一条语句，有返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语法四：多个参数，一条语句，有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只有一条语句与返回值时，大括号和return都可以省略</span></span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(com.compare(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Lambda表达式的参数列表可以不用写，因为JVM编译器可以通过上下文推断出类型，即“类型推断”。</li></ol><h3 id="3-Lambda表达式需要“函数式接口”的支持"><a href="#3-Lambda表达式需要“函数式接口”的支持" class="headerlink" title="3.Lambda表达式需要“函数式接口”的支持"></a>3.Lambda表达式需要“函数式接口”的支持</h3><p>函数式接口：接口中只有一个抽象方法时，那么这个接口叫做函数式接口。函数式接口可以使用@FunctionalInterface修饰，jvm会自动检查该接口是否为函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@FunctionalInterface</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">myLambdaModle</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(T t1, T t2)</span></span>;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myTest</span><span class="params">(<span class="keyword">int</span> o1, <span class="keyword">int</span> o2, myLambdaModle&lt;Integer&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> m.test(o1, o2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两个数进行运算</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum1 = myTest(<span class="number">3</span>, <span class="number">6</span>, (x, y) -&gt; x*y);</span><br><span class="line">       <span class="keyword">int</span> sum2 = myTest(<span class="number">3</span>, <span class="number">6</span>, (x, y) -&gt; x-y);</span><br><span class="line">       <span class="keyword">int</span> sum3 = myTest(<span class="number">3</span>, <span class="number">6</span>, (x, y) -&gt; x+y);</span><br><span class="line">       <span class="keyword">int</span> sum4 = myTest(<span class="number">3</span>, <span class="number">6</span>, (x, y) -&gt; x/y);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="二、四大内置核心函数式接口"><a href="#二、四大内置核心函数式接口" class="headerlink" title="二、四大内置核心函数式接口"></a>二、四大内置核心函数式接口</h2><h3 id="1-Consumer：消费型接口-void-accept-T-t"><a href="#1-Consumer：消费型接口-void-accept-T-t" class="headerlink" title="1.Consumer：消费型接口( void accept(T t) )"></a>1.Consumer<T>：消费型接口( void accept(T t) )</T></h3><p>消费型接口，有参数，无返回值类型的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费型接口Consumer&lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    consumo(<span class="number">500</span>, (x) -&gt; System.out.println(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumo</span> <span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; c)</span> </span>&#123;</span><br><span class="line">    c.accept(money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Supplier：供给型接口-T-get"><a href="#2-Supplier：供给型接口-T-get" class="headerlink" title="2.Supplier：供给型接口( T get() )"></a>2.Supplier<T>：供给型接口( T get() )</T></h3><p>供给类型的接口，只有产出，没有输入(只有返回值，没有入参)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 供给型接口，Supplier&lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">    List&lt;Integer&gt; list = supplier(<span class="number">10</span>, () -&gt; ran.nextInt(<span class="number">10</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机产生sum个数量得集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sum 集合内元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sup</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">supplier</span><span class="params">(<span class="keyword">int</span> sum, Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">        list.add(sup.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Function-lt-T-R-gt-：函数型接口-R-apply-T-t"><a href="#3-Function-lt-T-R-gt-：函数型接口-R-apply-T-t" class="headerlink" title="3.Function&lt;T, R&gt;：函数型接口( R apply(T t) )"></a>3.Function&lt;T, R&gt;：函数型接口( R apply(T t) )</h3><p>函数型接口，输入一个类型的参数，输出一个类型的参数，两种类型可以一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数型接口：Function&lt;R, T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    String s = strOperar(<span class="string">&quot; asdf &quot;</span>, x -&gt; x.substring(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    String s1 = strOperar(<span class="string">&quot; asdf &quot;</span>, x -&gt; x.trim());</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 需要处理得字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fun Function接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 处理之后得字符传</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">strOperar</span><span class="params">(String str, Function&lt;String, String&gt; fun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Predicate：断言型接口-boolean-test-T-t"><a href="#4-Predicate：断言型接口-boolean-test-T-t" class="headerlink" title="4.Predicate：断言型接口( boolean test(T t) )"></a>4.Predicate<T>：断言型接口( boolean test(T t) )</T></h3><p>断言型接口，输入一个参数，输出一个boolean类型的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断言型接口：Predicate&lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    l.add(<span class="number">102</span>);</span><br><span class="line">    l.add(<span class="number">172</span>);</span><br><span class="line">    l.add(<span class="number">13</span>);</span><br><span class="line">    l.add(<span class="number">82</span>);</span><br><span class="line">    l.add(<span class="number">109</span>);</span><br><span class="line">    List&lt;Integer&gt; list = filterInt(l, x -&gt; (x &gt; <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pre</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">filterInt</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pre)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.test(integer))</span><br><span class="line">            l.add(integer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2019/09/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/09/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程间的五种通讯方式"><a href="#进程间的五种通讯方式" class="headerlink" title="进程间的五种通讯方式"></a>进程间的五种通讯方式</h4><ol><li>管道pipe</li><li>FIFO(有名管道)</li><li>消息队列</li><li>信号量</li><li>共享内存</li><li>套接字socket</li><li>文件和记录锁定(UNIX中)</li></ol><h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——RabbitMQ</title>
      <link href="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/"/>
      <url>/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="消息队列发展史"><br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.jpeg" alt="主流消息队列对比"></p><h2 id="一、RabbitMQ简介"><a href="#一、RabbitMQ简介" class="headerlink" title="一、RabbitMQ简介"></a>一、RabbitMQ简介</h2><p>MQ全称是Message Queue，可以理解为消息队列的意思，简单来说就是消息以<strong>管道</strong>的方式进行传递。</p><h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><p>我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ，我们后面会一一对比这些消息队列。<br>另外，我们知道队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者发送消息1,2,3…对于消费者就会按照1,2,3…的顺序来消费。但是偶尔也会出现消息被消费的顺序不对的情况，比如某个消息消费失败又或者一个 queue 多个consumer 也会导致消息被消费的顺序不对，我们一定要保证消息被消费的顺序正确。<br>除了上面说的消息消费顺序的问题，使用消息队列，我们还要考虑如何保证消息不被重复消费？如何保证消息的可靠性传输（如何处理消息丢失的问题）？……等等问题。所以说使用消息队列也不是十全十美的，使用它也会让系统可用性降低、复杂度提高，另外需要我们保障一致性等问题。</p><p>RabbitMQ是一个实现了AMQP(Advanced Message Queuing Protocol)高级消息队列协议的消息队列服务，用Erlang语言实现的。</p><h2 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h2><p>在我们秒杀抢购商品的时候，系统会提醒我们稍等排队中，而不是页面卡死或报错给用户。<br>像这种排队结算就用到了消息队列机制，放入通道里面一个一个结算处理，而不是某个时间段突然涌入大批量的查询新增把数据库给搞宕机，所以RabbitMQ本质上起到的作用就是削峰，为业务保驾护航。<br>在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。</p><h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><ul><li><p>通过异步处理提高系统性能（削峰、减少响应所需时间）<br>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。<br>消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。<br>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，</strong>以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p></li><li><p>降低系统耦合性<br>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。<br>我们最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。<br>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<br>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。<br>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。<br>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p></li><li><p>不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。 另外，这两种消息模型是JMS提供的，AMQP协议还提供了5种消息模型。</p></li></ul><h3 id="使用消息队列带来的一些问题"><a href="#使用消息队列带来的一些问题" class="headerlink" title="使用消息队列带来的一些问题"></a>使用消息队列带来的一些问题</h3><ul><li>系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！</li><li>系统复杂性提高： 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li>一致性问题： 上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><h2 id="三、JMS对比AMQP"><a href="#三、JMS对比AMQP" class="headerlink" title="三、JMS对比AMQP"></a>三、JMS对比AMQP</h2><h3 id="3-1-JMS"><a href="#3-1-JMS" class="headerlink" title="3.1 JMS"></a>3.1 JMS</h3><h4 id="3-1-1-JMS简介"><a href="#3-1-1-JMS简介" class="headerlink" title="3.1.1 JMS简介"></a>3.1.1 JMS简介</h4><p>JMS（JAVA Message Service,java消息服务）是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。JMS（JAVA Message Service，Java消息服务）API是一个消息服务的标准或者说是规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。<br>ActiveMQ 就是基于 JMS 规范实现的。</p><h4 id="3-1-2-JMS两种消息模型"><a href="#3-1-2-JMS两种消息模型" class="headerlink" title="3.1.2 JMS两种消息模型"></a>3.1.2 JMS两种消息模型</h4><ol><li>点到点模型(P2P)<br>使用队列（Queue）作为消息通信载体；满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</li><li>发布/订阅模型(Pub/Sub)<br>发布订阅模型（Pub/Sub） 使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。</li></ol><h4 id="3-1-3-JMS五种不同的消息正文格式"><a href="#3-1-3-JMS五种不同的消息正文格式" class="headerlink" title="3.1.3 JMS五种不同的消息正文格式"></a>3.1.3 JMS五种不同的消息正文格式</h4><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p><ul><li>StreamMessage – Java原始值的数据流</li><li>MapMessage–一套名称-值对</li><li>TextMessage–一个字符串对象</li><li>ObjectMessage–一个序列化的 Java对象</li><li>BytesMessage–一个字节的数据流</li></ul><h3 id="3-2-AMQP"><a href="#3-2-AMQP" class="headerlink" title="3.2 AMQP"></a>3.2 AMQP</h3><h4 id="3-2-1-AMQP简介"><a href="#3-2-1-AMQP简介" class="headerlink" title="3.2.1 AMQP简介"></a>3.2.1 AMQP简介</h4><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。<br>RabbitMQ 就是基于 AMQP 协议实现的。</p><h4 id="3-2-2-五种消息模型"><a href="#3-2-2-五种消息模型" class="headerlink" title="3.2.2 五种消息模型"></a>3.2.2 五种消息模型</h4><ol><li>direct exchange</li><li>fanout exchange</li><li>topic exchange</li><li>headers exchange</li><li>system exchange</li></ol><h3 id="3-3-JMS对比AMQP"><a href="#3-3-JMS对比AMQP" class="headerlink" title="3.3 JMS对比AMQP"></a>3.3 JMS对比AMQP</h3><ul><li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。</li><li>JMS支持TextMessage、MapMessage等复杂的消息类型；而AMQP仅支持byte[]消息类型（复杂的类型可序列化后发送）。</li><li>由于Exchange提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而JMS仅支持队列和主题/订阅方式两种。</li></ul><h2 id="四、常见的消息队列对比"><a href="#四、常见的消息队列对比" class="headerlink" title="四、常见的消息队列对比"></a>四、常见的消息队列对比</h2><ol><li><strong>吞吐量：</strong>万级的ActiveMQ和RabbitMQ的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的RocketMQ和Kafka低一个数量级。</li><li><strong>可用性：</strong>都可以实现高可用。ActiveMQ和RabbitMQ都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。kafka也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用。</li><li><strong>时效性：</strong>RabbitMQ基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是ms级。</li><li><strong>功能支持：</strong>支持    除了Kafka，其他三个功能都较为完备。Kafka功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准。</li><li><strong>消息丢失：</strong>ActiveMQ和RabbitMQ丢失的可能性非常低，RocketMQ和Kafka理论上不会丢失。<br>总结：</li></ol><ul><li>ActiveMQ的社区算是比较成熟，但是较目前来说，ActiveMQ的性能比较差，而且版本迭代很慢，不推荐使用。</li><li>RabbitMQ在吞吐量方面虽然稍逊于Kafka和RocketMQ，但是由于它基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为RabbitMQ基于erlang开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li><li>RocketMQ阿里出品，Java系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且RocketMQ有阿里巴巴的实际业务场景的实战考验。RocketMQ社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的。</li><li>kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量。kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li></ul><p>参考：《Java工程师面试突击第1季-中华石杉老师》</p><h2 id="RabbitMQ核心概念"><a href="#RabbitMQ核心概念" class="headerlink" title="RabbitMQ核心概念"></a>RabbitMQ核心概念</h2><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。<br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/rabbitmq.jpg" alt="RabbitMQ整体模型架构"></p><h3 id="1-Producer-生产者-和Consumer-消费者"><a href="#1-Producer-生产者-和Consumer-消费者" class="headerlink" title="1. Producer(生产者)和Consumer(消费者)"></a>1. Producer(生产者)和Consumer(消费者)</h3><ul><li>Producer(生产者) :生产消息的一方（邮件投递者）</li><li>Consumer(消费者) :消费消息的一方（邮件收件人）<br>消息一般由 2 部分组成：消息头（或者说是标签 Label）和 消息体。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</li></ul><h3 id="2-Exchange-交换器"><a href="#2-Exchange-交换器" class="headerlink" title="2. Exchange(交换器)"></a>2. Exchange(交换器)</h3><p>在 RabbitMQ 中，消息并不是直接被投递到 Queue(消息队列) 中的，中间还必须经过 Exchange(交换器) 这一层，Exchange(交换器) 会把我们的消息分配到对应的 Queue(消息队列) 中。<br>Exchange(交换器) 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 Producer(生产者) ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。<br>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略：direct(默认)，fanout, topic, 和 headers，不同类型的Exchange转发消息的策略有所区别。<br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/exchange.jpg"><br>生产者将消息发给交换器的时候，一般会指定一个 RoutingKey(路由键)，用来指定这个消息的路由规则，而这个 RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。<br>RabbitMQ 中通过 Binding(绑定) 将 Exchange(交换器) 与 Queue(消息队列) 关联起来，在绑定的时候一般会指定一个 BindingKey(绑定建) ,这样 RabbitMQ 就知道如何正确将消息路由到队列了。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。<br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/bind.jpg"><br>生产者将消息发送给交换器时，需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p><h3 id="3-Queue-消息队列"><a href="#3-Queue-消息队列" class="headerlink" title="3. Queue(消息队列)"></a>3. Queue(消息队列)</h3><p>Queue(消息队列) 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。<br>RabbitMQ 中消息只能存储在 队列 中，这一点和 Kafka 这种消息中间件相反。Kafka 将消息存储在 topic（主题） 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。<br>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。<br>RabbitMQ 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p><h3 id="4-Broker-消息中间件的服务节点"><a href="#4-Broker-消息中间件的服务节点" class="headerlink" title="4. Broker(消息中间件的服务节点)"></a>4. Broker(消息中间件的服务节点)</h3><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。<br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/liucheng.jpg"></p><h3 id="5-Exchange-Types-交换器类型"><a href="#5-Exchange-Types-交换器类型" class="headerlink" title="5. Exchange Types(交换器类型)"></a>5. Exchange Types(交换器类型)</h3><ol><li>fanout：fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</li><li>direct：direct 类型的Exchange路由规则也很简单，一对一的匹配，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。<br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/direct.jpg"><br>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为”Info”或者”debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。<br>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</li><li>topic：direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：<ul><li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li><li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li><li>BindingKey 中可以存在两种特殊字符串“”和“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li></ul></li><li>headers：headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)’对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</li></ol><h3 id="6-RoutingKey-路由键-和BindingKey-绑定键"><a href="#6-RoutingKey-路由键-和BindingKey-绑定键" class="headerlink" title="6. RoutingKey(路由键)和BindingKey(绑定键)"></a>6. RoutingKey(路由键)和BindingKey(绑定键)</h3><p>RoutingKey（路由键）：用于把生成者的数据分配到交换器上；<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上；</p><h2 id="消息发送原理"><a href="#消息发送原理" class="headerlink" title="消息发送原理"></a>消息发送原理</h2><p>首先你必须连接到Rabbit才能发布和消费消息，那怎么连接和发送消息的呢？<br>你的应用程序和Rabbit Server之间会创建一个TCP连接，一旦TCP打开，并通过了认证，认证就是你试图连接Rabbit之前发送的Rabbit服务器连接信息和用户名和密码，有点像程序连接数据库，使用Java有两种连接认证的方式，后面代码会详细介绍，一旦认证通过你的应用程序和Rabbit就创建了一条AMQP信道（Channel）。<br>信道是创建在“真实”TCP上的虚拟连接，AMQP命令都是通过信道发送出去的，每个信道都会有一个唯一的ID，不论是发布消息，订阅队列或者介绍消息都是通过信道完成的。</p><h4 id="为什么不通过TCP直接发送命令？"><a href="#为什么不通过TCP直接发送命令？" class="headerlink" title="为什么不通过TCP直接发送命令？"></a>为什么不通过TCP直接发送命令？</h4><p>对于操作系统来说创建和销毁TCP会话是非常昂贵的开销，假设高峰期每秒有成千上万条连接，每个连接都要创建一条TCP会话，这就造成了TCP连接的巨大浪费，而且操作系统每秒能创建的TCP也是有限的，因此很快就会遇到系统瓶颈。<br>如果我们每个请求都使用一条TCP连接，既满足了性能的需要，又能确保每个连接的私密性，这就是引入信道概念的原因。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2019/09/16/Redis/"/>
      <url>/2019/09/16/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis，英文全称是Remote Dictionary Server（远程字典服务），Key-Value数据库。</p><p>可用于缓存，事件发布或订阅，高速队列等场景。<br>提供字符串、哈希、列表、队列、集合结构直接存取，基于内存，可持久化。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>热点数据的缓存</li><li>限时业务的运用<br>  redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。</li><li>计数器相关问题<br>  redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成。<br>  具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</li><li>分布式锁<br>  这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存，同时返回1，否则返回0 。<br>  这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。<br>  当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。<br>  在分布式锁的场景中，主要用在比如秒杀系统等。</li><li>延时操作<br>  比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。<br>  由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。<br>  所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期，我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。<br>  当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</li><li>排行榜相关问题<br>  关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。<br>  比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息。</li><li>点赞、好友等相互关系的存储<br>  Redis 利用集合的一些命令，比如求交集、并集、差集等。</li><li>简单队列<br>  由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。</li></ul><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h3 id="为什么单线程的Redis可以支持高并发访问？"><a href="#为什么单线程的Redis可以支持高并发访问？" class="headerlink" title="为什么单线程的Redis可以支持高并发访问？"></a>为什么单线程的Redis可以支持高并发访问？</h3><ul><li>为什么Redis选择单线程的实现方式<ol><li>redis是基于内存的，内存的读写速度非常快。CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽；</li><li>核心是基于非阻塞的IO多路复用机制；</li><li>redis是单线程的，反而省去了很多上下文切换线程的时间，避免了多线程的实现复杂度；</li></ol></li><li>为什么Redis能支持高并发访问<br>  从IO模型角度来说，Redis使用的是IO多路复用模型，使得它可以在网络IO操作并发处理数十万的客户端网络连接，实现非常高的网络吞吐率。<br>  这也是Redis可以实现高并发访问的最主要的原因。</li></ul><h2 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h2><h3 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h3><p>所谓redis的并发竞争key的问题也就是多个系统同时对一个key进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。</p><p>解决方案：分布式锁(zookeeper和redis都可以实现分布式锁)。如果不存在redis的并发竞争key问题，不要使用分布式锁，这样会影响性能。</p><p>基于zookeeper临时有序节点可以实现的分布式锁。<br>大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务器宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>只要使用缓存，就可能会涉及到缓存与数据库双存储双写，只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话(缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案)，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。<br>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><h2 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h2><p>Redis内部使用<code>文件事件处理器 file event handler</code>，这个文件事件处理器是<code>单线程</code>的，所以redis才叫做单线程的模型。<br>Redis的线程模型是基于单Reactor单线程模型实现。</p><p><img src="/2019/09/16/Redis/redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png"></p><p>文件事件处理器的结构包含4个部分：</p><ul><li>多个socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)</li></ul><p>文件事件处理器采用<code>IO多路复用机制</code>同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。<br>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h3 id="Redis的IO多路复用"><a href="#Redis的IO多路复用" class="headerlink" title="Redis的IO多路复用"></a>Redis的IO多路复用</h3><p>Redis的多路IO复用模型核心思想就是IO多路复用+事件派发，有事件发生了，通过事件派发器将其交给不同的处理器进行处理。</p><h3 id="Redis-6-0的多线程"><a href="#Redis-6-0的多线程" class="headerlink" title="Redis 6.0的多线程"></a>Redis 6.0的多线程</h3><p>Redis 6.0版本中引入了多线程,目的是为了提高IO读写效率,因此在解析客户端命令和写响应结果时采用了多线程。<br>核心的命令执行和IO多路复用模块依然是由主线程执行:<br><img src="/2019/09/16/Redis/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-6.0%E7%89%88%E6%9C%AC.png"></p><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><ul><li>5种基础类型<ul><li>String 字符串</li><li>Hash 哈希</li><li>List 列表</li><li>Set 集合</li><li>Sorted Set 有序集合</li></ul></li><li>3种特殊类型<ul><li>Bitmap 位图</li><li>HyperLogLog 基数统计</li><li>Geospatial 地理位置</li></ul></li><li>Stream类型 v5.0</li></ul><h3 id="五种基本数据类型"><a href="#五种基本数据类型" class="headerlink" title="五种基本数据类型"></a>五种基本数据类型</h3><p><img src="/2019/09/16/Redis/redis-5%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpeg"></p><h4 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1.String 字符串"></a>1.String 字符串</h4><blockquote><p>String是redis中最基本的数据类型，一个key对应一个value。</p></blockquote><p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><p>Redis中string(字符串)是动态字符串，允许修改,，可以对字符串进行操作，比如增加字符或者求子串：如果是整数或者浮点数，可以实现计算，比如自增等</p><p>string类型是Redis最基本的数据结构，一个redis中字符串value最多可以是512M。</p><table><thead><tr><th align="left">命令</th><th align="left">简述</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">获取存储在给定键中的值</td><td align="left">GET name</td></tr><tr><td align="left">SET</td><td align="left">设置存储在给定键中的值</td><td align="left">SET name value</td></tr><tr><td align="left">DEL</td><td align="left">删除存储在给定键中的值</td><td align="left">DEL name</td></tr><tr><td align="left">INCR</td><td align="left">将键存储的值加1</td><td align="left">INCR key</td></tr><tr><td align="left">DECR</td><td align="left">将键存储的值减1</td><td align="left">DECR key</td></tr><tr><td align="left">INCRBY</td><td align="left">将键存储的值加上整数</td><td align="left">INCRBY key amount</td></tr><tr><td align="left">DECRBY</td><td align="left">将键存储的值减去整数</td><td align="left">DECRBY key amount</td></tr></tbody></table><h4 id="2-Hash-哈希"><a href="#2-Hash-哈希" class="headerlink" title="2.Hash 哈希"></a>2.Hash 哈希</h4><blockquote><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p></blockquote><table><thead><tr><th align="left">命令</th><th align="left">简述</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">HSET</td><td align="left">添加键值对</td><td align="left">HSET hash-key sub-key1 value1</td></tr><tr><td align="left">HGET</td><td align="left">获取指定散列键的值</td><td align="left">HGET hash-key key1</td></tr><tr><td align="left">HGETALL</td><td align="left">获取散列中包含的所有键值对</td><td align="left">HGETALL hash-key</td></tr><tr><td align="left">HDEL</td><td align="left">如果给定键存在于散列中，那么就移除这个键</td><td align="left">HDEL hash-key sub-key1</td></tr></tbody></table><h4 id="3-List-列表"><a href="#3-List-列表" class="headerlink" title="3.List 列表"></a>3.List 列表</h4><blockquote><p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p></blockquote><table><thead><tr><th align="left">命令</th><th align="left">简述</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">RPUSH</td><td align="left">将给定值推入到列表右端</td><td align="left">RPUSH key value</td></tr><tr><td align="left">LPUSH</td><td align="left">将给定值推入到列表左端</td><td align="left">LPUSH key value</td></tr><tr><td align="left">RPOP</td><td align="left">从列表的右端弹出一个值，并返回被弹出的值</td><td align="left">RPOP key</td></tr><tr><td align="left">LPOP</td><td align="left">从列表的左端弹出一个值，并返回被弹出的值</td><td align="left">LPOP key</td></tr><tr><td align="left">LRANGE</td><td align="left">获取列表在给定范围上的所有值</td><td align="left">LRANGE key 0 -1</td></tr><tr><td align="left">LINDEX</td><td align="left">通过索引获取列表中的元素。也可以使用负数下标，以-1表示列表的最后一个元素，-2表示列表的倒数第二个元素，以此类推。</td><td align="left">LINDEX key index</td></tr></tbody></table><ul><li>lpush+lpop=Stack(栈)</li><li>lpush+rpop=Queue（队列）</li><li>lpush+ltrim=Capped Collection（有限集合）</li><li>lpush+brpop=Message Queue（消息队列）</li></ul><h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4.Set 集合"></a>4.Set 集合</h4><blockquote><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p></blockquote><table><thead><tr><th align="left">命令</th><th align="left">简述</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">SADD</td><td align="left">向集合添加一个或多个成员</td><td align="left">SADD key value</td></tr><tr><td align="left">SCARD</td><td align="left">获取集合的成员数</td><td align="left">SCARD key</td></tr><tr><td align="left">SMEMBERS</td><td align="left">返回集合中的所有成员</td><td align="left">SMEMBERS key member</td></tr><tr><td align="left">SISMEMBER</td><td align="left">判断 member 元素是否是集合 key 的成员</td><td align="left">SISMEMBER key member</td></tr></tbody></table><h4 id="5-Sorted-Set-有序集合"><a href="#5-Sorted-Set-有序集合" class="headerlink" title="5.Sorted Set 有序集合"></a>5.Sorted Set 有序集合</h4><blockquote><p>Redis 有序集合，和集合一样也是 string 类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p></blockquote><p>有序集合的成员是唯一的, 但分数(score)却可以重复。<br>有序集合是通过两种数据结构实现：</p><ul><li>压缩列表(ziplist):<br>  ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。<br>  它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。<br>  它能在O(1)的时间复杂度下完成list两端的push和pop操作。<br>  但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li><li>跳跃表（zSkiplist)<br>  跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。<br>  跳跃表的复杂度是O(log(n))。</li></ul><table><thead><tr><th align="left">命令</th><th align="left">简述</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">ZADD</td><td align="left">将一个带有给定分值的成员添加到有序集合里面</td><td align="left">ZADD zset-key 178 member1</td></tr><tr><td align="left">ZRANGE</td><td align="left">根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td><td align="left">ZRANGE zset-key 0-1 withccores</td></tr><tr><td align="left">ZREM</td><td align="left">如果给定元素成员存在于有序集合中，那么就移除这个元素</td><td align="left">ZREM zset-key member1</td></tr></tbody></table><h3 id="三种特殊类型"><a href="#三种特殊类型" class="headerlink" title="三种特殊类型"></a>三种特殊类型</h3><h4 id="6-Bitmaps"><a href="#6-Bitmaps" class="headerlink" title="6.Bitmaps"></a>6.Bitmaps</h4><blockquote><p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p></blockquote><h4 id="7-HyperLogLog"><a href="#7-HyperLogLog" class="headerlink" title="7.HyperLogLog"></a>7.HyperLogLog</h4><blockquote><p>Redis 2.8.9 版本更新了 Hyperloglog 数据结构！</p></blockquote><h4 id="8-Geospatial"><a href="#8-Geospatial" class="headerlink" title="8.Geospatial"></a>8.Geospatial</h4><blockquote><p>Redis 的 Geo 在 Redis 3.2 版本推出。<br>这个功能可以推算地理位置的信息: 两地之间的距离, 方圆几里的人</p></blockquote><h3 id="Stream类型"><a href="#Stream类型" class="headerlink" title="Stream类型"></a>Stream类型</h3><blockquote><p>Redis5.0中增加了一个数据类型Stream，它借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的消息队列。</p></blockquote><h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><blockquote><p>为什么需要持久化？<br>Redis是个基于内存的数据库。服务一旦宕机，内存中的数据将全部丢失。<br>通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复，1、会对数据库带来巨大的压力，2、数据库的性能不如Redis，导致程序响应慢。<br>所以对Redis来说，实现数据的持久化，避免从后端数据库中恢复数据，是至关重要的。</p></blockquote><h3 id="RDB-Redis-DataBase-持久化"><a href="#RDB-Redis-DataBase-持久化" class="headerlink" title="RDB(Redis DataBase)持久化"></a>RDB(Redis DataBase)持久化</h3><p>RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。</p><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><ul><li><p>手动触发</p><ul><li>save命令<br>  阻塞当前Redis服务器，直到RDB过程完成为止。<br>  对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</li><li>bgsave命令<br>  Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。<br>  阻塞只发生在fork阶段，一般时间很短。</li></ul></li><li><p>自动触发</p><ul><li><code>redis.conf</code>中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</li><li>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</li><li>执行debug reload命令重新加载redis时也会触发bgsave操作；</li><li>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；</li></ul></li></ul><h4 id="redis-conf中配置RDB"><a href="#redis-conf中配置RDB" class="headerlink" title="redis.conf中配置RDB"></a>redis.conf中配置RDB</h4><ul><li><p>Redis中默认的周期新设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 周期性执行条件的设置格式为</span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"># 默认的设置为：</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"># 以下设置方式为关闭RDB快照功能</span><br><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure></li><li><p>其它相关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># RDB文件在磁盘上的名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 文件保存路径</span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"># 如果持久化出错，主进程是否停止写入</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"># 是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 导入时是否检查</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure></li></ul><h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul><li>优点<ul><li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li><li>Redis加载RDB文件恢复数据要远远快于AOF方式；</li></ul></li><li>缺点<ul><li>RDB方式实时性不够，无法做到秒级的持久化；</li><li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li><li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li><li>版本兼容RDB文件问题；</li></ul></li></ul><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决</p><h3 id="AOF-append-only-file-持久化"><a href="#AOF-append-only-file-持久化" class="headerlink" title="AOF(append-only file)持久化"></a>AOF(append-only file)持久化</h3><blockquote><p>Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。<br>日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。<br>PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。</p></blockquote><p>AOF日志采用写后日志，即<code>先写内存，后写日志</code>。</p><h4 id="如何实现AOF"><a href="#如何实现AOF" class="headerlink" title="如何实现AOF"></a>如何实现AOF</h4><p>AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。</p><ul><li>命令追加<br>  当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</li><li>文件写入和同步<br>  关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：<ul><li>Always 同步写回：每个写命令执行完，立马同步地将日志写回磁盘。可靠性高，数据基本不丢失。每个写命令都要落盘，性能影响较大。</li><li>Everysec 每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘。性能适中。宕机时丢失1秒内的数据。</li><li>No 操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。性能好。宕机时丢失数据较多。<h4 id="redis-conf中配置AOF"><a href="#redis-conf中配置AOF" class="headerlink" title="redis.conf中配置AOF"></a>redis.conf中配置AOF</h4>默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># appendonly参数开启AOF持久化</span><br><span class="line">appendonly no/yes</span><br><span class="line"># AOF持久化的文件名，默认是appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"># 同步策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"># 加载aof出错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。<br>为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写机制来对AOF文件进行“瘦身”。</p><p>Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。<br><img src="/2019/09/16/Redis/redis-aof%E9%87%8D%E5%86%99.jpeg"></p><blockquote><p>AOF重写会阻塞吗？<br>AOF重写过程是由后台进程bgrewriteaof来完成的。<br>主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。<br>然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p></blockquote><p>所以aof在重写时，在fork进程时是会阻塞住主线程的。</p><blockquote><p>AOF日志何时会重写？<br>有两个配置项控制AOF重写的触发：<br><code>auto-aof-rewrite-min-size</code>:表示运行AOF重写时文件的最小大小，默认为64MB。<br><code>auto-aof-rewrite-percentage</code>:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。</p></blockquote><blockquote><p>重写日志时，有新数据写入咋整？<br>主线程fork出子进程的是如何复制内存数据的？<br>在重写日志整个过程时，主线程有哪些地方会被阻塞？<br>为什么AOF重写不复用原AOF日志？</p></blockquote><h3 id="RDB和AOF的混合持久化"><a href="#RDB和AOF的混合持久化" class="headerlink" title="RDB和AOF的混合持久化"></a>RDB和AOF的混合持久化</h3><p>Redis 4.0 中提出了一个混合使用AOF日志和内存快照的方法。<br>简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作。</p><h2 id="Redis消息传递：发布订阅模式"><a href="#Redis消息传递：发布订阅模式" class="headerlink" title="Redis消息传递：发布订阅模式"></a>Redis消息传递：发布订阅模式</h2><p>Redis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><h3 id="发布-订阅使用"><a href="#发布-订阅使用" class="headerlink" title="发布/订阅使用"></a>发布/订阅使用</h3><h4 id="基于频道-Channel-的发布-订阅"><a href="#基于频道-Channel-的发布-订阅" class="headerlink" title="基于频道(Channel)的发布/订阅"></a>基于频道(Channel)的发布/订阅</h4><h4 id="基于模式-pattern-的发布-订阅"><a href="#基于模式-pattern-的发布-订阅" class="headerlink" title="基于模式(pattern)的发布/订阅"></a>基于模式(pattern)的发布/订阅</h4><h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><h4 id="基于频道-Channel-的发布-订阅如何实现的？"><a href="#基于频道-Channel-的发布-订阅如何实现的？" class="headerlink" title="基于频道(Channel)的发布/订阅如何实现的？"></a>基于频道(Channel)的发布/订阅如何实现的？</h4><h4 id="基于模式-pattern-的发布-订阅如何实现的？"><a href="#基于模式-pattern-的发布-订阅如何实现的？" class="headerlink" title="基于模式(pattern)的发布/订阅如何实现的？"></a>基于模式(pattern)的发布/订阅如何实现的？</h4><h4 id="SpringBoot结合Redis发布-订阅实例？"><a href="#SpringBoot结合Redis发布-订阅实例？" class="headerlink" title="SpringBoot结合Redis发布/订阅实例？"></a>SpringBoot结合Redis发布/订阅实例？</h4><p><a href="https://blog.csdn.net/llll234/article/details/80966952">springboot集成redis实现消息发布订阅模式-双通道</a></p><h2 id="Redis事件"><a href="#Redis事件" class="headerlink" title="Redis事件"></a>Redis事件</h2><blockquote><p>Redis 采用事件驱动机制来处理大量的网络IO。<br>它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。</p></blockquote><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><blockquote><p>Redis 事务的本质是一组命令的集合。<br>事务支持一次执行多个命令，一个事务中所有命令都会被序列化。<br>在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p></blockquote><h3 id="Redis事务相关命令和使用"><a href="#Redis事务相关命令和使用" class="headerlink" title="Redis事务相关命令和使用"></a>Redis事务相关命令和使用</h3><ul><li>MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li><li>EXEC：执行事务中的所有操作命令。</li><li>DISCARD：取消事务，放弃执行事务块中的所有命令。</li><li>WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li><li>UNWATCH：取消WATCH对所有key的监视。<h4 id="CAS操作实现乐观锁"><a href="#CAS操作实现乐观锁" class="headerlink" title="CAS操作实现乐观锁"></a>CAS操作实现乐观锁</h4></li></ul><h2 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><h3 id="高可扩展-分片技术"><a href="#高可扩展-分片技术" class="headerlink" title="高可扩展-分片技术"></a>高可扩展-分片技术</h3><h2 id="缓存并发问题"><a href="#缓存并发问题" class="headerlink" title="缓存并发问题"></a>缓存并发问题</h2><h3 id="数据库和缓存一致性"><a href="#数据库和缓存一致性" class="headerlink" title="数据库和缓存一致性"></a>数据库和缓存一致性</h3><h4 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h4><blockquote><p>更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching</p></blockquote><p>Cache Aside Pattern</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，先更新数据库，然后再删除缓存。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>是什么：缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决办法：</p><ul><li>事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li><li>事中：本地ehcache+hystrix限流&amp;降级，避免mysql崩掉</li><li>事后：利用redis持久化机制保存的数据尽快恢复缓存</li></ul><p><img src="/2019/09/16/Redis/huancunxuebeng.jpg"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>是什么：一般是黑客故意去请求缓存和数据库中都不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决办法：</p><ul><li>采用布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li><li>缓存空结果：如果一个查询返回的数据为空(不管是数据不存在，还是系统故障)，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿，是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这是由于并发用户特别多，同时读缓存没读到数据(并发查询同一条数据)，又同时去数据库去数据，引起数据库压力瞬间增大，造成过大压力。</p><p>解决方案：</p><ul><li>设置热点数据，永远不过期</li><li>加互斥锁。</li></ul><h3 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h3><p>缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。</p><p>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。<br>缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。<br>这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</p><h4 id="最大缓存设置"><a href="#最大缓存设置" class="headerlink" title="最大缓存设置"></a>最大缓存设置</h4><p>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置缓存大小为4G</span><br><span class="line">CONFIG SET maxmemory 4gb</span><br></pre></td></tr></table></figure><h4 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h4><ul><li>不淘汰 <ul><li>noeviction （v4.0后默认的）</li></ul></li><li>对设置了过期时间的数据中进行淘汰 <ul><li>随机：volatile-random</li><li>ttl：volatile-ttl 移除即将过期的键值对</li><li>lru：volatile-lru 移除最近最少使用的键值对 跟使用的最后一次时间有关，淘汰最近使用时间离现在最久的</li><li>lfu：volatile-lfu 移除最近最不频繁使用的键值对 跟使用的次数有关，淘汰使用次数最少的</li></ul></li><li>全部数据进行淘汰 <ul><li>随机：allkeys-random</li><li>lru：allkeys-lru</li><li>lfu：allkeys-lfu</li></ul></li></ul><h2 id="版本特性"><a href="#版本特性" class="headerlink" title="版本特性"></a>版本特性</h2><h3 id="4-0"><a href="#4-0" class="headerlink" title="4.0"></a>4.0</h3><h3 id="5-0"><a href="#5-0" class="headerlink" title="5.0"></a>5.0</h3><h3 id="6-0"><a href="#6-0" class="headerlink" title="6.0"></a>6.0</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令总结</title>
      <link href="/2019/08/21/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/21/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器ip、端口连通情况"><a href="#服务器ip、端口连通情况" class="headerlink" title="服务器ip、端口连通情况"></a>服务器ip、端口连通情况</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>ping出域名对应的服务器ip</p><h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><p>telnet ip port</p><h4 id="nc-vz-w2-ip-port"><a href="#nc-vz-w2-ip-port" class="headerlink" title="nc -vz -w2 ip port"></a>nc -vz -w2 ip port</h4><p>mac测试远程端口是否正常，netcat</p><h2 id="linux性能监控命令"><a href="#linux性能监控命令" class="headerlink" title="linux性能监控命令"></a>linux性能监控命令</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>可以实时显示系统中各个进程的占用情况。<br><img src="/2019/08/21/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/top.png"><br>上部分列出了系统整体的统计信息：任务、CPU、内存、交换区等信息。<br>下部分列出进程的详细情况。</p><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>可以查看系统负载。显示的和top命令第一行一样。<br><img src="/2019/08/21/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/uptime.png"></p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看所有进程<br><img src="/2019/08/21/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/ps.png"></p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>全局正则表达式文本</p><h4 id="ps-ef"><a href="#ps-ef" class="headerlink" title="ps -ef"></a>ps -ef</h4><p>用标准格式显示进程</p><h4 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps aux"></a>ps aux</h4><p>用BSD格式来显示进程</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>这个命令用来查看当前建立的网络连接(深刻理解netstat每一项代表的含义)。最经典的案例就是查看本地系统打开了哪些端口：<br><img src="/2019/08/21/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/netstat.png"></p><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>可以用来监控虚拟内存。可对操作系统的虚拟内存、IO、CPU等多个指标的整体情况进行监视。<br><img src="/2019/08/21/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/vmstat.png"></p><h4 id="内存方面："><a href="#内存方面：" class="headerlink" title="内存方面："></a>内存方面：</h4><p>swpd：已经使用的交换内存（kb）<br>free：空闲的物理内存（kb）<br>buff：用作缓冲区的内存数（kb）<br>cache：用作高速缓存的内存数（kb）<br>si、so 两列，表示磁盘和内存之间交换的频繁程度。<br>分析思路：<br>如果 si、so 数值长期很大并且free长期很小，表示物理内存不能满足需要，也就是内存不足。由于磁盘的性能比内存是慢很多的，所以如果存在大量的页面交换，那么系统的性能必然会受到很大影响。</p><h4 id="CPU方面："><a href="#CPU方面：" class="headerlink" title="CPU方面："></a>CPU方面：</h4><p>r：展示了正在执行和等待cpu资源的任务个数。当这个值超过了cpu个数，就会出现cpu瓶颈。<br>us：用户CPU时间。<br>sy：系统CPU时间。<br>id：空闲CPU时间。<br>wa：等等I/O CPU时间。<br>us+sy+id+wa=100%<br>分析思路：<br>如果 r 经常大于4，且id经常小于40，表面CPU的负荷很重。</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>可以用来观察内存使用情况。<br><img src="/2019/08/21/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/free.png"><br>total= used + free<br>分析思路：<br>当 –/+ buffers/cache中的free长时间接近0，且 swap used长时间比较大时，说明物理内存已经不够用了，需要升级内存或降低内存的使用量。</p><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>可以用来监控磁盘I/O的情况。<br><img src="/2019/08/21/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/iostat.png"></p><h3 id="磁盘命令"><a href="#磁盘命令" class="headerlink" title="磁盘命令"></a>磁盘命令</h3><h4 id="df-（disk-free）"><a href="#df-（disk-free）" class="headerlink" title="df （disk free）"></a>df （disk free）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-a：全部文件系统列表，包含虚拟文件系统</span><br><span class="line">-B：指定显示scale size，比如以M，G为单位显示</span><br><span class="line">-h：方便人阅读方式显示。</span><br><span class="line">-H：和-h相似，不过其中1k = 1000byte， 1M=1000k</span><br><span class="line">-i：列出inode的信息</span><br><span class="line">-k ：区块为1024字节</span><br><span class="line">-l ：显示本地文件系统</span><br><span class="line">-p：使用POSIX规范输出</span><br><span class="line">-t：打印指定的文件系统类型</span><br><span class="line">-T：显示文件系统类型</span><br><span class="line">-x：不打印指定的文件系统类型</span><br></pre></td></tr></table></figure><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-l 列出素所有分区表</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2019/07/24/MySQL/"/>
      <url>/2019/07/24/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-Server体系结构"><a href="#MySQL-Server体系结构" class="headerlink" title="MySQL Server体系结构"></a>MySQL Server体系结构</h2><p><img src="/2019/07/24/MySQL/mysql-server-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p><h2 id="一条SQL的执行过程"><a href="#一条SQL的执行过程" class="headerlink" title="一条SQL的执行过程"></a>一条SQL的执行过程</h2><h3 id="MySQL中一条SQL是如何执行的"><a href="#MySQL中一条SQL是如何执行的" class="headerlink" title="MySQL中一条SQL是如何执行的"></a>MySQL中一条SQL是如何执行的</h3><p>大致过程如下：<br>SQL ==&gt; 查询缓存 ==&gt; 解析器 ==&gt; 优化器 ==&gt; 执行器</p><ul><li>客户端SQL发送到MySQL服务端，首先会去查询缓存里面查找，如果多次执行同一个SQL是会命中缓存中，此时直接通过缓存来取数据</li><li>若没有命中查询缓存，则将SQL发送给解析器，解析器会对SQL进行语法、语义分析，同时也会对SQL合法性进行校验</li><li>SQL语义解析出来后，优化器会对SQL语义进行优化，比如，是走索引还是全表扫描，优化器会根据实际情况来确定一个最优的执行方案（当然，不一定是最优的，只是给出MySQL认为是最优的执行方案）</li><li>优化完毕后，就给到执行器（调用具体某个存储引擎，例如innodb）进行执行SQL，取出SQL执行结果</li><li>最后将执行结果返回给客户端</li></ul><h3 id="准备更新一条数据到事务的提交的流程描述"><a href="#准备更新一条数据到事务的提交的流程描述" class="headerlink" title="准备更新一条数据到事务的提交的流程描述"></a>准备更新一条数据到事务的提交的流程描述</h3><p>从准备更新一条数据到事务的提交的流程描述</p><ul><li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li><li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li><li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li><li>完成以后就可以提交事务，在提交的同时会做以下三件事 <ul><li>将redo log buffer中的数据刷入到 redo log 文件中</li><li>将本次操作记录写入到 bin log文件中</li><li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li></ul></li><li>至此表示整个更新事务已经完成</li></ul><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>一个库中可以有多个不同存储引擎的表。</p><p>InnoDB和MyISAM数据库的表的结构定义信息都存储在frm文件中。<br>InnoDB的数据和索引存储在ibd文件中（聚集），MyISAM索引存在MYI文件中，数据存储在MYD文件中（非聚集）。  </p><h3 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h3><p>若一个主键被定义，该主键则作为密集索引；<br>若没有主键被定义，该表的第一个唯一非空索引则作为密集索引；<br>若不满足以上条件，innoDB内部会生成一个隐藏主键(rowid，密集索引，该主键是一个六字节的列，该列的值随着记录的插入而自增)。</p><p>即innoDB必须得有一个主键作为密集索引存在，innodb引擎里的主键一般都是聚集索引；<br>非主键索引都是非聚集索引，非主键索引存储相关键位和其对应的主键值，要进行两次查找(先通过非主键索引去查找主键索引，再通过主键索引去查找数据的物理地址)。</p><p>InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如updatetable set num=1 where name like “a%”，就是说在不确定的范围时，InnoDB还是会锁表的。<br>InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM索引结构: MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。<br>B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。<br>主键索引和其他索引没有任何区别, 都是稀疏索引, 表数据存储在独立的地方MYD, 表数据MYD和索引MYI的分开的, 索引用地址指向表数据。</p><h3 id="两者的对比"><a href="#两者的对比" class="headerlink" title="两者的对比"></a>两者的对比</h3><ol><li>是否支持行级锁；</li><li>是否支持事务和崩溃后的安全恢复<br> MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。<br> InnoDB提供事务支持、外部键等高级数据库功能。</li><li>是否支持外键；</li><li>是否支持MVCC<br> 仅InnoDB支持。<br> 应对高并发事务，MVCC比单纯的加锁更高效；<br> MVCC只在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>两个隔离级别下工作；<br> MVCC可以使用乐观锁和悲观锁来实现；<br> 各数据库中MVCC实现并不统一。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</span><br></pre></td></tr></table></figure></li></ol><h2 id="MySQL-InnoDB存储引擎体系结构"><a href="#MySQL-InnoDB存储引擎体系结构" class="headerlink" title="MySQL InnoDB存储引擎体系结构"></a>MySQL InnoDB存储引擎体系结构</h2><p><img src="/2019/07/24/MySQL/mysql-innodb-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"><br><img src="/2019/07/24/MySQL/mysql-innodb-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%842.png"></p><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><p>原子性（atomicity，或称不可分割性）<br>一致性（consistency）<br>隔离性（isolation，又称独立性）<br>持久性（durability）</p><h3 id="标准事务的隔离级别"><a href="#标准事务的隔离级别" class="headerlink" title="标准事务的隔离级别"></a>标准事务的隔离级别</h3><ul><li><p>读未提交 read-uncommitted<br>  允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p>  事务对当前被读取的数据不加锁；<br>  事务在更新某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放。</p></li><li><p>读已提交 read-committed<br>  允许读取并发事务已经提交过的数据，可以防止脏读，但是幻读或不可重复读仍有可能发生。</p><p>  事务对当前被读取的数据加行级共享锁（当读到时才加锁），一旦读完该行，立即释放；<br>  事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放。</p><p>  Oracle/SQLserver的默认隔离级别是read committed，是允许幻读和不可重复读存在的。<br>  MySQL InnoDB在RC级别通过快照读解决了不可重复读问题。</p></li><li><p>可重复读 repeatable-read<br>  对同一数据记录的多次读取结果都是一致的，除非是被本身事务自己所修改，可以防止脏读和不可重复读，但幻读仍有可能发生。</p><p>  事务在读取某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放；<br>  事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放。</p><p>  MySQL InnoDB默认隔离级别是RR，在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。</p></li><li><p>串行化 serializable<br>  最高的隔离级别，完全服从ACID的隔离级别。<br>  所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。</p><p>  事务在读取数据是，必须先对其加表级共享锁，直到事务结束才释放；<br>  事务在更新数据时，必须先对其加表级排他锁，知道事务结束才释放。</p></li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h3><ul><li><p>脏读 dirty read<br>  当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”。</p></li><li><p>不可重复读 unrepeatable read<br>  一个事务对同一数据的读取结果前后不一致。<br>  与脏读的区别在于，脏读的是另一事务未提交的数据，不可重复读的是另一事务已经提交的数据，只不过数据被其他事务修改过。</p><p>  事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p></li><li><p>幻读 phantom read<br>  事务读取某个范围的数据时，因为其他事务的insert操作导致前后两次读取的结果不一致。<br>  幻读和不可重复读的区别在于，不可重复读是针对确定的某一行数据而言，而幻读是针对不确定的多行数据，因此幻读通常出现在带有查询条件的范围查询中。<br>  一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询不存在的行。</p><p>  系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p></li><li><p>更新丢失(Lost Update)或脏写<br>  当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。</p></li></ul><h3 id="事务并发场景"><a href="#事务并发场景" class="headerlink" title="事务并发场景"></a>事务并发场景</h3><ul><li>读读情况<br>  并发事务相继读取相同记录，允许发生。</li><li>读-写或写-读情况<br>  读-写或写-读，即一个事务进行读取操作，另一个进行改动操作。<br>  这种情况下可能发生脏读、不可重复读、幻读的问题。</li><li>写写情况<br>  这种情况会出现脏写的问题，任何一种隔离级别都不允许这种问题的发生，是通过加锁来实现的。</li></ul><h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>怎么解决脏读、不可重复读、幻读的问题，有两种解决方案。</p><ul><li>方案一：读操作利用多版本并发控制(MVCC)，写操作进行加锁</li><li>方案二：读写操作都采用加锁的方法</li></ul><p>MySQL的InnoDB存储引擎默认事务隔离级别是<code>RR(可重复读)</code>，是通过 <code>next-key锁 + MVCC</code>一起实现的，正常读的时候不加锁，写的时候加锁。</p><h2 id="MySQL-InnoDB事务原理"><a href="#MySQL-InnoDB事务原理" class="headerlink" title="MySQL InnoDB事务原理"></a>MySQL InnoDB事务原理</h2><h3 id="MySQL-InnoDB事务特性实现"><a href="#MySQL-InnoDB事务特性实现" class="headerlink" title="MySQL InnoDB事务特性实现"></a>MySQL InnoDB事务特性实现</h3><ul><li>A-原子性；原子性通过undo log实现；</li><li>C-一致性；通过原子性、隔离性、持久性实现的；</li><li>I-隔离性；隔离级别，通过MVCC + 锁实现；</li><li>D-持久性；持久性通过redo log实现；</li></ul><h3 id="MySQL-InnoDB的事务隔离级别的实现原理"><a href="#MySQL-InnoDB的事务隔离级别的实现原理" class="headerlink" title="MySQL InnoDB的事务隔离级别的实现原理"></a>MySQL InnoDB的事务隔离级别的实现原理</h3><p>标准SQL事务隔离级别的实现是依赖锁的。<br>InnoDB使用不同的锁策略(Locking Strategy)以及MVCC机制来实现不同的隔离级别。</p><h4 id="读未提交-Read-UnCommitted"><a href="#读未提交-Read-UnCommitted" class="headerlink" title="读未提交 Read UnCommitted"></a>读未提交 Read UnCommitted</h4><p>事务对当前被读取的数据不加锁，都是<code>当前读</code>。<br>事务在更新某数据的瞬间，对其加行级共享锁，直到事务结束才释放。</p><h4 id="读已提交-Read-Committed"><a href="#读已提交-Read-Committed" class="headerlink" title="读已提交 Read Committed"></a>读已提交 Read Committed</h4><p>事务对当前被读取的数据不加锁，且是<code>快照读</code>。<br>事务在更新某数据的瞬间，对其加行级排他锁（Record Lock），直到事务结束才释放。</p><p>通过快照读，MySQL InnoDB在RC级别就解决了不可重复读的问题。</p><h4 id="可重复读-Repeatable-Read"><a href="#可重复读-Repeatable-Read" class="headerlink" title="可重复读 Repeatable Read"></a>可重复读 Repeatable Read</h4><p>事务对当前被读取的数据不加锁，且是<code>快照读</code>。<br>事务在更新某数据的瞬间，对其加行级排他锁（Record + gap = next-key lock），直到事务结束才释放。</p><p>通过临键锁，MySQL InnoDB在RR级别解决了幻读。</p><h4 id="序列化读"><a href="#序列化读" class="headerlink" title="序列化读"></a>序列化读</h4><p>事务在读取数据时，必须先对其加表级共享锁，直到事务结束才释放，都是<code>当前读</code>。<br>事务在更新数据时，必须先对其加表级排他锁，直到事务结束才释放。</p><h2 id="MySQL-InnoDB的MVCC实现机制"><a href="#MySQL-InnoDB的MVCC实现机制" class="headerlink" title="MySQL InnoDB的MVCC实现机制"></a>MySQL InnoDB的MVCC实现机制</h2><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。<br>MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用不加锁的方式去处理读-写冲突，<code>实现读-写冲突不加锁</code>。</p><h3 id="什么是MySQL-InnoDB下的当前读和快照读"><a href="#什么是MySQL-InnoDB下的当前读和快照读" class="headerlink" title="什么是MySQL InnoDB下的当前读和快照读"></a>什么是MySQL InnoDB下的当前读和快照读</h3><p>快照读和当前读都是针对于某一行数据记录来说的。</p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是最新版本。<br>像<code>UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE</code>、<code>SELECT ... FOR UPDATE</code>这些操作都是一种当前读。</p><p>为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>读取的是快照版本，也就是历史版本。<br>像不加锁的SELECT操作就是快照读，即不加锁的非阻塞读。</p><p>快照读的前提是隔离级别不是未提交读和序列化读级别。<br>因为未提交读总是读取最新的数据行，而不是符合当前事务版本的数据行；而序列化读则会对表加锁，退化成当前读。</p><h4 id="当前读，快照读和MVCC的关系"><a href="#当前读，快照读和MVCC的关系" class="headerlink" title="当前读，快照读和MVCC的关系"></a>当前读，快照读和MVCC的关系</h4><h3 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h3><blockquote><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 4个隐式字段，undo日志 ，Read View 来实现的。</p></blockquote><h4 id="4个隐式字段"><a href="#4个隐式字段" class="headerlink" title="4个隐式字段"></a>4个隐式字段</h4><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p><ul><li>DB_ROW_ID 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li><li>DB_TRX_ID 6byte, 最近修改(修改/插入)事务ID，记录创建这条记录/最后一次修改该记录的事务ID</li><li>DB_ROLL_PTR 7byte, 回滚指针，用于配合undo日志，指向这条记录的上一个版本（存储于rollback segment里）</li><li>DELETED_BIT 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了</li></ul><h4 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h4><p>InnoDB把这些为了回滚而记录的这些东西称之为undo log。<br>这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。</p><p>undo log主要分为3种：</p><ul><li>Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li><li>Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li><li>Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 <ul><li>删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。</li><li>为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。<br>  为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）。<br>  如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li></ul></li></ul><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><h3 id="MVCC相关问题"><a href="#MVCC相关问题" class="headerlink" title="MVCC相关问题"></a>MVCC相关问题</h3><h4 id="RC、RR级别下的InnoDB快照读有什么不同"><a href="#RC、RR级别下的InnoDB快照读有什么不同" class="headerlink" title="RC、RR级别下的InnoDB快照读有什么不同"></a>RC、RR级别下的InnoDB快照读有什么不同</h4><p>正是Read View生成时机的不同，从而造成RC、RR级别下快照读的结果的不同</p><ul><li>RR快照读<br>  在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见。<br>  即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见。</li><li>RC快照读<br>  在RC级别下的事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。</li></ul><p>总之，<br>在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；<br>而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="加锁的目的"><a href="#加锁的目的" class="headerlink" title="加锁的目的"></a>加锁的目的</h4><p>数据库的锁是为了解决事务的隔离性问题，为了让事务之间相互不影响，每个事务进行操作的时候都会对数据加上一把特有的锁，防止其他事务同时操作数据。</p><h4 id="锁是基于什么实现的"><a href="#锁是基于什么实现的" class="headerlink" title="锁是基于什么实现的"></a>锁是基于什么实现的</h4><p>在Innodb中，锁是作用在索引上面的，当我们的SQL命中索引时，那么锁住的就是命中条件内的索引节点(行锁)，如果没有命中索引的话，那我们锁的就是整个索引树（表锁）</p><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><ul><li>基于锁的属性分类：共享锁、排他锁。</li><li>基于锁的粒度分类：行级锁(innodb)、表级锁(innodb、myisam)、页级锁(innodb引擎)、记录锁、间隙锁、临键锁、自增锁。</li><li>基于锁的状态分类：意向共享锁、意向排它锁。</li><li>基于加锁的态度分类：悲观锁、乐观锁。</li></ul><h3 id="InnoDB的锁类型"><a href="#InnoDB的锁类型" class="headerlink" title="InnoDB的锁类型"></a>InnoDB的锁类型</h3><h4 id="隐式锁定和显式锁定"><a href="#隐式锁定和显式锁定" class="headerlink" title="隐式锁定和显式锁定"></a>隐式锁定和显式锁定</h4><ul><li>隐式锁定<br>  InnoDB在事务执行过程中，使用两阶段锁协议（不主动进行显示锁定的情况）<ul><li>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</li><li>锁只有在事务执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</li></ul></li><li>显式锁定<br>  InnoDB也支持通过特定的语句进行显示锁定（存储引擎层）  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode <span class="operator">/</span><span class="operator">/</span>共享锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> update <span class="operator">/</span><span class="operator">/</span>排他锁</span><br></pre></td></tr></table></figure><h4 id="1-基本锁"><a href="#1-基本锁" class="headerlink" title="1. 基本锁"></a>1. 基本锁</h4>在一个高并发系统中，会出现多会话同时访问同一资源的情况，此时即产生了竞争。<br>为了保证数据的一致性，必须要用锁机制来控制资源的并发访问。</li></ul><p>InnoDB采用的行锁的设计（MyISAM只支持表锁），行锁带来更高的并发性，但管理复杂度也要比表锁更高。<br>InnoDB共实现了2种标准的行级锁：</p><ul><li>共享锁（S Lock），允许持有锁的事务读取数据。</li><li>排它锁（X Lock），允许持有锁的事务修改和删除数据。</li></ul><h4 id="2-意向锁-Intention-locks"><a href="#2-意向锁-Intention-locks" class="headerlink" title="2. 意向锁 Intention locks"></a>2. 意向锁 Intention locks</h4><p>InnoDB存储引擎支持多粒度的锁定，即允许行级锁和表级锁同时存在。</p><ul><li>意向共享锁（IS lock），表示事务想要获得表中某几行的共享锁。</li><li>意向排它锁（IX lock），表示事务想要获得表中某几行的排它锁。</li></ul><p>意向锁是一种表级锁，表示事务稍后希望在更细的粒度上（行级别）加锁。</p><ul><li>select … lock in share mode; 会对表施加IS锁</li><li>select … for update; 会对表施加IX锁</li></ul><table><thead><tr><th align="center"></th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">冲突</td></tr><tr><td align="center">IX</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">冲突</td><td align="center">兼容</td></tr><tr><td align="center">S</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center">IS</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><p>例如，如果请求在记录r上加X锁，则需要先在表级别上加意向排他锁（IX），如果此时表上存在其他锁，则意向锁需要等待表级别锁的释放，待表级意向锁(IX)获得成功后，才可以对行级别加X锁。</p><p>意向锁只会阻塞表级别的请求（如全表扫描、lock tables … write），除此之外不会阻塞任何操作。</p><h4 id="3-行锁-记录锁-Record-locks"><a href="#3-行锁-记录锁-Record-locks" class="headerlink" title="3. 行锁/记录锁 Record locks"></a>3. 行锁/记录锁 Record locks</h4><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，而不是给表的行记录加锁实现的，这就意味着只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。</p><p>由于InnoDB的行锁实现是针对索引字段添加的锁，不是针对行记录加的锁，因此虽然访问的是InnoDB引擎下表的不同行，但如果使用相同的索引字段作为过滤条件，依然会发生锁冲突，只能串行进行，不能并发进行。</p><p>即使SQL中使用了索引，但是经过MySQL的优化器后，如果认为全表扫描比使用索引效率高，此时会放弃使用索引，因此也不会使用行锁，而是使用表锁。</p><p>例如：<code>select col from t where col=1 for update;</code> 即对col为1的记录添加记录锁，阻止其他事务对此记录的操作。</p><h4 id="4-间隙锁-Gap-locks"><a href="#4-间隙锁-Gap-locks" class="headerlink" title="4. 间隙锁 Gap locks"></a>4. 间隙锁 Gap locks</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</p><p>例如：<code>select col from t where col between 1 and 10 for update;</code>会锁住1~10之间的间隙，而不管这段间隙内是否存在记录，因此间隙锁可能只锁住了一段空气。此时如果想插入为col为5的记录会被阻塞，即使5的记录不存在。</p><p>间隙锁的唯一目的即是阻止其他的事务往间隙中插入记录，因此不同的事务可以对同样的间隙重复加锁，没有共享和排他类型之分。</p><h5 id="InnoDB自动使用间隙锁的条件"><a href="#InnoDB自动使用间隙锁的条件" class="headerlink" title="InnoDB自动使用间隙锁的条件"></a>InnoDB自动使用间隙锁的条件</h5><ol><li><code>可重复读 Repeatable Read</code>级别下才会有间隙锁。必须在RR级别下。</li><li>检索条件必须有索引。（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打开间隙锁设置</span><br><span class="line">innodb_locks_unsafe_for_binlog：默认值为OFF，即启用间隙锁</span><br></pre></td></tr></table></figure><h4 id="5-临键锁-Next-Key-locks"><a href="#5-临键锁-Next-Key-locks" class="headerlink" title="5. 临键锁 Next-Key locks"></a>5. 临键锁 Next-Key locks</h4><p>行锁与间隙锁组合起来用就叫做Next-Key Lock。<br>InnoDB默认加锁方式是<code>next-key</code>锁。</p><p><code>next-key lock</code>会对记录本身和记录之前的区间加锁。</p><blockquote><p>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.</p></blockquote><p>如果一个会话占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。</p><blockquote><p>If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order.</p></blockquote><p>例如：假设表中存在索引记录1,10。则next-key lock可能锁住的范围是：(-∞,1]、(1,10]、(10,+∞），对于最后一个区间，next-key lock也会锁住最大记录之后的间隙。</p><blockquote><p><code>Next-key lock</code>只在<code>MySQL InnoDB</code>的<code>*repeatable read</code>隔离级别下使用，主要是用来解决<code>幻读(phantom read)</code>的问题。</p></blockquote><p>当对唯一键值进行锁定时，查询的索引含有唯一属性，next-key lock将会降级为record lock，即仅锁住唯一记录。<br>而如果唯一键由多个列组成，而查询仅使用其中一列，则其实是range查询，InnoDB会依然使用next-key lock进行锁定。</p><h4 id="6-插入意向锁-Insert-intention-locks"><a href="#6-插入意向锁-Insert-intention-locks" class="headerlink" title="6. 插入意向锁 Insert intention locks"></a>6. 插入意向锁 Insert intention locks</h4><p>插入意向锁是间隙锁的一种，其由insert语句在插入记录前获取，代表将在间隙中插入记录的意向。</p><p>多个事务可以对同一个间隙重复加insert intention lock，只要插入的记录值不同，事务就不会冲突。</p><p>例如表中已存在记录1和10,两个事务分别想插入5和6。两个事务都会对1和10记录之间的间隙(2,9)加insert intention lock，但由于插入的记录值不同，因此后续对要插入的记录获取X锁的时候并不会冲突。</p><h4 id="7-自增锁-auto-inc-locks"><a href="#7-自增锁-auto-inc-locks" class="headerlink" title="7. 自增锁 auto-inc locks"></a>7. 自增锁 auto-inc locks</h4><p>自增锁是一种特殊类型的表锁，只要在事务对auto_increment类型的列插入数据时，才会施加auto-inc lock，此时其他想插入的事务都需要等待该锁的释放，而持有该锁的事务可以获得连续的primary key值。</p><h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="MySQL-Server层日志"><a href="#MySQL-Server层日志" class="headerlink" title="MySQL Server层日志"></a>MySQL Server层日志</h3><h4 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h4><p>记录所有更改数据（insert、update、delete等）的语句，还用于复制。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>主从复制</li><li>数据恢复</li></ul><h5 id="STATMENT、ROW、MIXED"><a href="#STATMENT、ROW、MIXED" class="headerlink" title="STATMENT、ROW、MIXED"></a>STATMENT、ROW、MIXED</h5><ul><li>STATMENT<br>  基于 SQL 语句的复制(statement-based replication, SBR)，每一条修改数据的 SQL 语句都会记录到 bin log 中<ul><li>优点 不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</li><li>缺点 在某些情况下会导致主从数据不一致，比如执行sysdate()、sleep()等</li></ul></li><li>ROW<br>  基于行的复制(row-based replication, RBR)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了<ul><li>优点 不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题</li><li>缺点 会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</li></ul></li><li>MIXED<br>  基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 bin log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 bin log</li></ul><h4 id="错误日志（errorlog）"><a href="#错误日志（errorlog）" class="headerlink" title="错误日志（errorlog）"></a>错误日志（errorlog）</h4><p>记录启动、运行或停止mysqld时出现的问题。</p><h4 id="慢查询日志（slow-query-log）"><a href="#慢查询日志（slow-query-log）" class="headerlink" title="慢查询日志（slow query log）"></a>慢查询日志（slow query log）</h4><p>记录所有执行时间超过long_query_time秒的所有查询或者不适用索引的查询。</p><h4 id="一般查询日志（general-log）"><a href="#一般查询日志（general-log）" class="headerlink" title="一般查询日志（general log）"></a>一般查询日志（general log）</h4><p>记录建立的客户端连接和执行语句。</p><h3 id="InnoDB存储引擎事务相关日志"><a href="#InnoDB存储引擎事务相关日志" class="headerlink" title="InnoDB存储引擎事务相关日志"></a>InnoDB存储引擎事务相关日志</h3><h4 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h4><p>redo log 记录的是数据被事务操作后的样子。<br>redo log是InnoDB存储引擎层实现的（也就是说是 Innodb 存储引擎独有的），用于保障事务的持久性，主要用于掉电等故障恢复。</p><p>redo log记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。<br>redo log是用来恢复数据的，用于保障已提交事务的持久化特性。</p><h4 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h4><p>Undo log 记录的是数据被事务操作前的样子。<br>undo log是InnoDB存储引擎层实现的（也就是说是 Innodb 存储引擎独有的），用于保障事务的原子性，主要用于事务回滚和MVCC。</p><p>因此假如由于系统错误或者<code>rollback</code>操作而回滚的话可以根据undo log的信息来进行回滚到被修改前的状态。<br>undo log是用来回滚数据的，用于保障未提交事务的原子性。</p><p>由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。<br>undo log主要分为3种：</p><ul><li>Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li><li>Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li><li>Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 <ul><li>删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。</li><li>为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。<br>  为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）。<br>  如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li></ul></li></ul><h3 id="主从同步从数据库"><a href="#主从同步从数据库" class="headerlink" title="主从同步从数据库"></a>主从同步从数据库</h3><h4 id="中继日志（relay-log）"><a href="#中继日志（relay-log）" class="headerlink" title="中继日志（relay log）"></a>中继日志（relay log）</h4><p>一般情况下它在MySQL主从同步读写分离集群的从节点才开启，主节点不需要这个日志。</p><h2 id="数据库主备搭建"><a href="#数据库主备搭建" class="headerlink" title="数据库主备搭建"></a>数据库主备搭建</h2><h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><p><img src="/2019/07/24/MySQL/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.png"></p><ul><li>主库对外提供读写的操作</li><li>从库对外提供读的操作</li></ul><p>主从架构的优势</p><ul><li>读写分离，减少主库压力，提升服务性能</li><li>备份数据</li><li>高可用，实时灾备</li></ul><p>主从架构需要考虑的问题</p><ul><li>主从一致性</li><li>主从延迟</li></ul><h3 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h3><ul><li>主数据库有个<code>bin log</code>二进制文件，纪录了所有增删改SQL语句。（binlog线程）</li><li>从数据库把主数据库的bin log文件的SQL 语句复制到自己的<code>中继日志 relay log</code>（io线程）</li><li>从数据库的relay log重做日志文件，再执行一次这些sql语句。（Sql执行线程）</li></ul><p>详细的主从同步过程如下：<br><img src="/2019/07/24/MySQL/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86.png"></p><ul><li>主库的更新SQL(update、insert、delete)被写到binlog</li><li>从库发起连接，连接到主库</li><li>此时主库创建一个binlog dump thread，把bin log的内容发送到从库</li><li>从库启动之后，创建一个I/O线程-io_thread，读取主库传过来的bin log内容并写入到relay log</li><li>从库还会创建一个SQL线程-sql_thread，从relay log里面读取内容，从ExecMasterLog_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db</li></ul><h3 id="主主、主从、主备"><a href="#主主、主从、主备" class="headerlink" title="主主、主从、主备"></a>主主、主从、主备</h3><ul><li>主主<br>两台都是主数据库，同时对外提供读写操作。<br>客户端访问任意一台。<br>数据存在双向同步。</li><li>主从<br>一台是主数据库，对外提供读写操作。<br>一台是从数据库，对外提供读操作。<br>数据从主库同步到从库。</li><li>主备<br>一台是主数据库，对外提供读写操作。<br>一台是备库，只作为备份作用，不对外提供读写，主机挂了就取而代之。<br>数据从主库同步到备库。</li></ul><h3 id="主从一致性"><a href="#主从一致性" class="headerlink" title="主从一致性"></a>主从一致性</h3><h3 id="主从延迟"><a href="#主从延迟" class="headerlink" title="主从延迟"></a>主从延迟</h3><p>与主从数据同步相关的时间点有三个：</p><ul><li>主库执行完一个事务，写入binlog，我们把这个时刻记为T1；</li><li>主库同步数据给从库，从库接收完这个binlog的时刻，记录为T2；</li><li>从库执行完这个事务，这个时刻记录为T3。</li></ul><p>主从延迟，指一个事务，在从库执行完的时间和在主库执行完的时间差值，即T3-T1。</p><h4 id="导致主从延迟的情况"><a href="#导致主从延迟的情况" class="headerlink" title="导致主从延迟的情况"></a>导致主从延迟的情况</h4><ul><li>从库机器比主库机器性能差</li><li>从库的查询压力大，消耗大量CPU，影响同步速度</li><li>大事务，大表的DDL语句</li><li>网络延迟</li><li>从数据库太多</li><li>低版本的MySQL只支持单线程复制，如果主库并发高，来不及送到从库会导致延迟。<code>MySQL从5.6开始支持多线程复制</code>。</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h3 id="分布式系统唯一主键ID"><a href="#分布式系统唯一主键ID" class="headerlink" title="分布式系统唯一主键ID"></a>分布式系统唯一主键ID</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——树</title>
      <link href="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/"/>
      <url>/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/tree.png"></p><ul><li>二叉树</li><li>动态查找树<ol><li>二叉查找树 BST</li><li>平衡二叉树 AVL</li><li>红黑树 RBT</li><li>哈夫曼树</li></ol></li><li>多路查找树<ol><li>B树</li><li>B+树</li><li>R树</li></ol></li></ul><h3 id="1-二分搜索树（BST）"><a href="#1-二分搜索树（BST）" class="headerlink" title="1.二分搜索树（BST）"></a>1.二分搜索树（BST）</h3><p>二叉树——&gt;完全二叉树——&gt;满二叉树<br>二叉树具有天然递归结构：每个节点的左子树也是二叉树，每个节点的右子树也是二叉树。</p><h4 id="二分搜索树的每个节点的值"><a href="#二分搜索树的每个节点的值" class="headerlink" title="二分搜索树的每个节点的值"></a>二分搜索树的每个节点的值</h4><p>大于其左子树的所有节点的值，小于其右子树的所有节点的值。<br>二分搜索树中存储的元素必须有可比较性。</p><h4 id="二分搜索树的前中后序遍历"><a href="#二分搜索树的前中后序遍历" class="headerlink" title="二分搜索树的前中后序遍历"></a>二分搜索树的前中后序遍历</h4><h3 id="2-平衡二叉树-AVL"><a href="#2-平衡二叉树-AVL" class="headerlink" title="2.平衡二叉树(AVL)"></a>2.平衡二叉树(AVL)</h3><p>基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。</p><p>AVL树的应用场景：</p><ul><li>windows对进程地址空间的管理</li></ul><h3 id="3-红黑树（R-B-Tree）"><a href="#3-红黑树（R-B-Tree）" class="headerlink" title="3.红黑树（R-B Tree）"></a>3.红黑树（R-B Tree）</h3><ol><li>任何一个节点都有颜色，黑色或者红色。</li><li>根节点是黑色的。</li><li>父子节点之间不能出现两个连续的红节点。</li><li>任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等。</li><li>空节点被认为是黑色的。</li></ol><p>红黑树的应用场景：</p><ol><li>epoll在内核中的实现，用红黑树管理事件块（文件描述符）</li><li>Java的TreeMap实现</li><li>nginx中，用红黑树管理timer</li><li>linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块</li></ol><h3 id="4-B-树"><a href="#4-B-树" class="headerlink" title="4.B-树"></a>4.B-树</h3><p>B-树是一种多路平衡查找树，在文件系统中很有用。<br>一颗m阶的B-树，或为空树，或为满足下列特性的m叉树：<br>1)树中每个节点至多有m棵子树；<br>2)若根节点不是叶子节点，则至少有两棵子树；<br>3)除根之外的所有非终端节点至少有m/2上限棵子树；<br>4)所有的非终端节点中包含下列信息数据：(n，A0，K1，A1，K2，A2，……，Kn，An)。其中，n(m/2-1&lt;=n&lt;=m-1)为关键字的个数(或n+1为该节点子树的个数)；Ki(1&lt;=i&lt;=n)为关键字，且Ki&lt; Ki+1；Ai(0&lt;=i&lt;=n)为指向该节点子树根节点的指针，且指针Ai-1所指子树中所有节点的关键字均小于Ki，An所指子树中所有的节点的关键字均大于Kn。<br>5)所有叶子结点位于同一层。保证平衡。<br><img src="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/B%E6%A0%91.jpg"></p><h4 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h4><p>在B-树上进行查找的过程是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程。<br>由于B-树用作文件的索引，因此它的查找涉及外存的存取。<br>在B-树上进行查找包含两种操作：(1)在B-树中找节点；(2)在节点中找关键字。由于B-树通常存储在磁盘上，则前一查找操作是在磁盘上进行的，而后一查找操作实在内存中进行的，即在磁盘上找到指针p所指节点后，先将节点中的信息读入内存，然后再利用顺序查找或折半查找查询等于K的关键字。</p><h4 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h4><p>插入和分裂<br>m阶的B树，每个结点最多m-1个关键字，保证最多有m棵子树。</p><h4 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h4><h4 id="B树怎么保证绝对平衡的？"><a href="#B树怎么保证绝对平衡的？" class="headerlink" title="B树怎么保证绝对平衡的？"></a>B树怎么保证绝对平衡的？</h4><h3 id="5-B-树"><a href="#5-B-树" class="headerlink" title="5.B+树"></a>5.B+树</h3><p>B+树是应文件系统所需而出的一种B-树的变型树(严格来说，它已不是此前定义的树了)。<br>一棵m阶的B+树和m阶的B-树的差异在于：<br>1)有n棵子树的节点中含有n个关键字；<br>2)所有的叶子节点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接；<br>3)所有的非终端节点可以看成是索引部分，节点中仅含有其子树(根节点)中的最大(或最小)关键字。<br><img src="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/B+%E6%A0%91.jpg"></p><h4 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B+树的查找"></a>B+树的查找</h4><h4 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h4><p>B+树的插入仅在叶子节点上进行，当节点中的关键字个数大于m时要分裂成两个节点，它们所含关键字的个数分别为(m+1)/2的上界，并且它们的双亲结点中应同时包含这两个结点中的最大关键字。</p><h4 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h4><p>B+树的删除也仅在叶子节点进行，当叶子结点中的最大关键字被删除时，其在非终端结点中的值可以作为一个“分界关键字”存在。若因删除而使节点中关键字的个数少于m/2时，其和兄弟节点的合并过程和B-树类似。</p><h3 id="6-线段树-区间树"><a href="#6-线段树-区间树" class="headerlink" title="6.线段树(区间树)"></a>6.线段树(区间树)</h3><p>线段树不是完全二叉树，是平衡二叉树。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假如我是一个诗人</title>
      <link href="/2019/05/28/%E9%9A%8F%E7%AC%94-%E8%90%BD%E5%AF%9E%E8%AF%97%E4%BA%BA/"/>
      <url>/2019/05/28/%E9%9A%8F%E7%AC%94-%E8%90%BD%E5%AF%9E%E8%AF%97%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>6<br>有一天<br>我和晚风做了一个约定<br>天色将暗时<br>我们互换身体<br>我有一个额外的条件<br>我要带走关于你的记忆</p><p>于是<br>那一晚我变成了风<br>我只做了一件事<br>三月中旬<br>满月当空<br>我吹来一大团水汽<br>然后云雾笼罩<br>月色朦胧</p><p>月亮是存在于十四行诗里的光辉<br>你是白日梦尽头的天光大放<br>当我看见你的那一刻<br>我对你说，“我看见了月亮”<br>今夜<br>我不要地球上的人观赏<br>我妄图独享</p><p>那个与晚风交换的“我”呢<br>他呆坐在荒野的尽头<br>不知道在凝望着什么<br>一如往常的许许多多个夜晚<br>他什么也做不了<br>除了凝望</p><p>第二天天色将暗时<br>我又坐在荒野的尽头<br>晚风袭来，带着显然的怒气<br>他再也不会与我交换<br>除非我什么也不带走，尤其关于你的记忆<br>他没有想到：<br>我所带走的，已经是我的全部</p><p>晚风再次提议<br>他想知道那种感觉<br>那种我装着你的时候的感觉<br>我拒绝了<br>晚风不解<br>他在我身边想了一整个晚上</p><p>于是那个夜晚<br>我又呆坐在荒野的尽头<br>不知道在凝望些什么<br>一如往常的许许多多个夜晚<br>我什么也做不了<br>除了凝望<br>我只觉得冷</p><p>5<br>假如我是一个诗人<br>一个乐观的诗人<br>我就会留意到我和你在一起时<br>天气很好，阳光温柔，风也善良<br>我们一起走在路上，想到什么便说什么<br>要是不说话，也十分美好<br>好像我们就该这样，从清晨到日暮<br>吃过饭后看月亮爬上来<br>听你说，“今晚的月亮好圆啊”</p><p>可我总在和你见面时便想到将要分别<br>想到这些我就难过到说不出话来<br>可是你明明什么也没有问我<br>美好的时光很短，短到让人看不见<br>美好不再<br>若是悲观者寿<br>我将长久且寂寥地等待下去</p><p>4<br>假如我是一个诗人<br>一个多情的诗人<br>我想象自己也许会为很多人动情<br>生活有时很长，还夹杂着苦难<br>我需要不断地去爱人方不至于难过</p><p>我遇到一些人像十八岁的云<br>一些人像十二月初冬的雪<br>像三四月的蝴蝶从蓝色里飞来<br>像鲜红的玫瑰、在夜晚醒来的星星<br>和睡不着的白日梦</p><p>我在同一段时间只钟情一个人<br>我不知道怎么会忽然不再了<br>有时候怪我，而有时不怪我<br>当我无法再把她写进字里行间<br>我知道，这已经不对了<br>喜欢一个人，才会为她写诗</p><p>从此朝也不思，夜也不想<br>诗和好梦都追随她而去<br>我只是在偶尔看到那些美好事物时恍然：<br>她是美好本身<br>而我呢，什么也不是</p><p>3<br>假如我是一个诗人<br>一个历经沧桑的诗人<br>我踏碎了一场冬天慕名而来<br>站在你的花园外目睹这久违的春色<br>九千里长风在我身后回旋、吟唱<br>送给你我肩上最后消融的雪花<br>借着夕阳的余晖袒露爱意</p><p>我自深深处走来，向你走来<br>轻声唤你：我的爱人</p><p>2<br>假如我是一个诗人<br>一个不羁的诗人<br>我在和你有关的事物中迸发灵感<br>譬如初见你时，我写“星光颤抖”<br>沉沦之后，写“夜色零落”<br>大可以在你忽远忽近时抽身离去<br>为什么我却越来越虚弱了</p><p>我想你<br>而有时你也想到我</p><p>1<br>如果我是一个落魄诗人<br>我会拿出比我还落魄的诗句<br>和比我富有的人交换<br>只换一分动容</p><p>诗里不会有山川河流<br>没存在草木生灵<br>只会写：我在上帝之上爱你<br>在时间之外想你<br>看客动容，我就可以继续爱你<br>声势浩大的爱意<br>是我唯一可以给你的东西</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="在浏览器中输入一个网址，按下回车后，发生了什么？"><a href="#在浏览器中输入一个网址，按下回车后，发生了什么？" class="headerlink" title="在浏览器中输入一个网址，按下回车后，发生了什么？"></a>在浏览器中输入一个网址，按下回车后，发生了什么？</h2><p><img src="httpqingqiu.png"></p><ol><li><strong>域名解析</strong><br> 浏览器通过浏览器缓存、系统缓存、路由器缓存、域名服务器搜索该域名的ip地址。</li><li><strong>发起TCP3次握手，建立TCP连接</strong><br> 拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序的80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。<br>为什么HTTP协议要基于TCP来实现？<br>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</li><li><strong>建立TCP连接后发起HTTP请求</strong><br><img src="httpqingqiubaowen.jpg"></li><li><strong>服务器端响应http请求，浏览器得到html代码</strong><br> 服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件。</li><li><strong>浏览器解析html代码，并请求html代码中的资源</strong><br> 浏览器拿到html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以请求成功显示的顺序并不一定是代码里面的顺序。<br>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</li><li><strong>浏览器对页面进行渲染呈现给用户</strong><br> 浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</li></ol><h2 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h2><p><img src="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png"></p><h2 id="物理层和数据链路层"><a href="#物理层和数据链路层" class="headerlink" title="物理层和数据链路层"></a>物理层和数据链路层</h2><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>IP ICMP ARP RARP AKP UUCP</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>TCP和UDP Socket</p><h3 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP 传输控制协议"></a>TCP 传输控制协议</h3><ol><li>TCP是面向连接的。面向连接，三次握手建立连接，四次挥手释放连接；</li><li>TCP提供可靠交付的服务。通过TCP连接传送的数据无差错、不丢失、不重复，并且按序到达。TCP的报文段是交给IP层(网络层)传送的，而IP层只能提供最大努力服务，网络提供的是不可靠的传输。</li><li>基于字节流。应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成是一连串的无结构的字节流。在TCP连接中传送的字节流的每一个字节都按顺序编号。</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。TCP连接的端点叫套接字(socket)。根据RFC793的定义，端口号拼接到IP地址即构成了套接字(IP地址：端口号)。每一条TCP连接唯一的被通信两端的两个套接字确定。</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li><li>TCP首部20个字节。源端口、目的端口，序号seq，确认号ack，同步位SYN，终止位FIN，确认位ACK，检验和，窗口，……</li><li>因为TCP下面的网络提供的是不可靠的传输，所以TCP必须采用适当的措施使得两个运输层之间的通信变得可靠：传输信道不产生差错；不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li></ol><h3 id="UDP-用户数据报协议"><a href="#UDP-用户数据报协议" class="headerlink" title="UDP 用户数据报协议"></a>UDP 用户数据报协议</h3><ol><li>UDP是无连接的，发送数据之前不需要建立连接。</li><li>UDP使用尽最大努力交付，不保证可靠交付。因此主机不需要维持复杂的连接状态表。</li><li>UDP是面向报文的。发送方的UDP(传输层)对应用层的应用程序交下来的报文，在添加UDP数据报首部后就向下交付给IP层，UDP对应用层交下来的报文既不合并也不拆分，而是保留这些报文的边界；在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。</li><li>UDP没有拥塞控制。网络出现的拥塞不会使源主机的发送速率降低，吞吐量只受限于数据生成速率、传输速率以及机器性能。</li><li>UDP支持一对一、一对多、多对一、多对多的交互通信。</li><li>UDP的首部开销小。UDP的首部：源端口，目的端口，长度(UDP用户数据报的长度)，检验和，每个字段两个字节，一共只有8个字节。</li></ol><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>ACK：确认序号标志<br>SYN：同步序号，用于建立连接过程<br>FIN：finish标志，用于释放连接(只有连接释放请求报文中置1)<br><img src="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>第一次握手，建立连接时，客户端发送<strong>SYN包(syn=x)<strong>到服务器，并进入</strong>SYN_SEND</strong>状态，等待服务器确认；<br>第二次握手，服务器收到SYN包，必须确认客户的SYN(ack=x+1)，同时自己也发送一个SYN包(syn=y)，即<strong>SYN+ACK</strong>包，此时服务器进入<strong>SYN_RCVD</strong>状态；<br>第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包<strong>ACK(ack=y+1)<strong>，此包发送完毕，客户端和服务器进入</strong>ESTABLISHED</strong>状态，完成三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"><br>第一次挥手：客户端发送连接释放报文，FIN=1，seq=u，客户端进入终止等待1状态。<br>第二次挥手：服务器对连接释放的确认，ACK=1，ack=u+1，seq=v，至此客户端进入终止等待2状态，但是服务器进入关闭等待状态，还能向客户端发送数据。<br>第三次挥手：服务器发送连接释放报文，FIN=1，ACK=1，ack=u+1，seq=w，因为服务器在关闭等待状态可能向客户端发送了数据，所以seq不是v，服务器进入最终确认状态。<br>第四次挥手：客户端对服务器发来的连接释放进行确认，ACK=1，ack=w+1，seq=u+1。服务器收到这个确认报文进入CLOSED状态，而客户端还没有关闭连接，客户端此时进入TIME_WAIT状态，需等待2MSL时间。</p><p><strong>为什么会有TIME_WAIT状态？</strong><br>TCP连接必须经过时间2MSL后才真正释放掉。</p><ol><li>确保A发送的最后一个确认报文段ACK能够到达B，这个报文段有可能丢失，使得LAST_ACK状态的B收不到对已发送的FIN+ACK的确认，B就会重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器。如果A不等待2MSL时间，而是马上进入CLOSED状态，那么B很有可能无法正常进入CLOSED状态；</li><li>防止已失效的连接请求报文段出现在本连接中，避免新旧连接混淆。</li></ol><p><strong>为什么需要四次挥手才能断开连接？</strong><br>因为TCP连接是全双工的，发送方和接收方都需要FIN报文和ACK报文。</p><h3 id="流量控制、拥塞控制"><a href="#流量控制、拥塞控制" class="headerlink" title="流量控制、拥塞控制"></a>流量控制、拥塞控制</h3><h4 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h4><ol><li>以字节为单位的<strong>滑动窗口</strong>。TCP使用滑动窗口做流量控制和乱序重排。</li><li>超时重传时间的选择。报文段往返时间RTT(发送一个数据包到收到相对应的ACK所花费的时间)；超时重传时间RTO(超市计时器设置的重传时间间隔)。</li><li>选择确认(select ACK)。<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以在TCP连接上实现对发送方的流量控制。发送方的发送窗口不能超过接收方给出的接收窗口的数值。TCP的窗口单位是字节，不是报文段。<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4>计算机网络中的链路容量(即带宽)、交换节点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫做拥塞。拥塞：对资源的需求超过了可用资源。<br>拥塞控制防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。</li></ol><p>TCP的拥塞控制算法：慢开始、拥塞避免、快重传、快恢复。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>HTTP和HTTPS WebSocket</p><h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><ul><li>HTTPS是具有安全性的SSL加密协议，是密文传输的，HTTP明文传输</li><li>连接方式不同，HTTPS默认使用<code>443</code>端口，HTTP使用<code>80</code>端口</li><li>HTTPS=HTTP+加密+认证+完整性保护</li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>SSL(Security Sockets Layer，安全套接层)是为网络通信提供安全及数据完整性的一种安全协议，是操作系统对外的API。<br>SSL3.0后更名为TLS，采用身份验证和数据加密保证网络通信的安全和数据的完整性。<br><img src="httpyuhttps.png"></p><h3 id="HTTP超文本传输协议"><a href="#HTTP超文本传输协议" class="headerlink" title="HTTP超文本传输协议"></a>HTTP超文本传输协议</h3><p>客户/服务器模式。<br>http协议本身是无连接的，虽然http使用了TCP作为运输层协议，但通信的双方在交换http报文之前不需要先建立http连接。<br>http协议是无状态的。同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。</p><h4 id="HTTP协议与TCP-IP协议的关系"><a href="#HTTP协议与TCP-IP协议的关系" class="headerlink" title="HTTP协议与TCP/IP协议的关系"></a>HTTP协议与TCP/IP协议的关系</h4><p>HTTP的长连接和短连接本质上是TCP的长连接和短连接。<br>HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。<br>IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。</p><h4 id="如何理解HTTP协议是无状态的"><a href="#如何理解HTTP协议是无状态的" class="headerlink" title="如何理解HTTP协议是无状态的"></a>如何理解HTTP协议是无状态的</h4><p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。<br>也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。<br>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议。</p><h4 id="http长连接和短连接"><a href="#http长连接和短连接" class="headerlink" title="http长连接和短连接"></a>http长连接和短连接</h4><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。<br>当客户端浏览器访问的某个HTML或其他类型的web页中包含有其他的web资源(如javaScript文件、图像文件、CSS文件等)，每遇到这样一个web资源，浏览器就会重新建立一个http会话。</p><p>从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。<br>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件(如apache)中设定这个时间。<br>实现长连接需要客户端和服务端都支持长连接。</p><h4 id="http-1-0、http-1-1、http-2-0、http-3-0"><a href="#http-1-0、http-1-1、http-2-0、http-3-0" class="headerlink" title="http/1.0、http/1.1、http/2.0、http/3.0"></a>http/1.0、http/1.1、http/2.0、http/3.0</h4><ul><li>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，HTTP1.1默认支持长连接</li><li>HTTP 1.1支持只发送header信息(不带任何body信息)。还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可</li><li>HTTP1.0是没有host域的，HTTP1.1才支持这个参数</li><li>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求</li><li>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快</li><li>HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取</li></ul><h4 id="http-中-get-和-post-区别"><a href="#http-中-get-和-post-区别" class="headerlink" title="http 中 get 和 post 区别"></a>http 中 get 和 post 区别</h4><p>http报文层面：GET将请求信息放在URL中，POST放在报文体中。<br>数据库层面：GET请求符合幂等性和安全性，POST不符合。<br>其他：GET请求可以被缓存、被存储，而POST不行。</p><h4 id="常见的-web-请求返回的状态码"><a href="#常见的-web-请求返回的状态码" class="headerlink" title="常见的 web 请求返回的状态码"></a>常见的 web 请求返回的状态码</h4><p>1xx表示通知信息，如请求收到了或正在进行处理<br>2xx表示成功，如202接受或知道了，200正常返回信息<br>3xx表示重定向，如要完成请求还必须采取进一步的行动<br>4xx表示客户端错误，如请求中有错误的语法或不能完成<br>5xx表示服务器的差错，如服务器失效无法完成请求<br>400错误的请求；404找不到，请求的资源不存在；401请求未经授权；403服务器收到请求，但是拒绝提供服务<br>302临时移动；301资源永久性地转移到其他URL；<br>500内部服务器错误；503服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p><h3 id="HTTP是无状态协议，如何保存用户状态"><a href="#HTTP是无状态协议，如何保存用户状态" class="headerlink" title="HTTP是无状态协议，如何保存用户状态"></a>HTTP是无状态协议，如何保存用户状态</h3><p>HTTP是一种不保存状态，即无状态(stateless)协议。也就是说HTTP协议自身不对请求和响应之间的通信状态进行保存。<br>那么我们如何保存用户状态呢？<br>Session机制的存在就是为了解决这个问题，session的主要作用就是通过服务端记录用户的状态。<br>典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为HTTP协议是无状态的，服务端给特定的用户创建特定的session之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个session，过了时间限制，就会销毁这个session)。</p><ul><li>在服务端保存session的方法很多，最常用的就是内存和数据库(使用内存数据库redis保存)。</li><li>既然session存放的服务器端，那么我们如何实现seesion跟踪呢？大部分情况下，我们都是通过在Cookie中附加一个Session ID的方式来跟踪。</li></ul><h3 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h3><p>Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><ol><li><strong>Cookie一般用来保存用户信息。</strong>比如①我们在Cookie中保存已经登录过的用户信息，下次访问网站的时候页面可以自动把你登录的一些基本信息给填了；②一般的网站都会有保持登录，也就是说下次再访问网站的时候就不需要重新登录了，这是因为用户登陆的时候我们可以存放一个Token在Cookie中，下次登录的时候只需要根据Token值来查找用户即可(为了安全考虑，重新登陆一般要将Token重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session的主要作用是通过服务端记录用户的状态。</strong>比如购物车场景。</li><li>Cookie数据存放在客户端(浏览器端)，Session数据保存在服务器端；</li><li>Session相对于Cookie更安全，因为Session是存储在服务器的。如果使用Cookie，一些敏感信息不要写入Cookie中，最好能将Cookie信息加密然后使用到的时候再去服务端解密。</li><li>服务器访问增多，Session会增加服务器负担，若考虑减轻服务器负担，应使用Cookie。<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4>在RFC6265中对Cookie进行了定义，规定万维网站点可以使用Cookie来跟踪用户。<br>Cookie表示在HTTP服务器和客户之间传递的状态信息。<br>cookie是由服务器发给客户端的特殊信息，以文本的形式存放在客户端；客户端再次请求的时候，会把cookie回发；服务器接收到后，会解析cookie生成与客户端相对应的内容。<br><img src="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E8%AE%BE%E7%BD%AE%E5%8F%8A%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B.png"><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4>session机制是服务器端的机制，是在服务器上保存的信息。<br>服务器解析客户端请求并操作session-id，按需保存状态信息。<br>Session是指使用HttpSession对象实现会话跟踪的技术，是一种在服务器端保持会话跟踪的解决方案。</li></ol><p>服务器在创建会话对象时，会为其分配一个唯一的会话标识——SessionID，以“JSESSIONID”的属性名保存在客户端Cookie中，在用户随后的请求中，服务器通过读取Cookie中的JSESSIONID属性值来识别不同的用户，从而实现对每个用户的会话跟踪。</p><p>session的实现方式：1.使用cookie来实现；2.使用URL回写来实现。</p><h4 id="cookie被禁用，如何实现session"><a href="#cookie被禁用，如何实现session" class="headerlink" title="cookie被禁用，如何实现session"></a>cookie被禁用，如何实现session</h4><p>最常用的就是利用URL重写，把SessionID直接附加在URL路径的后面。<br>URL重写通过HttpServletResponse的encodeURL()方法和encodeRedirectURL()方法实现。</p><ul><li>encodeURL()方法可以对任意请求的URL进行重写。</li><li>encodeRedirectURL()方法主要对使用sendRedirect()方法的URL进行重写。</li><li>URL重写方法根据请求信息中是否包含“Set-Cookie”请求头来决定是否进行URL重写，若包含该请求头，会将URL原样输出；若不包含，则会将会话标识重写到URL中。</li></ul><h3 id="Socket和WebSocket"><a href="#Socket和WebSocket" class="headerlink" title="Socket和WebSocket"></a>Socket和WebSocket</h3><p>WebSocket 是一种网络通信协议，类似 http 协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># http</span><br><span class="line">http://example.com:80/some/path</span><br><span class="line"># websocket</span><br><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等<br>域名解析、根域名服务器<br>DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>正向代理、反向代理<br>反向代理服务器</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>应用程序级别的概念。<br>阻塞与非阻塞是应用程序访问某一资源时候，该资源没有准备就绪时应用程序的处理方式。<br>关注的是发起请求之后等待数据返回时的状态。</p><p>被挂起无法执行其他操作的应用程序是阻塞型的；<br>可以立即去进行其他作业的应用程序是非阻塞型的。</p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>操作系统级别的。<br>是否是同步还是异步，关注的是任务完成时消息通知的方式。</p><p>由调用方（应用程序）主动问询的方式是同步调用；<br>由被调用方（操作系统内核）主动通知调用方（应用程序）任务已完成的方式是异步调用。</p><h3 id="网络IO、磁盘IO"><a href="#网络IO、磁盘IO" class="headerlink" title="网络IO、磁盘IO"></a>网络IO、磁盘IO</h3><h3 id="Unix的5种IO模型"><a href="#Unix的5种IO模型" class="headerlink" title="Unix的5种IO模型"></a>Unix的5种IO模型</h3><h4 id="BIO-Block-IO"><a href="#BIO-Block-IO" class="headerlink" title="BIO(Block IO)"></a>BIO(Block IO)</h4><p>BIO同步阻塞IO</p><h4 id="NIO-Non-Block-IO"><a href="#NIO-Non-Block-IO" class="headerlink" title="NIO(Non-Block IO)"></a>NIO(Non-Block IO)</h4><p>NIO同步非阻塞IO</p><h4 id="信号驱动I-O-signal-driven-I-O-SIGIO"><a href="#信号驱动I-O-signal-driven-I-O-SIGIO" class="headerlink" title="信号驱动I/O  signal driven I/O (SIGIO)"></a>信号驱动I/O  signal driven I/O (SIGIO)</h4><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><h4 id="AIO-Asynchronize-IO"><a href="#AIO-Asynchronize-IO" class="headerlink" title="AIO(Asynchronize IO)"></a>AIO(Asynchronize IO)</h4><p>AIO异步非阻塞IO</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——12.4java与线程</title>
      <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%9412.4java%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%9412.4java%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——12.3java内存模型</title>
      <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%9412.3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%9412.3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机内存模型、缓存一致性、MESI-协议"><a href="#计算机内存模型、缓存一致性、MESI-协议" class="headerlink" title="计算机内存模型、缓存一致性、MESI 协议"></a>计算机内存模型、缓存一致性、MESI 协议</h2><h3 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h3><p>由于计算机的存储设备与运算器的运算速度之间有着几个数量级的差距，所以现代计算机系统不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(cache)来作为内存与处理器之间的缓冲。<br>将运算需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。</p><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性(Cache Coherence)。<br>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%9412.3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/neicunmoxing.png"></p><p>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？</p><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI、Synapse、Firefly及DragonProtocol等等。<br>Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的。</p><p>MESI是指4种状态的首字母，每个Cache line有4个状态，可用两个bit表示。</p><ul><li>M 修改(Modify)<br>  缓存块已经被改动，必须被写回主存，其他处理器不能再缓存这个块。</li><li>E 独享、互斥(Exclusive)<br>  缓存块还没有被改动，且其他处理器不能装入这个缓存块。</li><li>S 共享(Shared)<br>  缓存块未被改动，且其他处理器能够装入这个缓存块。</li><li>I 无效(Invalid)<br>  缓存块中的数据无效。</li></ul><p>可见性、原子性、有序性、happens-before、内存屏障、synchronized、volatile、final、锁</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。<br>此处的变量(Variable)与java编程中所说的变量略有区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为后者是线程私有的，不会被共享，自然就不存在竞争问题。<br>为了获得较好的执行效能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存在和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权力。</p><p>Java内存模型规定了所有的变量都存储在主内存(MainMemory)中(可以类比物理机的主内存，此处仅是虚拟机内存的一部分)。<br>每条线程还有自己的工作内存(WorkingMemeory，可与处理器高速缓存类比)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量。<br>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%9412.3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/javaneicunmoxing.png"></p><h3 id="12-3-2-内存间交互操作"><a href="#12-3-2-内存间交互操作" class="headerlink" title="12.3.2 内存间交互操作"></a>12.3.2 内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8中操作(虚拟机实现时必须保证每一种操作都是原子的、不可再分的)来完成：</p><ul><li>lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write(写入)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><h3 id="12-3-4-对于volatile型变量的特殊规则"><a href="#12-3-4-对于volatile型变量的特殊规则" class="headerlink" title="12.3.4 对于volatile型变量的特殊规则"></a>12.3.4 对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是java虚拟机提供的最轻量级的同步机制，但是它并不容易被正确地、完整地理解，以至于许多程序员都不去使用它，遇到需要处理多线程数据竞争的问题时一律使用synchronized来进行同步。</p><p>Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些规则定义之前，先介绍一下这个关键字的作用。<br>当一个变量被定义成volatile之后，它将具备两种特性，第一是<code>保证此变量对所有线程的可见性</code>；第二是<code>禁止指令重排序优化</code>。</p><p>两种特性产生的原因是Java内存模型对volatile变量的三条特殊规则。</p><ul><li><p>规则1<br>  只有当线程T对变量V执行的前一个操作为load时，线程T才可以对变量V执行use操作;<br>  并且只有当线程T对变量V执行的后一个操作为use时，线程T才可以对变量V执行load操作。</p><p>  该规则令read - load - use形成整体性的原子操作，使得volatile变量在被使用前会从主内存中读取最新值。</p></li><li><p>规则2<br>  只有当线程T对变量V执行的前一个操作为assign时，线程T才可以对变量V执行store动作;<br>  并且只有当线程T对变量V执行的后一个操作为store时，线程T才可以对变量V执行assign动作。</p><p>  该规则令assign - store - write形成整体性的原子操作，使得volatile变量在被赋值后会立即同步回主内存。</p></li><li><p>规则3<br>  假定操作A是线程T对变量V实施的use或assign操作，操作F是和操作A关联的load或store操作，操作P是和操作F相关联的read或write操作；<br>  假定操作B是线程T对变量W实施的use或assign操作，操作G是和操作B关联的load或store操作，操作Q是和操作G相关联的read或write操作；<br>  如果A先于B，则P先于Q。</p></li></ul><p>这里的<code>可见性</code>是指<code>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</code>，而普通变量不能做到这一点，变量值在线程间传递均需要通过主内存来完成。<br>如：线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量的值才会对线程B可见。</p><p>关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。<br>这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。<br>volatile变量在各个线程的工作内存中不存在一致性问题(在各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题)，但是<code>java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的</code>。</p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用synchronized或java.util.concurrent中的原子类)来保证原子性：</p><ol><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ol><p>使用volatile变量的第二个语义是<code>禁止指令重排序优化</code>，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”(Within-Thread-As-If-Serial Semantics)。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%9412.3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/volatile-zhilingchongpaixu.png"></p><h5 id="volatile与内存屏障"><a href="#volatile与内存屏障" class="headerlink" title="volatile与内存屏障"></a>volatile与内存屏障</h5><ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障</li></ul><p>解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？<br>确实在某些情况下，volatile同步机制的性能要优于锁(使用synchronized关键字或java.util.concurrent包里面的锁)，但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地说volatile就会比synchronized快上多少。<br>如果让volatile自己与自己比较，则可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障(Memory Barrier或Memory Fence)指令来保证处理器不发生乱序执行。<br>不过即便如此，大多数情况下volatile的总开销仍然要比锁来得低，我们在volatile与锁中选择的唯一判断依据仅仅是volatile的语义能否满足使用场景的需求。</p><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%9412.3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/volatile-dingyiguize.png"></p><h3 id="12-3-4-对于long和double型变量的特殊规则"><a href="#12-3-4-对于long和double型变量的特殊规则" class="headerlink" title="12.3.4 对于long和double型变量的特殊规则"></a>12.3.4 对于long和double型变量的特殊规则</h3><p>Java内存模型只保证32位数据类型操作的原子性，对于64位数据类型（long和double）操作则由两个32位原子操作组成。</p><p>java内存模型要求lock、unlock、read、load、assign、use、store和write这八个操作都具有原子性。<br>但是对于64位的数据类型(long和double)，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的<code>long和double的非原子性协定</code>。</p><p>如果有多个进程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。<br>不过这种读取到“半个变量”的情况非常罕见，因为java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。<br>在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要将用到的long和double变量专门声明为volatile。</p><h3 id="12-3-5-原子性、可见性与有序性"><a href="#12-3-5-原子性、可见性与有序性" class="headerlink" title="12.3.5 原子性、可见性与有序性"></a>12.3.5 原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。<br>想要线程安全，必须保证原子性、可见行、有序性。</p><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><p>由Java内存模型来直接保证原子性变量操作包括read、load、assign、use、store和write这六个，大致可以认为基本数据类型的访问读写是具备原子性的(long和double的非原子性协定例外)。<br>如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求。<br>尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p><h4 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性(Visibility)"></a>可见性(Visibility)</h4><p>可见性就是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。<br>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。<br>普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新，因此可以说volatile保证了多线程操作时变量的可见性，而普通变量不能保证这一点。</p><p>除了volatile之外，java还有两个关键字能实现可见性，它们是synchronized和final。<br>同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)”这条规则获得的。<br>而final关键字的可见性是指被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去(this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那么在其他线程中就能看见final字段的值。</p><h4 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性(Ordering)"></a>有序性(Ordering)</h4><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。<br>前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。<br>volatile关键字本身就包含了禁止指令重排序的含义。<br>而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p><h3 id="12-3-6-先行发生规则（happens-before）"><a href="#12-3-6-先行发生规则（happens-before）" class="headerlink" title="12.3.6 先行发生规则（happens-before）"></a>12.3.6 先行发生规则（happens-before）</h3><p>先行发生原则（happens - before），如果操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——8虚拟机字节码执行引擎</title>
      <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%948%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%948%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——7虚拟机类加载机制</title>
      <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="7-1概述"><a href="#7-1概述" class="headerlink" title="7.1概述"></a>7.1概述</h3><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。</p><p>在java语言里面，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为java应用程序提供高度的灵活性。<br>java中天生可以<code>动态扩展</code>的语言特性就是依赖<code>运行期动态加载和动态连接</code>这个特点实现的。</p><h3 id="7-2类加载的时机"><a href="#7-2类加载的时机" class="headerlink" title="7.2类加载的时机"></a>7.2类加载的时机</h3><p>类加载机制：jvm把class文件加载到内存，并对数据进行校验、分配、解析和初始化，最终形成jvm可以直接使用的java类型的过程。</p><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"><br>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了以上七个阶段，其中验证、准备和解析三个部分统称为连接。</p><p><code>加载、验证、准备、初始化和卸载</code>这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。<br>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持java语言的运行时绑定。<br>按部就班地“开始”，而不是按部就班地“进行”或“完成”，因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。</p><p>什么情况下需要开始类加载过程的第一个阶段：加载。虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。<br>但是对于初始化阶段，虚拟机规范则是严格规定了有些只有四种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之前开始)：<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E6%9C%89%E4%B8%94%E5%8F%AA%E6%9C%89.png"></p><p>对于这四种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语“有且只有”，这四种场景中的行为称为<code>对一个类进行主动引用</code>。<br>除此之外所有引用类的方式，都不会触发初始化，称为被动引用。</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化；</li><li>通过数组定义来引用类，不会触发此类的初始化；</li><li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li></ul><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A0%E8%BD%BD.png"></p><h3 id="7-3类加载的过程"><a href="#7-3类加载的过程" class="headerlink" title="7.3类加载的过程"></a>7.3类加载的过程</h3><h4 id="7-3-1加载"><a href="#7-3-1加载" class="headerlink" title="7.3.1加载"></a>7.3.1加载</h4><p>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。</p><p>“加载”阶段是“类加载”过程的一个阶段，这两个名词看起来很相似。<br>在加载阶段，虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</li></ol><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E8%8E%B7%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81.png"><br>相对于类加载过程的其他阶段，加载阶段(准确地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员们可以通过定义自己的类加载器去控制字节流的获取方式。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。<br>然后在java堆中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持这固定的先后顺序。</p><h4 id="7-3-2验证"><a href="#7-3-2验证" class="headerlink" title="7.3.2验证"></a>7.3.2验证</h4><p>确保加载的类信息符合jvm规范，没有安全方面的问题。</p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>Java语言本身是相对安全的语言(依然是相对于C/C++来说)，使用纯粹的java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。<br>但前面已经说过，Class文件并不一定要求用java源码编译而来，可以使用任何途径，包括用十六进制编辑器直接编写来产生Class文件。<br>在字节码的语言层面上，上述java代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。<br>虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p><p>尽管验证阶段是非常重要的，并且验证阶段的工作量在虚拟机的类加载子系统中占了很大一部分，但虚拟机规范对这个阶段的限制和指导显得非常笼统，仅仅说了一句如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个java.lang.VerifyError异常或其子类异常，具体应当检查哪些方面，如果检查，何时检查，都没有强制要求或明确说明，所以不同的虚拟机对类验证的实现可能会有所不同，但大致上都会完成下面四个阶段的检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。</p><ol><li><p>文件格式验证<br> 第一阶段是要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。<br> 验证点包括：是否以魔数0xCAFEBABE开头；主、次版本号是否在当前虚拟机处理范围之内；常量池的常量中是否有不被支持的常量类型(检查常量tag标志)；指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据；Class文件中各个部分及文件本身是否有被删除的或附加的其他信息；</p><p> 实际上第一阶段的验证点远不止这些，上面这些只是从HotSpot虚拟机源码中摘抄的一小部分，该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个java类型信息的要求。<br> 这阶段的验证是基于字节流进行的，进行了这个阶段的验证之后，字节流才会进入内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构进行的。</p></li><li><p>元数据验证<br> 第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。<br> 这个阶段可能包括的验证点如下：这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)；这个类的父类是否继承了不允许被继承的类(被final修饰的类)；如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；类中的字段、方法是否与父类产生了矛盾(例如覆盖了父类的final字段，或者出现不符合规则的方法重写)；<br> 第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合java语言规范的元数据信息。</p></li><li><p>字节码验证<br> 第三阶段是整个验证过程中最复杂的一个阶段，主要工作是进行数据流和控制流分析。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析。<br> 这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。<br> 例如：保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况——在操作栈中放置了一个int类型的数据，使用时却按long类型来加载如本地变量表中；保证跳转指令不会跳转到方法体以外的字节码指令上；保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型则是危险和不合法的；</p><p> 如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说名其一定就是安全的。<br> 即使字节码验证之中进行了大量的检查，也不能保证这一点。这里涉及了离散数学中一个很著名的问题“Halting Problem”。通俗一点的说法就是，通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。<br> <img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%AD%97%E8%8A%82%E7%A0%81%E9%AA%8C%E8%AF%81.png"></p></li><li><p>符号引用验证<br> 最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。<br> 符号引用验证可以看做是对类自身以外(常量池中的各种符号引用)的信息进行匹配性的校验，通常需要校验以下内容：符号引用中通过字符串描述的全限定名是否能找到对应的类；在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段；符号引用中的类、字段和方法的访问性(private、protected、public、default)是否可被当前类访问；</p><p> 符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p></li></ol><h4 id="7-3-3准备"><a href="#7-3-3准备" class="headerlink" title="7.3.3准备"></a>7.3.3准备</h4><p>正式为类变量(static)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。<br>两个容易混淆的概念：这时候进行内存分配的仅包括类变量(static修饰的变量)，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在java堆中；这里所说的初始值“通常情况”下是数据类型的零值。</p><p>假设一个类变量的定义为：public static int value = 123; 那么变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会被执行。</clinit></p><p>“通常情况”下初始值是零值，相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，public static final int value = 123; 编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png"></p><h4 id="7-3-4解析"><a href="#7-3-4解析" class="headerlink" title="7.3.4解析"></a>7.3.4解析</h4><p>虚拟机常量池内的符号引用替换为直接引用的过程。</p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？</p><ul><li><p>符号引用(Symbolic Reference)<br>  符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p></li><li><p>直接引用(Direct Reference)<br>  直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p></li></ul><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E8%A7%A3%E6%9E%90.png"><br>解析动作主要针对类或接口、字段、类方法、接口访问四类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。</p><ol><li>类或接口的解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol><h4 id="7-3-5初始化"><a href="#7-3-5初始化" class="headerlink" title="7.3.5初始化"></a>7.3.5初始化</h4><p>初始化阶段是执行类构造器<clinit>()方法的过程。<br>类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的。<br>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<br>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。<br>当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。</clinit></clinit></clinit></p><ul><li>类的主动引用(一定会发生类的初始化)<ol><li>new一个类的对象；</li><li>调用类的静态成员(除了final常量)和静态方法；</li><li>使用java.lang.reflect包的方法对类进行反射调用；</li><li>当虚拟机启动java Hello，则一定会初始化Hello类，说白了就是先启动mian方法所在的类；</li><li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类。</li></ol></li><li>类的被动引用(不会发生类的初始化)<ol><li>当访问一个静态域时，只有真正声明这个域的类才会被初始化(通过子类引用父类的静态变量，不会导致子类初始化)；</li><li>通过数组定义类引用，不会触发此类的初始化；</li><li>引用常量不会触发此类的初始化(常量在编译阶段就存入调用类的常量池中了)。</li></ol></li></ul><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。<br>到了初始化阶段，才真正开始执行类中定义的java程序代码(或者说是字节码)。<br>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/clinit.png"><br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/clinit2.png"></clinit></p><h3 id="7-4类加载器"><a href="#7-4类加载器" class="headerlink" title="7.4类加载器"></a>7.4类加载器</h3><p>类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。</p><p>类缓存：标准的javaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间，不过jvm垃圾收集器可以回收这些Class对象。</p><ol><li>启动类加载器(Bootstrap Classloader)<br> 用来加载java的核心库(JAVA_HOME/jre/lib/rt.jar，或sun.boot.class.path路径下的内容)，是用原生代码来实现的，并不继承自java.lang.ClassLoader。<br> 加载扩展类和应用程序类加载器，并指定他们的父类加载器。</li><li>扩展类加载器(Extension Classloader)<br> 用来加载java的扩展库(JAVA_HOME/jre/ext/.jer，或java.ext.dirs路径下的内容)。<br> java虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载java类。<br> 由sun.misc.Launcher$ExtClassLoader实现。</li><li>应用程序类加载器(Application Classloader)<br> 它根据java应用的类路径(classpath，java.class.path路径)来加载类，一般来说，java应用的类都是由它来完成加载的。<br> 由sun.misc.Launcher$AppClassLoader实现。</li><li>自定义类加载器<br> 开发人员可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。</li></ol><p>java.class.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个java类，即java.lang.Class类的一个实例。<br>除此之外，ClassLoader还负责加载java应用所需的资源，如图像文件和配置文件等。</p><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"><br>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，这里类加载器之间的父子关系一般不会以继承(Inheritance)的关系来实现，而是都使用组合(Composition)关系来复用父加载器的代码。</p><p>类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的java程序中，但它并不是一个强制性的约束模型，而是java设计者们推荐给开发者们的一种类加载器实现方法。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。</p><p>双亲委托机制是为了保证java核心库的类型安全，这种机制保证不会出现用户自己能定义java.lang.Object类的情况。</p><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%947%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png"></p><p>类加载器的代理模式：交给其他加载器来加载指定的类。<br>双亲委派机制是代理模式的一种，并不是所有的类加载器都采用双亲委派机制；tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。</p><p>自定义类加载器的流程：继承java.lang.ClassLoader；首先检查请求的类型是否已经被这个类加载器加载到命名空间中了，如果已经加载，直接返回；委派类加载请求给父类加载器，如果父类加载器能够完成，则返回父类加载器加载的Class实例；调用本类加载类的findClass(……)方法，试图获取对应的字节码，如果获取的到，则调用defineClass(……)导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass(……)，loadClass(……)转抛异常，终止加载过程。</p><p>实现双亲委派模型的代码都集中来自java.lang.ClassLoader的loadClass()方法：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，则再抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p><p>注意，被两个类加载器加载的同一个类，jvm不认为是相同的类。</p><p>思考：</p><ol><li><p>假如我们自己写了一个java.lang.String的类，我们是否可以替换调JDK本身的类？<br> 答案是否定的。我们不能实现。<br> 为什么呢？<br> 我看很多网上解释是说双亲委托机制解决这个问题，其实不是非常的准确。因为双亲委托机制是可以打破的，你完全可以自己写一个classLoader来加载自己写的java.lang.String类，但是你会发现也不会加载成功，具体就是因为针对java.※开头的类，jvm的实现中已经保证了必须由bootstrp来加载。<br> 因为String已经在启动时被加载，所以用户自定义类ClassLoader是无法加载一个自定义的String。</p></li><li><p>既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？<br> 因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class。<br> 如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。</p><p> 定义自已的类加载器分为两步：</p><ol><li>继承java.lang.ClassLoader</li><li>重写父类的findClass方法</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——6类文件结构</title>
      <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%946%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%946%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——排序</title>
      <link href="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/zonghebijiao.jpg"></p><h3 id="一、排序-上-：为什么插入排序比冒泡排序更受欢迎？"><a href="#一、排序-上-：为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="一、排序(上)：为什么插入排序比冒泡排序更受欢迎？"></a>一、排序(上)：为什么插入排序比冒泡排序更受欢迎？</h3><p>分析一个排序算法，从哪几方面入手：</p><h4 id="1-排序算法的执行效率"><a href="#1-排序算法的执行效率" class="headerlink" title="1.排序算法的执行效率"></a>1.排序算法的执行效率</h4><p>1）最好情况、最坏情况、平均情况时间复杂度。<br>2）时间复杂度的系数、常数、低阶。<br>3）比较次数和交换(或移动)次数。基于比较的排序算法会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。</p><h4 id="2-排序算法的内存消耗"><a href="#2-排序算法的内存消耗" class="headerlink" title="2.排序算法的内存消耗"></a>2.排序算法的内存消耗</h4><p>算法的内存消耗可以通过空间复杂度来衡量，针对排序算法的空间复杂度，引入了一个概念——原地排序(Sorted in place)。原地排序算法就是特指空间复杂度为O(1)的排序算法，包括冒泡排序、插入排序、选择排序。</p><h4 id="3-排序算法的稳定性"><a href="#3-排序算法的稳定性" class="headerlink" title="3.排序算法的稳定性"></a>3.排序算法的稳定性</h4><p>除了执行效率和内存消耗，针对排序算法还有一个重要的度量指标——稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。<br>假如现在有一组数据：2，9，3，4，8，3，按照大小排序之后是2，3，3，4，8，9。这组数据里有两个3，经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那这种排序算法就是稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就是不稳定的。<br>数据结构和算法在讲排序的时候，都是用整数来举例，在真正软件开发中，要排序的往往不是单纯的整数，而是一组对象，需要按照对象的某个key来排序。<br>比如，现在要给电商交易系统中的“订单”排序，订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有10万条订单数据，希望按照金额从小到大对订单数据排序。对于金额相同的订单，希望按照下单时间从早到晚有序。<br>对于这样一个排序需求，借助稳定排序算法，先按照下单时间给订单排序，然后用稳定排序算法，按照订单金额重新排序。这样两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间排序。稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</p><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><h4 id="1-1冒泡排序是原地排序算法吗？"><a href="#1-1冒泡排序是原地排序算法吗？" class="headerlink" title="1.1冒泡排序是原地排序算法吗？"></a>1.1冒泡排序是原地排序算法吗？</h4><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是一个原地排序算法。</p><h4 id="1-2冒泡排序是稳定的排序算法吗？"><a href="#1-2冒泡排序是稳定的排序算法吗？" class="headerlink" title="1.2冒泡排序是稳定的排序算法吗？"></a>1.2冒泡排序是稳定的排序算法吗？</h4><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的。</p><h4 id="1-3冒泡排序的时间复杂度"><a href="#1-3冒泡排序的时间复杂度" class="headerlink" title="1.3冒泡排序的时间复杂度"></a>1.3冒泡排序的时间复杂度</h4><p>最好情况下要排序的数据是有序的，只需要进行一次比较操作，是O(n)。而最坏情况下，要排序的数据刚好是倒序排列的，要进行n次冒泡操作，为O(n2)。<br>对于包含n个数据的数组，这n个数据有n!中排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的，如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算很复杂。<br>这里，通过“有序度”和“逆序度”这两个概念来进行分析。<br>有序度是数组中具有有序关系的元素对的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure><p><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/youxudu.jpg"><br>对于一个倒序排列的数组，比如654321，有序度为0；对于一个完全有序的数组，比如123456，有序度就是n×(n-1)/2，就是15。我们把这种完全有序的数组的有序度叫做满有序度。<br>逆序度的定义正好跟有序度相反(默认从小到大为有序)。</p><h4 id="逆序度-满有序度-有序度"><a href="#逆序度-满有序度-有序度" class="headerlink" title="逆序度 = 满有序度 - 有序度"></a>逆序度 = 满有序度 - 有序度</h4><p>排序的过程就是增加有序度，减少逆序度的过程，最后达到满有序度。</p><p>对于包含n个数据的数组进行冒泡排序，平均交换次数在最坏情况下，初始状态有序度为0，要进行n×(n-1)/2次交换；最好情况下，初始状态的有序度是n×(n-1)/2，就不需要进行交换。取中间值n×(n-1)/4来表示平均情况。定性分析下平均情况的时间复杂度为O(n2)。</p><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h3><h4 id="2-1插入排序是原地排序算法吗？"><a href="#2-1插入排序是原地排序算法吗？" class="headerlink" title="2.1插入排序是原地排序算法吗？"></a>2.1插入排序是原地排序算法吗？</h4><p>插入排序算法不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。</p><h4 id="2-2插入排序是稳定的排序算法吗？"><a href="#2-2插入排序是稳定的排序算法吗？" class="headerlink" title="2.2插入排序是稳定的排序算法吗？"></a>2.2插入排序是稳定的排序算法吗？</h4><p>在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p><h4 id="2-3插入排序的时间复杂度"><a href="#2-3插入排序的时间复杂度" class="headerlink" title="2.3插入排序的时间复杂度"></a>2.3插入排序的时间复杂度</h4><p>最好情况下从头遍历已经有序的元素O(n)；最坏情况下数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，为O(n2)。平均时间复杂度为O(n2)。</p><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><p>选择排序算法的实现思路有点类似插入排序，也区分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><h4 id="3-1选择排序是原地排序算法吗？"><a href="#3-1选择排序是原地排序算法吗？" class="headerlink" title="3.1选择排序是原地排序算法吗？"></a>3.1选择排序是原地排序算法吗？</h4><p>空间复杂度为O(1)，是一种原地排序算法。</p><h4 id="3-2选择排序是稳定的排序算法吗？"><a href="#3-2选择排序是稳定的排序算法吗？" class="headerlink" title="3.2选择排序是稳定的排序算法吗？"></a>3.2选择排序是稳定的排序算法吗？</h4><p>选择排序是一种不稳定的排序算法。</p><h4 id="3-3选择排序的时间复杂度"><a href="#3-3选择排序的时间复杂度" class="headerlink" title="3.3选择排序的时间复杂度"></a>3.3选择排序的时间复杂度</h4><p>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为O(n2)。</p><h3 id="为什么插入排序要比冒泡排序更受欢迎？"><a href="#为什么插入排序要比冒泡排序更受欢迎？" class="headerlink" title="为什么插入排序要比冒泡排序更受欢迎？"></a>为什么插入排序要比冒泡排序更受欢迎？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line">if (a[j] &gt; a[j+1]) &#123; // 交换</span><br><span class="line">   int tmp = a[j];</span><br><span class="line">   a[j] = a[j+1];</span><br><span class="line">   a[j+1] = tmp;</span><br><span class="line">   flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line">if (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+1] = a[j];  // 数据移动</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码实现上看，冒泡排序的数据交换要比插入排序的数据移动操作要多，cpu处理时间就长。虽然两者时间复杂度一样，但是插入排序优化空间要大，例如其中的希尔排序。</p><h3 id="二、排序-下-：如何用快排思想在O-n-内查找无序数组中第k大元素？"><a href="#二、排序-下-：如何用快排思想在O-n-内查找无序数组中第k大元素？" class="headerlink" title="二、排序(下)：如何用快排思想在O(n)内查找无序数组中第k大元素？"></a>二、排序(下)：如何用快排思想在O(n)内查找无序数组中第k大元素？</h3><p>时间复杂度为O(nlogn)的归并排序和快速排序，都用到了分治思想。</p><h3 id="4-归并排序-Merge-Sort"><a href="#4-归并排序-Merge-Sort" class="headerlink" title="4.归并排序(Merge Sort)"></a>4.归并排序(Merge Sort)</h3><p>思想：要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br>归并排序使用的是分治思想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//归并排序的递推公式</span><br><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure><p>给下标从p到r的数组排序，将这个排序问题转化为两个子问题，p到q和q+1到r，下标q等于p和r的中间位置(p+r)/2。当两个子数组都排好序之后，合并在一起，p到r也就排好序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序算法, A 是数组，n 表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  // 递归终止条件</span><br><span class="line">  if p &gt;= r  then return</span><br><span class="line"></span><br><span class="line">  // 取 p 到 r 之间的中间位置 q</span><br><span class="line">  q = (p+r) / 2</span><br><span class="line">  // 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+1, r)</span><br><span class="line">  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+1...r])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merge(A[p...r], A[p...q], A[q+1...r]) &#123;</span><br><span class="line">  var i := p，j := q+1，k := 0 // 初始化变量 i, j, k</span><br><span class="line">  var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组</span><br><span class="line">  while i&lt;=q AND j&lt;=r do &#123;</span><br><span class="line">    if A[i] &lt;= A[j] &#123;</span><br><span class="line">      tmp[k++] = A[i++] // i++ 等于 i:=i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] = A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 判断哪个子数组中有剩余的数据</span><br><span class="line">  var start := i，end := q</span><br><span class="line">  if j&lt;=r then start := j, end:=r</span><br><span class="line">  </span><br><span class="line">  // 将剩余的数据拷贝到临时数组 tmp</span><br><span class="line">  while start &lt;= end do &#123;</span><br><span class="line">    tmp[k++] = A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 将 tmp 中的数组拷贝回 A[p...r]</span><br><span class="line">  for i:=0 to r-p do &#123;</span><br><span class="line">    A[p+i] = tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1归并排序是稳定的排序算法吗？"><a href="#4-1归并排序是稳定的排序算法吗？" class="headerlink" title="4.1归并排序是稳定的排序算法吗？"></a>4.1归并排序是稳定的排序算法吗？</h4><p>归并排序的稳定性要看merge()合并函数。另外，稳定性是由方法本身决定的，对不稳定的排序方法而言，不管其描述形式如何，总能举出一个说明不稳定的实例来；反之，对稳定的排序方法，总能找到一种不引起不稳定的描述形式。<br>合并前后的前后顺序不变，就是稳定的。</p><h4 id="4-2归并排序的时间复杂度"><a href="#4-2归并排序的时间复杂度" class="headerlink" title="4.2归并排序的时间复杂度"></a>4.2归并排序的时间复杂度</h4><p>归并排序可以递归实现，递归代码的时间复杂度也可以写成递推公式。<br>我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br><span class="line"></span><br><span class="line">T(n) = 2*T(n/2) + n</span><br><span class="line">     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</span><br><span class="line">     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span><br><span class="line">     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     = 2^k * T(n/2^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure><p>当T(n/2^k)=T(1)时，也就是n/2^k=1，得到k=log2n。代入得到T(n)=Cn+nlog2n。大O标记法表示就是T(n)=O(nlogn)。</p><h4 id="4-3归并排序的空间复杂度"><a href="#4-3归并排序的空间复杂度" class="headerlink" title="4.3归并排序的空间复杂度"></a>4.3归并排序的空间复杂度</h4><p>归并排序的时间复杂度任何情况下都是O(nlogn)，但是归并排序并没有像快排那样应用广泛，原因在于它不是原地排序算法。因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。<br>空间复杂度为O(n)。</p><h3 id="5-快速排序-Quick-Sort"><a href="#5-快速排序-Quick-Sort" class="headerlink" title="5.快速排序(Quick Sort)"></a>5.快速排序(Quick Sort)</h3><p>快排利用的也是分治。不稳定。<br>思想：假设要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点)。遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。经过这一步骤之后，数组p到r之间的数据就被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。<br>根据分治、递推的处理思想，递归排序下标从p到<br>q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，说明所有的数据都有序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r</span><br><span class="line"></span><br><span class="line">// 快速排序，A 是数组，n 表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">// 快速排序递归函数，p,r 为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  if p &gt;= r then return</span><br><span class="line">  </span><br><span class="line">  q = partition(A, p, r) // 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-1)</span><br><span class="line">  quick_sort_c(A, q+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的处理过程是从下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程由上到下，先分区，然后再处理子问题。快排通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>现在有10个接口访问日志文件，每个日志文件大小约为300MB，每个文件里的日志都是按照时间戳从小到大排序的。希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB，如何能“快速”地将这10个日志文件合并？</p><h3 id="三、线性排序：如何根据年龄给100万用户数据排序？"><a href="#三、线性排序：如何根据年龄给100万用户数据排序？" class="headerlink" title="三、线性排序：如何根据年龄给100万用户数据排序？"></a>三、线性排序：如何根据年龄给100万用户数据排序？</h3><p>桶排序、计数排序、基数排序，这三种排序算法的时间复杂度是线性的，所以叫做线性排序(Linear Sort)。之所以能做到线性的时间复杂度，是因为这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p><h3 id="6-桶排序"><a href="#6-桶排序" class="headerlink" title="6.桶排序"></a>6.桶排序</h3><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><h4 id="6-1桶排序的时间复杂度"><a href="#6-1桶排序的时间复杂度" class="headerlink" title="6.1桶排序的时间复杂度"></a>6.1桶排序的时间复杂度</h4><p>如果要排序的数据有n个，我们把它们均匀地划分到m个桶内，每个桶内就有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为O(klogk)。m个桶排序的时间复杂度就是O(mklogk)，因为k=n/m，所以整个桶排序的时间复杂度就是O(nlog(n/m))。当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。</p><h4 id="6-2桶排序的应用场景"><a href="#6-2桶排序的应用场景" class="headerlink" title="6.2桶排序的应用场景"></a>6.2桶排序的应用场景</h4><p>桶排序对要排序数据的要求非常苛刻。首先，要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据排序完之后，桶与桶之间的数据不需要在进行排序。其次，数据在各个桶之间的分布是比较均匀的，如果数据经过桶的划分，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了，在极端情况下，如果数据都被分到一个桶里，那就退化为O(nlogn)了。<br>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。<br>比如说我们有10GB的订单数据，希望按订单金额(假设金额都是正整数)进行排序，但是我们内存有限，只有几百MB，没办法一次性把10GB的数据都加载到内存中。这个时候可以借助桶排序的思想来解决这个问题。<br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/tongpaixuyingxu.png"></p><h3 id="7-计数排序-Counting-Sort"><a href="#7-计数排序-Counting-Sort" class="headerlink" title="7.计数排序(Counting Sort)"></a>7.计数排序(Counting Sort)</h3><p>计数排序可以说是桶排序的一种特殊情况。<br>当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。<br>我们都经历过高考，高考查分系统，我们查分数的时候，系统会显示我们的成绩以及所在省的排名。2016年山东省有70万考生，如何通过成绩快速排序得出名次呢？<br>考生的满分是750分，最小是0分，这个数据的范围不算大，所以我们可以分成751个桶，对应分数从0到750分。根据考生的成绩，将这70万考生划分到751个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了70万考生的排序，因为只涉及扫描遍历操作，所以时间复杂度是O(n)。<br>计数排序的算法思想与桶排序类似，只是桶的大小粒度不一样，为什么叫“计数”，“计数”的含义来自哪里？<br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu1.png"><br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu2.png"><br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu3.png"><br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu4.jpg"></p><h3 id="8-基数排序-Radix-Sort"><a href="#8-基数排序-Radix-Sort" class="headerlink" title="8.基数排序(Radix Sort)"></a>8.基数排序(Radix Sort)</h3><p>再来看这样一个排序问题，假设我们有10万个手机号码，希望将这10万个手机号码从小到大排序，有什么比较快速的排序方法？<br>快排可以做到O(nlogn)，手机号码有11位，范围太大，不适合用桶排序、计数排序。<br>可以用基数排序。<br>假设要比较两个手机号码a和b的大小，如果在前面几位中，a手机号码已经比b的大了，那后面的几位就不用看了。<br>基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="关于模式"><a href="#关于模式" class="headerlink" title="关于模式"></a>关于模式</h2><p>在讨论模式之前，必须对“模式”这个词加以界定，以规范后面的讨论和研究。<br>简而言之，人们在自己的环境中不断发现问题和寻找问题的解决方案的时候，发现有一些问题及其解决方案不断变换面孔反复出现，但在这些不同的面孔后面有着共同的本质，这些共同的本质就是模式。<br>一个围棋下得好的人知道，好的“形”对于围棋非常重要。形是棋子在棋盘上的几何形状的抽象化。形就是模式(pattern)，也是人脑把握和认识外界的关键。模式化的过程是把问题抽象化，在忽略掉不重要的细节后，发现问题的一般性本质，并找到普遍使用的解决方案的过程。</p><h2 id="设计模式的7个原则"><a href="#设计模式的7个原则" class="headerlink" title="设计模式的7个原则"></a>设计模式的7个原则</h2><h3 id="开—闭原则-Open-Closed-Principle-OCP"><a href="#开—闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开—闭原则(Open-Closed Principle,OCP)"></a>开—闭原则(Open-Closed Principle,OCP)</h3><p>一个软件实体应当对扩展开放，对修改关闭。<br>在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。换言之，应当可以在不必修改源代码的前提下改变这个模块的行为。</p><h3 id="里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle,LSP)"></a>里氏代换原则(Liskov Substitution Principle,LSP)</h3><p>一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。<br>反过来的代换不成立，即如果一个软件实体使用的是一个子类，那么它不一定适用于基类。<br>里氏代换要求凡是基类型使用的地方，子类型一定适用，因此子类必须具备基类型的全部接口。</p><h3 id="依赖倒转原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒转原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle,DIP)"></a>依赖倒转原则(Dependence Inversion Principle,DIP)</h3><p>依赖于抽象，而不依赖于具体。<br>针对接口编程。<br>传统的过程性系统的设计办法倾向于使高层次的模块依赖于低层次的模块；抽象层次依赖于具体层次。依赖倒转原则是要把这个错误的依赖关系倒转过来。<br>里氏代换原则是依赖倒转原则的基础，依赖倒转原则是开-闭原则的基础。</p><h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle,ISP)"></a>接口隔离原则(Interface Segregation Principle,ISP)</h3><p>使用多个专门的接口比使用单一的总接口要好。<br>从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小的接口上的。<br>将“接口”理解为一个类所提供的所有方法的特征集合，也就是一种在逻辑上才存在的概念，这样的话，接口的划分就直接带来类型的划分。角色的合理划分。<br>将接口理解为狭义的java接口，这样一来，接口隔离原则讲的就是为同一个角色提供宽、窄不同的接口，以对付不同的客户端。定制服务。</p><h3 id="合成-聚合复用原则-Composite-Aggregate-Reuse-Principle-CARP"><a href="#合成-聚合复用原则-Composite-Aggregate-Reuse-Principle-CARP" class="headerlink" title="合成/聚合复用原则(Composite/Aggregate Reuse Principle,CARP)"></a>合成/聚合复用原则(Composite/Aggregate Reuse Principle,CARP)</h3><p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。<br>尽量使用合成/聚合，尽量不要使用继承。</p><h3 id="迪米特法则-Demeter-Principle"><a href="#迪米特法则-Demeter-Principle" class="headerlink" title="迪米特法则(Demeter Principle)"></a>迪米特法则(Demeter Principle)</h3><p>又叫做最少知识原则(Least Knowledge Principle，LKP)<br>一个对象应当对其他对象有尽可能少的了解。<br>只与你直接的朋友们通信；<br>不要跟“陌生人”说话；<br>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p><h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle, SRP)"></a>单一职责原则(Single Responsibility Principle, SRP)</h3><p>一个类只负责一个功能领域中的相应职责。</p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><h3 id="创建模式-5种"><a href="#创建模式-5种" class="headerlink" title="创建模式(5种)"></a>创建模式(5种)</h3><h3 id="结构模式-7种"><a href="#结构模式-7种" class="headerlink" title="结构模式(7种)"></a>结构模式(7种)</h3><h3 id="行为模式-11种"><a href="#行为模式-11种" class="headerlink" title="行为模式(11种)"></a>行为模式(11种)</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——递归</title>
      <link href="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/"/>
      <url>/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>推荐注册返佣金——现在很多App都有这个功能。用户A推荐用户B来注册，用户B又推荐了用户C来注册。可以说，用户C的“最终推荐人”为用户A，用户B的“最终推荐人”也为用户A，用户A没有“最终推荐人”。<br>一般来说，会通过数据库来记录这种推荐关系。在数据库表中，可以记录两行数据，其中actor_id表示用户id，referrer_id表示推荐人id。<br><img src="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/acre.jpg"><br>基于这个背景，给定一个用户ID，如何查找这个用户的“最终推荐人”？</p><h3 id="1-关于递归"><a href="#1-关于递归" class="headerlink" title="1.关于递归"></a>1.关于递归</h3><p>数据结构与算法，有两个最难理解的知识点，一个是动态规划，一个是递归。<br>递归是一中应用非常广泛的算法(或者编程技巧)，有很多数据结构与算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等。<br>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</p><h3 id="2-递归需要满足的三个条件"><a href="#2-递归需要满足的三个条件" class="headerlink" title="2.递归需要满足的三个条件"></a>2.递归需要满足的三个条件</h3><h4 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1)一个问题的解可以分解为几个子问题的解"></a>1)一个问题的解可以分解为几个子问题的解</h4><p>子问题就是数据规模更小的问题。</p><h4 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2)这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2)这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h4><h4 id="3-存在递归终止条件"><a href="#3-存在递归终止条件" class="headerlink" title="3)存在递归终止条件"></a>3)存在递归终止条件</h4><p>把问题分解为子问题，子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，需要有终止条件。</p><h3 id="3-如何编写递归代码"><a href="#3-如何编写递归代码" class="headerlink" title="3.如何编写递归代码"></a>3.如何编写递归代码</h3><p>写递归代码最关键的是写出递推公式，找到终止条件，将递推公式转化为代码。<br>假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问这n个台阶有多少中走法？<br>如果有7个台阶，可以2，2，2，1这样上去，也可以1，2，1，1，2这样，走法很多，如何用编程求得总共有多少中走法？<br>想一下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法加上先走2阶后，n-2个台阶的走法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure><p>再来看终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法，所以f(1)=1。然而，只有这一个是不够的。<br>n=2时，f(2)=f(1)+f(0)，如果递归终止条件只有一个f(1)=1，那f(2)就无法求解了，而f(0)是客观不可行的，所以要把f(2)=2作为一个终止条件，表示走两个台阶，有两种走法，一步走完或者分两步来走。<br>把递归终止条件和递推公式放到一起就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(1)=1</span><br><span class="line">f(2)=2</span><br><span class="line">f(n)=f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><p>转化为递归代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int f(int n)</span><br><span class="line">&#123;</span><br><span class="line">if(n == 1) return 1;</span><br><span class="line">if(n == 2) return 2;</span><br><span class="line">return f(n-1) + f(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。"><a href="#写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。" class="headerlink" title="写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。"></a>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。</h4><p>当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解。像刚刚这个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归坪铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。<br>对于递归代码，这种试图想搞清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。<br>如果一个问题A可以分解为若干子问题B、C、D，可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而且，只需要思考问题A和子问题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题和子子问题，子子问题和子子子问题之间的关系，屏蔽掉递归细节。</p><h4 id="编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。"><a href="#编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。" class="headerlink" title="编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。"></a>编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。</h4><h3 id="4-递归代码要警惕堆栈溢出"><a href="#4-递归代码要警惕堆栈溢出" class="headerlink" title="4.递归代码要警惕堆栈溢出"></a>4.递归代码要警惕堆栈溢出</h3><p>为什么递归代码容易造成堆栈溢出？如何预防堆栈溢出？<br>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br>上面的例子，如果将系统栈或者JVM堆栈大小设置为1KB，在求解f(1999)时便会出现如下堆栈报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>如何避免出现堆栈溢出？<br>声明一个全局变量，可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度(比如1000)之后，就不继续往下再递归了，直接返回报错。<br>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，会影响代码的可读性。所以，如果最大深度比较小，比如10、50，可以用这种方法，否则这种方法并不是很实用。</p><h3 id="5-递归代码要警惕重复计算"><a href="#5-递归代码要警惕重复计算" class="headerlink" title="5.递归代码要警惕重复计算"></a>5.递归代码要警惕重复计算</h3><p><img src="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/fchongfujisuan.jpg"><br>从图中，可以看到，想要计算f(5),需要先计算f(4)和 f(3)，而计算f(4) 还需要计算f(3)，因此f(3) 就被计算了很多次，这就是重复计算问题。<br>为了避免重复计算，可以通过一个数据结构(比如散列表)来保存已经求解过的f(k)。当递归调用到f(k)时，先从中看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">  if (n == 1) return 1;</span><br><span class="line">  if (n == 2) return 2;</span><br><span class="line">  </span><br><span class="line">  // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)</span><br><span class="line">  if (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    return hasSovledList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int ret = f(n-1) + f(n-2);</span><br><span class="line">  hasSovledList.put(n, ret);</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。</p><h3 id="6-递归代码改写为非递归代码"><a href="#6-递归代码改写为非递归代码" class="headerlink" title="6.递归代码改写为非递归代码"></a>6.递归代码改写为非递归代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int f(n)</span><br><span class="line">&#123;</span><br><span class="line">if(n == 1) return 1;</span><br><span class="line">if(n == 2) return 2;</span><br><span class="line"></span><br><span class="line">int ret = 0;</span><br><span class="line">int pre = 2;</span><br><span class="line">int prepre = 1;</span><br><span class="line">for(int i = 3; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = pre + prepre;</span><br><span class="line">prepre = pre;</span><br><span class="line">pre = ret;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">//刚好这个走台阶的问题类似斐波那契数列</span><br></pre></td></tr></table></figure><p>抽象出递推公式、初始值和边界条件，用迭代循环实现改写。<br>是不是所有的递归代码都可以改写为这种迭代循环的非递归写法？<br>笼统地讲，是的。因为递归本身就是借助栈来实现的，因不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。<br>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也没有解决前面讲到的某些问题，徒增了实现的复杂度。</p><h3 id="如何找到“最终推荐人”"><a href="#如何找到“最终推荐人”" class="headerlink" title="如何找到“最终推荐人”"></a>如何找到“最终推荐人”</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long findRootReferrerId(long actorId)</span><br><span class="line">&#123;</span><br><span class="line">Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">if(referrerId == null) return actorId;</span><br><span class="line">return findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际项目中，这三行代码并不能工作，为啥？这里面有两个问题。<br>一，如果递归很深，可能会有堆栈溢出的问题。<br>二，如果数据库里存在脏数据，还需要处理由此产生的无限递归问题。比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果A的推荐人是B，B的推荐人是C，C 的推荐人是A，这样就会发生死循环。<br>第一个问题，可以用限制递归深度来解决。<br>第二个问题，自动检测A-B-C-A这种“环”的存在。如何来检测环的存在？</p><h3 id="思考：对于递归代码，有什么好的调试方法？"><a href="#思考：对于递归代码，有什么好的调试方法？" class="headerlink" title="思考：对于递归代码，有什么好的调试方法？"></a>思考：对于递归代码，有什么好的调试方法？</h3><p>1.打印日志发现，递归值。<br>2.结合条件断点进行调试。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——队列</title>
      <link href="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/"/>
      <url>/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>我们知道，CPU资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致CPU频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><h4 id="当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？"><a href="#当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？" class="headerlink" title="当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？"></a>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</h4><h4 id="1-如何理解“队列”"><a href="#1-如何理解“队列”" class="headerlink" title="1.如何理解“队列”"></a>1.如何理解“队列”</h4><p>队列这个概念可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。<br>队列跟栈相似，支持的操作也有限，最基本的操作也是两个：入队enqueue()，放一个数据到队列尾部；出队dequeue()，从队列头部取一个元素。<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/duiliehezhan.jpg"><br>队列和栈一样，也是一种操作受限的线性表数据结构。<br>作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；java concurrent并发包利用ArrayBlockingQueue来实现公平锁等。</p><h4 id="2-顺序队列和链式队列"><a href="#2-顺序队列和链式队列" class="headerlink" title="2.顺序队列和链式队列"></a>2.顺序队列和链式队列</h4><p>用数组实现的队列叫做顺序队列，用链表实现的队列叫做链式队列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//用数组实现的队列</span><br><span class="line">public class ArrayQueue</span><br><span class="line">&#123;</span><br><span class="line">//数组:items 数组大小:n</span><br><span class="line">private String[] items;</span><br><span class="line">private int n=0;</span><br><span class="line">//head表示队头下标 tail表示队尾下标</span><br><span class="line">private int head=0;</span><br><span class="line">private int tail=0;</span><br><span class="line"></span><br><span class="line">//申请一个大小为capacity的数组</span><br><span class="line">public ArrayQueue(int capacity)</span><br><span class="line">&#123;</span><br><span class="line">items = new String[capacity];</span><br><span class="line">n = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入队</span><br><span class="line">public boolean enqueue(String item)</span><br><span class="line">&#123;</span><br><span class="line">//如果tail==n 表示队列已满</span><br><span class="line">if(tail == n) return false;</span><br><span class="line">items[tail] = item;</span><br><span class="line">tail++;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//出队</span><br><span class="line">public String dequeue()</span><br><span class="line">&#123;</span><br><span class="line">//如果head==tail 表示队列为空</span><br><span class="line">if(head == tail) return null;</span><br><span class="line">String ret = item[head];</span><br><span class="line">head++;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于栈来说，只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/queue1.jpg"><br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/queue2.jpg"><br>随着不停的入队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题如何解决？<br>在数组中，数组的删除操作会导致数组中的数据不连续，解决方法是用数据搬移。但是，每次进行出队操作删除队列头的元素(相当于删除数组下标为0的数据)，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的O(1)变为O(n)。如何优化呢？<br>实际上，在出队时可以不用搬移数据。如果没有空闲空间了，只需要在入队时，集中触发一次数据的搬移操作。借助这个思想，出队函数dequeue()保持不变，改动一下入队函数enqueue():</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//入队操作，将item放入队尾</span><br><span class="line">public boolean enqueue(String item)</span><br><span class="line">&#123;</span><br><span class="line">//tail==n表示队列末尾没有空间了</span><br><span class="line">if(tail == n)</span><br><span class="line">&#123;</span><br><span class="line">//如果tail==n并且head==0表示整个队列都占满了，无法在添加元素</span><br><span class="line">if(head == 0) return false;</span><br><span class="line">//数据搬移</span><br><span class="line">for(int i=head;i&lt;tail;i++)</span><br><span class="line">&#123;</span><br><span class="line">item[i-head] = items[i];</span><br><span class="line">&#125;</span><br><span class="line">//搬移完之后更新head和tail</span><br><span class="line">tail -= head;</span><br><span class="line">head = 0;</span><br><span class="line">&#125;</span><br><span class="line">items[tail] = item;</span><br><span class="line">tail++;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于链表的实现，同样需要两个指针：head指针和tail指针。它们分别指向链表的第一个结点和最后一个结点。入队时，tail-&gt;next=new_node,tail=tail-&gt;next;出队时，head=head-&gt;next。<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/lianbiaoduilie.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//基于链表的实现</span><br><span class="line">public class QueueBasedOnLinkedList &#123;</span><br><span class="line">private static class Node &#123;</span><br><span class="line">    private String data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(String data, Node next) &#123;</span><br><span class="line">      this.data = data;</span><br><span class="line">      this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getData() &#123;</span><br><span class="line">      return data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private Node head = null;</span><br><span class="line">  private Node tail = null;</span><br><span class="line"></span><br><span class="line">  public void enqueue(String value) &#123;</span><br><span class="line">    if (tail == null) &#123;</span><br><span class="line">      Node newNode = new Node(value, null);</span><br><span class="line">      head = newNode;</span><br><span class="line">      tail = newNode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tail.next = new Node(value, null);</span><br><span class="line">      tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String dequeue() &#123;</span><br><span class="line">    if (head == null) return null;</span><br><span class="line"></span><br><span class="line">    String value = head.data;</span><br><span class="line">    head = head.next;</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">      tail = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void printAll() &#123;</span><br><span class="line">    Node p = head;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">      System.out.print(p.data + &quot; &quot;);</span><br><span class="line">      p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3.循环队列"></a>3.循环队列</h4><p><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/jiayichu.JPG"><br>循环队列，顾名思义，它长得像一个环。原本队列是有首有尾的，是一条直线，现在把它首尾相连，扳成了一个环。</p><p><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/xunhuanduilie.jpg"><br>图中这个队列的大小为8，当前head=4，tail=7.当有一个新的元素a入队时，放入下标为7的位置。但这个时候，并不把tail更新为8，而是将其在环中后移一位，到下标为0的位置。当再有一个元素b入队时，将b放入下标为0的位置，然后tail+1更新为1。所以，a、b依次入队之后：<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/xunhuan-ab.jpg"><br>循环队列的代码实现难度要比非循环队列难一些，关键在于，确定好队空和队满的判定条件。<br>用数组实现的非循环队列中，队满的判定条件是tail==n，队空的判定条件是head==tail。<br>循环队列为空的判断条件仍然是head==tail。队满的判断条件稍有不同：<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/xunhuan-duiman.jpg"></p><h4 id="当队满时，-tail-1-n-head。"><a href="#当队满时，-tail-1-n-head。" class="headerlink" title="当队满时，(tail+1)%n=head。"></a>当队满时，(tail+1)%n=head。</h4><p>当队列满时，图中tail指向的位置实际上是没有存储数据的，这种方法是少用一个元素空间，约定以“队列头指针在队列尾指针的下一位置上”作为队列“满”的标志。<br>另一种方法是另设一个标志位以区别队列是“空”还是“满”。另外占用一个内存空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CircularQueue &#123;</span><br><span class="line">  // 数组：items，数组大小：n</span><br><span class="line">  private String[] items;</span><br><span class="line">  private int n = 0;</span><br><span class="line">  // head 表示队头下标，tail 表示队尾下标</span><br><span class="line">  private int head = 0;</span><br><span class="line">  private int tail = 0;</span><br><span class="line"></span><br><span class="line">  // 申请一个大小为 capacity 的数组</span><br><span class="line">  public CircularQueue(int capacity) &#123;</span><br><span class="line">    items = new String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 入队</span><br><span class="line">  public boolean enqueue(String item) &#123;</span><br><span class="line">    // 队列满了</span><br><span class="line">    if ((tail + 1) % n == head) return false;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + 1) % n;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 出队</span><br><span class="line">  public String dequeue() &#123;</span><br><span class="line">    // 如果 head == tail 表示队列为空</span><br><span class="line">    if (head == tail) return null;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + 1) % n;</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-阻塞队列和并发队列"><a href="#4-阻塞队列和并发队列" class="headerlink" title="4.阻塞队列和并发队列"></a>4.阻塞队列和并发队列</h4><p>队列这种数据结构很基础，平时的业务开发不大可能从0实现一个队列，甚至不会用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。<br>阻塞队列是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/zuseduilie1.jpg"><br>上述的定义就是一个“生产者—消费者模型”。使用阻塞队列可以轻松实现一个“生产者—消费者模型”。<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/zuseduilie2.jpg"></p><p>那，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，如何实现一个线程安全的队列呢？<br>线程安全的队列叫做并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发操作，这也是循环队列比链式队列应用更加广泛的原因，</p><h4 id="5-线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？"><a href="#5-线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？" class="headerlink" title="5.线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？"></a>5.线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？</h4><p>一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<br>对于如何存储排队的请求，我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。基于链表和基于数组实现的队列对于排队请求有何区别？<br>基于链表的实现方式，可以实现一个支持无限排队的无界队列(unbounded queue)，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。<br>基于数组实现的有界队列(bounded queue)，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，是很有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。<br>除了队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考:"></a>思考:</h4><h4 id="1-除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？"><a href="#1-除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？" class="headerlink" title="(1)除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？"></a>(1)除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？</h4><h4 id="2-如何实现无锁并发队列？"><a href="#2-如何实现无锁并发队列？" class="headerlink" title="(2)如何实现无锁并发队列？"></a>(2)如何实现无锁并发队列？</h4><p><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/sikao.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——栈</title>
      <link href="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/"/>
      <url>/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h4 id="如何实现浏览器的前进和后退功能？"><a href="#如何实现浏览器的前进和后退功能？" class="headerlink" title="如何实现浏览器的前进和后退功能？"></a>如何实现浏览器的前进和后退功能？</h4><p>当你依次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面b和a。当你后退到页面a，点击前进按钮，就可以重新查看页面b和c。但是，如果你后退到页面b后，点击了新的页面d，那就无法在通过前进、后退功能查看页面c了。</p><h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><p>方法调用！</p><h4 id="如何理解栈？"><a href="#如何理解栈？" class="headerlink" title="如何理解栈？"></a>如何理解栈？</h4><p>关于“栈”，有一个非常贴切的例子，就是一摞叠在一起的盘子。放盘子的时候，都是从下往上一个一个放；取的时候，从上往下一个一个地依次取，不能从中间任意抽出。后进者先出，先进者后出，这就是典型的“栈”结构。<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/zhan.jpg"><br>从栈的操作特性上看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。<br>特定的数据结构是对特定场景的抽象，数据或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时比较不可控。<br>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</p><h4 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h4><p>栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，叫做顺序栈；用链表实现的栈，叫做链式栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 基于数组实现的顺序栈</span><br><span class="line">public class ArrayStack &#123;</span><br><span class="line">  private String[] items;  // 数组</span><br><span class="line">  private int count;       // 栈中元素个数</span><br><span class="line">  private int n;           // 栈的大小</span><br><span class="line"></span><br><span class="line">  // 初始化数组，申请一个大小为 n 的数组空间</span><br><span class="line">  public ArrayStack(int n) &#123;</span><br><span class="line">    this.items = new String[n];</span><br><span class="line">    this.n = n;</span><br><span class="line">    this.count = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 入栈操作</span><br><span class="line">  public boolean push(String item) &#123;</span><br><span class="line">    // 数组空间不够了，直接返回 false，入栈失败。</span><br><span class="line">    if (count == n) return false;</span><br><span class="line">    // 将 item 放到下标为 count 的位置，并且 count 加一</span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 出栈操作</span><br><span class="line">  public String pop() &#123;</span><br><span class="line">    // 栈为空，则直接返回 null</span><br><span class="line">    if (count == 0) return null;</span><br><span class="line">    // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span><br><span class="line">    String tmp = items[count-1];</span><br><span class="line">    --count;</span><br><span class="line">    return tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//基于链表实现的链式栈</span><br><span class="line">public class StackBasedOnLinkedList &#123;</span><br><span class="line"></span><br><span class="line">private static class Node &#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(int data, Node next) &#123;</span><br><span class="line">      this.data = data;</span><br><span class="line">      this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getData() &#123;</span><br><span class="line">      return data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private Node top = null;</span><br><span class="line"></span><br><span class="line">  public void push(int value) &#123;</span><br><span class="line">    Node newNode = new Node(value, null);</span><br><span class="line"></span><br><span class="line">    if (top == null) &#123;</span><br><span class="line">      top = newNode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      newNode.next = top;</span><br><span class="line">      top = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int pop() &#123;</span><br><span class="line">    if (top == null) return -1;</span><br><span class="line">    int value = top.data;</span><br><span class="line">    top = top.next;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void printAll() &#123;</span><br><span class="line">    Node p = top;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">      System.out.print(p.data + &quot; &quot;);</span><br><span class="line">      p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为n的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)。入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度是O(1)。<br>注意，这里存储数据需要一个大小为n的数组，并不是说空间复杂度就是O(n)。因为，这n个空间是必须的，无法省掉。所以在说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p><h4 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h4><p>刚才那个基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储next指针，内存消耗相对较多。<br>基于数组实现一个可以支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，就申请一个更大的数组，将原来的数据搬移到新数组中。<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/dongtaikuorong.jpg"><br>动态扩容的顺序栈，对于出栈操作来说，不会涉及到内存的重新申请和数据搬移，所以出栈的时间复杂度是O(1)。但是对于入栈操作来说，当栈中有空闲空间时，入栈操作的时间复杂度为O(1)，当空间不够时，就需要重新申请内存和数据搬移，时间复杂度就成了O(n)。<br>入栈操作，最好情况时间复杂度是O(1)，最坏情况时间复杂度是O(n)。均摊时吉安复杂度是O(1)。<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/juntan.jpg"></p><h4 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h4><p>栈作为一个比较基础的数据结构，比较经典的一个应用场景是函数调用栈。<br>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   int a = 1; </span><br><span class="line">   int ret = 0;</span><br><span class="line">   int res = 0;</span><br><span class="line">   ret = add(3, 5);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   printf(&quot;%d&quot;, res);</span><br><span class="line">   reuturn 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int add(int x, int y) &#123;</span><br><span class="line">   int sum = 0;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，main()函数调用了add()函数，获取计算结果，与临时变量a相加，最后打印res的值。下图可以看到这个过程对应的函数栈里出栈、入栈的操作，在执行到add()函数时，函数调用栈的情况。<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/hanshuzhanzhen.jpg"></p><h4 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h4><p>栈的另一个常见的应用场景，编译器利用栈来实现表达式求值。<br>这里将算术表达式简化为只包含加减乘除四则运算(其实更复杂的还有与或非等逻辑运算、括号等)，比如：34+13*9+44-12/3。</p><p>对于这个四则运算，人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事。<br>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素比较。如果比运算符栈栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/biaodashiqiuzhi.jpg"></p><h4 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h4><p>借助栈来检查表达式中的括号是否匹配。<br>假设表达式中只包含三种括号，圆括号()、方括号[]、花括号{}，并且它们可以任意嵌套。比如，{[()]}或[({})([])]等都为合法形式，而([){}]为不合法形式。对于一个只包含括号的表达式字符串，如何检查它是否合法呢？<br>思路：用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，就将其压入栈中；当扫描到右括号时，将其与栈顶左括号匹配，若能够匹配，将此栈顶左括号出栈，继续扫描其余的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有左括号，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法形式；否则，说明有未匹配的左括号，为非法格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        //栈中只进左括号 每当有一个括号要进栈时就看它是不是与栈顶括号相匹配 匹配就pop 不匹配就进栈</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        char[] chars=s.toCharArray();</span><br><span class="line">        for(char theChar:chars)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stack.size()==0)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(theChar);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(isCompact(stack.peek(),theChar))</span><br><span class="line">            &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(theChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.size()==0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean isCompact(char a,char b)</span><br><span class="line">    &#123;</span><br><span class="line">        return ( (a==&#x27;(&#x27; &amp;&amp; b==&#x27;)&#x27;) || (a==&#x27;&#123;&#x27; &amp;&amp; b==&#x27;&#125;&#x27;) || (a==&#x27;[&#x27; &amp;&amp; b==&#x27;]&#x27;) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用两个栈来实现浏览器的前进、后退功能"><a href="#用两个栈来实现浏览器的前进、后退功能" class="headerlink" title="用两个栈来实现浏览器的前进、后退功能"></a>用两个栈来实现浏览器的前进、后退功能</h4><p>使用两个栈X和Y，把首次浏览的页面依次压入栈X，当点击后退按钮时，依次从栈X中出现，并将出栈的数据依次放入栈Y。当点击前进按钮时，依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，就说明没有页面可以继续后退浏览了。当栈Y中没有数据，说明没有页面可以点击前进按钮浏览了。</p><p>举个例子，我们顺序查看了a-b-c三个页面，依次把a、b、c压入栈：<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/abc.jpg"><br>通过浏览器的后退按钮，从页面c后退到页面a之后，就依次把c和b从栈X中弹出，并且依次放入到栈Y中：<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/tuibc.jpg"><br>点击前进按钮回到b页面，将b从栈Y中弹出，放入栈X：<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/jinb.jpg"><br>通过页面b跳转到新的页面d，页面c就无法再通过前进、后退按钮重复查看，这是清空栈Y：<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/dianjixindeyemian.jpg"></p><h4 id="为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗"><a href="#为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗" class="headerlink" title="为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗?"></a>为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗?</h4><p>不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最好的选择。<br>从调用函数进入被调用函数，对于数据来说，变化的是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p><h4 id="JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储java中的对象。那JVM中的“栈”和这里说的“栈”是不是一回事？如果不是，那它为什么又叫做“栈”"><a href="#JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储java中的对象。那JVM中的“栈”和这里说的“栈”是不是一回事？如果不是，那它为什么又叫做“栈”" class="headerlink" title="JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储java中的对象。那JVM中的“栈”和这里说的“栈”是不是一回事？如果不是，那它为什么又叫做“栈”?"></a>JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储java中的对象。那JVM中的“栈”和这里说的“栈”是不是一回事？如果不是，那它为什么又叫做“栈”?</h4><p>我以为内存中的栈和数据结构的栈不是一个概念。内存中的堆栈是内存中的数据区域，是一段虚拟的内存空间，数据结构中的堆栈是抽象的数据存储结构。但是它们都有“栈”的特性。<br>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为堆和栈。<br>代码区：存储方法体的二进制代码。高级调度(作业)、中级调度(内存)、低级调度(进程)控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——链表</title>
      <link href="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="经典链表应用场景：LRU缓存淘汰算法"><a href="#经典链表应用场景：LRU缓存淘汰算法" class="headerlink" title="经典链表应用场景：LRU缓存淘汰算法"></a>经典链表应用场景：LRU缓存淘汰算法</h4><p>缓存是一种提高数据读取性能技术，硬件设计和软件开发中都有应用：CPU缓存、数据库缓存、浏览器缓存等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留，需要缓存淘汰策略来决定，如：先进先出策略(first in first out)、最少使用策略LFU(least frequently used)、最近最少使用策略(least recently used)。<br>所以想一下，如何用链表来实现LRU缓存淘汰策略？</p><h4 id="数组-amp-链表：底层存储结构"><a href="#数组-amp-链表：底层存储结构" class="headerlink" title="数组&amp;链表：底层存储结构"></a>数组&amp;链表：底层存储结构</h4><p>数组需要一块连续的内存空间来存储，对内存的要求比较高。如果需要申请一个100MB大小的数组，当内存中没有连续的、足够大的内存空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败。<br>链表，不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。<br><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/neicunfenbu.jpg"></p><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>链表通过指针将一组零散的内存块串联在一起。我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，把这个记录下个结点地址的指针叫做后继指针next。<br><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/danlianbiao.jpg"><br>单链表中，有两个结点是比较特殊的，分别是第一个结点和最后一个结点。习惯性地把第一个结点叫做头结点，把最后一个结点叫做尾结点。头结点用来记录链表的基地址，通过它可以遍历得到整条链表。尾结点的指针不是指向下一个结点，而是指向一个空地址null，表示这是链表上最后一个结点。<br>与数组一样，链表也支持数据的查找、插入和删除操作。<br>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)。而在链表中插入或者删除一个数据，不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。<br>针对链表的插入和删除操作，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)。<br><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/charuandshanchu.jpg"><br>但是，链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据不是连续存储的，就无法像数组那样，根据首地址和下标，通过寻址公式只算计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表是一种特殊的单链表。唯一区别在于尾结点。单链表的尾结点指针指向空地址，表示这是最后的结点；而循环链表的尾结点指针指向链表的头结点。<br><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/xunhuanlianbiao.jpg"><br>循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环形结构特点时适合采用，比如著名的<a href="https://blog.csdn.net/weixin_38214171/article/details/80352921">约瑟夫问题</a>。</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。<br><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/shuangxianglianbiao.jpg"><br>双向链表需要额外的两个空间来存储后继节点和前驱结点的地址。所以如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。但它支持双向遍历。</p><h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><p><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/shuangxiangxunhuan.jpg"></p><h3 id="单链表-amp-双向链表比较"><a href="#单链表-amp-双向链表比较" class="headerlink" title="单链表&amp;双向链表比较"></a>单链表&amp;双向链表比较</h3><h4 id="1-删除结点中“值等于某个给定值”的结点"><a href="#1-删除结点中“值等于某个给定值”的结点" class="headerlink" title="1.删除结点中“值等于某个给定值”的结点"></a>1.删除结点中“值等于某个给定值”的结点</h4><h4 id="2-删除给定指针指向的结点"><a href="#2-删除给定指针指向的结点" class="headerlink" title="2.删除给定指针指向的结点"></a>2.删除给定指针指向的结点</h4><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过前面讲的指针操作将其删除。尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度是O(n)。<br>对于第二种情况，已经找到了要删除的结点，但是删除某个结点q需要知道指向它的前驱结点p，而单链表不支持直接获取前驱结点，所以为了找到前驱结点，还是要从头结点开始遍历链表，知道p-&gt;next=q，说明p是q的前驱结点。但是对于双向链表来说，因为双向链表的结点中已经保存了前驱结点的指针，就不需要像单链表那样遍历。<br>对于插入操作，在链表的指定结点前面插入一个结点，双向链表可以在O(1)时间复杂度搞定，而单向链表需要O(n)的时间复杂度。<br>除此之外，对于一个有序链表，双向链表的按值查询的效率要比单链表高一些。因为双向链表可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>Java中LinkedHashMap的实现中就用到了双向链表这种数据结构。</p><h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>当内存空间充足的时候，如果我们更加追求代码的执行速度，就可以选择空间复杂度相对较高但时间复杂度相对很低的算法或者数据结构。<br>相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，要反过来用时间换空间的设计思路。<br>实际上，缓存就是利用了空间换时间的设计思想。</p><h3 id="链表-amp-数组：性能比较"><a href="#链表-amp-数组：性能比较" class="headerlink" title="链表&amp;数组：性能比较"></a>链表&amp;数组：性能比较</h3><p><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/xingneng.jpg"><br>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高；而链表在内存中不是连续存储，所以对CPU缓存不友好，没办法有效预读。<br>引申：CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(具体大小这里不确定，跟CPU实现有关)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取，反之要去内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的矛盾。对于数组来说，存储空间是连续的，所以在加载某个下标的时候就可以把后面的几个下标元素也加载到CPU缓存，这样执行速度就快于存储空间不连续的链表存储。<br>链表本身没有大小限制，天然的支持动态扩容，插入元素只需要修改指针的指向就可以，这是我理解的链表与数组的最大区别。</p><h4 id="如何基于链表实现LRU缓存淘汰算法"><a href="#如何基于链表实现LRU缓存淘汰算法" class="headerlink" title="如何基于链表实现LRU缓存淘汰算法"></a>如何基于链表实现LRU缓存淘汰算法</h4><p>思路：维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表：<br>1.如果此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，将其从原来的位置删除，然后再插入到链表的头部。<br>2.如果此数据没有在缓存链表中：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则删除链表尾结点，再将新的数据结点插入到链表的头部。<br>这样，不管缓存有没有满，都需要遍历一遍链表，这种基于链表的实现思路，缓存访问的时间复杂度是O(n)。<br>引申：引入散列表(Hash Table)来记录每个数据的位置，可以将缓存访问的时间复杂度降到O(1)。</p><h4 id="如何基于数组实现LRU缓存淘汰策略？"><a href="#如何基于数组实现LRU缓存淘汰策略？" class="headerlink" title="如何基于数组实现LRU缓存淘汰策略？"></a>如何基于数组实现LRU缓存淘汰策略？</h4><p>思路：维护一个有序的数组，越靠近数组首位置的数据越是最早访问的，当有一个新的数据被访问时：<br>1.如果这个数据已经存在于数组中，把对应位置的数据删掉，直接把这个数据加到数组的最后一位。时间复杂度为O(n)。<br>2.如果这个数据不存在这个数组中，数组还有空间的话，就把这个数据直接添加到最后一位；没有空间的话，删除掉数组的第一个元素，然后把数据插入到数组最后一个。时间复杂度为O(n)。</p><h4 id="如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？"><a href="#如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？" class="headerlink" title="如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？"></a>如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？</h4><p>思路：使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">  public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">    if (head == null || head.next == null) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line"></span><br><span class="line">    while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">      ListNode next = slow.next;</span><br><span class="line">      slow.next = prev;</span><br><span class="line">      prev = slow;</span><br><span class="line">      slow = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fast != null) &#123;  //奇数个结点时</span><br><span class="line">      slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (slow != null) &#123;</span><br><span class="line">      if (slow.val != prev.val) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——2.4OutOfMemoryError异常</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%942.4OutOfMemoryError%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%942.4OutOfMemoryError%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>在java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。</p><h3 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1. Java堆溢出"></a>1. Java堆溢出</h3><p>java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量到达最大堆的容量限制后产生内存溢出异常。</p><h3 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2. 虚拟机栈和本地方法栈溢出"></a>2. 虚拟机栈和本地方法栈溢出</h3><p>由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数(设置本地方法栈大小)虽然存在，但实际上是无效的，栈容量只由-Xss参数设定。</p><p>关于虚拟机栈和本地方法栈，在java虚拟机规范中描述了两种异常：</p><ol><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ol><p>这里把异常分成两种情况看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。</p><p>在单线程的操作中，以下两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError异常：</p><ol><li>使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的栈深度相应缩小。</li><li>定义了大量的本地变量，增加此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的栈深度相应缩小。</li></ol><h3 id="3-运行时常量池溢出"><a href="#3-运行时常量池溢出" class="headerlink" title="3.运行时常量池溢出"></a>3.运行时常量池溢出</h3><h3 id="4-方法区溢出"><a href="#4-方法区溢出" class="headerlink" title="4.方法区溢出"></a>4.方法区溢出</h3><h3 id="5-本机直接内存溢出"><a href="#5-本机直接内存溢出" class="headerlink" title="5.本机直接内存溢出"></a>5.本机直接内存溢出</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——2.3对象访问</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%942.3%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%942.3%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>在java语言中，对象访问是如何进行的？</p><p>对象访问在java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会涉及java栈、java堆和方法区这三个最重要内存区域之间的关联关系。</p><h4 id="Object-obj-new-Object"><a href="#Object-obj-new-Object" class="headerlink" title="Object obj = new Object();"></a>Object obj = new Object();</h4><p>假设这句代码出现在方法体中，那<code>Object obj</code>这部分的语义将会反映到<code>java栈的本地变量表</code>中，作为一个reference类型数据出现。而<code>new Object()</code>这部分的语义将会反应到<code>java堆</code>中，形成一块存储了<code>Object类型所有实例数据值(Instance Data，对象中各个实例字段的数据)的结构化内存</code>，根据具体类型以及虚拟机实现的对象内存布局(Object Memory Layout)的不同，这块内存的长度是不固定的。<br>另外，在java堆中还必须包含能查找到此对象类型数据(如对象类型、父类、实现的接口、方法等)的地址信息，这些类型数据则存储在<code>方法区</code>中。</p><p>由于reference类型在java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。</p><ol><li><p>如果使用<code>句柄</code>访问方式，java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%942.3%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/jubingfangwen.png" alt="通过句柄访问对象"></p></li><li><p>如果使用<code>直接指针</code>访问方式，java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%942.3%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/zhijiezhizhen.png" alt="通过直接指针访问对象"></p></li></ol><p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普通的行为)时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p><p>就<code>Sun HotSpot</code>而言，它是使用<code>直接指针</code>进行对象访问的；从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——2.2运行时数据区域</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%942.2%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%942.2%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%942.2%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/yunxingshishujuquyu.png"></p><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><p>程序计数器(program counter register)是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p><p>在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说一个内核)只会执行一条线程中的指令。<br>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为<code>线程私有</code>的内存。</p><p>如果线程正在执行的是一个<code>java方法</code>，这个计数器记录的是正在执行的<code>虚拟机字节码指令的地址</code>；如果正在执行的是<code>native方法</code>，这个计数器值则为<code>空(undefined)</code>。</p><p>此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="2-java虚拟机栈"><a href="#2-java虚拟机栈" class="headerlink" title="2.java虚拟机栈"></a>2.java虚拟机栈</h3><p>与程序计数器一样，java虚拟机栈(java virtual machine stacks)也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会同时创建一个<code>栈帧</code>(stack frame,栈帧是方法运行期的基础数据结构)用于存储<code>局部变量表、操作栈、动态链接、方法出口</code>等信息。<br>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>经常有人把java内存区分为堆内存(heap)和栈内存(stack)，这种分法比较粗糙，java内存区域的划分实际上远比这复杂。<br>这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。<br>其中的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。</p><p>局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、long、float、double)、对象引用(reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。<br>其中64位长度的long和double类型的数据会占用两个局部变量空间(slot)，其余的数据类型只占用1个。<br>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机栈可以动态扩展(当前大部分的java虚拟机都可动态扩展，只不过java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出<code>OutOfMemoryError</code>异常。</p><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h3><p>本地方法栈(native method stacks)与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的<code>native方法</code>服务。</p><p>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。<br>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><p>关于本地方法：一个Native Method就是一个java程序调用非java代码的接口。<br>一个本地方法是这样一个java的方法：该方法的实现由非java语言实现，比如C。<br>这个特征并非java所特有，很多其他的编程语言都有这一机制……</p><h3 id="4-java堆"><a href="#4-java堆" class="headerlink" title="4.java堆"></a>4.java堆</h3><p>对于大多数应用来说，java堆(java Heap)是java虚拟机所管理的内存中最大的一块。<br>java堆是被所有<code>线程共享</code>的一块内存区域，在虚拟机启动时创建。</p><p>此内存区域的唯一目的就是<code>存放对象实例</code>，几乎所有的对象实例都在这里分配内存。这一点在java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。<br>但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，<code>栈上分配、标量替换优化技术</code>将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作<code>GC堆(garbage collected heap)</code>。<br>如果从<code>内存回收</code>的角度看，由于现在收集器基本都是采用的<code>分代收集算法</code>，所以java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。<br>如果从<code>内存分配</code>的角度看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区(thread local allocation buffer,TLAB)。<br>不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><p>根据java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。<br>在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。<br>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h3><p>方法区中的信息：类的静态方法、静态变量、常量池、类的代码。</p><p>方法区(method area)与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”(Permanent Generation)，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。<br>对于其他虚拟机(如BEA JRockit、IBM J9等)来说是不存在永久代的概念的。<br>即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。</p><p>方法区是一个规范，它的实现取决于不同的虚拟机。</p><ul><li>Java8之前，HotSpot虚拟机使用<code>永久代</code>来实现方法区。</li><li>Java8及之后，HotSpot虚拟机使用<code>元空间</code>来实现方法区。</li></ul><p>java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。<br>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。<br>这个区域的内存回收目标主要是针对<code>常量池的回收和对类型的卸载</code>，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分的区域的回收确实是有必要的。<br>在Sub公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>根据java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6.运行时常量池"></a>6.运行时常量池</h3><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。<br>Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>Java虚拟机对Class文件的每一部分(自然也包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。<br>但对于运行时常量池，java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需求来实现这个内存区域。<br>不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。<br>Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7.直接内存"></a>7.直接内存</h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p><p>在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在java堆和native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括RAM及SWAP区或者分页文件)的大小及处理器寻址空间的限制。<br>服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.5内存分配与回收策略</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.5%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.5%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>Java技术体系中所提倡的<code>自动内存管理</code>最终可以归结为自动化地解决了两个问题：<code>给对象分配内存</code>以及<code>回收分配给对象的内存</code>。</p><h4 id="给对象分配内存"><a href="#给对象分配内存" class="headerlink" title="给对象分配内存"></a>给对象分配内存</h4><p>对象的内存分配，往大方向上讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，讲按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。</p><p>但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配。在Java编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。<br>当你写好一个Java程序后，源语言的语句将由Java编译器编译成字节码，而不是编译成与某个特定的处理器硬件平台对应的指令代码（比如，Intel的Pentium微处理器或IBM的System/390处理器）。字节码是可以发送给任何平台并且能在那个平台上运行的独立于平台的代码。</p><h3 id="1-对象优先在Eden上分配"><a href="#1-对象优先在Eden上分配" class="headerlink" title="1. 对象优先在Eden上分配"></a>1. 对象优先在Eden上分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p><p>虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前内存各区域的分配情况。在实际应用中，内存回收日志一般是打印到文件后通过日志工具进行分析。</p><ul><li>新生代GC(Minor GC)：指发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC(但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>所谓大对象就是指，需要大量连续内存空间的java对象，最典型的大对象就是那种很长的字符串及数组。</p><p>大对象对虚拟机的内存分配来说就是一个坏消息(比遇到一个大对象更加坏的消息就是遇到一群“朝生夕死”的“短命大对象”，写程序的时候应当避免)，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><h3 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h3><p>虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，哪些对象应当放在老年代中。</p><p>为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。<br>如果对象在Eden出生并经过第一个Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。<br>对象在Survivor区中每熬过一个Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁)时，就会被晋升到老年代中。<br>对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。</p><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</p><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><p>在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。<br>如果大于，则改为直接进行一次Full GC。<br>如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。</p><p>新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况时(最极端就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。</p><p>与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p><p>取平均值进行比较是一种动态概念的手段，也就是说如果某次Minor GC存活后的对象徒增，远远高于平均值的话，依然会导致担保失败(Handle Promotion Failure)。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。<br>虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.4垃圾收集器</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。</p><p><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/lajishoujiqi.png"><br>图中展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。</p><p>明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。<br>因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。</p><h4 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h4><p>单线程，stop the word</p><h4 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2. ParNew收集器"></a>2. ParNew收集器</h4><p>Serial收集器的多线程版本</p><h4 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3. Parallel Scavenge收集器"></a>3. Parallel Scavenge收集器</h4><h4 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4. Serial Old收集器"></a>4. Serial Old收集器</h4><p>Serial收集器的老年代版本</p><h4 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h4><p>Parallel收集器的老年代版本</p><h4 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h4><p>concurrent mark sweep，是一种以获取最短回收停顿时间为目标的收集器，非常符合在注重用户体验的应用上使用。<br>CMS收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。</p><p>CMS收集器用“标记—清除”算法实现。整个过程分为四个步骤：初始标记—并发标记—重新标记—并发清除。<br>优点：并发收集、低停顿。<br>缺点：对CPU资源敏感，无法处理浮动垃圾，使用“标记—清除”算法会导致收集结束时会有大量空间碎片产生。</p><h4 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h4><p>G1(Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的及其，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。</p><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征，具备以下特点：并行与并发，分代收集，空间整合，可预测的停顿。<br>运作分为四个步骤：初始标记—并发标记—最终标记—筛选回收。</p><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h4 id="8-垃圾收集器参数总结"><a href="#8-垃圾收集器参数总结" class="headerlink" title="8. 垃圾收集器参数总结"></a>8. 垃圾收集器参数总结</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.2对象死或否</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.2%E5%AF%B9%E8%B1%A1%E6%AD%BB%E6%88%96%E5%90%A6/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.2%E5%AF%B9%E8%B1%A1%E6%AD%BB%E6%88%96%E5%90%A6/</url>
      
        <content type="html"><![CDATA[<p>堆中几乎存放着java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还<code>存活</code>着，哪些已经<code>死去</code>(即不可能再被任何途径使用的对象).</p><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1.引用计数算法"></a>1.引用计数算法</h3><p>很多教科书判断对象是否存活的算法是：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。<br>任何时刻计数器都为0的对象就是不可能再被使用的。</p><p>客观地说，引用计数算法(Reference Counting)的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案列，例如微软的COM(Component Object Model)技术、使用ActionScript3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。</p><p>但是，java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决<code>对象之间的相互循环引用</code>的问题。</p><p><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.2%E5%AF%B9%E8%B1%A1%E6%AD%BB%E6%88%96%E5%90%A6/yinyongjishu.png"><br>testGC()方法中对象objA和objB都有字节instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用。<br>实际上这两个对象已经不可能再被访问，但是它们因为互相引用这对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。</p><p><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.2%E5%AF%B9%E8%B1%A1%E6%AD%BB%E6%88%96%E5%90%A6/yinyongjishujieguo.png"><br>从运行结果可以看到GC日志中包含“4603K-&gt;210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p><h3 id="2-根搜索算法"><a href="#2-根搜索算法" class="headerlink" title="2.根搜索算法"></a>2.根搜索算法</h3><p>在主流的商用程序语言中(java和C#，甚至包括前面提到的古老的Lisp)，都是使用<code>根搜索算法(GC Roots Tracing)</code>判定对象是否存活的。</p><p>这个算法的基本思路就是通过一系列的名为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)。<br>当一个对象到GC Roots没有任何引用链相连(用图论的话来说就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。</p><p><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.2%E5%AF%B9%E8%B1%A1%E6%AD%BB%E6%88%96%E5%90%A6/gensousuo.png"><br>如图，对象object5、object6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p><p>在java语言里，可作为GC Roots的对象包括下面几种：</p><ol><li>虚拟机栈(栈帧中的本地变量表)中的引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中的常量引用的对象。</li><li>本地方法栈中JNI(即一般说的native方法)的引用的对象。</li></ol><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判断对象是否存活都与<code>引用</code>有关。</p><p>在JDK1.2之前，java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外内存的起始地址，就称这块内存代表着一个引用。<br>这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。<br>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>在JDK1.2之后，java对引用的概念进行了扩充，将引用分为强引用(strong reference)、软引用(soft reference)、弱引用(weak reference)、虚引用(phantom reference)四种。<br>这四种引用强度依次逐渐减弱。</p><ol><li><code>强引用</code>就是指在程序代码之中普遍存在的，类似“Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li><code>软引用</code>用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</li><li><code>弱引用</code>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现软引用。</li><li><code>虚引用</code>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现软引用。</li></ol><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<br>要真正宣告一个对象死亡，至少要经历两次标记过程。</p><p>如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。<br>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。<br>这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。<br>这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> * 1.对象可以在被GC时自我拯救</span></span><br><span class="line"><span class="comment"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SACE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;yes,i am still alive :)&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"> <span class="keyword">super</span>.finalize();</span><br><span class="line"> System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line"> FinalizeEscapeGC.SACE_HOOK = <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"> SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line"> SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"> System.gc();</span><br><span class="line"> <span class="comment">//因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line"> Thread.sleep(<span class="number">500</span>);</span><br><span class="line"> <span class="keyword">if</span>(SAVE_HOOK ！= <span class="keyword">null</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> SAVE_HOOK.isAlive();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;no,i am dead :(&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//下面这段代码与上面完全相同，但是这次自救却失败了</span></span><br><span class="line"> SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"> System.gc();</span><br><span class="line"> <span class="comment">//因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line"> Thread.sleep(<span class="number">500</span>);</span><br><span class="line"> <span class="keyword">if</span>(SAVE_HOOK ！= <span class="keyword">null</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> SAVE_HOOK.isAlive();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;no,i am dead :(&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">finalize method executed!</span><br><span class="line">yes,i am still alive :)</span><br><span class="line">no,i am dead :(</span><br></pre></td></tr></table></figure><p>从运行结果可以看到，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。<br>另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>很多人认为方法区(或者HotSpot虚拟机中的永久代)是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><p><code>回收废弃常量</code>与回收java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。<br>常量池中的其他类(接口)、方法、字段的符号引用也与此类似。</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。</p><p>类需要同时满足下面3个条件才能算是<code>无用的类</code>：</p><ol><li>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。<br>是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类的加载和卸载信息。-verbose:class及-XX:+TraceClassLoading可以在Product版的虚拟机中使用，但是-XX:+TraceClassLoading参数需要fastdebug版的虚拟机支持。<br>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.3垃圾回收算法</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="标记——清除算法-Mark-Sweep"><a href="#标记——清除算法-Mark-Sweep" class="headerlink" title="标记——清除算法(Mark-Sweep)"></a>标记——清除算法(Mark-Sweep)</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉被标记的对象。<br>标记过程在另一篇“深入理解JVM——对象死或否”中讲述，对象标记判定对象是不是还“存活”。</p><p>主要缺点有两个。<br>一个是效率问题，标记和清除过程的效率都不高。<br>另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/marksweep.png" alt="标记——清除算法示意图"><br>举个不恰当的例子，类似于我们扔垃圾，我们把垃圾扔到垃圾桶里，扔到垃圾桶里的垃圾只是被标记为了“垃圾”，我们并不会立刻把它扔掉，当垃圾桶满了的时候，我们统一清除它们。</p><h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h3><p>为了解决效率问题，出现了这种称为“复制”的收集算法。</p><p>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。</p><p>这种算法的代价是将内存缩小为原来的一半，未免太高了，也就是说浪费一半的内存空间。</p><p><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/copying.png" alt="复制算法示意图"></p><p>现在的商业虚拟机都采用复制算法来回收新生代。<br>IBM的专门研究表名，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是<code>将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor</code>。<br>当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。</p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存是会被“浪费”的。<br>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行<code>分配担保(Handle Promotion)</code>。</p><p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。<br>内存的分配担保也一样，如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p><h3 id="标记——整理算法-Mark-Compact"><a href="#标记——整理算法-Mark-Compact" class="headerlink" title="标记——整理算法(Mark-Compact)"></a>标记——整理算法(Mark-Compact)</h3><p>复制算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据<code>老年代</code>的特点，便提出了这种<code>标记——整理算法</code>，标记过程仍然与“标记——清除算法”一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%943.3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/markcompact.png" alt="标记——整理算法示意图"></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。</p><p>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p>在<code>新生代</code>中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<code>复制算法</code>，只需要付出少量存活对象的复制成本就可以完成收集。<br>而<code>老年代</code>中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<code>“标记——清除”</code>或<code>“标记——整理”</code>算法来进行回收。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——数组</title>
      <link href="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
      <url>/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么数组要从0开始编号，而不是从1开始？"><a href="#为什么数组要从0开始编号，而不是从1开始？" class="headerlink" title="为什么数组要从0开始编号，而不是从1开始？"></a>为什么数组要从0开始编号，而不是从1开始？</h4><h4 id="如何实现随机访问？"><a href="#如何实现随机访问？" class="headerlink" title="如何实现随机访问？"></a>如何实现随机访问？</h4><h3 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1.什么是数组"></a>1.什么是数组</h3><p>数组(Array)是一种①线性表数据结构。它用一组②连续的内存空间，来存储一组具有相同类型的数据。</p><h4 id="①线性表"><a href="#①线性表" class="headerlink" title="①线性表"></a>①线性表</h4><p>顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。<br><img src="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/xianxingbiao.jpg"><br>相对立的非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。<br><img src="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/feixianxingbiao.jpg"></p><h4 id="②连续的内存空闲和相同类型的数据"><a href="#②连续的内存空闲和相同类型的数据" class="headerlink" title="②连续的内存空闲和相同类型的数据"></a>②连续的内存空闲和相同类型的数据</h4><p>相同类型保证数组元素内存地址的计算公式可以成立，从而支持随机访问。<br>优点：正因为这两个限制，数组才有了一个特性：随机访问（并不是random的随机，可能理解为任意访问更清晰一点。）。<br>缺点：但是，要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><h3 id="2-数组是如何实现根据下标随机访问数组元素的？"><a href="#2-数组是如何实现根据下标随机访问数组元素的？" class="headerlink" title="2.数组是如何实现根据下标随机访问数组元素的？"></a>2.数组是如何实现根据下标随机访问数组元素的？</h3><p><img src="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/shuzuneicun.jpg"><br>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size(元素类型长度)</span><br></pre></td></tr></table></figure><h4 id="注意：数组和链表的区别"><a href="#注意：数组和链表的区别" class="headerlink" title="注意：数组和链表的区别"></a>注意：数组和链表的区别</h4><p>“链表适合插入、删除，时间复杂度是O(1)；数组适合查找，查找时间复杂度是O(1)。”实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为O(1)，即便是排好序的数组，二分查找的时间复杂度最好也是O(logn)。正确的表述应该是，“数组支持随机访问，根据下标随机访问的时间复杂度是O(1)。”</p><h3 id="3-低效的“插入”和“删除”"><a href="#3-低效的“插入”和“删除”" class="headerlink" title="3.低效的“插入”和“删除”"></a>3.低效的“插入”和“删除”</h3><p>数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，那，为什么会导致低效？改进方法？</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>假设现在有一个数组，长度为n，现在我们需要把一个数组插入到数组中的第k个位置。为了把第k个位置腾出来给信赖的数据，需要将第k~n这部分元素都顺序地往后挪一位。这样的话，插入操作的时间复杂度是多少？<br>最好情况：如果在数组的末尾插入元素，就不需要移动数据，这时的时间复杂度是O(1)。<br>最坏情况：如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O(n)。<br>平均情况时间复杂度为(1+2+……+n)/n=O(n)。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，要将某个数据插入到第k个位置，为了避免大规模的数据搬移，简单办法是：直接将第k为数据搬移到数组元素的最后，把新的元素直接放入第k个位置。<br><img src="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/wuxucharu.jpg"><br>这样，在特定场景下，在第k个位置插入一个元素的时间复杂度就降为O(1)。这个处理思想在快排中会用到。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>跟插入数据类似，如果我们要删除第k个位置的数据，为了内存的连续性，也需要搬移数据，不然数组中间会出现空缺，内存就不连续了。<br>如果要删除数组末尾的数据，则最好情况时间复杂度为O(1)；删除数组开头的数据，最坏情况时间复杂度为O(n)；平均情况时间复杂度为O(n)。</p><p>在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率也许会提高很多。<br>假设数组a[10]中存储了8个元素：a,b,c,d,e,f,g,h。现在，我们要依次删除a,b,c三个元素。<br><img src="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/jizhongshanchu.jpg"><br>为了避免d,e,f,g,h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br>而这，正是JVM垃圾回收之标记——清除算法的思想。<br>标记——清除算法：从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象设一个标记，这个过程不会回收任何对象。只有全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。所以剩下的堆空间是不连续的。标记——清除算法只有在少量垃圾产生时会很高效。</p><h3 id="4-警惕数组的访问越界问题"><a href="#4-警惕数组的访问越界问题" class="headerlink" title="4.警惕数组的访问越界问题"></a>4.警惕数组的访问越界问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int arr[3] = &#123;0&#125;;</span><br><span class="line">    for(; i&lt;=3; i++)&#123;</span><br><span class="line">        arr[i] = 0;</span><br><span class="line">        printf(&quot;hello world\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段C语言代码的运行结果并非是打印三行“hello world”，而是会无限打印“hello world”。<br>因为，数组的大小是3，a[0],a[1],a[2],而这段代码书写错误，导致for循环的结束条件错写为了i&lt;=3而不是i&lt;3，所以当i=3时，数组a[3]访问越界。<br>在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据前面提到的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么a[3]=0就相当于i=0，就导致代码无限循环。</p><h4 id="为什么a-3-的内存地址正好是变量i的内存地址"><a href="#为什么a-3-的内存地址正好是变量i的内存地址" class="headerlink" title="为什么a[3]的内存地址正好是变量i的内存地址"></a>为什么a[3]的内存地址正好是变量i的内存地址</h4><pre><code>函数体内的局部变量存在栈上，且是连续压栈。这段代码的变量压栈顺序是：i,arr[0],arr[1],arr[2]。变量i最先入栈，然后是数组元素，因为数组地址连续从小到大，实际栈中的变量顺序为：arr[0],arr[1],arr[2],i。这样arr[3]的地址刚好与i相同。另外的解释是：与编译器的实现有关。linux的gcc有一个编译选项(-fno-stack-protector)用于关闭堆栈保护功能。默认情况下启动堆栈保护，不管i声明在前还是声明在后，i都会在数组之后压栈，只会循环4次；如果关闭了堆栈保护功能，则会出现死循环。</code></pre><p>数组越界在C语言中是一种未决行为(没有定义的行为)，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质是访问一段连续内存，只要数组通过偏移计算得到的内存地址时可用的，那么程序就可能不会报任何错误。<br>Java本身就会做越界检查，数组越界会抛出java.lang.ArrayIndexOutOfBoundsException。</p><h3 id="5-容器能否完全替代数组？"><a href="#5-容器能否完全替代数组？" class="headerlink" title="5.容器能否完全替代数组？"></a>5.容器能否完全替代数组？</h3><p>针对数组类型，java提供了ArrayList容器类，C++STL中的vector。<br>拿java的ArrayList举例。ArrayList最大的优势就是可以将很多数组操作的细节封装起来，比如对数组的插入、删除操作。<br>另外就是支持动态扩容。数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间，如果申请的大小不够，就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。如果使用ArrayList，就不需要关心底层的扩容逻辑，ArrayList每次存储空间不够的时候，就会将空间自动扩容为1.5倍。需要注意的是，因为扩容操作涉及内存申请和数据搬移，是比较耗时的，所以如果事先能确定需要存储的数据大小，最好在创建ArrayList时事先指定大小。<br>1.java的ArrayList无法存储基本类型，涉及到拆装箱，会有一定性能消耗，涉及到技能或需要使用基本数据类型，选用数组。<br>2.如果数据大小事先已知，且对数据的操作简单，可以用数据。<br>3.多维数组表示时，数组更直观。Object[][] array和容器ArrayList<ArrayList> array。</ArrayList></p><h3 id="6-为什么数组要从0开始编号，而不是从1开始？"><a href="#6-为什么数组要从0开始编号，而不是从1开始？" class="headerlink" title="6.为什么数组要从0开始编号，而不是从1开始？"></a>6.为什么数组要从0开始编号，而不是从1开始？</h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”。<br>如果用a来表示数组的首地址，a[0]就是偏移为0的地址，也就是首地址，a[k]表示偏移了k个type_size的位置，所以a[k]的内存地址计算只需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure><p>如果，数组从1开始奇数，那计算a[k]的内存地址变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure><p>对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。</p><h3 id="7-二维数组元素的地址计算公式"><a href="#7-二维数组元素的地址计算公式" class="headerlink" title="7.二维数组元素的地址计算公式"></a>7.二维数组元素的地址计算公式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//行优先</span><br><span class="line">a[i][j] = a[0][0] + i * n * data_type_size + j * data_type_size</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——复杂度分析</title>
      <link href="/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是复杂度分析？"><a href="#什么是复杂度分析？" class="headerlink" title="什么是复杂度分析？"></a>什么是复杂度分析？</h3><p>1.数据结构和算法解决“如何让计算机更快时间、更省空间的解决问题”。<br>2.因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能。<br>3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。<br>4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</p><h3 id="为什么要进行复杂读分析？"><a href="#为什么要进行复杂读分析？" class="headerlink" title="为什么要进行复杂读分析？"></a>为什么要进行复杂读分析？</h3><p>1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。<br>2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。</p><h3 id="如何进行复杂度分析？"><a href="#如何进行复杂度分析？" class="headerlink" title="如何进行复杂度分析？"></a>如何进行复杂度分析？</h3><h4 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h4><p>1.来源<br>算法的执行时间与每行代码的执行次数成正比，用T（n）=O（f（n））表示，其中T（n）表示算法执行总时间，f（n）表示每行代码执行总次数，而n往往代表数据的规模。<br>2.特点<br>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时忽略这些项。</p><h4 id="复杂度分析法则"><a href="#复杂度分析法则" class="headerlink" title="复杂度分析法则"></a>复杂度分析法则</h4><p>1.单段代码看高频。比如循环。<br>2.多段代码取最大。比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3.嵌套代码求乘积。比如递归、多重循环等。<br>4.多个规模求加法。比如方法有两个参数（m、n）控制两个循环的次数，那么这时就取二者复杂度相加。</p><h3 id="常用的复杂度级别"><a href="#常用的复杂度级别" class="headerlink" title="常用的复杂度级别"></a>常用的复杂度级别</h3><h4 id="多项式阶"><a href="#多项式阶" class="headerlink" title="多项式阶"></a>多项式阶</h4><p>随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括：O（1）（常数阶）、O（logn）（对数阶）、O（n）（线性阶）、O（nlogn）（线性对数阶）、O（n^2）（平方阶）、O（n^3）（立方阶）。</p><h4 id="非多项式阶"><a href="#非多项式阶" class="headerlink" title="非多项式阶"></a>非多项式阶</h4><p>随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括O（2^n）（指数阶）、O（n！）（阶乘阶）。<br><img src="/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/fuzaduliangji.jpg" alt="复杂度量级"></p><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率和数据规模之间的增长关系。<br><img src="/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/on.jpg"></p><h3 id="复杂度分析的四个概念"><a href="#复杂度分析的四个概念" class="headerlink" title="复杂度分析的四个概念"></a>复杂度分析的四个概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// n 表示数组 array 的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码要实现的功能是，在一个无序的数组（array）中，查找变量x出现的位置。如果没有找到，就返回-1。这段代码的复杂度看上去的话是O（n）。</p><h4 id="最好情况时间复杂度"><a href="#最好情况时间复杂度" class="headerlink" title="最好情况时间复杂度"></a>最好情况时间复杂度</h4><p>代码在最理想情况下执行的时间复杂度。<br>在最理想的情况下，要查找的变量x正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。</p><h4 id="最坏情况时间复杂度"><a href="#最坏情况时间复杂度" class="headerlink" title="最坏情况时间复杂度"></a>最坏情况时间复杂度</h4><p>代码在最坏情况下执行的时间复杂度。<br>如果数组中没有要查找的变量x，需要把整个数组都遍历一遍。</p><h4 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h4><p>用代码在所有情况下执行的次数的加权平均值表示。<br>要查找的变量x，要么在数组中，要么就不在数组里，这两种情况对应的概率统计起来很麻烦，假设在数组中与不在数组中的概率都为1/2。另外，要查找的数据出现在0<del>n-1这n个位置的概率也是一样的，为1/n。所以根据概率乘法法则，要查找的数据出现在0</del>n-1中任意位置的概率就是1/（2n）。<br><img src="/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/pingjun.jpg"><br>这个值是概率论中的加权平均值，也叫做期望值，所以平均时间复杂度的全称应该叫做加权平均时间复杂度或者期望时间复杂度。<br>引入概率之后，前面那段代码的加权平均值为（3n+1）/4，用大O表示法来表示，去掉系数和常量，仍然为O（n）。</p><h4 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// array 表示一个长度为 n 的数组</span><br><span class="line">// 代码中的 array.length 就等于 n</span><br><span class="line">int[] array = new int[n];</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">   if (count == array.length) &#123;</span><br><span class="line">      int sum = 0;</span><br><span class="line">      for (int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[0] = sum;</span><br><span class="line">      count = 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现一个往数组中插入数据的功能。当数组满了之后，count==array.length时，我们用for循环遍历数组求和，并清空数组，将求和之后的sum值放到数组的第一个位置，然后将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。<br>时间复杂度最好为O（1），最坏为O（n），平均时间复杂度也是O（1）。<br>假设数组的长度是n，根据数据插入的位置不同，分为n种情况，每种情况的时间复杂度是O（1），另外在数组没有空闲空间时插入一个数据，这时是O（n），这n+1种情况发生的改率一样，都是1/（n+1）。<br><img src="/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/pingjun2.jpg"></p><p>对于后面这个inset（）函数来说，O（1）和O（n）出现的频率是有规律的，而且有一定的前后时序关系，一般都是一个O（n）插入之后，紧跟着n-1个O（1）的插入操作，循环往复。<br>针对这种特殊场景，引入一种更加简单的分析方法：摊还分析法，通过摊还分析得到均摊时间复杂度。<br>均摊时间复杂度是一种特殊的平均时间复杂度。<br>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这时候，可以将这一组操作放在一块儿分析，将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度等于最好情况时间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下迁移指定MySQL数据库至Linux</title>
      <link href="/2019/04/12/linux-Windows%E4%B8%8B%E8%BF%81%E7%A7%BB%E6%8C%87%E5%AE%9AMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%B3Linux/"/>
      <url>/2019/04/12/linux-Windows%E4%B8%8B%E8%BF%81%E7%A7%BB%E6%8C%87%E5%AE%9AMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%B3Linux/</url>
      
        <content type="html"><![CDATA[<p>在配置好阿里云服务器的javaweb环境后，发现mysql里面没有数据，才想到要把部署在Windows下的mysql数据库迁移到linux服务器中，且只迁移该项目的数据库。</p><p>本步骤基于cent os 7，使用的文件传输工具为FileZilla,数据库管理工具为Navicat for MySQL。迁移之前请确保两台主机已安装配置好MySQL数据库。</p><h3 id="使用sql脚本文件迁移"><a href="#使用sql脚本文件迁移" class="headerlink" title="使用sql脚本文件迁移"></a>使用sql脚本文件迁移</h3><h4 id="Windows（迁出数据库主机）"><a href="#Windows（迁出数据库主机）" class="headerlink" title="Windows（迁出数据库主机）"></a>Windows（迁出数据库主机）</h4><p>  1.打开Navicat，在项目所在数据库处，右键-&gt;转储SQL文件 </p><p>  2.导出sql文件成功 </p><h4 id="Linux（迁入数据库主机）"><a href="#Linux（迁入数据库主机）" class="headerlink" title="Linux（迁入数据库主机）"></a>Linux（迁入数据库主机）</h4><p>  1.打开FileZilla，登录，将导出的.sql文件上传到服务器指定的路径下（我是放在了/usr/java/mysql下）<br>  2.执行sql脚本文件<br>    mysql -u root -p 输入密码后进入mysql命令行<br>    create database 项目数据库名;<br>    use 项目数据库名;<br>    source 路径/XXX.sql<br>    执行成功，show tables;可以看到已经导入的表</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地Windows操作系统连接Linux实例（阿里云ECS）</title>
      <link href="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/"/>
      <url>/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>第一步：在本机上的java web首先要设计的差不多，localhost:8080可以访问</p><p>第二步：注册阿里云账号，租用阿里云服务器。由于我还是学生，花了9.9买了一个月的最低配云服务器ECS，服务器系统Linux CentOS7.3。</p><p>第三步：文件准备 jdk+tomcat+mysql（+redis）<br>提供链接：<a href="https://pan.baidu.com/s/1yrRfv17fq72OJsl2r94IjQ">https://pan.baidu.com/s/1yrRfv17fq72OJsl2r94IjQ</a><br>提取码：3bd8<br>文件上传工具：FileZilla<br>服务器连接工具：putty（可有可不有，相当于服务器实例的远程连接）</p><p>cd usr –&gt; mkdir java<br>为了便于文件的管理和区分，可以在/usr目录下新建/java文件夹，并创建/jdk、/tomcat、/mysql、/redis，将对应的压缩包上传到对应的文件夹下。<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.png"></p><p>第四步：安装JDK环境<br>cd /usr/java/jdk    ————进入jdk目录</p><p>tar -zxvf jdk-8u144-linux-x64.tar.gz  ————解压<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%AE%89%E8%A3%85jdk.png"></p><p>解压成功后，需要配置环境变量，在命令行输入 vi /etc/profile 然后回车，会有下图显示<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E9%85%8D%E7%BD%AEjava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8A.png"></p><p>这时，按键盘上的i键，此时可以编辑（命令框下方会有INSERT），这是vim编辑格式，在空白处插入一下字句，如下图<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E9%85%8D%E7%BD%AEjava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png"></p><p>输入完后，按ESC键退出编辑，输入：wq回车保存。</p><p>输入指令source /etc/profile，然后java -version 验证是否配置成功，验证是否配置成功。<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E9%AA%8C%E8%AF%81java%E7%89%88%E6%9C%AC.png"></p><p>出现 java version “1.8.0_144”便配置成功了。</p><p>第五步：安装tomcat<br>cd /usr/java/tomcat   ————进入tomcat目录</p><p>tar -zxvf apache-tomcat-版本号.tar.gz   ————解压</p><p>cd /usr/java/tomcat/apache-tomcat-版本号/bin  ————进入解压后tomcat文件夹</p><p>./startup.sh  ————开启tomcat，这样tomcat会自动配置环境变量，无需自己vim去添加环境变量<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%BC%80%E5%90%AFtomcat.png"></p><p>tomcat成功启动之后，打开浏览器输入公网IP:8080应该就可以访问到tomcat主页。如果出现无法访问、响应时间过长这样的信息，跟端口开放有关，我们在第八步之后处理。</p><p>第六步：安装mysql<br>cd /usr/java/mysql  ————进入mysql目录</p><p>rpm -Uvh mysql80-community-release-el7-2.noarch.rpm  ————安装rpm 回车之后 出现两个100%，如下图，成功安装<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%AE%89%E8%A3%85mysqlrpm.png"></p><p>yum install mysql-community-server  ————安装mysql服务<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%AE%89%E8%A3%85mysql.png"></p><p>service mysqld start  ————启动mysql服务<br>ps -ef | grep mysqld  ————查看mysql服务<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/mysql%E6%88%90%E5%8A%9F%E5%90%AF%E5%8A%A8.png"></p><p>grep ‘temporary password’ /var/log/mysqld.log  ————获取初始密码<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/msql%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81.png"></p><p>cd /usr/java/mysql  ————进入mysql目录<br>mysql -uroot -p     ————以root用户登录mysql，出现passowrd后输入上面的初始密码，密码输入不会显示<br>登录成功之后，输入ALTER语句更改密码，密码是大小写字母+数字+符号的组合才能通过<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E4%BF%AE%E6%94%B9mysql%E5%AF%86%E7%A0%81.png"></p><p>在root用户登录状态下，创建work用户并授权增删改查，因为root用户远程登录会有诸多问题，所以在这里创建一个work用户方便以后的操作，创建方法如下图，创建用户和授权操作要分开。<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%88%9B%E5%BB%BAwork%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E6%9D%83.png"></p><p>flush privileges;  —————刷新权限 配置生效</p><p>mysql -uwork -P3306 -h你的IP -p  ————通过work用户访问服务器，输入修改后的密码后就可以了<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E9%80%9A%E8%BF%87work%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p><p>第七步：安装redis<br>cd /usr/java/redis  ————进入redis目录<br>tar -zvxf redis-5.0.4.tar.gz  ————解压</p><p>cd /usr/java/redis/redis-5.0.4 ————进入解压后的redis目录<br>vi redis.conf  ————配置redis的一些属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#监听所有的IP地址（<span class="number">61</span>行）</span><br><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>注释掉为#bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">#设置为守护进程（<span class="number">128</span>行）</span><br><span class="line">daemonize no 改为 daemonize yes</span><br></pre></td></tr></table></figure><p>ESC :wq保存之后，输入make并回车，安装redis<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%AE%89%E8%A3%85redis.png"></p><p>输入下图指令，启动redis服务并连接测试<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%90%AF%E5%8A%A8redis%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95.png"></p><p>第八步：项目上传<br>将自己的javaweb项目export出一个.war文件，将这个.war文件上传至服务器的tomcat的webapps下<br>在tomcat启动情况下 ./startup.sh，会自动将（项目.war）解析成（项目）<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0.png"></p><p>全部部署成功，打开浏览器，输入公网IP<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%85%AC%E7%BD%91IP.png"></p><p>输入公网IP/项目路径<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%85%AC%E7%BD%91IP2.png"></p><p>会出现的问题：<br>tomcat默认端口为8080，http支持的端口是80，如果要跟微信测试号连接的话，微信测试号支持的端口是80，所以要将tomcat下的server.xml中的port：8080改成port：80<br>在阿里云服务器的实例中，需要配置安全组，添加端口信息，表示开放这些端口。<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%AE%89%E5%85%A8%E7%BB%84.png"></p><p>我遇到的问题是：安全组开放了80端口和8080端口，结果在浏览器访问IP：80和IP：8080都是无法访问的情况；在将安全组中的端口改成上图情况，也就是取消了8080端口后，都可以成功访问，也就是第八步图中的样子，只是这是都不需要输入端口号了。<br>如果碰到访问不了的情况，多半是安全组问题，以及去tomcat下的server.xml文件中的配置信息。<br>至于firewall和iptables，防火墙与端口的问题，应该不是很重要，因为我都配置过，结果并没有什么卵用…</p><p>附一个本地命令行测试连接成功与否的方法 win+R ——&gt; telnet 公网ip 80<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/telnet%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5.png" alt="如图为连接失败，端口80未开放"></p><p>成功的话，会进入下图这样的命令框<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/telnet%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.png"></p><p>另外一个问题：如果页面能够访问了，也就是tomcat连接没有问题了，但是数据库mysql中的数据显示不出来，只有html或者jsp中的标签布局可以显示，这时要注意两个问题————<br>  一：本地mysql中的项目所用到的数据库没有上传到服务器mysql中，导致服务器中mysql里没有所创建的那些表，也就查不到数据。<br>  详见另一篇博文：windows下迁移指定mysql数据库至linux</p><p>  二：服务器mysql版本与JDBC连接所需要的mysql-connection-java jar版本是不是一致，一致才能够连接到。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blue Butterfly</title>
      <link href="/2019/04/04/%E9%9A%8F%E7%AC%94-Blue-Butterfly/"/>
      <url>/2019/04/04/%E9%9A%8F%E7%AC%94-Blue-Butterfly/</url>
      
        <content type="html"><![CDATA[<p>我在清晨醒来的时候流泪<br>一只蓝色蝴蝶经过我深深的梦里<br>我的梦里</p><p>我闭上眼睛回想她的来过<br>她会一直都在<br>是我这单薄的一生如此真切的渴望</p><p>可我要怎么去知道，我不知道<br>也许只是偶然的造访<br>回忆才是她真实存在的地方</p><p>蝴蝶记忆很短<br>爱上一朵花后六秒就忘记<br>如果我有一万亩玫瑰和一点星光<br>就对她说：留下来吧</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—排序总结</title>
      <link href="/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>算法描述：将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序（即L.r[1].key&gt;L.r[2].key），则将两个记录交换之，然后比较第二个记录和第三个记录。依次类推，直到第n-1个记录和第n个记录的关键字进行过比较为止，此过程称为第一趟起泡排序，其结果使得关键字最大的记录被安置到最后一个记录的位置上。最坏情况，初始序列为“逆序”，需进行n-1趟排序，进行n(n-1)/2次比较，并做等数量级的记录移动，时间复杂度为O(n的平方)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)  <span class="comment">//外层循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;length-i;j++) <span class="comment">//内层循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j-<span class="number">1</span>]&gt;a[j]) <span class="comment">//前者大于后者 交换之</span></span><br><span class="line">&#123;</span><br><span class="line">temp=a[j];</span><br><span class="line">a[j]=a[j-<span class="number">1</span>];</span><br><span class="line">a[j-<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> length)</span>  <span class="comment">//优化的冒泡排序</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果有500个数值的数组，前100个无序，后400个有序，该方法对于后400个数据只需要比较一次，</span></span></span><br><span class="line"><span class="function"><span class="comment">//便记录下这个标识然后设置尾边界，以后的99次不会与后面400个数据比较 节省时间。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j,k;</span><br><span class="line"><span class="keyword">int</span> flag=length; <span class="comment">//flag来记录最后交换的位置 也就是排序的尾边界</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(flag&gt;<span class="number">0</span>) <span class="comment">//flag&gt;0的话说明排序未结束</span></span><br><span class="line">&#123;</span><br><span class="line">k=flag;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j-<span class="number">1</span>]&gt;a[j])  <span class="comment">//交换</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp=a[j];</span><br><span class="line">a[j]=a[j-<span class="number">1</span>];</span><br><span class="line">a[j-<span class="number">1</span>]=temp;</span><br><span class="line"></span><br><span class="line">flag=j; <span class="comment">//表示交换过数据 记录尾边界</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是对冒泡排序的一种改进。它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br>一趟快速排序的具体做法是：附设两个指针low和high，它们的初值分别为low和high，设枢轴记录的关键字为pivotkey，则首先从high所指位置起向前搜索找到第一个关键字小于pivotkey的记录和枢轴记录互相交换，然后从low所指位置起向后搜索，找到第一个关键字大于pivotkey的记录和枢轴记录互相交换，重复这两步直至low=high为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> first, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i=first;</span><br><span class="line">         <span class="keyword">int</span> j=end;</span><br><span class="line">         <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">             <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;  <span class="comment">//右侧扫描</span></span><br><span class="line">                 j--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(i &lt; j) &#123;  <span class="comment">//将较小记录交换到前面</span></span><br><span class="line">                 <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                 a[i] = a[j];</span><br><span class="line">                 a[j] = temp;</span><br><span class="line">                 <span class="comment">//i++;</span></span><br><span class="line">             &#125; </span><br><span class="line">             <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123; <span class="comment">//左侧扫描</span></span><br><span class="line">                 i++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(i &lt; j) &#123; <span class="comment">//将较大记录交换到后面</span></span><br><span class="line">                 <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                 a[i] = a[j];</span><br><span class="line">                 a[j] = temp;</span><br><span class="line">                 <span class="comment">//j--;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> pivot;</span><br><span class="line">         <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">             pivot = partition(a, low, high);</span><br><span class="line">             quickSort(a, low, pivot-<span class="number">1</span>);</span><br><span class="line">             quickSort(a, pivot+<span class="number">1</span>, high);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序——简单选择排序"><a href="#选择排序——简单选择排序" class="headerlink" title="选择排序——简单选择排序"></a>选择排序——简单选择排序</h3><p>算法描述：对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录与第一个记录的位置进行交换，接着对不包括第一个记录以外的其他记录进行第二轮比较，得到最小的记录并与第二个记录进行位置交换，重复该过程，直到进行比较的记录只有一个时为止。<br>选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 平均O(n^2),最好O(n^2),最坏O(n^2);空间复杂度O(1);不稳定;简单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="comment">// 找出最小值的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[k]) &#123;</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将最小值放到未排序记录的第一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                arr[k] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123; <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        selectionSort(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : b)</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一致有序。重复这个过程，直到未排序区间中元素为空，算法结束。<br><img src="/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/charupaixu.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a表示数组 n表示数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> value = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//查找插入的位置</span></span><br><span class="line">        <span class="keyword">for</span>(;j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; value)&#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j]; <span class="comment">//数据移动</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j+<span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序——堆排序"><a href="#选择排序——堆排序" class="headerlink" title="选择排序——堆排序"></a>选择排序——堆排序</h3><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想：要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br><img src="/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/guibingpaixu.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归并排序算法, a是数组，n表示数组大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    mergeSortInternally(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值</span></span><br><span class="line">    <span class="keyword">int</span> q = p + (r - p)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 分治递归</span></span><br><span class="line">    mergeSortInternally(a, p, q);</span><br><span class="line">    mergeSortInternally(a, q+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">    merge(a, p, q, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = p;</span><br><span class="line">    <span class="keyword">int</span> j = q+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 初始化变量i, j, k</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>]; <span class="comment">// 申请一个大小跟a[p...r]一样的临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">        tmp[k++] = a[i++]; <span class="comment">// i++等于i:=i+1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">    <span class="keyword">int</span> start = i;</span><br><span class="line">    <span class="keyword">int</span> end = q;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">      start = j;</span><br><span class="line">      end = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">      tmp[k++] = a[start++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将tmp中的数组拷贝回a[p...r]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) &#123;</span><br><span class="line">      a[p+i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h3 id="复杂度总结"><a href="#复杂度总结" class="headerlink" title="复杂度总结"></a>复杂度总结</h3><p><img src="/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93.jpg" alt="复杂度总结"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于爱情的解释</title>
      <link href="/2019/03/17/%E9%9A%8F%E7%AC%94-%E5%85%B3%E4%BA%8E%E7%88%B1%E6%83%85%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2019/03/17/%E9%9A%8F%E7%AC%94-%E5%85%B3%E4%BA%8E%E7%88%B1%E6%83%85%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p><a href="https://music.163.com/#/song?id=1315718569">有一种悲伤-A-Lin</a></p><p>————“要是爱情可以解释得清楚的话，这世界上就不会有这么多人因此而痛苦了。”</p><p>那天 我在茫茫人海中<br>独独发现了你<br>然后在我漫长的夜晚里<br>有了唯一动人的星星</p><p>要是爱情可以解释<br>我那时还不会那么快乐<br>和你有关的一切<br>比快乐还要快乐</p><p>如今 我把你好好地<br>还回人海里<br>然后我一个人的生活里<br>常常做梦梦见一个人</p><p>要是爱情可以解释<br>我现在就不会这么悲伤<br>和你有关的一切<br>比悲伤还要悲伤</p><p>你是我的爱情<br>你只是不是我的爱人<br>和你有关的一切<br>开始很快乐<br>后来就悲伤起来</p><p>你像极了爱情<br>像极了我要爱的人<br>关于爱情唯一的解释<br>无非就是一个你而已</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情书</title>
      <link href="/2019/02/14/%E6%83%85%E4%B9%A6/"/>
      <url>/2019/02/14/%E6%83%85%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p>你好哇，亲爱的我的爱人：<br>&emsp;&emsp;Hello，world：你好哇，我的爱人——我的世界。<br>&emsp;&emsp;因为程序员打出来的第一行代码是：“hello，world！”，所以写给你的第一封信这样来开头的话，好像，你就是我的世界了。<br>&emsp;&emsp;也是因为第一句话其实是极难的，无论是说的，还是写的。当一个少不经事的男孩子怀着激动的心情紧张地打下一行“嗨喽，你好哇！”发给那个极好的女孩子时，他总算向她和美好靠近了一步，然后他又焦急而慌张地等待她的回复，每一秒等待他都清晰地感觉到自己的心和身体在打颤，终于没有多久她稳重大方地回了一句“你好”，他的灵魂此刻在幸福的打颤，他们之间是要发生一些什么的。<br>&emsp;&emsp;所以在这里的话，写的第一句，可以说是我取巧了，取巧在我的专业，取巧在我隐藏起我的慌张和无措，以及故作模样的仪式感。<br>&emsp;&emsp;当我要谈一谈我们两个人的时候，我总要先说说我，再把目光投向你，这是一个自我剖析过去然后拉回你所在的现实的过程，最后让我说说关于我们——有关于未来。<br>&emsp;&emsp;98年的我都不敢信过完年我就虚岁22了，二十载荒唐，养成了一身的欲望，在所有的喜怒忧思悲恐惊中我最爱你，在所有的眼耳鼻舌身意的愿望中我最想要你。尤其静夜，我的情欲大，纷纷飘下，在我写下这些字的此刻。因为我的爱人，你还尚未到来，我实在不宜用太大的篇幅去讲我，怕你害怕，我也实在不愿向你隐瞒，等你来的那一天，我将一切都说与你，好的坏的都是关于我的。<br>&emsp;&emsp;在冬天刚到的时候，我说，“我干涸的心想要一场夏天，夏天太远，冬至已至，一场隆冬的雪亦能解渴。”<br>&emsp;&emsp;我已经渴望了太久。<br>&emsp;&emsp;这个冬天的雪没有那么大，这个冬天也快要走远了，我的孤独和花园已经枯萎了太久，在转瞬就至的春天和盼望已久的夏天里，你挑一个日子来吧，因为秋天是一个适合谈恋爱的季节，是一个浪漫的季节，我应该为你温柔；你若不来，“自古逢秋悲寂寥”，我一生都为你寂寥。<br>&emsp;&emsp;你也许不会相信，我常常想象你是多么美好，多么可爱，但实际见你面的时候，我相信，你比我想象的要美好得多，可爱得多。你不能说我这是说谎，因为如果不然的话，我当然可以仅仅靠想你就满足，而不必那样渴望着想见到你，我是如此羡慕那些与你想见面就能见面的人。<br>&emsp;&emsp;你不知道，我这颗心已经厌世嫉俗惯了，每一个惨淡晦暗的清晨都觉得快要不行了，坚持不住了，可是啊，看着你笑的照片，听听你的声音，就觉得，时事维艰也不过如此。<br>&emsp;&emsp;你知道吗，我好想看见你的笑容啊。就是在那种难捱的日子里，你会笑的眼睛里氤氲着的光，注视着我，驱散我深渊一样的心深处最顽固的黑暗。你做我的蚩梦吧，你永远年轻，永远热泪盈眶。你饱含着的热情，我靠近一分，就消散一分我长久以来攒了满身的沮丧。即便我仍是沮丧，我却有充足的气力去做事。<br>&emsp;&emsp;这封情书请你一定要收下。你要相信，先有情，才有话，才有诗，才有书。我这决不是在忽悠你。</p><p>一个不知所谓的臭男生</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Markdown</title>
      <link href="/2019/01/18/markdown-%E5%85%B3%E4%BA%8EMarkdown%E8%AF%AD%E8%A8%80/"/>
      <url>/2019/01/18/markdown-%E5%85%B3%E4%BA%8EMarkdown%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown是一种轻量级的「标记语言」</strong><span id="more"></span></p><p><img src="https://www.mdeditor.com/images/logos/markdown.png" alt="markdown" title="markdown"></p><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p><h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><h6 id="标题H5-1"><a href="#标题H5-1" class="headerlink" title="标题H5"></a>标题H5</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr><p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s></p><p><em>斜体字</em>      <em>斜体字</em></p><p><strong>粗体</strong>  <strong>粗体</strong></p><p><em><strong>粗斜体</strong></em> <em><strong>粗斜体</strong></em></p><p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p><p><strong>缩写(同HTML的abbr标签)</strong></p><blockquote><p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p></blockquote><p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p><h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><blockquote><p>引用文本 Blockquotes</p></blockquote><p>引用的行内混合 Blockquotes</p><blockquote><p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/">普通链接</a>。</p></blockquote><h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><p><a href="https://www.mdeditor.com/">普通链接</a><br><a href="https://www.mdeditor.com/" title="普通链接带标题">普通链接带标题</a><br>直接链接：<a href="https://www.mdeditor.com/">https://www.mdeditor.com</a><br>[锚点链接][anchor-id]<br>[anchor-id]: <a href="https://www.mdeditor.com/">https://www.mdeditor.com/</a><br><a href="mailto:test.test@gmail.com">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 <a href="mailto:&#116;&#101;&#115;&#x74;&#x2e;&#x74;&#x65;&#115;&#116;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;">&#116;&#101;&#115;&#x74;&#x2e;&#x74;&#x65;&#115;&#116;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;</a>  <a href="mailto:&#x77;&#x77;&#x77;&#x40;&#x76;&#105;&#112;&#46;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;">&#x77;&#x77;&#x77;&#x40;&#x76;&#105;&#112;&#46;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;</a></p><blockquote><p>@pandao</p></blockquote><h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><p>执行命令：<code>npm install marked</code></p><h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p><pre><code>&lt;?php    echo &quot;Hello world!&quot;;?&gt;</code></pre><p>预格式化文本：</p><pre><code>| First Header  | Second Header || ------------- | ------------- || Content Cell  | Content Cell  || Content Cell  | Content Cell  |</code></pre><h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HTML-代码-HTML-codes"><a href="#HTML-代码-HTML-codes" class="headerlink" title="HTML 代码 HTML codes"></a>HTML 代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Editor.md, Markdown, Editor&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#444</span>;<span class="attribute">font-family</span>: <span class="string">&quot;Microsoft Yahei&quot;</span>, Tahoma, <span class="string">&quot;Hiragino Sans GB&quot;</span>, Arial;<span class="attribute">background</span>:<span class="number">#fff</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style</span>: none;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none;<span class="attribute">vertical-align</span>: middle;&#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-xxl&quot;</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-green&quot;</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>图片加链接 (Image + Link)：</p><p><a href="https://www.mdeditor.com/images/logos/markdown.png" title="markdown"><img src="https://www.mdeditor.com/images/logos/markdown.png"></a></p><blockquote><p>Follow your heart.</p></blockquote><hr><h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul><li>列表一</li><li>列表二<ul><li>列表二-1</li><li>列表二-2</li><li>列表二-3</li></ul></li><li>列表三<ul><li>列表一</li><li>列表二</li><li>列表三</li></ul></li></ul><h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol><li>第一行</li><li>第二行</li><li>第三行</li></ol><h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul><li><input checked disabled type="checkbox"> GFM task list 1</li><li><input checked disabled type="checkbox"> GFM task list 2</li><li><input disabled type="checkbox"> GFM task list 3<ul><li><input disabled type="checkbox"> GFM task list 3-1</li><li><input disabled type="checkbox"> GFM task list 3-2</li><li><input disabled type="checkbox"> GFM task list 3-3</li></ul></li><li><input disabled type="checkbox"> GFM task list 4<ul><li><input disabled type="checkbox"> GFM task list 4-1</li><li><input disabled type="checkbox"> GFM task list 4-2</li></ul></li></ul><hr><h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table><thead><tr><th>项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>Function name</th><th>Description</th></tr></thead><tbody><tr><td><code>help()</code></td><td>Display the help window.</td></tr><tr><td><code>destroy()</code></td><td><strong>Destroy your computer!</strong></td></tr></tbody></table><table><thead><tr><th align="left">Left-Aligned</th><th align="center">Center Aligned</th><th align="right">Right Aligned</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="center">some wordy text</td><td align="right">$1600</td></tr><tr><td align="left">col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><table><thead><tr><th>Item</th><th align="right">Value</th></tr></thead><tbody><tr><td>Computer</td><td align="right">$1600</td></tr><tr><td>Phone</td><td align="right">$12</td></tr><tr><td>Pipe</td><td align="right">$1</td></tr></tbody></table><hr><h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><p>&copy; &amp;  &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p><p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p><p>18&ordm;C  &quot;  &apos;</p><p>[========]</p><h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote><p>Blockquotes :star:</p></blockquote><h4 id="GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul><li><input checked disabled type="checkbox"> :smiley: @mentions, :smiley: #refs, <a href>links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li><li><input checked disabled type="checkbox"> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li><li><input checked disabled type="checkbox"> [ ] :smiley: this is a complete item :smiley:;</li><li><input disabled type="checkbox"> []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li><li><input disabled type="checkbox"> [ ]this is an incomplete item :fa-star: :fa-gear:;<ul><li><input disabled type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li><li><input disabled type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li></ul></li></ul><h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p><p>[========]</p><h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E=mc^2$$</p><p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p><p>$$x &gt; y$$</p><p>$$(\sqrt{3x-1}+(1+x)^2)$$</p><p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p><p>多行公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) = \int_&#123;-\infty&#125;^\infty</span><br><span class="line">    \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125;</span><br><span class="line">    \,d\xi</span><br></pre></td></tr></table></figure><h3 id="分页符-Page-break"><a href="#分页符-Page-break" class="headerlink" title="分页符 Page break"></a>分页符 Page break</h3><blockquote><p>Print Test: Ctrl + P</p></blockquote><p>[========]</p><h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 用户登陆</span><br><span class="line">op=&gt;operation: 登陆操作</span><br><span class="line">cond=&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e=&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>[========]</p><h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>who on the moon</title>
      <link href="/2019/01/16/%E9%9A%8F%E7%AC%94-who-on-the-moon/"/>
      <url>/2019/01/16/%E9%9A%8F%E7%AC%94-who-on-the-moon/</url>
      
        <content type="html"><![CDATA[<p><a href="https://music.163.com/#/song?id=1315718569">月球上的人</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这首歌讲的是男主角把自己置身于月球，作为一个月球上的人来重新审视自己曾经的一段感情。</span><br><span class="line">众所周知，用月球的角度是因为从月球所看到的地球上的事物都是过去的，光的传播需要时间，</span><br><span class="line">时过境迁后才后悔自己当初太不会相爱的本领，真想忘记自己正身处的未来去重新爱一次。</span><br></pre></td></tr></table></figure><p>网易云热评上，这样说。</p><p>关于明月，我还听说过</p><blockquote><p>最冷的日子<br>我把自己披在身上取暖<br>星空浩瀚<br>明月是明月的前身<br>你是虚构的<br>只能在虚构里爱你<br>世界需要燃烧也需要灰烬<br>我才长出一颗心           </p></blockquote><p>“明月是明月的前身”，月亮和地球的距离随时间而改变，大约为三十八万千米，因为人的眼睛接收到的是光，以光速约要1.28秒到达你的眼睛，所以你所看到的月亮事实上是1.28秒之前的月亮。</p><blockquote><p>你承诺过的月亮<br>还是没有出现<br>而我无眠，或者<br>我只是衣单天寒地<br>替你多爱了一夜人间</p></blockquote><p>可是，我等的月亮，还，没有出现。</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最冷一天</title>
      <link href="/2019/01/01/%E9%9A%8F%E7%AC%94-%E6%9C%80%E5%86%B7%E4%B8%80%E5%A4%A9/"/>
      <url>/2019/01/01/%E9%9A%8F%E7%AC%94-%E6%9C%80%E5%86%B7%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://music.163.com/#/song?id=187786">最冷一天</a></p><p>我想有一只小猫<br>最冷的时候<br>我把她抱在怀里取暖</p><p>每一个早晨<br>或明晰或晦暗的早晨<br>我还没睁开眼睛，就<br>睡意朦胧地伸出手臂<br>揽过睡在我右侧柔软的猫</p><p>我用力地抱着她，抱紧她<br>我心里有个声音：我什么也不要了<br>我再不要什么了<br>这荒唐的人间你们去爱吧<br>我好好儿爱她</p><p>我总要吻过她才有饱满的气力去做一天的事<br>她还睡着，她总要轻声哼一句<br>我的心简直要化了</p><p>我回家照例是要带她最爱吃的和<br>一支玫瑰花<br>夏天的话还要为她挑一件碎花裙<br>今生种花，来世漂亮<br>她无论何时都可以说得上是漂亮非常了</p><p>另外呢，春天我送她春风<br>夏天给她撑阳伞，秋天为她扫落叶<br>冬天，就给她下一场隆隆的大雪<br>风花雪月的故事里，她是我的<br>那一轮月亮，永恒的<br>月亮</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一朵百合</title>
      <link href="/2018/06/03/%E9%9A%8F%E7%AC%94-%E4%B8%80%E6%9C%B5%E7%99%BE%E5%90%88/"/>
      <url>/2018/06/03/%E9%9A%8F%E7%AC%94-%E4%B8%80%E6%9C%B5%E7%99%BE%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>一朵清澈的百合<br>生长在右侧隔着的银河</p><p>二十一日风来了<br>她在月光下睡着</p><p>听清她湿润的呓语<br>带我去另一个时空造爱飞行</p><p>扶风上升的她<br>撞进我比尘轻<br>比蚁微渺的生命</p><p>她一开口<br>人间就是了</p><p>滞空温柔的间隙<br>加速度停顿认真感应</p><p>她发出一声叹息<br>太古里的叹息</p><p>今夜四海八荒宁静下来<br>第二天纷纷飘下我纷纷的情欲</p><p>一朵清澈的百合<br>生长在清丽的风尘里</p><p>四月里醒来<br>一双眼睛装下一个生平</p><p>她没有说话<br>没有回答</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想来情应尽矣</title>
      <link href="/2018/04/12/%E8%AF%8D-%E6%83%B3%E6%9D%A5%E6%83%85%E5%BA%94%E5%B0%BD%E7%9F%A3/"/>
      <url>/2018/04/12/%E8%AF%8D-%E6%83%B3%E6%9D%A5%E6%83%85%E5%BA%94%E5%B0%BD%E7%9F%A3/</url>
      
        <content type="html"><![CDATA[<p>2018-04-12<br>忆秦娥<br>&emsp;&emsp;清明诀，清明冰雨彻长夜。彻长夜，从此无心，任它明月。<br>&emsp;&emsp;泰安驿里东风冽，大梦归断重城阙。重城阙，前尘隔海，青山阔别。</p><p>2016-11-26<br>&emsp;&emsp;料应情尽矣。万般景、象天法地，都不如意。疑慢贪嗔痴折煞，解语参差是命。风满后、佳木也寂。欺山赶海践雪径，已枉然、此恨无人记。都付与，短长句。<br>&emsp;&emsp;心知此后来无计。便结了、缘浅路陌，旧时知己。还似初识还不似，彻夜后还难静。休顾他、恁多言语。自有造化双鱼腹，果与因、皆系锦书里。是问情，怎生起。</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我想在你的怀中失去记忆</title>
      <link href="/2018/02/21/%E9%9A%8F%E7%AC%94-%E6%88%91%E6%83%B3%E5%9C%A8%E4%BD%A0%E7%9A%84%E6%80%80%E4%B8%AD%E5%A4%B1%E5%8E%BB%E8%AE%B0%E5%BF%86/"/>
      <url>/2018/02/21/%E9%9A%8F%E7%AC%94-%E6%88%91%E6%83%B3%E5%9C%A8%E4%BD%A0%E7%9A%84%E6%80%80%E4%B8%AD%E5%A4%B1%E5%8E%BB%E8%AE%B0%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p>我想在你的怀中失去记忆<br>做个好梦然后留在这里/<br>你看见死掉的罗曼蒂克<br>我告诉你 那已经过去了<br>都是过去了/<br>十二月走后鸟就来了<br>来年可期<br>往事 无需问</p><p>如果明天你将我叫醒<br>我便知晓你是中意我的/<br>活进你的日子里<br>夜晚与清晨就明晰起来<br>睡梦竟变得可爱/<br>梦 是我做的<br>白鸟是你化成的</p><p>我在什么时辰唤你名字<br>你醒来就来临/<br>于是你站在高高的枝头上<br>容我看着你 远远地<br>看着你<br>一如十年后看着你 远远地/<br>等着<br>等着我 唤你名字</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你</title>
      <link href="/2017/12/13/%E9%9A%8F%E7%AC%94-%E4%BD%A0/"/>
      <url>/2017/12/13/%E9%9A%8F%E7%AC%94-%E4%BD%A0/</url>
      
        <content type="html"><![CDATA[<p>你这样你<br>入眼是你<br>囿于灵魂<br>又困于命理</p><p>你这样你<br>遗憾是你<br>一纸荒唐<br>换一个姓名</p><p>你这样你<br>你多迷离<br>游于想象<br>又脱于实际</p><p>你这样你<br>你太彻底<br>成为好梦<br>没成为具体</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薄荷薄荷</title>
      <link href="/2017/12/11/%E9%9A%8F%E7%AC%94-%E8%96%84%E8%8D%B7%E8%96%84%E8%8D%B7/"/>
      <url>/2017/12/11/%E9%9A%8F%E7%AC%94-%E8%96%84%E8%8D%B7%E8%96%84%E8%8D%B7/</url>
      
        <content type="html"><![CDATA[<p>我看过你的眼睛<br>住着一颗星星<br>在夜晚听悉我心事<br>清晨遗落我梦里</p><p>我听过你的声音<br>沉入海的深底<br>在沦陷之后没治愈<br>没有关系&emsp;没关系</p><p>薄荷薄荷&emsp;你没说话<br>天亮之前我要找你不肯回家<br>如果明天下落不明<br>你知道我曾为你动过情吗<br>薄荷薄荷&emsp;你别说话<br>我想给你讲个故事自始无终<br>可是&emsp;“好”<br>好吧</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/11/11/hello-world/"/>
      <url>/2017/11/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
