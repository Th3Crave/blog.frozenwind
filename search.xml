<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大数据-浅谈</title>
      <link href="/posts/33930.html"/>
      <url>/posts/33930.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="OLAP-amp-OLTP"><a href="#OLAP-amp-OLTP" class="headerlink" title="OLAP &amp; OLTP"></a>OLAP &amp; OLTP</h3><ul><li>OLAP（Online Analytical Processing）在线分析处理<ul><li>定义<br>  主要用于处理企业级的决策分析、战略分析以及业务分析等方面。<br>  OLAP主要是用了多维数据分析技术和聚合算法，可以将大量数据划分成各种不同的角度，方便分析数据。</li><li>数据类型</li><li>查询模式</li><li>性能要求</li><li>数据安全性</li><li>应用场景</li></ul></li><li>OLTP（Online Transaction Processing）在线事务处理<ul><li>定义<br>  主要用于处理企业级的常规业务操作。<br>  OLTP主要强调数据的准确性、事务的原子性、处理的并发性。</li><li>数据类型</li><li>查询模式</li><li>性能要求</li><li>数据安全性</li><li>应用场景</li></ul></li></ul><p>在企业级应用中，OLAP和OLTP扮演着不同的角色。<br>OLAP主要用于企业级决策和战略分析，需要快速的数据查询和分析技术。<br>OLTP主要用于企业日常操作，需要快速的数据更新和处理技术。</p><h3 id="KFD"><a href="#KFD" class="headerlink" title="KFD"></a>KFD</h3><p><img src="/posts/33930/k-f-d.jpeg"></p><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><h3 id="Apache-Flink"><a href="#Apache-Flink" class="headerlink" title="Apache Flink"></a>Apache Flink</h3><h3 id="Apache-Doris"><a href="#Apache-Doris" class="headerlink" title="Apache Doris"></a>Apache Doris</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务-服务调用-gRPC</title>
      <link href="/posts/52533.html"/>
      <url>/posts/52533.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 服务调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构-Dubbo3</title>
      <link href="/posts/30079.html"/>
      <url>/posts/30079.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://dubbo.apache.org/">https://dubbo.apache.org</a><br><a href="https://cn.dubbo.apache.org/zh-cn/blog/index.html">https://cn.dubbo.apache.org/zh-cn/blog/index.html</a></p><p>很多人对Dubbo的理解是RPC框架，但是就目前看来，Dubbo已经不仅仅是一个RPC框架了。<br>Dubbo 定位是一款微服务开发框架，它侧重解决微服务实践从服务定义、开发、通信到治理的问题，因此 Dubbo 同时提供了 RPC 通信、与应用开发框架的适配、服务治理等能力。</p><h3 id="Dubbo与SpringCloud"><a href="#Dubbo与SpringCloud" class="headerlink" title="Dubbo与SpringCloud"></a>Dubbo与SpringCloud</h3><p><img src="/posts/30079/dubbo-springcloud.png"></p><p><a href="https://cn.dubbo.apache.org/zh-cn/overview/what/xyz-difference/">https://cn.dubbo.apache.org/zh-cn/overview/what/xyz-difference/</a></p><h3 id="Dubbo与Istio"><a href="#Dubbo与Istio" class="headerlink" title="Dubbo与Istio"></a>Dubbo与Istio</h3><h2 id="Dubbo3"><a href="#Dubbo3" class="headerlink" title="Dubbo3"></a>Dubbo3</h2><p><a href="https://cn.dubbo.apache.org/zh-cn/overview/what/overview/">https://cn.dubbo.apache.org/zh-cn/overview/what/overview/</a></p><p><img src="/posts/30079/dubbo3-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p><ul><li>服务治理抽象控制面<br>服务治理控制面不是特指如注册中心类的单个具体组件，而是对 Dubbo 治理体系的抽象表达。<br>控制面包含协调服务发现的注册中心、流量管控策略、Dubbo Admin 控制台等，如果采用了 Service Mesh 架构则还包含 Istio 等服务网格控制面。</li><li>Dubbo数据面<br>数据面代表集群部署的所有 Dubbo 进程，进程之间通过 RPC 协议实现数据交换，Dubbo 定义了微服务应用开发与调用规范并负责完成数据传输的编解码工作。<ul><li>服务消费者 (Dubbo Consumer)，发起业务调用或 RPC 通信的 Dubbo 进程</li><li>服务提供者 (Dubbo Provider)，接收业务调用或 RPC 通信的 Dubbo 进程</li></ul></li></ul><h3 id="如何结合K8S云原生？"><a href="#如何结合K8S云原生？" class="headerlink" title="如何结合K8S云原生？"></a>如何结合K8S云原生？</h3><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><ul><li>服务注册与发现架构</li><li>元数据服务架构<br>  <img src="/posts/30079/dubbo3-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-%E5%AE%8F%E8%A7%82%E6%9E%B6%E6%9E%84.png"></li><li>事件驱动架构</li></ul><h3 id="服务自省-应用级服务注册与发现"><a href="#服务自省-应用级服务注册与发现" class="headerlink" title="服务自省 - 应用级服务注册与发现"></a>服务自省 - 应用级服务注册与发现</h3><p>随着<strong>微服务架构</strong>和<strong>云原生技术</strong>的兴起，<strong>以应用为粒度</strong>的注册模型已是大势所趋，如 Spring Cloud 和 Kubernetes 服务注册与发现模型。<br>在术语上，微服务架构中的“服务”（Services）与云原生中“应用”（Applications）是相同的概念，属于逻辑名称，而它们的成员则以服务实例（Service Instances）体现，服务和服务实例的数量关系为 1:N。</p><p>Dubbo 服务自省首要需求是<strong>减轻注册中心的承载的压力</strong>，同时，<strong>以应用为粒度</strong>的服务注册与发现模型不但能够最大化的减少 Dubbo 服务元信息注册数量，而且还能支持 Spring Cloud 和 Kubernetes 环境，可谓是一举两得。</p><p><img src="/posts/30079/dubbo3-%E6%9C%8D%E5%8A%A1%E8%87%AA%E7%9C%81-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><ol><li>服务提供者启动，首先解析应用定义的“普通服务”并依次注册为 RPC 服务，紧接着注册内建的 MetadataService 服务，最后打开 TCP 监听端口。</li><li>启动完成后，将实例信息注册到注册中心（<strong>仅限ip、port等实例相关数据</strong>），提供者启动完成。</li><li>服务消费者启动，首先依据其要“消费的 provider 应用名”到注册中心查询地址列表，并完成订阅（以实现后续地址变更自动通知）。</li><li>消费端拿到地址列表后，紧接着对 MetadataService 发起调用，返回结果中包含了所有应用定义的“普通服务”及其相关配置信息。</li><li>至此，消费者可以接收外部流量，并对提供者发起 Dubbo RPC 调用</li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-线程池-CompletableFuture</title>
      <link href="/posts/51693.html"/>
      <url>/posts/51693.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>创建线程的方式只有两种：继承Thread或者实现Runnable接口。 但是这两种方法都存在一个缺陷，没有返回值</p><p>Java 1.5 以后，可以通过向<strong>线程池</strong>提交一个<strong>Callable</strong>来获取一个<strong>包含返回值的Future对象</strong>。</p><h3 id="Future接口的局限性"><a href="#Future接口的局限性" class="headerlink" title="Future接口的局限性"></a>Future接口的局限性</h3><p>当Future的线程进行了一个非常耗时的操作，那我们的主线程也就阻塞了。<br>当我们在简单业务上，可以使用Future的另一个重载方法get(long,TimeUnit)来设置超时时间，避免我们的主线程被无穷尽地阻塞。</p><p>单纯使用Future接口或者FutureTask类并不能很好地完成以下我们所需的业务：</p><ol><li>将两个异步计算合并为一个，这两个异步计算之间相互独立，同时第二个又依赖于第一个的结果</li><li>等待Future集合中的所有任务都完成</li><li>仅等待Future集合中最快结束的任务完成，并返回它的结果</li><li>通过编程方式完成一个Future任务的执行</li><li>当Future的完成时间完成时会收到通知，并能使用Future的计算结果进行下一步的的操作，不只是简单地阻塞等待操作的结果</li></ol><h3 id="什么是CompletableFuture"><a href="#什么是CompletableFuture" class="headerlink" title="什么是CompletableFuture"></a>什么是CompletableFuture</h3><p><strong>CompletableFuture</strong>是<strong>java.util.concurrent</strong>库在<strong>java 8</strong>中新增的主要工具，同传统的Future相比，其支持流式计算、函数式编程、完成通知、自定义异常处理等很多新的特性。</p><ul><li>CompletableFuture实现了Future接口，因此有异步执行返回结果的能力。</li><li>CompletableFuture实现了CompletionStage接口，该接口是Java8新增的一个接口，用于异步执行中的阶段处理，其大量用在Lambda表达式计算过程中，目前只有CompletableFuture一个实现类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nexus-线上问题</title>
      <link href="/posts/4034.html"/>
      <url>/posts/4034.html</url>
      
        <content type="html"><![CDATA[<h2 id="版本3-38-1-01"><a href="#版本3-38-1-01" class="headerlink" title="版本3.38.1-01"></a>版本3.38.1-01</h2><h3 id="group组下成员代理仓库挂了，导致download很慢"><a href="#group组下成员代理仓库挂了，导致download很慢" class="headerlink" title="group组下成员代理仓库挂了，导致download很慢"></a>group组下成员代理仓库挂了，导致download很慢</h3><h3 id="mvn-deploy-第三方jar包到nexus，自动解析出来的pom信息不全"><a href="#mvn-deploy-第三方jar包到nexus，自动解析出来的pom信息不全" class="headerlink" title="mvn deploy 第三方jar包到nexus，自动解析出来的pom信息不全"></a>mvn deploy 第三方jar包到nexus，自动解析出来的pom信息不全</h3><ul><li><p>项目内二方包，idea Maven Lifecycle deploy 相当于 <code>mvn deploy:deploy</code></p></li><li><p>Nexus页面UI上传构件<br><img src="/posts/4034/nexus-upload-jar.png"><br><img src="/posts/4034/nexus-upload-jar&pom.png"></p><p>直接上传到 Nexus 的 Maven 仓库对应的 REST API。</p></li><li><p>命令mvn deploy:deploy-file</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy:deploy-file </span><br><span class="line">    -Dmaven.test.skip=<span class="literal">true</span> </span><br><span class="line">    -DgroupId=com.example </span><br><span class="line">    -DartifactId=demo </span><br><span class="line">    -Dversion=1.0.0 </span><br><span class="line">    -Dpackaging=jar </span><br><span class="line">    -Dfile=demo-1.0.0.jar </span><br><span class="line">    -DrepositoryId=x-repo </span><br><span class="line">    -Durl=http://localhost:8081/nexus/content/repositories/thirdparty/ </span><br><span class="line">    -DpomFile=pom.xml</span><br></pre></td></tr></table></figure><p>当执行 mvn deploy 时，<strong>Maven</strong> 的<code>maven-deploy-plugin</code>会将构件(jar,pom 等)上传到 <strong>Nexus 的 Maven 仓库对应的 REST API</strong>。</p><ul><li>maven-deploy-plugin<ol><li>initProperties，如果没有<code>-DpomFile</code>指定pomFile，会去<code>META-INF/maven/.*/pom\\.xml</code>找pom文件</li><li>如果查找失败，<code>pom == null &amp;&amp; generatePom</code>，则生成一个最简单的pom。</li><li>artifactDeployer.deploy( getSession().getProjectBuildingRequest(), deploymentRepository, deployableArtifacts );<br> <img src="/posts/4034/maven-deploy-plugin-put.png"><br> 最终将文件上传到<code>-Durl</code>指定的仓库地址。</li></ol></li><li>nexus-repository-maven<br>Nexus 的 Maven 仓库功能(nexus-repository-maven 模块)会处理这个 REST API 请求。<br>如果不指定<code>-DpomFile</code>，Nexus会默认<code>generatePom</code>为true，只会生成一个最简单的pom，缺少依赖，会导致依赖该组件的服务无法获取组件的依赖。</li></ul></li></ul><h3 id="批量deploy-jar包"><a href="#批量deploy-jar包" class="headerlink" title="批量deploy jar包"></a>批量deploy jar包</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> DevOps </category>
          
          <category> 制品管理 </category>
          
          <category> Nexus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nexus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础-集合-LinkedHashMap</title>
      <link href="/posts/13387.html"/>
      <url>/posts/13387.html</url>
      
        <content type="html"><![CDATA[<h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p><img src="/posts/13387/LinkedHashMap-%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedHashMap</strong>实现了<strong>Map接口</strong>，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。<strong>可将LinkedHashMap看作采用linked list增强的HashMap</strong>。</p><p>事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是<strong>LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。</p><h2 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (accessOrder)</span><br><span class="line">         <span class="comment">// afterNodeAccess 按读取顺序排序</span></span><br><span class="line">         afterNodeAccess(e);</span><br><span class="line">     <span class="keyword">return</span> e.value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        <span class="comment">// afterNodeAccess 按读取顺序排序</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="afterNodeAccess-Node-lt-K-V-gt-e"><a href="#afterNodeAccess-Node-lt-K-V-gt-e" class="headerlink" title="afterNodeAccess(Node&lt;K,V&gt; e)"></a>afterNodeAccess(Node&lt;K,V&gt; e)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap经典用法"><a href="#LinkedHashMap经典用法" class="headerlink" title="LinkedHashMap经典用法"></a>LinkedHashMap经典用法</h2><p>LinkedHashMap除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。<br>具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。<br>在每次插入新元素的之后LinkedHashMap会自动询问**removeEldestEntry()<strong>是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让</strong>removeEldestEntry()**返回true，就能够实现一个固定大小的FIFO策略的缓存。</p><p>示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。</span></span><br><span class="line"><span class="comment"> * 实现 LRUCache 类：</span></span><br><span class="line"><span class="comment"> * 1. LRUCache(int capacity) 以 正整数 作为容量capacity 初始化 LRU 缓存</span></span><br><span class="line"><span class="comment"> * 2. int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span></span><br><span class="line"><span class="comment"> * 3. void put(int key, int value)如果关键字key 已经存在，则变更其数据值value ；如果不存在，则向缓存中插入该组key-value 。如果插入操作导致关键字数量超过capacity ，则应该 逐出 最久未使用的关键字。</span></span><br><span class="line"><span class="comment"> * 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 输入</span></span><br><span class="line"><span class="comment"> * [&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span></span><br><span class="line"><span class="comment"> * [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span></span><br><span class="line"><span class="comment"> * 输出</span></span><br><span class="line"><span class="comment"> * [null, null, null, 1, null, -1, null, -1, 3, 4]</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 解释</span></span><br><span class="line"><span class="comment"> * LRUCache lRUCache = new LRUCache(2);</span></span><br><span class="line"><span class="comment"> * lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span></span><br><span class="line"><span class="comment"> * lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span></span><br><span class="line"><span class="comment"> * lRUCache.get(1);    // 返回 1</span></span><br><span class="line"><span class="comment"> * lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></span><br><span class="line"><span class="comment"> * lRUCache.get(2);    // 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment"> * lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></span><br><span class="line"><span class="comment"> * lRUCache.get(1);    // 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment"> * lRUCache.get(3);    // 返回 3</span></span><br><span class="line"><span class="comment"> * lRUCache.get(4);    // 返回 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache_LinkedHashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache_LinkedHashMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  LinkedHashMap</span></span><br><span class="line"><span class="comment">         *  这里的 accessOrder 默认是为false，如果要按读取顺序排序需要将其设为 true</span></span><br><span class="line"><span class="comment">         *  initialCapacity 代表 map 的 容量，loadFactor 代表加载因子 (默认即可)</span></span><br><span class="line"><span class="comment">         *  public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123;</span></span><br><span class="line"><span class="comment">         *      super(initialCapacity, loadFactor);</span></span><br><span class="line"><span class="comment">         *      this.accessOrder = accessOrder;</span></span><br><span class="line"><span class="comment">         *  &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cache = <span class="keyword">new</span> LinkedHashMap&lt;Integer, Integer&gt;(capacity, <span class="number">0.75f</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 当Entry个数超过cache的size时，删除最老的Entry</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cache.size() &gt; capacity;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache_LinkedHashMap lruCache = <span class="keyword">new</span> LRUCache_LinkedHashMap(<span class="number">2</span>);</span><br><span class="line">        lruCache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lruCache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">1</span>));</span><br><span class="line">        lruCache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生-Kubernetes</title>
      <link href="/posts/52389.html"/>
      <url>/posts/52389.html</url>
      
        <content type="html"><![CDATA[<p>Kubernetes是一个开源容器管理工具，负责容器部署，容器扩缩容以及负载平衡。<br>作为Google的创意之作，它提供了出色的社区，并与所有云提供商合作。因此，我们可以说Kubernetes不是一个容器化平台，而是一个多容器管理解决方案。</p><p>众所周知，Docker提供容器的生命周期管理，Docker镜像构建运行时容器。但是，由于这些单独的容器必须通信，因此使用Kubernetes。因此，我们说Docker构建容器，这些容器通过Kubernetes相互通信。因此，可以使用Kubernetes手动关联和编排在多个主机上运行的容器。</p><p><a href="https://kubernetes.io/zh-cn/docs/home/">kubernetes.io/zh-cn</a></p><h2 id="K8S整体架构"><a href="#K8S整体架构" class="headerlink" title="K8S整体架构"></a>K8S整体架构</h2><p><img src="/posts/52389/k8s-arch-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p><h3 id="K8S组件"><a href="#K8S组件" class="headerlink" title="K8S组件"></a>K8S组件</h3><p><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/">https://kubernetes.io/zh-cn/docs/concepts/overview/components/</a></p><h4 id="控制平面组件（Control-Plane-Components）"><a href="#控制平面组件（Control-Plane-Components）" class="headerlink" title="控制平面组件（Control Plane Components）"></a>控制平面组件（Control Plane Components）</h4><p>控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件。<br>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。</p><ol><li><strong>kube-apiserver</strong><br> API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。<br> Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</li><li><strong>etcd</strong><br> 一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。</li><li><strong>kube-scheduler</strong><br> 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。<br> 调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</li><li><strong>kube-controller-manager</strong><br> 负责运行控制器进程。<br> 从逻辑上讲， 每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。<br> 这些控制器包括：<ul><li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</li><li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。</li></ul></li><li><strong>cloud-controller-manager</strong><br> 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</li></ol><h4 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件</h4><p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p><ol><li><strong>kubelet</strong><br> kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。<br> kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。<br> kubelet 不会管理不是由 Kubernetes 创建的容器。</li><li><strong>kube-proxy</strong><br> kube-proxy 是集群中每个节点（node）上所运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。<br> kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。<br> 它的作用是使发往 Service 的流量（通过ClusterIP和端口）负载均衡到正确的后端Pod。</li><li><strong>容器运行时 container-runtime</strong><br> 负责管理运行容器的软件，比如docker。</li></ol><h4 id="插件（Addons）"><a href="#插件（Addons）" class="headerlink" title="插件（Addons）"></a>插件（Addons）</h4><p>插件使用 Kubernetes 资源（DaemonSet、 Deployment 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 kube-system 命名空间。</p><ol><li><strong>kube-dns</strong><br> 集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录（记录service和为service分配的集群IP的对应关系）。<br> Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</li><li><strong>Ingress Controller</strong><br> 为服务提供k8s集群外网入口</li><li><strong>Heapster</strong><br> 提供资源监控</li><li><strong>Dashboard</strong><br> 提供GUI</li><li><strong>Federation</strong><br> 提供跨可用区的集群</li><li><strong>Fluentd-elasticsearch</strong><br> 提供集群日志采集、存储与查询</li></ol><h3 id="K8S资源对象"><a href="#K8S资源对象" class="headerlink" title="K8S资源对象"></a>K8S资源对象</h3><p>Kubernetes 中的所有内容都被抽象为“资源”，如 Pod、Service、Node 等都是资源。<br>“对象”就是“资源”的实例，是持久化的实体。如某个具体的 Pod、某个具体的 Node。Kubernetes 使用这些实体去表示整个集群的状态。</p><p>对象的创建、删除、修改都是通过 “Kubernetes API”，也就是 “Api Server” 组件提供的 API 接口，这些是 RESTful 风格的 Api，与 k8s 的“万物皆对象”理念相符。命令行工具 “kubectl”，实际上也是调用 kubernetes api。</p><p>K8s 中的资源类别有很多种，kubectl 可以通过配置文件来创建这些 “对象”，配置文件更像是描述对象“属性”的文件，配置文件格式可以是 “JSON” 或 “YAML”，常用 “YAML”。</p><p>几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置：<strong>对象 spec（规约）</strong> 和 <strong>对象 status（状态）</strong>。</p><p>这里有一个 <code>.yaml</code> 示例文件，展示了 Kubernetes Deployment 的必需字段和对象 spec：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 告知 Deployment 运行 2 个与该模板匹配的 Pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>在想要创建的 Kubernetes 对象所对应的 <code>.yaml</code> 文件中，需要配置的字段如下：</p><ul><li>apiVersion - 创建该对象所使用的 Kubernetes API 的版本</li><li><strong>kind</strong> - 想要创建的对象的类别</li><li>metadata - 帮助唯一标识对象的一些数据，包括一个 name 字符串、UID 和可选的 namespace</li><li>spec - 你所期望的该对象的状态</li></ul><h4 id="资源-对象种类"><a href="#资源-对象种类" class="headerlink" title="资源/对象种类"></a>资源/对象种类</h4><ol><li><p>（工作负载）Workload类对象</p><ol><li><p>Pod</p></li><li><p>Controllers<br> Deployment/Statefulset/Daemonset/Job等。</p><p> Certificate Controller<br> ClusterRoleAggregation Controller<br> Node Controller<br> CronJob Controller<br> Daemon Controller<br> Deployment Controller<br> StatefulSet Controller<br> Endpoint Controller<br> Endpointslice Controller<br> Garbage Collector<br> Namespace Controller<br> Job Controller<br> Pod AutoScaler<br> PodGC Controller<br> ReplicaSet Controller<br> Service Controller<br> ServiceAccount Controller<br> Volume Controller<br> Resource quota Controller<br> Disruption Controller</p></li></ol></li><li><p>Discovery&amp;Loadbalance类对象<br> Service/Endpoints/Ingress</p></li><li><p>Workload类对象<br> Configmap/ Secret/ Volume/ PersistentVolume</p></li><li><p>Cluster类对象<br> Node/Namespace/Role/ClusterRole</p></li></ol><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="Cluster、Master、Node"><a href="#Cluster、Master、Node" class="headerlink" title="Cluster、Master、Node"></a>Cluster、Master、Node</h4><ul><li>Cluster<br>   Cluster（集群） 是计算、存储和网络资源的集合，Kubernetes 利用这些资源运行各种基于容器的应用。<br>   最简单的 Cluster 可以只有一台主机（它既是 Mater 也是 Node）。</li><li>Master<br>   Master 是 Cluster 的大脑，它的主要职责是调度，即决定将应用放在哪里运行。<br>   Master 运行 Linux 操作系统，可以是物理机或者虚拟机。<br>   为了实现高可用，可以运行多个 Master。</li><li>Node<br>   Node 的职责是运行容器应用。<br>   Node 由 Master 管理，Node 负责监控并汇报容器的状态，并根据 Master 的要求管理容器的生命周期。<br>   Node 运行在 Linux 操作系统，可以是物理机或者是虚拟机。</li></ul><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>基本概念：</p><ol><li>Pod 是 Kubernetes 的最小工作单元。</li><li>每个 Pod 包含一个或多个容器。Pod 中的容器会作为一个整体被 Master 调度到一个 Node 上运行。</li></ol><p>引入Pod的目的：</p><ol><li><strong>可管理性</strong>: 有些容器天生就是需要紧密联系，一起工作。Pod 提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes 以 Pod 为最小单位进行调度、扩展、共享资源、管理生命周期。</li><li><strong>通信和资源共享</strong>: Pod 中的所有容器使用同一个网络 namespace，即相同的 IP 地址和 Port 空间。它们可以直接用 localhost 通信。同样的，这些容器可以共享存储，当 Kubernetes 挂载 volume 到 Pod，本质上是将 volume 挂载到 Pod 中的每一个容器。</li></ol><p>Pod的使用方式：</p><ol><li><strong>运行单一容器</strong>: <code>one-container-per-Pod</code> 是 Kubernetes 最常见的模型，这种情况下，只是将单个容器简单封装成 Pod。即便是只有一个容器，Kubernetes 管理的也是 Pod 而不是直接管理容器。</li><li><strong>运行多个容器</strong>: 对于那些联系非常紧密，而且需要直接共享资源的容器，应该放在一个 Pod 中。比如下面这个 Pod 包含两个容器：一个 File Puller，一个是 Web Server。File Puller 会定期从外部的 Content Manager 中拉取最新的文件，将其存放在共享的 volume 中。Web Server 从 volume 读取文件，响应 Consumer 的请求。这两个容器是紧密协作的，它们一起为 Consumer 提供最新的数据；同时它们也通过 volume 共享数据。所以放到一个 Pod 是合适的。</li></ol><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>基本概念：<br>Kubernetes 通常不会直接创建 Pod，而是通过 Controller 来管理 Pod 的。Controller 中定义了 Pod 的部署特性，比如有几个副本，在什么样的 Node 上运行等。为了满足不同的业务场景，Kubernetes 提供了多种 Controller，包括 Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job 等。</p><p>各个Controller：</p><ol><li><strong>Deployment：</strong> Deployment 是最常用的 Controller，比如我们可以通过创建 Deployment 来部署应用的。Deployment 可以管理 Pod 的多个副本，并确保 Pod 按照期望的状态运行。</li><li><strong>ReplicaSet：</strong> ReplicaSet 实现了 Pod 的多副本管理。使用 Deployment 时会自动创建 ReplicaSet，也就是说 Deployment 是通过 ReplicaSet 来管理 Pod 的多个副本，我们通常不需要直接使用 ReplicaSet。</li><li><strong>DaemonSet：</strong> DaemonSet 用于每个 Node 最多只运行一个 Pod 副本的场景。正如其名称所揭示的，DaemonSet 通常用于运行 daemon。</li><li><strong>StatefuleSet：</strong> StatefuleSet 能够保证 Pod 的每个副本在整个生命周期中名称是不变的。而其他 Controller 不提供这个功能，当某个 Pod 发生故障需要删除并重新启动时，Pod 的名称会发生变化。同时 StatefuleSet 会保证副本按照固定的顺序启动、更新或者删除。</li><li><strong>Job：</strong> Job 用于运行结束就删除的应用。而其他 Controller 中的 Pod 通常是长期持续运行。</li></ol><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><ol><li>Deployment 可以部署多个副本，每个 Pod 都有自己的 IP。而 Pod 很可能会被频繁地销毁和重启，它们的 IP 会发生变化，用 IP 来访问 Deployment 副本不太现实。</li><li>Service 定义了外界访问一组特定 Pod 的方式。Service 有自己的 IP 和端口，Service 为 Pod 提供了负载均衡。</li></ol><h4 id="Namaspace"><a href="#Namaspace" class="headerlink" title="Namaspace"></a>Namaspace</h4><ol><li>Namespace 可以将一个物理的 Cluster 逻辑上划分成多个虚拟 Cluster，每个 Cluster 就是一个 Namespace。不同 Namespace 里的资源是完全隔离的。</li><li>Kubernetes 默认创建了两个 Namespace<ol><li><strong>default</strong>：创建资源时如果不指定，将被放到这个 Namespace 中。</li><li><strong>kube-system</strong>：Kubernetes 自己创建的系统资源将放到这个 Namespace 中。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/posts/40991.html"/>
      <url>/posts/40991.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/40991/docker-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Knative-Eventing 结合Kafka Channel实现事件总线</title>
      <link href="/posts/47874.html"/>
      <url>/posts/47874.html</url>
      
        <content type="html"><![CDATA[<h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><img src="/posts/47874/%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg"></p><p>如上图，主要以Kafka Channel为例，整体分为控制面和数据面。控制面负责根据Broker或者Trigger生成一系列的其他资源，包括运行的pod和channel类的配置等。</p><h2 id="控制面"><a href="#控制面" class="headerlink" title="控制面"></a>控制面</h2><h3 id="整体流程介绍"><a href="#整体流程介绍" class="headerlink" title="整体流程介绍"></a>整体流程介绍</h3><p>有两个流程可以触发配置的生成，即broker的创建流程和trigger的创建流程，均为外部添加，分别定义生产和消费的流程。结合上图，每种颜色的虚线代表一种触发流程。</p><h4 id="涉及模块与资源"><a href="#涉及模块与资源" class="headerlink" title="涉及模块与资源"></a>涉及模块与资源</h4><p>介绍流程前，先介绍涉及的资源。</p><ul><li>各类Controller<ul><li><strong>mt-broker-controller</strong><br>  多租户broker的controller，watch broker和trigger，当有添加或者变更时，分别生成channel和subscription(简称sub);</li><li><strong>event-controller</strong><br>  负责channel backup、sub同步、顺序投递等多项内容。<br>  核心流程是sub的流程，根据mt-broker-controller生成的sub，同步到channel中。</li><li><strong>eventing-kafka-channel-controller</strong><br>  watch kafka channel，有变更后负责kafka相关的资源的创建，包含topic、receiver、dispatcher、channel service等等，这里相对较复杂。</li></ul></li><li>各类配置（k8s自定义资源）<ol><li><strong>Broker</strong><br> 是使用方添加，核心是spec.config，表示是哪种类型的broker，后续由哪种类型的controller处理。 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">eventing.knative.dev/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Broker</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">console-integration-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">        <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">config-br-default-channel</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">knative-eventing</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">    <span class="attr">address:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://broker-ingress.knative-eventing.svc.cluster.local/console-integration-test/e-0fa923f63c58387a</span></span><br><span class="line"><span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">knative.dev/channelAPIVersion:</span> <span class="string">messaging.knative.dev/v1beta1</span></span><br><span class="line">    <span class="attr">knative.dev/channelAddress:</span> <span class="string">http://e-0fa923f63c58387a-kne-trigger-kn-channel.console-integration-test.svc.cluster.local</span></span><br><span class="line">    <span class="attr">knative.dev/channelKind:</span> <span class="string">KafkaChannel</span></span><br><span class="line">    <span class="attr">knative.dev/channelName:</span> <span class="string">e-0fa923f63c58387a-kne-trigger</span></span><br></pre></td></tr></table></figure></li><li><strong>Channel</strong><br> 包含大部分信息，channel定义具体的实现类型，如下边的kafka topic、订阅信息等，由mt-broker-controller、eventing-kafka-channel-controller和event-controller共同维护 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">messaging.knative.dev/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KafkaChannel</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">eventing.knative.dev/broker:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">        <span class="attr">eventing.knative.dev/brokerEverything:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">        <span class="attr">kafkaTopic:</span> <span class="string">console-integration-test.e-0fa923f63c58387a-kne-trigger</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a-kne-trigger</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">console-integration-test</span></span><br><span class="line">    <span class="attr">ownerReferences:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">eventing.knative.dev/v1</span></span><br><span class="line">        <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">Broker</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">f4397394-5256-444f-986a-3d30494b9eb3</span></span><br><span class="line">    <span class="attr">resourceVersion:</span> <span class="string">&quot;1256200358&quot;</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">a72f806c-4447-486a-a66f-f581272792db</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">numPartitions:</span> <span class="number">6</span></span><br><span class="line">    <span class="attr">replicationFactor:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">retentionDuration:</span> <span class="string">PT168H</span></span><br><span class="line">    <span class="attr">subscribers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">replyUri:</span> <span class="string">http://broker-ingress.knative-eventing.svc.cluster.local/console-integration-test/e-0fa923f63c58387a</span></span><br><span class="line">        <span class="attr">subscriberUri:</span> <span class="string">http://broker-filter.knative-eventing.svc.cluster.local/triggers/console-integration-test/e-0fa923f63c58387a/7c2d2fb2-17e6-4358-8690-78e994a94926</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">ee29f447-4d1b-480c-88d6-a9a34ec425e0</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">    <span class="attr">address:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://e-0fa923f63c58387a-kne-trigger-kn-channel.console-integration-test.svc.cluster.local</span></span><br></pre></td></tr></table></figure></li><li><strong>channel-service</strong><br> 维护channel对应的service，控制着流量从ingress出来，发送到哪里 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">eventing-kafka-channels</span></span><br><span class="line">        <span class="attr">kafkachannel-name:</span> <span class="string">e-0fa923f63c58387a-kne-trigger</span></span><br><span class="line">        <span class="attr">kafkachannel-namespace:</span> <span class="string">console-integration-test</span></span><br><span class="line">        <span class="attr">kafkachannel-receiver:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a-kne-trigger-kn-channel</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">console-integration-test</span></span><br><span class="line">    <span class="attr">ownerReferences:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">messaging.knative.dev/v1beta1</span></span><br><span class="line">        <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">KafkaChannel</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a-kne-trigger</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">a72f806c-4447-486a-a66f-f581272792db</span></span><br><span class="line">    <span class="attr">resourceVersion:</span> <span class="string">&quot;1250797977&quot;</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">9f147779-0bd3-490c-9d14-f4717e14b300</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">externalName:</span> <span class="string">kafka-cluster-32603413-receiver.knative-eventing.svc.cluster.local</span></span><br><span class="line">    <span class="attr">internalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line">    <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">    <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><strong>Trigger</strong><br> trigger是使用方添加的，会触发消费相关的流程，指定了broker的信息，mt-broker-controller会根据broker生成对应的sub <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">eventing.knative.dev/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Trigger</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">eventing.knative.dev/broker:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">console-integration-test</span></span><br><span class="line">    <span class="attr">ownerReferences:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">eventing.knative.dev/v1</span></span><br><span class="line">        <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">Broker</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">f4397394-5256-444f-986a-3d30494b9eb3</span></span><br><span class="line">    <span class="attr">resourceVersion:</span> <span class="string">&quot;1254842424&quot;</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">7c2d2fb2-17e6-4358-8690-78e994a94926</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">broker:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">    <span class="attr">filter:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">subscriber:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://**.**.net/event/save?busId=e-0fa923f63c58387a&amp;busProject=console</span></span><br></pre></td></tr></table></figure></li><li><strong>subscription</strong><br> sub为订阅信息，涉及channel，相关核心的部分，会有event-controller同步到channel中 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">messaging.knative.dev/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Subscription</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">eventing.knative.dev/broker:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">        <span class="attr">eventing.knative.dev/trigger:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a-e-0fa923f63caf5783cb75857ee6af2dda00ad7e4e29</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">console-integration-test</span></span><br><span class="line">    <span class="attr">ownerReferences:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">eventing.knative.dev/v1</span></span><br><span class="line">        <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">Trigger</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">7c2d2fb2-17e6-4358-8690-78e994a94926</span></span><br><span class="line">    <span class="attr">resourceVersion:</span> <span class="string">&quot;1254842422&quot;</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">ee29f447-4d1b-480c-88d6-a9a34ec425e0</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">channel:</span></span><br><span class="line">        <span class="attr">apiVersion:</span> <span class="string">messaging.knative.dev/v1beta1</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">KafkaChannel</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a-kne-trigger</span></span><br><span class="line">    <span class="attr">reply:</span></span><br><span class="line">        <span class="attr">ref:</span></span><br><span class="line">        <span class="attr">apiVersion:</span> <span class="string">eventing.knative.dev/v1</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">Broker</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">e-0fa923f63c58387a</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">console-integration-test</span></span><br><span class="line">    <span class="attr">subscriber:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://broker-filter.knative-eventing.svc.cluster.local/triggers/console-integration-test/e-0fa923f63c58387a/7c2d2fb2-17e6-4358-8690-78e994a94926</span></span><br><span class="line"><span class="attr">status:</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="Broker创建流程"><a href="#Broker创建流程" class="headerlink" title="Broker创建流程"></a>Broker创建流程</h4><ol><li>通过接口或者cli生成broker</li><li>mt-broker-controller 监听 borker<br> 有broker添加后根据broker生成channel，并检查相关的ingress、dispatcher等状态，更新到broker的status中。<br> 比如channel的url会更新到Annotations中，ingress会从这里获取去，其格式:http://{channel.name}.{namespace}.svc.cluster.local</li><li>eventing-kafka-channel-controller 监听 channel，有变更后，会进行多很多具体资源的创建。<ul><li>Kafka topic创建</li><li>Receiver如果不存在，进行service和deployment的创建</li><li>channel对应的service的创建，建立channel到receiver的关联关系，即确定上一步中url的具体服务地址，这样可以适配多种channel</li><li>Dispather的service和deployment的创建，一个channel对应一个dispatcher的service</li><li>更新channel自己的信息，如Annotations和Labels</li></ul></li></ol><h4 id="Trigger创建流程"><a href="#Trigger创建流程" class="headerlink" title="Trigger创建流程"></a>Trigger创建流程</h4><ol><li>通过接口或者cli生成trigger</li><li>mt-broker-controller 监听 trigger，生成sub，主要是添加channel信息、生成对应的trigger url等，并更新trigger的状态</li><li>eventing-controller 监听 sub，将变更同步到channel中，eventing-kafka-channel-controller将会根据channel的变更做相关的调整，这块同<strong>broker的创建流程</strong>中的相关部分</li></ol><h3 id="主要流程源码分析"><a href="#主要流程源码分析" class="headerlink" title="主要流程源码分析"></a>主要流程源码分析</h3><p>根据上面的内容，流程上主要是：</p><ul><li>broker创建后channel的生成<br>  其中涉及mt-broker-controller和eventing-kafka-channel-controller</li><li>trigger创建后sub的生成<br>  其中涉及mt-broker-controller</li></ul><h4 id="依赖的框架"><a href="#依赖的框架" class="headerlink" title="依赖的框架"></a>依赖的框架</h4><p>基于<code>knative.dev/pkg/injection/sharedmain</code><br><a href="https://github.com/knative/pkg/blob/main/injection/sharedmain/main.go">https://github.com/knative/pkg/blob/main/injection/sharedmain/main.go</a></p><h4 id="mt-broker-controller"><a href="#mt-broker-controller" class="headerlink" title="mt-broker-controller"></a>mt-broker-controller</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;knative.dev/pkg/injection/sharedmain&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;knative.dev/eventing/pkg/reconciler/broker&quot;</span></span><br><span class="line">mttrigger <span class="string">&quot;knative.dev/eventing/pkg/reconciler/broker/trigger&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">component = <span class="string">&quot;mt-broker-controller&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sharedmain.Main(</span><br><span class="line">component,</span><br><span class="line">broker.NewController,</span><br><span class="line">mttrigger.NewController,</span><br><span class="line">)</span><br><span class="line">broker.Tracer.Shutdown(context.Background())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mt-broker-controller主要watch两类变更，<strong>broker和trigger的变更</strong>。</p><h4 id="eventing-kafka-channel-controller"><a href="#eventing-kafka-channel-controller" class="headerlink" title="eventing-kafka-channel-controller"></a>eventing-kafka-channel-controller</h4><p>主要监听channel的变更。</p><h3 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h3><h2 id="数据面"><a href="#数据面" class="headerlink" title="数据面"></a>数据面</h2><h3 id="整体流程介绍-1"><a href="#整体流程介绍-1" class="headerlink" title="整体流程介绍"></a>整体流程介绍</h3><p>一条消息发送和接受的整个流程：</p><ol><li>消息先进入ingress，在ingress中完成CloudEvent的转换和相关校验，然后根据broker中的channel的svc地址，发送过去；</li><li>receiver收到ingress发送过来的消息，从request.Host中解析出namespace，channel name，然后调用kafka的producer发送，此处除了config-map config-kafka和secret kafka-cluster基本不和外部模块交互；</li><li>dispatcher根据订阅启动对应的消费者，消费到消息后，根据sub中的url，推送到filter；配置变更来源于channel，一个channel对应一个服务，所有的订阅都在一个服务中；</li><li>filter主要实现了过滤，收到dispatcher的请求后，进行过滤，然后发送到接收端；</li></ol><h3 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h3><p>ingress主要完成了两个功能：</p><ol><li>message校验以及转换成CloudEvent</li><li>从broker annotations中的knative.dev/channelAddress查到地址，并发送到相应的地址</li></ol><h3 id="receiver"><a href="#receiver" class="headerlink" title="receiver"></a>receiver</h3><p>recevier主要负责将event发送到broker中，主要内容如下：</p><ol><li>维护kafkaclient，这里配置从cm中获取(timeout、KeepAlive、RequiredAcks(默认配置是-1))，但是不支持动态更新，secret的变更支持动态更新</li><li>接收http请求，从host中获取到namespace和channel name，其格式：http://{channel.name}.{namespace}.svc.cluster.local</li><li>调用kafkaclient发送event</li></ol><h3 id="dispatcher"><a href="#dispatcher" class="headerlink" title="dispatcher"></a>dispatcher</h3><p>dispatcher跟其他模块不同，它是一个channel一个service，此外相对其他模块复杂些，其中包含控制和数据两个方面的变更，主要内容如下：</p><ul><li>控制面<ol><li>Reconcile流程，感知channel的变更，根据sub部分的信息调整consumer，关闭减少的，启动新增的，并且会根据启动状态更新channel中的status</li><li>根据channel的Secret Watcher变更，同receiver，涉及kafka client的变更，此类变更比较重，会重启所有的consumer。这个过程也会触发reconcile流程。</li></ol></li><li>数据面<br>  相对简单，拿到消息后，根据配置，推送到filter，主要工作由channel.MessageDispatcher</li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter代码结构类似ingress，相对其他模块，较为简单，主要是接收http请求，处理后，在发送http请求，具体流程如下：</p><ol><li>接收请求，并校验，从路径中解析出当前属于哪个trigger，格式如<code>/triggers/namespace/name/uid</code>，可以得到namespace和name</li><li>根据namespace和name获取trigger的具体配置</li><li>根据配置获取filter，如果配置了，按其进行过滤</li><li>未过滤掉的发送给接收端</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>模块间主要通过http通信，其地址是其对应的标识，各模块负责服务的资源地址格式如下：</p><table><thead><tr><th align="left">资源</th><th align="left">所在服务</th><th align="left">uri</th></tr></thead><tbody><tr><td align="left">broker</td><td align="left">ingress</td><td align="left"><a href="http://broker-ingress.knative-eventing.svc.cluster.local/%7Bnamespace%7D/%7Bbrokername%7D">http://broker-ingress.knative-eventing.svc.cluster.local/{namespace}/{brokername}</a></td></tr><tr><td align="left">channel</td><td align="left">receiver</td><td align="left">http://{channel.name}.{namespace}.svc.cluster.local</td></tr><tr><td align="left">sub</td><td align="left">dispatcher</td><td align="left">无</td></tr><tr><td align="left">trigger</td><td align="left">filter</td><td align="left"><a href="http://broker-filter.knative-eventing.svc.cluster.local/triggers/%7Bnamespace%7D/%7Btrigger.name%7D/%7Btrigger.uid%7D">http://broker-filter.knative-eventing.svc.cluster.local/triggers/{namespace}/{trigger.name}/{trigger.uid}</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
            <tag> Knative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发：限流</title>
      <link href="/posts/29987.html"/>
      <url>/posts/29987.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是限流"><a href="#什么是限流" class="headerlink" title="什么是限流"></a>什么是限流</h3><p>在日常生活中限流很常见，例如去有些景区玩，每天售卖的门票数是有限的，例如 2000 张，即每天最多只有 2000 个人能进去游玩。<br>那在我们工程上限流是什么呢？限制的是 「流」，在不同场景下「流」的定义不同，可以是每秒请求数、每秒事务处理数、网络流量等等。</p><p>而通常我们说的限流指代的是<strong>限制到达系统的并发请求数</strong>，使得系统能够正常的处理<strong>部分</strong>用户的请求，来保证系统的稳定性。</p><p>限流不可避免的会造成用户的请求变慢或者被拒的情况，从而会影响用户体验。<br>因此限流是需要在用户体验和系统稳定性之间做平衡的，即我们常说的 <strong>trade off</strong>。</p><p>限流也称流控（流量控制）。<br>每个系统都有服务的上线，所以当流量超过服务极限能力时，系统可能会出现卡死、崩溃的情况，所以就有了降级和限流。<br>限流其实就是：当高并发或者瞬时高并发时，为了保证系统的稳定性、可用性，系统以牺牲部分请求为代价或者延迟处理请求为代价，保证系统整体服务可用。</p><h3 id="为什么要限流"><a href="#为什么要限流" class="headerlink" title="为什么要限流"></a>为什么要限流</h3><p>日常的业务上有类似秒杀活动、双十一大促或者突发新闻等场景，用户的流量突增，后端服务的处理能力是有限的，如果不能处理好突发流量，后端服务很容易就被打垮。<br>亦或是爬虫等不正常流量，我们对外暴露的服务都要以最大恶意去防备调用者。<br>我们不清楚调用者会如何调用我们的服务，假设某个调用者开几十个线程一天二十四小时疯狂调用你的服务，如果不做啥处理咱服务也算完了，更胜的还有DDos攻击。<br>还有对于很多第三方开放平台来说，不仅仅要防备不正常流量，还要保证资源的公平利用，一些接口都免费给你用了，资源都不可能一直都被你占着吧，别人也得调的。</p><p>限流的本质是因为后端处理能力有限，需要截掉超过处理能力之外的请求，亦或是为了均衡客户端对服务端资源的公平调用，防止一些客户端饿死。</p><h2 id="常见的限流算法"><a href="#常见的限流算法" class="headerlink" title="常见的限流算法"></a>常见的限流算法</h2><h3 id="1-计数器"><a href="#1-计数器" class="headerlink" title="1. 计数器"></a>1. 计数器</h3><p>最简单的限流算法就是计数限流了。</p><p>例如系统能同时处理 100 个请求，保存一个计数器，处理了一个请求，计数器就加一，一个请求处理完毕之后计数器减一。<br>每次请求来的时候看看计数器的值，如果超过阈值就拒绝。<br>非常简单粗暴。</p><p>计数器的值要是存内存中就算单机限流算法；如果放在第三方存储里，例如 Redis 中，集群机器访问就算分布式限流算法。</p><p>优点就是：简单粗暴，单机在 Java 中可用 Atomic 等原子类、分布式就 Redis incr。<br>缺点就是：假设我们允许的阈值是1万，此时计数器的值为 0， 当 1 万个请求在前 1 秒内一股脑儿的都涌进来，这突发的流量可是顶不住的。<br>缓缓地增加流量处理和一下子涌入对于程序来说是不一样的。</p><ul><li>采用AtomicInteger<br>  <img src="/posts/29987/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E5%99%A8-AtomicInteger%E4%BC%AA%E4%BB%A3%E7%A0%81.png"></li><li>采用令牌Semaphore</li><li>采用ThreadPoolExecutor java线程池</li></ul><h3 id="2-固定窗口"><a href="#2-固定窗口" class="headerlink" title="2. 固定窗口"></a>2. 固定窗口</h3><p>一般的限流都是为了限制在指定时间间隔内的访问量，因此还有个算法叫固定窗口。</p><p>相比于计数限流主要是多了个时间窗口的概念，<strong>计数器每过一个时间窗口就重置</strong>。<br>规则如下：</p><ul><li>请求次数小于阈值，允许访问并且计数器 +1；</li><li>请求次数大于阈值，拒绝访问；</li><li>这个时间窗口过了之后，计数器清零；</li></ul><p><img src="/posts/29987/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95-%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3-%E4%BC%AA%E4%BB%A3%E7%A0%81.png"></p><h4 id="固定窗口临界问题"><a href="#固定窗口临界问题" class="headerlink" title="固定窗口临界问题"></a>固定窗口临界问题</h4><p>假设系统每秒允许 100 个请求，假设第一个时间窗口是 0-1s，在第 0.55s 处一下次涌入 100 个请求，过了 1 秒的时间窗口后计数清零，此时在 1.05 s 的时候又一下次涌入100个请求。<br>虽然窗口内的计数没超过阈值，但是全局来看在 0.55s-1.05s 这 0.1 秒内涌入了 200 个请求，这其实对于阈值是 100/s 的系统来说是无法接受的。<br><img src="/posts/29987/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95-%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3-%E4%B8%B4%E7%95%8C%E9%97%AE%E9%A2%98.png"></p><h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h3><p>滑动窗口限流解决固定窗口临界值的问题，可以保证在任意时间窗口内都不会超过阈值。<br>相对于固定窗口，滑动窗口除了需要引入计数器之外，还需要<strong>记录时间窗口内每个请求到达的时间点</strong>，因此<strong>对内存的占用会比较多</strong>。</p><p>规则如下，假设时间窗口为 1 秒：</p><ul><li>记录每次请求的时间</li><li>统计每次请求的时间 至 往前推1秒这个时间窗口内请求数，并且 1 秒前的数据可以删除。</li><li>统计的请求数小于阈值就记录这个请求的时间，并允许通过，反之拒绝。</li></ul><p><img src="/posts/29987/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E7%A4%BA%E4%BE%8B%E5%9B%BE.png"><br><img src="/posts/29987/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E4%BC%AA%E4%BB%A3%E7%A0%81.png"></p><h4 id="短时间内的流量暴击"><a href="#短时间内的流量暴击" class="headerlink" title="短时间内的流量暴击"></a>短时间内的流量暴击</h4><p>滑动窗口和固定窗口都<strong>无法解决短时间之内集中流量的突击</strong>。</p><p>我们所想的限流场景是：<br>每秒限制 100 个请求。希望请求每 10ms 来一个，这样我们的流量处理就很平滑，但是真实场景很难控制请求的频率，因此可能存在 5ms 内就打满了阈值的情况。<br>当然对于这种情况还是有变型处理的，例如设置多条限流规则。不仅限制每秒 100 个请求，再设置每  10ms 不超过 2 个。</p><p>多说一句，<strong>这个滑动窗口可与TCP的滑动窗口不一样</strong>。<br>TCP的滑动窗口是接收方告知发送方自己能接多少“货”，然后发送方控制发送的速率。</p><h3 id="4-漏桶"><a href="#4-漏桶" class="headerlink" title="4. 漏桶"></a>4. 漏桶</h3><p>漏桶，它可以解决时间窗口类的痛点，使得流量更加平滑。</p><p>如下图所示，水滴持续滴入漏桶中，底部定速流出。<br>如果水滴滴入的速率大于流出的速率，当存水超过桶的大小的时候就会溢出。</p><p>规则如下：</p><ul><li>请求来了放入桶中</li><li>桶内请求量满了拒绝请求</li><li>服务定速从桶内拿请求处理</li></ul><p><img src="/posts/29987/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95-%E6%BC%8F%E6%A1%B6-%E7%A4%BA%E4%BE%8B%E5%9B%BE.png"></p><p>可以看到水滴对应的就是请求。<br>它的特点就是<strong>宽进严出</strong>，无论请求多少，请求的速率有多大，都按照固定的速率流出，对应的就是<strong>服务按照固定的速率处理请求</strong>。</p><p>看到这想到啥，是不是和消息队列思想有点像，削峰填谷。<br>一般而言漏桶也是由<strong>队列</strong>来实现的，<strong>处理不过来的请求就排队，队列满了就开始拒绝请求</strong>。<br>看到这又想到啥，<strong>线程池</strong>不就是这样实现的嘛？</p><p>经过漏洞这么一过滤，请求就能平滑的流出，看起来很像很挺完美的？实际上它的优点也即缺点。<br>面对<strong>突发请求</strong>，服务的处理速度和平时是一样的，这其实不是我们想要的。<br>在面对突发流量我们希望在系统平稳的同时，提升用户体验即能更快的处理请求，而不是和正常流量一样，循规蹈矩的处理（看看，之前滑动窗口说流量不够平滑，现在太平滑了又不行，难搞啊）。</p><p>而<strong>令牌桶</strong>在应对<strong>突击流量</strong>的时候，可以更加的“激进”。</p><h3 id="5-令牌桶算法"><a href="#5-令牌桶算法" class="headerlink" title="5. 令牌桶算法"></a>5. 令牌桶算法</h3><p>令牌桶其实和漏桶的原理类似，只不过<strong>漏桶是定速地流出</strong>，而<strong>令牌桶是定速地往桶里塞入令牌</strong>，然后请求只有拿到了令牌才能通过，之后再被服务器处理。<br>当然令牌桶的大小也是有限制的，假设桶里的令牌满了之后，定速生成的令牌会丢弃。</p><p>规则：</p><ul><li>定速的往桶内放入令牌</li><li>令牌数量超过桶的限制，丢弃</li><li>请求来了先向桶内索要令牌，索要成功则通过被处理，反之拒绝</li></ul><p><img src="/posts/29987/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95-%E4%BB%A4%E7%89%8C%E6%A1%B6-%E7%A4%BA%E4%BE%8B%E5%9B%BE.png"></p><p>看到这又想到啥？<strong>Semaphore信号量</strong>，信号量可控制某个资源被同时访问的个数，其实和咱们拿令牌思想一样，一个是拿信号量，一个是拿令牌。<br>只不过信号量用完了返还，而咱们令牌用了不归还，因为令牌会定时再填充。</p><p>应对突发流量的时候，桶内假如有 100 个令牌，那么这 100 个令牌可以马上被取走，而不像漏桶那样匀速的消费。<br>所以<strong>在应对突发流量的时候令牌桶表现的更佳</strong>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>拿<strong>令牌桶</strong>来说<ul><li>假设你没预热，那是不是上线时候桶里没令牌？没令牌请求过来不就直接拒了么？这就误杀了，明明系统没啥负载现在。</li><li>再比如说请求的访问其实是随机的，假设令牌桶每20ms放入一个令牌，桶内初始没令牌，这请求就刚好在第一个20ms内有两个请求，再过20ms里面没请求，其实从40ms来看只有2个请求，应该都放行的，而有一个请求就直接被拒了。</li><li>这就有可能造成很多请求的误杀，但是如果看监控曲线的话，好像流量很平滑，峰值也控制的很好。</li></ul></li><li>再拿<strong>漏桶</strong>来说，漏桶中请求是暂时存在桶内的，这其实<strong>不符合互联网业务低延迟的要求</strong>。</li></ul><h4 id="限流组件"><a href="#限流组件" class="headerlink" title="限流组件"></a>限流组件</h4><p>一般而言，我们不需要自己实现限流算法来达到限流的目的，不管是接入层限流还是细粒度的接口限流，都有现成的轮子使用，其实现也是用了上述我们所说的限流算法。</p><ul><li>Google Guava 提供的限流工具类 RateLimiter，是基于令牌桶实现的，并且扩展了算法，支持预热功能。</li><li>阿里开源的限流框架Sentinel 中的匀速排队限流策略，就采用了漏桶算法。</li><li>Nginx 中的限流模块 limit_req_zone，采用了漏桶算法。</li><li>OpenResty 中的 resty.limit.req库等等。</li></ul><h2 id="单机-amp-分布式"><a href="#单机-amp-分布式" class="headerlink" title="单机 &amp; 分布式"></a>单机 &amp; 分布式</h2><p>本质上单机限流和分布式限流的区别其实就在于 <strong>“阈值”</strong> 存放的位置。</p><p>单机限流就上面所说的算法直接在单台服务器上实现就好了，而往往我们的服务是集群部署的。<br>因此需要多台机器协同提供限流功能。</p><h3 id="单机限流"><a href="#单机限流" class="headerlink" title="单机限流"></a>单机限流</h3><p>应用级限流方式只是单应用内的请求限流，不能进行全局限流。</p><ul><li>限流总资源数</li><li>限流总并发/连接/请求数</li><li>限流某个接口的总并发/请求数</li><li>限流某个接口的时间窗请求数</li><li>平滑限流某个接口的请求数</li><li>Guava RateLimiter</li></ul><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>我们需要<strong>分布式限流</strong>和<strong>接入层限流</strong>来进行全局限流。</p><ul><li>redis+lua实现中的lua脚本</li><li>使用Nginx+Lua实现的Lua脚本</li><li>使用 OpenResty 开源的限流方案</li><li>限流框架，比如Sentinel实现降级限流熔断</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 架构 </category>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 限流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础-注解</title>
      <link href="/posts/6790.html"/>
      <url>/posts/6790.html</url>
      
        <content type="html"><![CDATA[<p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。<br>它是框架学习和设计者必须掌握的基础。</p><h2 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h2><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。</p><p>它主要的作用有以下四方面：</p><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><p>这么来说是比较抽象的，我们具体看下注解的常见分类：</p><ul><li><strong>Java自带的标准注解</strong><ul><li><code>@Override</code> 标明重写某个方法，表示当前的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code> 标明某个类或方法过时，表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li><li><code>@SuppressWarnings</code> 标明要忽略的警告，表示关闭编译器警告信息</li></ul></li><li><strong>元注解</strong><br>  元注解是用于定义注解的注解。<ul><li><code>@Retention</code> 用于标明注解被保留的阶段</li><li><code>@Target</code> 用于标明注解使用的范围</li><li><code>@Inherited</code> 用于标明注解可继承</li><li><code>@Documented</code> 用于标明是否生成javadoc文档</li></ul></li><li><strong>自定义注解</strong><br>  可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li></ul><h3 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h3><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解可以被用来<strong>修饰方法</strong>，并且它<strong>只在编译时有效</strong>，在编译后的class文件中便不再存在。<br>这个注解的作用就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。</p><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。<br>这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。<br>它的作用是告诉编译器忽略指定的警告信息。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：<code>@Target</code>，<code>@Retention</code>，<code>@Documented</code>，<code>@Inherited</code>, 在JDK 1.8中提供了两个元注解 <code>@Repeatable</code>和<code>@Native</code>。</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p><code>@Target</code>注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方）。</p><p><code>@Target</code>注解用来说明那些被它所注解的注解类可修饰的对象范围：<strong>packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）</strong>。<br>在定义注解类时使用<code>@Target</code>能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在<strong>ElementType</strong> 枚举中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    TYPE, <span class="comment">// 类、接口、枚举类</span></span><br><span class="line">    FIELD, <span class="comment">// 成员变量（包括：枚举常量）</span></span><br><span class="line">    METHOD, <span class="comment">// 成员方法</span></span><br><span class="line">    PARAMETER, <span class="comment">// 方法参数</span></span><br><span class="line">    CONSTRUCTOR, <span class="comment">// 构造方法</span></span><br><span class="line">    LOCAL_VARIABLE, <span class="comment">// 局部变量</span></span><br><span class="line">    ANNOTATION_TYPE, <span class="comment">// 注解类</span></span><br><span class="line">    PACKAGE, <span class="comment">// 可用于修饰：包</span></span><br><span class="line">    TYPE_PARAMETER, <span class="comment">// 类型参数，JDK 1.8 新增</span></span><br><span class="line">    TYPE_USE <span class="comment">// 使用类型的任何地方，JDK 1.8 新增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p><code>@Reteniton</code>注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时。</p><p>一共有三种策略，定义在<strong>RetentionPolicy</strong>枚举中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    SOURCE,    <span class="comment">// 源文件保留</span></span><br><span class="line">    CLASS,     <span class="comment">// 编译期保留，默认值</span></span><br><span class="line">    RUNTIME    <span class="comment">// 运行期保留，可通过反射去获取注解信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SourcePolicy &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ClassPolicy &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RuntimePolicy &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>用定义好的三个注解类分别去注解一个方法。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetentionTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SourcePolicy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sourcePolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ClassPolicy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RuntimePolicy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runtimePolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过执行<code>javap -verbose RetentionTest</code>命令获取到的 RetentionTest 的 class 字节码内容如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> retention.RetentionTest();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sourcePolicy</span><span class="params">()</span></span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">    stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classPolicy</span><span class="params">()</span></span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">    stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">    RuntimeInvisibleAnnotations:</span><br><span class="line">    <span class="number">0</span>: #<span class="number">11</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runtimePolicy</span><span class="params">()</span></span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">    stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">    <span class="number">0</span>: #<span class="number">14</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译器并没有记录下 <code>sourcePolicy()</code> 方法的注解信息；</li><li>编译器分别使用了 <code>RuntimeInvisibleAnnotations</code> 和 <code>RuntimeVisibleAnnotations</code> 属性去记录了<code>classPolicy()方法</code>和 <code>runtimePolicy()方法</code>的注解信息。</li></ul></li></ol><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p><code>@Documented</code>注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p><code>@Inherited</code>注解的作用：被它修饰的Annotation将具有继承性。<br>如果某个类使用了被@Inherited修饰的Annotation，则<strong>其子类</strong>将自动具有该注解。</p><h3 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h3><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><h2 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="深入理解注解"></a>深入理解注解</h2><p><strong>注解支持继承吗</strong><br>注解是不支持继承的。</p><p>不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承<strong>java.lang.annotation.Annotation</strong>接口。<br>虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p><p>区别于注解的继承，被注解的子类继承父类注解可以用@Inherited，如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p><p><strong>注解实现的原理</strong><br><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a><br><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务-服务调用-Dubbo</title>
      <link href="/posts/55099.html"/>
      <url>/posts/55099.html</url>
      
        <content type="html"><![CDATA[<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li><strong>让你设计一个RPC框架你怎么设计？</strong><br>RPC 框架基础的核心其实就这么几点：</li></ol><ul><li>动态代理(屏蔽底层调用细节)</li><li>序列化(网络数据传输需要扁平的数据)</li><li>协议(规定协议，才能识别数据)</li><li>网络传输(I/O模型BB一下，一般用 Netty 作为底层通信框架即可)</li></ul><ol start="2"><li>Dubbo 是用来做什么的？内部的大概原理能讲一下吗？</li><li>Dubbo 的提供者核心源码和原理：服务提供者是如何将自己的服务暴露出去的，然后消费者为什么能调用？</li><li>Dubbo 的消费者核心源码和原理：服务消费者是如何仅仅通过一个接口类直接调用到提供者的，并且做到失败重试、负载均衡的？</li><li>Netty：Dubbo 是使用 Netty 作为通信框架，那么使用 Netty 有什么好处？</li><li>编解码器如何处理粘包和拆包，如何解决 TCP 网络传输中的拆包和粘包？</li></ol><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p><img src="/posts/55099/dubbo-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p><p>结合上图说下Dubbo的基本工作流程，主要分为四步：</p><ol><li>Provider向注册中心注册服务信息，包括Provider的IP和端口；</li><li>Consumer从注册中心订阅提供者服务；</li><li>Consumer通过服务URL调用Provider；</li><li>Consumer和Provider异步上报统计信息给监控中心。</li></ol><h3 id="四大角色"><a href="#四大角色" class="headerlink" title="四大角色"></a>四大角色</h3><p>工作流程所设计的四大模块分别是：</p><ol><li>注册中心Registry</li><li>服务提供者Provider</li><li>服务消费者Consumer</li><li>监控中心Monitor</li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 服务调用 </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务-服务调用-OpenFeign</title>
      <link href="/posts/54592.html"/>
      <url>/posts/54592.html</url>
      
        <content type="html"><![CDATA[<p><code>OpenFeign</code>在分布式服务中运用非常广泛，它和<code>RPC</code>所要达到的效果一致，就是为了简化远程服务调用的操作，通过使用<code>OpenFeign</code>可以使得调用远程服务就像调用本地服务一样方便。</p><p>但是其和<strong>RPC</strong>在实现上还是不太一样，不一样的地方主要还是调用的方式。<br><strong>OpenFeign</strong>是内部实现了<strong>Rest服务调用</strong>，从而一个本地服务调用远程服务的接口时，主要还是通过Rest服务调用的方式，那么对于服务端的要求就是其服务需要将这个接口通过rest暴露出来，不然OpenFeign将无法工作；<br>而<strong>RPC</strong>则不需要服务端将该接口以rest服务的形式暴露出来，而是直接通过<strong>底层netty进行通信</strong>来互相沟通的。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>远程过程调用（Remote Procedure Call Protocol，简称RPC）。</p><p>RPC 框架说白了就是让你可以像调用本地方法一样调用远程服务提供的方法，而不需要关心底层的通信细节。简单地说就让远程服务调用更加简单、透明。<br>一个RPC框架大致需要<strong>动态代理、序列化、网络请求、网络请求接受(netty实现)、动态加载、反射</strong>这些知识点。<br>现在开源及各公司自己造的RPC框架层出不穷，唯有掌握原理是一劳永逸的。</p><p>业界主流的 RPC 框架整体上分为三类：</p><ol><li>支持多语言的 RPC 框架，比较成熟的有 Google 的 gRPC、Apache（Facebook）的 Thrift；</li><li>只支持特定语言的 RPC 框架，例如新浪微博的 Motan；</li><li>支持服务治理等服务化特性的分布式服务框架，其底层内核仍然是 RPC 框架, 例如阿里的 Dubbo。</li></ol><h3 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h3><p>具象状态传输（Representational State Transfer, REST）。</p><p>REST 不是一种协议，它是一种架构。大部分REST的实现中使用了RPC的机制，大致由三部分组成：</p><ol><li>method：动词（get、post之类的）</li><li>Host：URI（统一资源标识），服务器，端口</li><li>Path：名词（路径，服务器里面的某个东西）路径的结尾是资源的形态（如html、text、image、pdf等）</li></ol><p>即，对 host 里面的某个 Path 里面的东西做一些 get 或 post 操作。<br>传输层基于HTTP，相比于TCP，多了一层协议。</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是Netflix公司（第一代SpringCloud）研发的一个轻量级RESTful的伪HTTP服务客户端。<br>Feign内置了Ribbon逻辑，通过负载均衡算法可以从注册中心中寻找服务。<br>Feign 是 Netflix 公司产品，已经停止更新了。</p><p>Feign只是对HTTP调用组件进行了易用性封装，底层还是使用我们常见的OkHttp、HttpClient等组件（我们不生产水，我们只是水的搬运工）<br><img src="/posts/54592/feign-%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%9D%97%E7%9B%AE%E5%BD%95.png"></p><p>Feign的目标之一就让这些HTTP客户端更好用，使用方式更统一（这和Spring出现的目的如出一辙），更像RPC。</p><h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p><img src="/posts/54592/feign-%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.jpeg"></p><h3 id="客户端组件-feign-Client"><a href="#客户端组件-feign-Client" class="headerlink" title="客户端组件 feign.Client"></a>客户端组件 feign.Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> feign;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> feign.Request.Options;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**客户端接口</span></span><br><span class="line"><span class="comment"> * Submits HTTP &#123;<span class="doctag">@link</span> Request requests&#125;. </span></span><br><span class="line"><span class="comment"> * Implementations are expected to be thread-safe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="comment">//提交HTTP请求，并且接收response响应后进行解码</span></span><br><span class="line">  <span class="function">Response <span class="title">execute</span><span class="params">(Request request, Options options)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于不同的feign.Client 实现类，内部完成HTTP请求的组件和技术不同，故，feign.Client 有多个不同的实现。<br><img src="/posts/54592/feign-client-%E5%AE%9E%E7%8E%B0%E7%B1%BB.png"></p><ul><li>Client.Default类<br>  默认的feign.Client 客户端实现类，内部使用HttpURLConnnection 完成URL请求处理；</li><li>ApacheHttpClient类<br>  内部使用 Apache httpclient 开源组件完成URL请求处理的feign.Client 客户端实现类；</li><li>OkHttpClient类<br>  内部使用 OkHttp3 开源组件完成URL请求处理的feign.Client 客户端实现类。</li><li>LoadBalancerFeignClient类<br>  内部使用 Ribben 负载均衡技术完成URL请求处理的feign.Client 客户端实现类。</li></ul><h4 id="Java中常用http客户端"><a href="#Java中常用http客户端" class="headerlink" title="Java中常用http客户端"></a>Java中常用http客户端</h4><ul><li>JDK原生HttpClient<br>  原生HttpClient是在Java 9中作为孵化模块引入的，然后在Java11中作为JEP 321的一部分正式可用，<strong>HTTPClient</strong>取代了JDK更早期的<strong>HttpUrlConnection</strong>类。<ul><li>使用 HttpURLConnection 发起 HTTP 请求最大的优点是不需要引入额外的依赖，但是使用起来非常繁琐，也缺乏连接池管理、域名机械控制等特性支持。</li><li>在 Java 9 中，官方在标准库中引入了一个 high level、支持 HTTP/2 的 HttpClient</li></ul></li><li>Apache HttpComponents项目中的HttpClient<br>  Apache HttpClient带有连接池的功能，具备优秀的HTTP连接的复用能力。</li><li>OkHttpClient<br>  使用OkHttp3 开源组件完成URL请求处理，OkHttp3 开源组件由Square公司开发。</li><li>Spring Boot中的WebClient</li></ul><h2 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h2><p>Feign的第一个目标是减少HTTP API的复杂性，<strong>希望能将HTTP调用做到像RPC一样易用</strong>。而<a href="https://github.com/spring-cloud/spring-cloud-openfeign">Spring Cloud OpenFeign</a>将其和Spring Cloud体系打通，让Feign更加方便的在Spring Cloud中使用。</p><p>OpenFeign是SpringCloud自己研发的，在Feign的基础上做了增强。<br>OpenFeign除了原有Ribbon逻辑外，还支持了Hystrix和Spring MVC注解。</p><p>OpenFeign 是SpringCloud在Feign的基础上支持了SpringMVC的注解，如@RequestMapping等。<br>OpenFeign 的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过JDK动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p><h3 id="问题探究"><a href="#问题探究" class="headerlink" title="问题探究"></a>问题探究</h3><h4 id="1-FeignClient-如何根据接口生成实现（代理）类的？"><a href="#1-FeignClient-如何根据接口生成实现（代理）类的？" class="headerlink" title="1. @FeignClient 如何根据接口生成实现（代理）类的？"></a>1. @FeignClient 如何根据接口生成实现（代理）类的？</h4><p>Feign使用必须要有接口，满足JDK动态代理的使用条件，所以Feign使用的就是JDK自带的动态代理技术。</p><p>Feign接口的每个方法有 <strong>@RequestMapping</strong> ，意味着这些方法可以映射到不同的远端HTTP路径，所以给整个Feign接口做代理时，代理类的方法必须知道对应到哪个远端HTTP路径，虽然我们可以在 <strong>java.lang.reflect.InvocationHandler#invoke</strong> 的方法入参 Method 中去解析 @RequestMapping 拿url（<strong>注意，大多数开源框架很忌讳在运行时高频使用JDK的反射，这样影响执行效率，Dubbo的Provider端也不是用反射来调用本地方法的</strong>），所以<strong>在Feign使用JDK动态代理技术时，需要提前将接口带 @RequestMapping 方法解析出来</strong>。<br>为了探究这块的具体实现，我们移步原生Feign的feign-core包的核心类<a href="https://kgithub.com/OpenFeign/feign/blob/master/core/src/main/java/feign/ReflectiveFeign.java">ReflectiveFeign</a>。</p><p>ReflectiveFeign借助于JDK动态代理，根据我们的业务接口生成对应的代理类，这个代理类会根据调用的方法来直接找到对应已经提前准备好的 MethodHandler，直接调用即可完成Feign的使命，根据上面的使用方法，我们不难猜到 MethodHandler 里面有HTTP调用的相关信息（这些信息之前是在接口方法定义的 @RequestMapping 或 @RequestLine 之中），而且<strong>MethodHandler#invoke会完成真正的HTTP调用并将结果反序列化成原接口方法的返回值对象</strong>。</p><h4 id="2-生成的实现（代理）类是如何适配各种HTTP组件的？"><a href="#2-生成的实现（代理）类是如何适配各种HTTP组件的？" class="headerlink" title="2. 生成的实现（代理）类是如何适配各种HTTP组件的？"></a>2. 生成的实现（代理）类是如何适配各种HTTP组件的？</h4><p>这个问题应该由Feign来回答，而不是Spring Cloud OpenFeign，Feign的<strong>feign-core模块</strong>中有一个<strong>Client接口</strong>，<strong>专门用来给各个HTTP组件提供接入接口</strong>。</p><p>和<strong>Slf4j适配各种日志组件</strong>的方案类似——<a href="https://blog.csdn.net/manzhizhen/article/details/90736101">SLF4J漫谈</a></p><h4 id="3-生成的实现（代理）类如何实现HTTP请求应答序列化和反序列化的？"><a href="#3-生成的实现（代理）类如何实现HTTP请求应答序列化和反序列化的？" class="headerlink" title="3. 生成的实现（代理）类如何实现HTTP请求应答序列化和反序列化的？"></a>3. 生成的实现（代理）类如何实现HTTP请求应答序列化和反序列化的？</h4><ul><li>原生的Feign<br>  原生的Feign允许添加额外的解码器，官方给出了Consumer的例子：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里假定ProviderDemoService中有一个返回MyResponse的方法</span></span><br><span class="line">    MyResponse response = Feign.builder()</span><br><span class="line">                    .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                    .client(<span class="keyword">new</span> OkHttpClient())</span><br><span class="line">                    .target(ProviderDemoService.class, <span class="string">&quot;https://xxxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  为了能做到这一点，原生Feign提供了 Decoder 和 Encoder 两个接口（本文只重点关注解码部分）：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Decoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decodes an http response into an object corresponding to its</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.lang.reflect.Method#getGenericReturnType() generic return type&#125;. If you need to</span></span><br><span class="line"><span class="comment">     * wrap exceptions, please do so via &#123;<span class="doctag">@link</span> DecodeException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response the response to decode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type &#123;<span class="doctag">@link</span> java.lang.reflect.Method#getGenericReturnType() generic return type&#125; of the</span></span><br><span class="line"><span class="comment">     *        method corresponding to this &#123;<span class="doctag">@code</span> response&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> instance of &#123;<span class="doctag">@code</span> type&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException will be propagated safely to the caller.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> DecodeException when decoding failed due to a checked exception besides IOException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FeignException when decoding succeeds, but conveys the operation failed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">decode</span><span class="params">(Response response, Type type)</span> <span class="keyword">throws</span> IOException, DecodeException, FeignException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Converts objects to an appropriate representation in the template.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object what to encode as the request body.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bodyType the type the object should be encoded as. &#123;<span class="doctag">@link</span> #MAP_STRING_WILDCARD&#125;</span></span><br><span class="line"><span class="comment">     *        indicates form encoding.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> template the request template to populate.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> EncodeException when encoding failed due to a checked exception.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Object object, Type bodyType, RequestTemplate template)</span> <span class="keyword">throws</span> EncodeException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Spring Cloud OpenFeign<br>  换成Spring Cloud OpenFeign的话，就得和Spring的Web体系打通了，这里就不得不提一个构造类即 <strong>FeignClientsConfiguration</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：为了演示方便，对其进行了代码裁剪</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">// 这里将Spring Web的消息转换器机制注入进来</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="comment">// 构造解码Decoder的Spring Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Decoder <span class="title">feignDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的SpringDecoder实现了Feign的Decoder接口，并且将Spring Web的消息转换器设置到SpringDecoder来使用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptionalDecoder(<span class="keyword">new</span> ResponseEntityDecoder(<span class="keyword">new</span> SpringDecoder(<span class="keyword">this</span>.messageConverters)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="comment">// 构造编码Encoder的Spring Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Encoder <span class="title">feignEncoder</span><span class="params">(ObjectProvider&lt;AbstractFormWriter&gt; formWriterProvider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> springEncoder(formWriterProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Encoder <span class="title">springEncoder</span><span class="params">(ObjectProvider&lt;AbstractFormWriter&gt; formWriterProvider)</span> </span>&#123;</span><br><span class="line">        AbstractFormWriter formWriter = formWriterProvider.getIfAvailable();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (formWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SpringEncoder(<span class="keyword">new</span> SpringPojoFormEncoder(formWriter), <span class="keyword">this</span>.messageConverters);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SpringEncoder(<span class="keyword">new</span> SpringFormEncoder(), <span class="keyword">this</span>.messageConverters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-生成的实现（代理）类是如何注入到Spring容器中的？"><a href="#4-生成的实现（代理）类是如何注入到Spring容器中的？" class="headerlink" title="4. 生成的实现（代理）类是如何注入到Spring容器中的？"></a>4. 生成的实现（代理）类是如何注入到Spring容器中的？</h4><p><strong>Spring Cloud OpenFeign</strong>如何将动态生成的代理类和Spring容器打通？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line"><span class="comment">// 注解内容省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是<code>@EnableFeignClients</code>的 <code>@Import</code> 提前加载Spring Bean的方式，触发了 <strong>FeignClientRegistrar</strong> 的初始化。<br>FeignClientRegistrar 由于实现了 ImportBeanDefinitionRegistrar 接口，我们知道在处理@Configuration类时可以通过Import注册其他Spring Bean定义的能力，而还不知道哪些接口使用了 @FeignClient，所以在 FeignClientRegistrar 需要做的就是扫描某些路径（该路径由配置Spring扫描路径包括@EnableFeignClients中配置的路径）的接口类，识别对应的 @FeignClient，给这些接口类创建代理对象。而为了把这些代理对象注入到Spring 容器中，所以还得借助 <strong>FactoryBean</strong> 的能力。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 服务调用 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生-Istio</title>
      <link href="/posts/18398.html"/>
      <url>/posts/18398.html</url>
      
        <content type="html"><![CDATA[<h2 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h2><p><a href="https://www.redhat.com/zh/topics/microservices/what-is-a-service-mesh">https://www.redhat.com/zh/topics/microservices/what-is-a-service-mesh</a></p><p>服务网格（例如开源项目 Istio）用于控制应用的不同部分之间如何共享数据。</p><h3 id="微服务与服务网格"><a href="#微服务与服务网格" class="headerlink" title="微服务与服务网格"></a>微服务与服务网格</h3><p><img src="/posts/18398/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-%E5%BE%AE%E6%9C%8D%E5%8A%A1.png"></p><h3 id="服务网格是如何运作的？"><a href="#服务网格是如何运作的？" class="headerlink" title="服务网格是如何运作的？"></a>服务网格是如何运作的？</h3><p>服务网格不会为应用的运行时环境加入新功能，任何架构中的应用还是需要相应的规则来指定请求如何从 A 点到达 B 点。但服务网格的不同之处在于，它从各个服务中提取逻辑管理的服务间通信，并将其抽象为一个基础架构层。</p><p>要这样做，服务网格会以<strong>网络代理阵列的形式</strong>内置到应用中。</p><p>在服务网格中，请求将通过所在基础架构层中的代理在微服务之间路由。正因如此，构成服务网格的各个代理有时也被称为”sidecar”（挎斗/边车），这是因为它们与每个服务并行运行，而非在内部运行。总之，这些”sidecar”代理（与每项服务分离）构成了网格式网络。<br><img src="/posts/18398/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-sidecar.png" alt="sidecar"></p><p>sidecar 代理与微服务并肩协作，用于将请求路由给其他代理。这些 sidecar 共同构成了网格式网络。<br><img src="/posts/18398/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-%E7%BD%91%E6%A0%BC%E5%BC%8F%E6%9E%B6%E6%9E%84.png"></p><h2 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h2><p>Istio 是一个开源服务网格平台，它可以控制微服务之间数据的共享方式。其附带的 API 可以将 Istio 集成到任何日志记录平台、遥测或策略系统中。在设计上，Istio 可以在多种环境中运行：企业本地、云托管、Kubernetes容器，或虚拟机上运行的服务等。</p><p>Istio 的架构分为数据平面和控制平面两部分。<br>在<strong>数据平面</strong>中，通过在环境中部署 sidecar 代理，即可为服务添加 Istio 支持。该 sidecar 代理与微服务并存，用于将请求路由给其他代理，或从其他代理那路由请求。这些代理共同构成了一个网格网络，可拦截微服务之间的网络通信。<br><strong>控制平面</strong>则负责管理和配置代理来路由流量。此外，控制平面还可配置组件，以实施相关策略并收集遥测数据。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生-Knative</title>
      <link href="/posts/14900.html"/>
      <url>/posts/14900.html</url>
      
        <content type="html"><![CDATA[<h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p><a href="https://murphy.blog.csdn.net/article/details/127846026">https://murphy.blog.csdn.net/article/details/127846026</a></p><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><h2 id="Knative"><a href="#Knative" class="headerlink" title="Knative"></a>Knative</h2><p>Knative 是谷歌牵头发起的 Serverless 项目。<br>其目标是基于 Kubernetes 的 Serverless 解决方案，旨在标准化 Serverless，简化其学习成本。</p><p>Knative 是以 Kubernetes 的一组自定义资源类型（CRD）的方式来安装的，因此只需使用几个 YAML 文件就可以轻松地开始使用 Knative 了。<br>这也意味着，在本地或者托管云服务上，任何可以运行 Kubernetes 的地方都可以运行 Knative 和代码。</p><p><img src="/posts/14900/knative-%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png"></p><h3 id="Knative的定位"><a href="#Knative的定位" class="headerlink" title="Knative的定位"></a>Knative的定位</h3><p><img src="/posts/14900/knative-%E5%AE%9A%E4%BD%8D.png"></p><p>Knative构建在<strong>Kubernetes、Istio、Container</strong>的基础上，以<strong>K8S的CRD</strong>形式存在。</p><ul><li>基础设施：<strong>Kubernetes作为基础设施</strong>进行容器编排，解决应用编排和运行环境</li><li>通信设施：<strong>Isito作为通信基础设施层</strong>，保证服务的运行可检测、可配置、可追踪</li><li>模板+环境：<strong>Knative</strong>使用应用模板和统一的运行环境来标准化服务的构建、部署和管理</li></ul><p>Knative 解决了现在Serverless 的诸多问题。<br>如果kubernetes是容器编排的事实上的标准，那么Knative也许就是未来serverless的事实上的标准。</p><p>Knative的优势：</p><ul><li>便利性：Knative 以 Kubernetes 作为其底层框架，因此无论是线上还是线下，任何 Kubernetes 集群，无论是云上 Kubernetes 服务还是自建 Kubernetes 集群，都可通过安装 knative 插件快速的搭建 serverless 平台。</li><li><strong>标准化</strong>：Knative 联合 CNCF，<strong>把所有事件标准化，统一为 CloudEvent</strong>，提供事件的跨平台，同时让函数和具体的调用方能够解耦。</li><li>服务间解耦：使用 Knative 使得应用不在与底层依赖服务强绑定，可以跨云实现业务互通。</li><li>成熟的生态：Knative 基于 Kubernetes 体系构建，与 kubernetes 生态结合更紧密。</li><li>自动伸缩：监控应用的请求，并自动扩缩容, 借助于istio(ambassador,gloo等)天生支持蓝绿发布、回滚功能，方便应用发布流程。</li><li>应用监控：支持日志的收集、查找和分析，并支持 VAmetrics 数据展示、调用关系 tracing。</li></ul><h3 id="Knative的组成"><a href="#Knative的组成" class="headerlink" title="Knative的组成"></a>Knative的组成</h3><p>为了实现 serverless 应用的管理，knative 把整个系统分成了三个部分：</p><ul><li><strong>Build：构建模块</strong>，把用户定义的函数和应用 build 成容器镜像，提供云原生“从源代码到容器”的镜像构建能力。</li><li><strong>Serving：服务模块</strong>，用来配置应用的路由、升级策略、自动扩缩容等功能，通过 Serving 部署容器并提供通用的服务模型。</li><li><strong>Eventing：事件模块</strong>，用来自动完成事件的绑定和触发，提供事件全局订阅、传递和管理能力，实现事件驱动。</li></ul><h4 id="Build-构建模块"><a href="#Build-构建模块" class="headerlink" title="Build 构建模块"></a>Build 构建模块</h4><h4 id="Serving-服务模块"><a href="#Serving-服务模块" class="headerlink" title="Serving 服务模块"></a>Serving 服务模块</h4><p>基于负载自动伸缩，包括在没有负载时缩减到零。<br>允许为多个修订版本（revision）应用创建流量策略，从而能够通过 URL 轻松路由到目标应用程序。</p><p>knative serving 功能是<strong>基于 kubernetes 和 istio 开发</strong>的。可以认为 knative 提供了更高的抽象，自动封装掉了 kubernetes 和 istio 的实现细节。</p><ul><li>kubernetes 来管理容器（deployment、pod）</li><li>istio 来管理网络路由（VirtualService、DestinationRule）</li></ul><p>serving 的核心功能是<strong>让应用运行起来提供服务</strong>。<br>虽然听起来很简单，但包括了很多的事情：</p><ul><li>自动化启动和销毁容器</li><li>根据名字生成网络访问相关的 service、ingress 等对象</li><li>监控应用的请求，并自动扩缩容</li><li>支持蓝绿发布、回滚功能，方便应用方法流程</li></ul><h4 id="Eventing-事件模块"><a href="#Eventing-事件模块" class="headerlink" title="Eventing 事件模块"></a>Eventing 事件模块</h4><p>使得生产和消费事件变得容易。<br>抽象出事件源，并允许操作人员使用自己选择的消息传递层。</p><p>serverless 最重要的是<strong>基于事件的触发机制</strong>，也就是说当某件事发生时，就触发某个特定的函数。</p><p>事件概念的出现，让函数和具体的调用方能够解耦。<br>函数部署出来不用关心谁会调用它，而事件源触发也不用关心谁会处理它。</p><p>为了让整个事件系统更有扩展性和通用性，knative 定义了很多事件相关的概念。简单介绍一下：</p><ul><li>EventSource：<strong>事件源</strong>，能够产生事件的外部系统。</li><li>Feed：把某种类型的 EventType 和 EventSource 和对应的 Channel 绑定到一起。</li><li>Channel：<strong>对消息实现的一层抽象</strong>，后端可以使用 kafka、RabbitMQ、Google PubSub 作为具体的实现。</li><li>Subscription：<strong>把 channel 和后端的函数绑定到一起</strong>，一个 channel 可以绑定到多个knative service。</li></ul><p><a href="https://skyao.io/learning-knative/introduction/motivation.html">https://skyao.io/learning-knative/introduction/motivation.html</a><br><a href="https://www.bookstack.cn/read/getting-started-with-knative/eventing.md">https://www.bookstack.cn/read/getting-started-with-knative/eventing.md</a></p><h2 id="Knative-Eventing"><a href="#Knative-Eventing" class="headerlink" title="Knative - Eventing"></a>Knative - Eventing</h2><p>Kubernetes 用户在实现开发和部署阶段服务之间松耦合的同时，服务间常要通过不同的事件机制来进行事件传递，<strong>为了解决大部分的云原生消息通信需求</strong>，Knative 提供了 Eventing 组件。</p><p><img src="/posts/14900/knative-eventing-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>Eventing 主要由<strong>事件源（Event Source）</strong>、<strong>事件处理（Flow）</strong>、<strong>事件消费者（Event Consumer）</strong>三部分构成。</p><ul><li>事件源 Event Source</li><li>事件处理 Flow<ul><li>Source to Service，直接事件接收<br>通过事件源直接转发到单一事件消费者。支持直接调用 Knative Service 或者 Kubernetes Service 进行消费处理。这样的场景下，如果调用的服务不可用，事件源负责重试机制处理。</li><li>Channels &amp; Subscriptions，通过事件通道(Channel)以及事件订阅(Subscriptions)转发事件处理<br>这样的情况下，可以通过 Channel 保证事件不丢失并进行缓冲处理，通过 Subscriptions 订阅事件以满足多个消费端处理。</li><li>Brokers &amp; Triggers，通过 brokers 和 triggers 支持事件消费及过滤机制<br>从 v0.5 开始，Knative Eventing 定义 Broker 和 Trigger 对象，实现了对事件进行过滤（亦如通过 ingress 和 ingress controller 对网络流量的过滤一样）。<br>通过定义 Broker 创建 Channel，通过 Trigger 创建 Channel 的订阅（subscription），并产生事件过滤规则。</li></ul></li><li>事件消费者 Event Consumer</li></ul><h3 id="Event-Source"><a href="#Event-Source" class="headerlink" title="Event Source"></a>Event Source</h3><p>事件源是 Kubernetes 自定义资源，它提供了一种机制用于注册特定软件系统对某一类事件的兴趣。</p><h3 id="Event-Registry"><a href="#Event-Registry" class="headerlink" title="Event Registry"></a>Event Registry</h3><p>Event Registry 维护着一个事件类型目录，这些事件可以从不同Broker中消费。<br>Event Registry 引入了一个新的 EventType CRD，以便将事件类型的信息持久化在集群的数据存储中。</p><p><strong>利用Registry发现事件</strong>：使用Registry，可以发现能够从Broker的事件网格中消费的不同类型的事件。该Registry是为与Broker/Trigger模型一起使用而设计的，旨在帮助创建Triggers。</p><h3 id="Broker-amp-Trigger"><a href="#Broker-amp-Trigger" class="headerlink" title="Broker &amp; Trigger"></a>Broker &amp; Trigger</h3><ul><li>Broker<br><img src="/posts/14900/knative-eventing-broker.png"><br>Broker代表了 “Event Mesh”。事件被发送到Broker的入口（Ingress），然后被发送到对该事件感兴趣的任何订阅者。一旦进入Broker，除CloudEvent之外的所有元数据都会被剥离（例如，除非设置为CloudEvent属性，否则没有该事件如何进入Broker的概念）。</li><li>Trigger<br>Trigger 代表了从特定的Broker订阅事件的愿望。</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channels是Kubernetes Custom Resources(k8s自定义资源)，它定义了一个单一的事件转发和持久层。<br>消息实现可以通过Kubernetes Custom Resource提供Channel的实现，支持不同的技术，如Apache Kafka或NATS Streaming。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
            <tag> Knative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-IOC-实现原理详解-2-Bean实例化</title>
      <link href="/posts/7396.html"/>
      <url>/posts/7396.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/posts/7396/ioc%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE-bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png"></p><p>本文主要研究如何从IOC容器已有的BeanDefinition信息，实例化出Bean对象。<br>这里还会包括三块重点内容：</p><ol><li>BeanFactory中getBean的主体思路</li><li>Spring如何解决循环依赖问题</li><li>Spring中Bean的生命周期</li></ol><h2 id="一、BeanFactory中getBean的主体思路"><a href="#一、BeanFactory中getBean的主体思路" class="headerlink" title="一、BeanFactory中getBean的主体思路"></a>一、BeanFactory中getBean的主体思路</h2><p>我们知道BeanFactory定义了Bean容器的规范，其中包含根据bean的名字、Class类型和参数等来得到bean实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据bean的名字和Class类型等来得到bean实例    </span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;    </span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Class requiredType)</span> <span class="keyword">throws</span> BeansException</span>;    </span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure><h3 id="研究源码之前的初步思考"><a href="#研究源码之前的初步思考" class="headerlink" title="研究源码之前的初步思考"></a>研究源码之前的初步思考</h3><p>了解过<strong>IoC容器初始化</strong>的流程，<strong>最终将Bean的定义即BeanDefinition放到beanDefinitionMap中</strong>，本质上是一个<code>ConcurrentHashMap&lt;String, Object&gt;</code>，并且BeanDefinition接口中包含了这个类的Class信息以及是否是单例等。<br><img src="/posts/7396/getBean-BeanDefinition.png" alt="BeanDefinition属性"></p><p>这样我们初步有了实现<code>Object getBean(String name)</code>这个方法的思路：</p><ol><li>从<strong>beanDefinitionMap</strong>通过<strong>beanName</strong>获得<strong>BeanDefinition</strong></li><li>从<strong>BeanDefinition</strong>中获得<strong>beanClassName</strong></li><li>通过<strong>反射</strong>初始化beanClassName的实例instance<ul><li><strong>构造函数</strong>从<strong>BeanDefinition</strong>的**getConstructorArgumentValues()**方法获取</li><li><strong>属性值</strong>从<strong>BeanDefinition</strong>的**getPropertyValues()**方法获取</li></ul></li><li>返回beanName的实例instance</li><li>由于BeanDefinition还有单例的信息，如果是无参构造函数的实例还可以放在一个<strong>缓存</strong>中，这样下次获取这个单例的实例时只需要从缓存中获取，如果获取不到再通过上述步骤获取。</li></ol><p>（PS：如上只是我们初步的思路，而Spring还需要考虑各种设计上的问题，比如beanDefinition中其它定义，循环依赖等；所以来看下Spring是如何是如何实现的）</p><h3 id="Spring中getBean的主体思路"><a href="#Spring中getBean的主体思路" class="headerlink" title="Spring中getBean的主体思路"></a>Spring中getBean的主体思路</h3><p><strong>BeanFactory</strong>实现<strong>getBean</strong>方法在<strong>AbstractBeanFactory</strong>中，这个方法重载都是调用<strong>doGetBean</strong>方法进行实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本：spring-beans-5.2.9-RELEASE</span></span><br><span class="line"><span class="comment">// AbstractBeanFactory#doGetBean</span></span><br><span class="line"><span class="comment">// 参数typeCheckOnly：bean实例是否包含一个类型检查</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理别名BeanName、处理带&amp;符的工厂BeanName</span></span><br><span class="line"><span class="comment">// 解析bean的真正name，如果bean是工厂类，name前缀会加&amp;，需要去掉</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从单例缓存中获取对象</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="comment">// 一、单例缓存中有 &amp;&amp; 为无参单例args == null</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="comment">// 如果单例bean的实例正在创建中，则直接抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果 sharedInstance 是普通的 Bean 实例，则下面的方法会直接返回</span></span><br><span class="line"><span class="comment">// 2. 如果 sharedInstance 是 FactoryBean 类型，则需要获取 getObject 方法，可以参考关于 FactoryBean 的实现类 </span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二、单例缓存中没有</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 循环依赖有三种，setter注入、多实例和构造函数</span></span><br><span class="line"><span class="comment">// Spring 只能解决 setter 注入，所以这里是 Prototype 则会抛出异常</span></span><br><span class="line"><span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="comment">// 【父 bean 工厂存在 &amp;&amp; bean 不存在于当前bean工厂】，则委派给父Bean工厂获取</span></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line"><span class="comment">// 获取 name 对应的 beanName，如果 name 是以 &amp; 开头，则返回 &amp; + beanName</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeCheckOnly，用于判断调用 getBean 方法时，是否仅是做类型检查</span></span><br><span class="line"><span class="comment">// 如果不是只做类型检查，就会调用 markBeanAsCreated 进行记录</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"><span class="comment">// 将当前bean实例放入alreadyCreated集合里，标识这个bean准备创建了</span></span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 这里通过beanName获取相关信息来组装RootBeanDefinition</span></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// 检查当前创建的 bean 定义是否为抽象 bean 定义</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前Bean的依赖项</span></span><br><span class="line"><span class="comment">// 在实例化自己之前，需要先实例化自己依赖的bean</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="comment">// 监测是否存在 depends-on 循环依赖，若存在则会抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册依赖记录</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加载 depends-on 依赖（dep 是 depends-on 缩写）</span></span><br><span class="line"><span class="comment">// 初始化当前bean依赖的bean</span></span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处开始创建实例对象</span></span><br><span class="line"><span class="comment">// 1、创建Bean实例：单例</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 把 beanName 和 new ObjectFactory 匿名内部类传入回调</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 真正创建bean的方法</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line"><span class="comment">// 创建失败则销毁</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、创建Bean实例：原型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3、创建Bean实例：根据bean的scope创建</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line"><span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"><span class="comment">// 如果需要类型转换，这里会进行操作</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line"><span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> convertedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很长，主体逻辑如下：</p><ul><li>解析bean的真正name，如果bean是工厂类，name前缀会加&amp;，需要去掉</li><li>先从<strong>单例缓存</strong>中尝试获取<code>getSingleton(beanName)</code><ul><li>如果单例缓存中有 &amp;&amp; <code>args == null</code>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果bean单例正在创建中，打印日志</li><li>bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</li></ul></li><li>如果单例缓存中没有：<ul><li>如果bean实例正在创建中，则直接抛出异常  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果bean definition 不存在于当前bean工厂中，则委派给父Bean工厂获取</li><li>标记这个beanName的实例正在创建</li><li>确保它的依赖也被初始化</li><li>真正创建 <ol><li>单例时</li><li>原型时</li><li>根据bean的scope创建</li></ol></li></ul></li></ul></li></ul><h2 id="二、Spring如何解决循环依赖问题"><a href="#二、Spring如何解决循环依赖问题" class="headerlink" title="二、Spring如何解决循环依赖问题"></a>二、Spring如何解决循环依赖问题</h2><p>首先需要说明：</p><ol><li>Spring只是解决了<strong>单例模式</strong>下<strong>setter注入</strong>的循环依赖问题；</li><li>Spring为了解决单例的循环依赖问题，使用了<strong>三级缓存</strong>。</li></ol><h3 id="Spring单例模式下的setter注入和三级缓存"><a href="#Spring单例模式下的setter注入和三级缓存" class="headerlink" title="Spring单例模式下的setter注入和三级缓存"></a>Spring单例模式下的setter注入和三级缓存</h3><p>先来看下这三级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>第一层缓存（singletonObjects）</strong>：单例对象缓存池，已经实例化并且属性赋值，这里的对象是<strong>成熟对象</strong>；</li><li><strong>第二层缓存（earlySingletonObjects）</strong>：单例对象缓存池，已经实例化但尚未属性赋值，这里的对象是<strong>半成品对象</strong>；</li><li><strong>第三层缓存（singletonFactories）</strong>: 单例工厂的缓存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSingletonBeanRegistry#getSingleton</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">    <span class="comment">// 1. Spring首先从singletonObjects（一级缓存）中尝试获取</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 2. 若是获取不到 &amp;&amp; 对象在建立中，则尝试从earlySingletonObjects(二级缓存)中获取</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 3. 若是二级缓存获取不到 &amp;&amp; 【allowEarlyReference=true 允许从singletonFactories经过getObject获取】</span></span><br><span class="line">        <span class="comment">//    则经过singletonFactory.getObject()(三级缓存)获取</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            singletonObject = singletonFactory.getObject();</span><br><span class="line">                            <span class="comment">// 经过singletonFactory.getObject()(三级缓存)获取到了</span></span><br><span class="line">                            <span class="comment">// 则将singletonObject放入到earlySingletonObjects，也就是将三级缓存提高到二级缓存中</span></span><br><span class="line">                            <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                            <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>allowEarlyReference</strong><br>  是否容许从<strong>singletonFactories</strong>中经过getObject拿到对象</li><li>isSingletonCurrentlyInCreation()<br>  判断当前单例bean是否正在建立中，也就是没有初始化完成。<br>  (好比A的构造器依赖了B对象因此得先去建立B对象， 或则在A的populateBean过程当中依赖了B对象，得先去建立B对象，这时的A就是处于建立中的状态。)</li></ul><p>分析<strong>getSingleton()<strong>的整个过程，Spring首先从</strong>一级缓存singletonObjects</strong>中获取。若是获取不到，而且对象正在建立中，就再从<strong>二级缓存earlySingletonObjects</strong>中获取。若是仍是获取不到且容许singletonFactories经过getObject()获取，就从**三级缓存singletonFactory.getObject()(三级缓存)**获取，若是获取到了则将其put进二级缓存。</p><p>从上面三级缓存的分析，咱们能够知道，<strong>Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache</strong>。<br>这个cache的类型是<strong>ObjectFactory</strong>，定义以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在bean建立过程当中，有两处比较重要的匿名内部类实现了<strong>ObjectFactory</strong>接口。</p><ol><li>一处是Spring利用其建立bean的时候<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBeanFactory#doGetBean</span></span><br><span class="line"><span class="comment">// 1、创建Bean实例：单例</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    <span class="comment">// 此处lambda表达式为ObjectFactory的实现</span></span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>另外一处就是：<strong>AbstractAutowireCapableBeanFactory#doCreateBean#addSingletonFactory</strong></li></ol><h3 id="doCreateBean-bean的创建"><a href="#doCreateBean-bean的创建" class="headerlink" title="doCreateBean bean的创建"></a>doCreateBean bean的创建</h3><p><img src="/posts/7396/getbean-createbean.png"></p><ul><li>在 doCreateBean 方法中包括的内容较多，但核心主要是创建实例、加入缓存以及最终进行属性填充，属性填充就是把一个bean的各个属性字段涉及到的类填充进去。</li><li>createBeanInstance，创建 bean 实例，并将 bean 实例包装到 BeanWrapper 对象中返回</li><li>addSingletonFactory，添加 bean 工厂对象到 singletonFactories 缓存中</li><li>getEarlyBeanReference，获取原始对象的早期引用，在 getEarlyBeanReference 方法中，会执行 AOP 相关逻辑。若 bean 未被 AOP 拦截，getEarlyBeanReference 原样返回 bean。</li><li>populateBean，填充属性，解析依赖关系。也就是从这开始去找寻 A 实例中属性 B，紧接着去创建 B 实例，最后在返回回来。</li><li>initializeBean(beanName, exposedObject, mbd)：完成 bean 的属性填充注入后，进一步初始化 bean，在此过程中产生代理对象。此时 bean 的创建工作正式完成，已经可以在项目中使用了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span>   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#doCreateBean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化bean</span></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        <span class="comment">// 先尝试从缓存中取</span></span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用构造方法创建一个空实例对象，并用BeanWrapper进行包装</span></span><br><span class="line">        <span class="comment">// 通过构造方法反射得到一个空实例对象</span></span><br><span class="line">        <span class="comment">// 由此可知无法解决构造方法注入的循环依赖</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许后置处理程序修改合并后的bean定义</span></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="comment">// 获取所有的后置处理器，如果后置处理器实现了MergedBeanDefinitionPostProcessor接口，则一次调用其postProcessMergedBeanDefinition方法</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allowCircularReferences 自动尝试解析bean之间的循环引用</span></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">// 如果满足循环依赖缓存条件，先缓存具体对象</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处是解决循环依赖的关键！！！</span></span><br><span class="line">        <span class="comment">// 循环依赖处理逻辑：将已完成实例化，但是未完成属性赋值和相关的初始化的一个不完整的bean添加到三级缓存singletonFactories中</span></span><br><span class="line"><span class="comment">// 具体内部会遍历后置处理器，判断是否有SmartInstantiationAwareBeanPostProcessor的实现类，然后调用里面getEarlyBeanReference覆盖当前Bean</span></span><br><span class="line"><span class="comment">// 默认不做任何操作返回当前Bean，作为拓展，这里比如可以供AOP来创建代理类</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始对Bean实例进行初始化</span></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对bean进行属性填充，在这里面完成依赖注入的相关内容</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 完成属性依赖注入后，进一步初始化Bean</span></span><br><span class="line"><span class="comment">// 具体进行了以下操作：</span></span><br><span class="line"><span class="comment">// 1.若实现了BeanNameAware，BeanClassLoaderAware，BeanFactoryAwareAware等接口，则注入相关对象</span></span><br><span class="line"><span class="comment">// 2.遍历后置处理器，调用实现的postProcessBeforeInitialization方法，</span></span><br><span class="line"><span class="comment">// 3.如果实现了initialzingBean，调用实现的 afterPropertiesSet()</span></span><br><span class="line"><span class="comment">// 4.如果配置了init-mothod，调用相应的init方法</span></span><br><span class="line"><span class="comment">// 5.遍历后置处理器，调用实现的postProcessAfterInitialization</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 后续代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring为何不能解决非单例属性之外的循环依赖？"><a href="#Spring为何不能解决非单例属性之外的循环依赖？" class="headerlink" title="Spring为何不能解决非单例属性之外的循环依赖？"></a>Spring为何不能解决非单例属性之外的循环依赖？</h3><p>Spring是借助单例的三级缓存来解决单例的setter注入的循环依赖。</p><h4 id="Spring为什么不能解决构造器的循环依赖？"><a href="#Spring为什么不能解决构造器的循环依赖？" class="headerlink" title="Spring为什么不能解决构造器的循环依赖？"></a>Spring为什么不能解决构造器的循环依赖？</h4><p>构造器注入形成的循环依赖： 也就是beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成初始化，这种情况的结果就是两个bean都不能完成初始化，循环依赖难以解决。<br>Spring解决循环依赖主要是依赖三级缓存，但是<strong>在调用构造方法之前还未将其放入三级缓存之中</strong>，因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的Bean，因此不能解决。</p><h4 id="Spring为什么不能解决prototype作用域循环依赖？"><a href="#Spring为什么不能解决prototype作用域循环依赖？" class="headerlink" title="Spring为什么不能解决prototype作用域循环依赖？"></a>Spring为什么不能解决prototype作用域循环依赖？</h4><p>这种循环依赖同样无法解决，因为spring不会缓存<code>‘prototype’</code>作用域的bean，而spring中循环依赖的解决正是通过缓存来实现的。</p><h4 id="Spring为什么不能解决多例的循环依赖？"><a href="#Spring为什么不能解决多例的循环依赖？" class="headerlink" title="Spring为什么不能解决多例的循环依赖？"></a>Spring为什么不能解决多例的循环依赖？</h4><p>多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖。</p><h3 id="其它循环依赖如何解决？"><a href="#其它循环依赖如何解决？" class="headerlink" title="其它循环依赖如何解决？"></a>其它循环依赖如何解决？</h3><ul><li>生成代理对象产生的循环依赖<ol><li>使用@Lazy注解，延迟加载</li><li>使用@DependsOn注解，指定加载先后关系</li><li>修改文件名称，改变循环依赖类的加载顺序</li></ol></li><li>使用@DependsOn产生的循环依赖<br>  这类循环依赖问题要找到@DependsOn注解循环依赖的地方，迫使它不循环依赖就可以解决问题。</li><li>多例循环依赖<br>  这类循环依赖问题可以通过把bean改成单例的解决。</li><li>构造器循环依赖<br>  这类循环依赖问题可以通过使用<code>@Lazy注解</code>解决。</li></ul><h2 id="三、Spring中Bean的生命周期"><a href="#三、Spring中Bean的生命周期" class="headerlink" title="三、Spring中Bean的生命周期"></a>三、Spring中Bean的生命周期</h2><p><strong>Spring 只帮我们管理单例模式 Bean 的完整生命周期</strong>；对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p><p>Spring 容器可以管理 singleton 作用域 Bean 的生命周期，在此作用域下，Spring 能够精确地知道该 Bean 何时被创建，何时初始化完成，以及何时被销毁。</p><p>而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。每次客户端请求 prototype 作用域的 Bean 时，Spring 容器都会创建一个新的实例，并且不会管那些被配置成 prototype 作用域的 Bean 的生命周期。</p><p>了解 Spring 生命周期的意义就在于，<strong>可以利用 Bean 在其存活期间的指定时刻完成一些相关操作</strong>。这种时刻可能有很多，但一般情况下，会在 Bean 被初始化后和被销毁前执行一些相关操作。</p><p><img src="/posts/7396/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B.png" alt="Spring 容器中 Bean 的生命周期流程"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-IOC-实现原理详解-1-IOC初始化流程</title>
      <link href="/posts/53843.html"/>
      <url>/posts/53843.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/posts/53843/ioc%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE-ioc%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.png"></p><p>了解过了IOC的设计要点和设计结构，这篇来看一下源码的实现：<strong>Spring如何实现将资源配置通过加载、解析，生成BeanDefinition并注册到IoC容器中的</strong>（就是上图中圈出来的部分）。</p><h2 id="如何将Bean从配置或注解中解析后放到IoC容器中的？"><a href="#如何将Bean从配置或注解中解析后放到IoC容器中的？" class="headerlink" title="如何将Bean从配置或注解中解析后放到IoC容器中的？"></a>如何将Bean从配置或注解中解析后放到IoC容器中的？</h2><h3 id="初始化的入口"><a href="#初始化的入口" class="headerlink" title="初始化的入口"></a>初始化的入口</h3><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><p>SpringBoot启动的话，当前applicationContext是<strong>AnnotationConfigServletWebServerApplicationContext</strong>。</p><h4 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassPathXmlApplicationContext构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Bean资源加载器</span></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置配置路径 将传入的xml配置位置信息设置到configLocations</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容器</span></span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        <span class="comment">// 核心方法</span></span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigApplicationContext构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">//主要是scan方法完成bean的注册</span></span><br><span class="line">    scan(basePackages);</span><br><span class="line">    <span class="comment">//核心方法</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationConfigApplicationContext#scan</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//扫描包，进行Bean注册</span></span><br><span class="line">    doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化的主体流程-AbstractApplicationContext-refresh"><a href="#初始化的主体流程-AbstractApplicationContext-refresh" class="headerlink" title="初始化的主体流程 AbstractApplicationContext.refresh()"></a>初始化的主体流程 AbstractApplicationContext.refresh()</h3><p>Spring IoC容器对<strong>Bean定义资源的载入</strong>是从<code>refresh()</code>函数开始的。</p><p>refresh()是一个模板方法。<br>refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。<br>refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext#refresh()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">// 准备初始化容器工作，设置启动标志、记录启动时间等</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 创建 beanFactory，并加载bean定义等</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">// beanFactory注入一些标准组件，例如ApplicationContextAwareProcessor，ClassLoader等</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">// 给实现类留的一个钩子，例如注入BeanPostProcessors，这里是个空方法</span></span><br><span class="line">            <span class="comment">// post processor的意思是后置处理器</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">            <span class="comment">// 5</span></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 调用在上下文中注册为bean的工厂处理器。</span></span><br><span class="line">            <span class="comment">// 执行 BeanFactoryPostProcessor 实现类的 postProcessBeanFactory()方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6</span></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 注册 BeanPostProcessor bean后置处理器实现类</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7</span></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">// 国际化资源处理</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8</span></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">// bean工厂注册一个key为applicationEventMulticaster的广播器 用于事件广播</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9</span></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">// 给实现类留的一钩子，可以执行其他refresh的工作，比如启动tomcat server</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 10</span></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">// 注册事件监听器</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 11</span></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 完成单例bean的初始化</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 12</span></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            <span class="comment">// 完成容器启动，发布容器启动事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的设计上是一个非常典型的资源类加载处理型的思路，头脑中需要形成如下图的顶层思路</strong>（而不是只停留在流水式的方法上面）：</p><ul><li><strong>模板方法设计模式</strong>，模板方法中使用典型的<strong>钩子方法</strong></li><li>将<strong>具体的初始化加载方法</strong>插入到钩子方法之间</li><li>将初始化的阶段封装，用来记录当前初始化到什么阶段，常见的设计是xxxPhase/xxxStage</li><li>资源加载初始化有失败等处理，必然是try/catch/finally</li></ul><p><img src="/posts/53843/refresh-%E9%A1%B6%E5%B1%82%E6%80%9D%E8%B7%AF.png"></p><h4 id="初始化BeanFactory之obtainFreshBeanFactory"><a href="#初始化BeanFactory之obtainFreshBeanFactory" class="headerlink" title="初始化BeanFactory之obtainFreshBeanFactory"></a>初始化BeanFactory之obtainFreshBeanFactory</h4><p><strong>AbstractApplicationContext</strong>的<strong>obtainFreshBeanFactory()<strong>方法调用</strong>子类容器</strong>的**refreshBeanFactory()**方法，启动容器载入Bean定义资源文件的过程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext#ConfigurableListableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractApplicationContext#refreshBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure><p><strong>refreshBeanFactory</strong>方法由以下两个子类实现：<br><img src="/posts/53843/refresh-refreshBeanFactory-%E5%AD%90%E7%B1%BB%E5%AE%9E%E7%8E%B0.png"></p><ul><li><strong>AbstractRefreshableApplicationContext</strong><br>  AbstractApplicationContext类中只抽象定义了refreshBeanFactory()方法，容器真正调用的是其子类<strong>AbstractRefreshableApplicationContext</strong>实现的refreshBeanFactory()方法。<br>  在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。<br>  方法的源码如下：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext </span></span><br><span class="line"><span class="comment">// AbstractRefreshableApplicationContext#refreshBeanFactory</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation performs an actual refresh of this context&#x27;s underlying</span></span><br><span class="line"><span class="comment"> * bean factory, shutting down the previous bean factory (if any) and</span></span><br><span class="line"><span class="comment"> * initializing a fresh bean factory for the next phase of the context&#x27;s lifecycle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器</span></span><br><span class="line">    <span class="comment">// 当前beanFactory为【private volatile DefaultListableBeanFactory beanFactory】;</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean定义</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器 </span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>loadBeanDefinitions<br>  该方法由以下子类实现：<br>  <img src="/posts/53843/refresh-refreshBeanFactory-loadBeanDefinitions.png"></li></ul></li><li><strong>GenericApplicationContext</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry </span></span><br><span class="line"><span class="comment">// GenericApplicationContext#refreshBeanFactory</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do nothing: We hold a single internal BeanFactory and rely on callers</span></span><br><span class="line"><span class="comment"> * to register beans through our public methods (or the BeanFactory&#x27;s).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="初始化BeanFactory之loadBeanDefinitions"><a href="#初始化BeanFactory之loadBeanDefinitions" class="headerlink" title="初始化BeanFactory之loadBeanDefinitions"></a>初始化BeanFactory之loadBeanDefinitions</h4><p>Abstrac<strong>tRefreshable</strong>ApplicationContext中只定义了<strong>抽象的loadBeanDefinitions方法</strong>，该方法由以下子类实现：<br><img src="/posts/53843/refresh-refreshBeanFactory-loadBeanDefinitions.png"></p><p>在各自的实现中，解析bean生成BeanDefinition。</p><h4 id="解析过后的BeanDefinition在IoC容器中的注册"><a href="#解析过后的BeanDefinition在IoC容器中的注册" class="headerlink" title="解析过后的BeanDefinition在IoC容器中的注册"></a>解析过后的BeanDefinition在IoC容器中的注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过BeanDefinitionRegistry将BeanDefinitionHolder注册到BeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    <span class="comment">// 通过BeanDefinitionRegistry将BeanDefinitionHolder注册到BeanFactory</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用BeanDefinitionReaderUtils向IoC容器注册解析的BeanDefinition时，真正完成注册功能的是<strong>DefaultListableBeanFactory</strong>。</p><h4 id="DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition"><a href="#DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition" class="headerlink" title="DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition"></a>DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition</h4><p>IOC容器本质上就是一个beanDefinitionMap， 注册就是将BeanDefinition <strong>put</strong>到<strong>beanDefinitionMap</strong>中。</p><p>至此，Bean定义资源文件中配置的Bean被解析过后，已经注册到IoC容器中，被容器管理起来，真正完成了IoC容器初始化所做的全部工作。<br>现在IoC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。<br>这些注册的Bean定义信息是IoC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-前言</title>
      <link href="/posts/30902.html"/>
      <url>/posts/30902.html</url>
      
        <content type="html"><![CDATA[<p>Spring是什么？它是怎么诞生的？有哪些主要的组件和核心功能呢?<br>本文通过这几个问题来构筑对<strong>Spring和Spring Framework</strong>的整体认知。</p><h2 id="什么是Spring？"><a href="#什么是Spring？" class="headerlink" title="什么是Spring？"></a>什么是Spring？</h2><blockquote><p>Spring是什么？它是怎么诞生的？它的诞生是为了解决什么问题？</p></blockquote><h3 id="Spring的起源"><a href="#Spring的起源" class="headerlink" title="Spring的起源"></a>Spring的起源</h3><p>百度百科中关于Spring的起源介绍如下：</p><p>要谈Spring的历史，就要先谈J2EE。J2EE应用程序的广泛实现是在1999年和2000年开始的，它的出现带来了诸如事务管理之类的<strong>核心中间层概念的标准化</strong>，但是在实践中并没有获得绝对的成功，因为<strong>开发效率</strong>、开发难度和实际的性能都令人失望。</p><p>曾经使用过EJB开发JAVA EE应用的人，一定知道，在EJB开始的学习和应用非常的艰苦，很多东西都不能一下子就很容易的理解。EJB要严格地实现各种不同类型的接口，类似的或者重复的代码大量存在。而配置也是复杂和单调，同样使用JNDI进行对象查找的代码也是单调而枯燥。虽然有一些开发工作随着xdoclet的出现，而有所缓解，但是学习EJB的高昂代价，和极低的开发效率，极高的资源消耗，都造成了EJB的使用困难。<br>而Spring出现的初衷就是为了解决类似的这些问题。</p><p><strong>Spring的一个最大的目的就是使JAVA EE开发更加容易</strong>。同时，Spring之所以与Struts、Hibernate等单层框架不同，是因为Spring致力于提供一个以统一的、高效的方式构造整个应用，并且可以将单层框架以最佳的组合揉和在一起建立一个连贯的体系。可以说Spring是一个提供了更完善开发环境的一个框架，可以为POJO(Plain Ordinary Java Object)对象提供企业级的服务。</p><p>Spring的形成，最初来自Rod Jahnson所著的一本很有影响力的书籍《Expert One-on-One J2EE Design and Development在新窗口打开》，就是在这本书中第一次出现了Spring的一些核心思想，该书出版于2002年。</p><h3 id="Spring的特性和优势"><a href="#Spring的特性和优势" class="headerlink" title="Spring的特性和优势"></a>Spring的特性和优势</h3><p>Spring Framework有哪些特性，用了这个框架对开发而言有什么好处呢？</p><p><strong>从Spring框架的特性来看：</strong></p><ul><li>非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API</li><li>控制反转：IOC——Inversion of Control，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。</li><li>依赖注入：DI——Dependency Injection，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。</li><li>面向切面编程：Aspect Oriented Programming——AOP</li><li>容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期</li><li>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。</li><li>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表现层的 SpringMVC 和持久层的 Spring JDBC）</li></ul><p><strong>从使用Spring框架的好处来看：</strong></p><ul><li>Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。</li><li>Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只要担心你需要的，而其它的就可以忽略了。</li><li>Spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像 ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。</li><li>测试一个用 Spring 编写的应用程序很容易，因为环境相关的代码被移动到这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。</li><li>Spring 的 web 框架是一个设计良好的 web MVC 框架，它为比如 Structs 或者其他工程上的或者不怎么受欢迎的 web 框架提供了一个很好的供替代的选择。MVC 模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。模型(Model)封装了应用程序数据，通常它们将由 POJO 类组成。视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释 HTML 输出。控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。</li><li>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</li><li>轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。</li><li>Spring 提供了一致的事务管理接口，可向下扩展到（使用一个单一的数据库，例如）本地事务并扩展到全局事务（例如，使用 JTA）</li></ul><h3 id="谈谈对Spring的理解"><a href="#谈谈对Spring的理解" class="headerlink" title="谈谈对Spring的理解"></a>谈谈对Spring的理解</h3><p>Spring是一个轻量级的IoC和AOP容器框架，是为Java应用程序提供基础性服务的一套框架。<br>目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。<br>轻量级是相对于重量级而言的，轻量级一般就是非侵入式的、所依赖的东西少、资源占用少、部署简单，容易使用。</p><h2 id="Spring有哪些组件？"><a href="#Spring有哪些组件？" class="headerlink" title="Spring有哪些组件？"></a>Spring有哪些组件？</h2><p>下图来自，<a href="https://docs.spring.io/spring-framework/docs/5.0.0.M4/spring-framework-reference/pdf/spring-framework-reference.pdf">官方文档 Spring-framework 5.0</a><br>需要注意的是，虽然这个图来源于Spring Framwork5.0 M4 版本，但是它依然是V4版本的图，比如Spring 5版本中的web模块已经去掉了Portlet模块，新增了WebFlux模块等。</p><p><img src="/posts/30902/spring-framework-%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png"></p><p>上图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。<br>下面分别对这些模块的作用进行简单介绍（并且结合SpringFramework5.x源码模块对应各模块关系）。</p><h3 id="Core-Container（Spring的核心容器）"><a href="#Core-Container（Spring的核心容器）" class="headerlink" title="Core Container（Spring的核心容器）"></a>Core Container（Spring的核心容器）</h3><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 SpEL 表达式语言模块组成，没有这些核心容器，也不可能有 AOP、Web 等上层的功能。<br>具体介绍如下：</p><ul><li><strong>Beans 模块</strong>：提供了框架的基础部分，包括控制反转和依赖注入。</li><li><strong>Core 核心模块</strong>：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。</li><li><strong>Context 上下文模块</strong>：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。</li><li><strong>SpEL 模块</strong>：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</li></ul><p><img src="/posts/30902/spring-%E7%BB%84%E4%BB%B6-CoreContainer.png"></p><h3 id="Data-Access-Integration（数据访问／集成）"><a href="#Data-Access-Integration（数据访问／集成）" class="headerlink" title="Data Access/Integration（数据访问／集成）"></a>Data Access/Integration（数据访问／集成）</h3><p>数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块。<br>具体介绍如下：</p><ul><li><strong>JDBC 模块</strong>：提供了一个 JDBC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。</li><li><strong>ORM 模块</strong>：提供与流行的“对象-关系”映射框架无缝集成的 API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring 事务管理，无需额外控制事务。</li><li><strong>OXM 模块</strong>：提供了一个支持 Object /XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。将 Java 对象映射成 XML 数据，或者将XML 数据映射成 Java 对象。</li><li><strong>JMS 模块</strong>：指 Java 消息服务，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS，JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li><li><strong>Transactions 事务模块</strong>：支持编程和声明式事务管理。</li></ul><p><img src="/posts/30902/spring-%E7%BB%84%E4%BB%B6-%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90&%E8%AE%BF%E9%97%AE.png"></p><h3 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h3><p>Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Webflux 组件。<br>具体介绍如下：</p><ul><li><strong>Web 模块</strong>：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IOC 容器初始化以及 Web 应用上下文。</li><li><strong>Servlet 模块</strong>：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。</li><li><strong>WebSocket 模块</strong>：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建 WebSocket Server，从而实现双向通讯。</li><li><strong>Webflux 模块</strong>： Spring WebFlux 是 Spring Framework 5.x中引入的新的响应式web框架。与Spring MVC不同，它不需要Servlet API，是完全异步且非阻塞的，并且通过Reactor项目实现了Reactive Streams规范。Spring WebFlux 用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。</li></ul><p><img src="/posts/30902/spring-%E7%BB%84%E4%BB%B6-web%E6%A8%A1%E5%9D%97.png"></p><h3 id="AOP、Aspects、Instrumentation和Messaging"><a href="#AOP、Aspects、Instrumentation和Messaging" class="headerlink" title="AOP、Aspects、Instrumentation和Messaging"></a>AOP、Aspects、Instrumentation和Messaging</h3><p>在 Core Container 之上是 AOP、Aspects 等模块，具体介绍如下：</p><ul><li><strong>AOP 模块</strong>：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。</li><li><strong>Aspects 模块</strong>：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li><li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li>messaging 模块：Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</li><li>jcl 模块： Spring 5.x中新增了日志框架集成的模块。</li></ul><p><img src="/posts/30902/spring-%E7%BB%84%E4%BB%B6-AOP%E7%AD%89.png"></p><h3 id="Test模块"><a href="#Test模块" class="headerlink" title="Test模块"></a>Test模块</h3><p>Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。<br>包含Mock Objects, TestContext Framework, Spring MVC Test, WebTestClient。</p><p><img src="/posts/30902/spring-%E7%BB%84%E4%BB%B6-test%E6%A8%A1%E5%9D%97.png"></p><h2 id="为什么用Spring？"><a href="#为什么用Spring？" class="headerlink" title="为什么用Spring？"></a>为什么用Spring？</h2><p><a href="https://spring.io/why-spring">https://spring.io/why-spring</a></p><p><a href="https://docs.spring.io/spring-framework/docs/">https://docs.spring.io/spring-framework/docs/</a><br><a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><h2 id="写一个Spring的Hello-World的例子引出要点"><a href="#写一个Spring的Hello-World的例子引出要点" class="headerlink" title="写一个Spring的Hello World的例子引出要点"></a>写一个Spring的Hello World的例子引出要点</h2><p><img src="/posts/30902/spring-%E4%BE%8B%E5%AD%90-helloworld.png"></p><h3 id="控制反转-IOC"><a href="#控制反转-IOC" class="headerlink" title="控制反转 - IOC"></a>控制反转 - IOC</h3><blockquote><p>第一个需求：<strong>查询用户</strong>（service通过调用dao查询pojo），<strong>本质上如何创建Dao、Service等</strong></p></blockquote><ul><li><p><strong>如果没有Spring框架，我们需要自己创建Dao、Service等</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserDaoImpl userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">UserSericeImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">userService.setUserDao(userDao);</span><br><span class="line">List&lt;User&gt; userList = userService.findUserList();</span><br></pre></td></tr></table></figure></li><li><p><strong>有了Spring框架，可以将原有Bean的创建工作转给框架, 需要用时从Bean的容器中获取即可</strong>，这样便简化了开发工作，Bean的创建和使用分离了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create and configure beans</span></span><br><span class="line"><span class="comment">// xml方式声明bean</span></span><br><span class="line">ApplicationContext context =</span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;aspects.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>, <span class="string">&quot;services.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve configured instance</span></span><br><span class="line">UserServiceImpl service = context.getBean(<span class="string">&quot;userService&quot;</span>, UserServiceImpl.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use configured instance</span></span><br><span class="line">List&lt;User&gt; userList = service.findUserList();</span><br></pre></td></tr></table></figure></li></ul><p>更进一步，便能理解为何会有如下的知识点了：</p><ol><li><strong>Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean</strong>，这个就叫<strong>控制反转 - Inversion of Control (IoC)</strong></li><li>Spring 框架托管创建的Bean放在哪里呢？ 这便是<strong>Spring容器（IoC Container）</strong></li><li>Spring 框架为了更好让用户配置Bean，必然会引入<strong>不同方式来配置Bean</strong>？ 这便是<strong>xml配置，Java配置，注解配置</strong>等支持</li><li>Spring 框架既然接管了Bean的生成，必然需要<strong>管理整个Bean的生命周期</strong>等</li><li><strong>应用程序代码从Ioc Container中获取依赖的Bean，注入到应用程序中</strong>，这个过程叫 <strong>依赖注入(Dependency Injection，DI)</strong> ； 所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong></li><li>在依赖注入时，有哪些方式呢？这就是构造器方式，**@Autowired, @Resource, @Qualifier**… 同时Bean之间存在依赖（可能存在先后顺序问题，以及<strong>循环依赖</strong>问题等）</li></ol><h3 id="面向切面-AOP"><a href="#面向切面-AOP" class="headerlink" title="面向切面 - AOP"></a>面向切面 - AOP</h3><blockquote><p>第二个需求：给Service所有方法调用添加日志（调用方法时），<strong>本质上是解耦问题</strong></p></blockquote><ul><li><strong>如果没有Spring框架</strong>，我们需要在每个service的方法中都添加记录日志的方法，在业务代码逻辑中耦合日志处理</li><li><strong>有了Spring框架</strong>，通过@Aspect注解定义了切面，这个切面中定义了拦截所有service中的方法，并记录日志。框架将日志记录和业务需求的代码解耦了，不再是侵入式的了</li></ul><p>更进一步，便能理解为何会有如下的知识点了：</p><ol><li>Spring 框架通过定义切面, 通过拦截切点实现了不同业务模块的解耦，这个就叫<strong>面向切面编程 - Aspect Oriented Programming (AOP)</strong></li><li>为什么@Aspect注解使用的是aspectj的jar包呢？这就引出了<strong>Aspect4J和Spring AOP的历史渊源</strong>，只有理解了Aspect4J和Spring的渊源才能理解有些注解上的兼容设计</li><li>如何支持更多拦截方式来实现解耦， 以满足更多场景需求呢？ 这就是@Around, @Pointcut… 等的设计</li><li>那么Spring框架又是如何实现AOP的呢？ 这就引入<strong>代理技术</strong>，分<strong>静态代理和动态代理</strong>，<strong>动态代理又包含JDK代理和CGLIB代理</strong>等</li></ol><h2 id="Spring框架是如何逐步简化开发的"><a href="#Spring框架是如何逐步简化开发的" class="headerlink" title="Spring框架是如何逐步简化开发的"></a>Spring框架是如何逐步简化开发的</h2><p><img src="/posts/30902/spring-%E7%AE%80%E5%8C%96%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式任务</title>
      <link href="/posts/15037.html"/>
      <url>/posts/15037.html</url>
      
        <content type="html"><![CDATA[<p>分布式定时任务调度。</p><h2 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h2><p><a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p><h2 id="基于xxl-job二次开发"><a href="#基于xxl-job二次开发" class="headerlink" title="基于xxl-job二次开发"></a>基于xxl-job二次开发</h2><p><img src="/posts/15037/ischeduler%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"></p><ul><li>i-scheduler-spring-boot-starter<br>  其它web服务只需引用此starter包即可。<br>  依赖i-scheduler-core。</li><li>i-scheduler-core<br>  starter组件核心模块，提供其它服务需要实现的BaseSchedule，HandlerPoolHelper通过反射的方式调用具体的Schedule任务。</li><li>i-scheduler-admin<br>  分布式任务调度中心。</li><li>i-scheduler-web<br>  管理页面。</li></ul><h3 id="i-scheduler-spring-boot-starter"><a href="#i-scheduler-spring-boot-starter" class="headerlink" title="i-scheduler-spring-boot-starter"></a>i-scheduler-spring-boot-starter</h3><h4 id="ScheduleAutoConfiguration"><a href="#ScheduleAutoConfiguration" class="headerlink" title="ScheduleAutoConfiguration"></a>ScheduleAutoConfiguration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// springboot自动装配</span></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.haier.schedule.starter.ScheduleAutoConfiguration</span><br></pre></td></tr></table></figure><ol><li>声明i-scheduler组件所需的Bean</li><li>添加SchedulerInterceptor拦截器，以便任务调度</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;server.port:8080&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String port;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String adminAddress = <span class="string">&quot;http://scheduler-admin.i-scheduler:8080/api&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;server.servlet.context-path:&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String contextPath;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;scheduler.admin.open:true&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Boolean open;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;scheduler.job.open:true&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Boolean jobOpen;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Lazy</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> SchedulerInterceptor schedulerInterceptor;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.open != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.open.booleanValue())</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.jobOpen != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.jobOpen.booleanValue())</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">    registry.addInterceptor(<span class="keyword">this</span>.schedulerInterceptor)</span><br><span class="line"></span><br><span class="line">    .addPathPatterns(<span class="keyword">new</span> String[] &#123; <span class="string">&quot;/**&quot;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 拦截器</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SchedulerInterceptor <span class="title">schedulerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SchedulerInterceptor();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReportPoolHelper <span class="title">reportPoolHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReportPoolHelper(<span class="keyword">this</span>.adminAddress);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HandlerPoolHelper <span class="title">handlerPoolHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HandlerPoolHelper();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 业务服务定时任务执行器</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ScheduleExecutor <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduleExecutor(<span class="keyword">this</span>.port, <span class="keyword">this</span>.adminAddress, <span class="keyword">this</span>.contextPath, <span class="keyword">this</span>.open, <span class="keyword">this</span>.jobOpen);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 切面</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ScheduleAspect <span class="title">aspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduleAspect(<span class="keyword">this</span>.adminAddress);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 运行器</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SchedulerRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SchedulerRunner(<span class="keyword">this</span>.adminAddress, <span class="keyword">this</span>.contextPath, <span class="keyword">this</span>.port, <span class="keyword">this</span>.open);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SchedulerInterceptor"><a href="#SchedulerInterceptor" class="headerlink" title="SchedulerInterceptor"></a>SchedulerInterceptor</h4><p>拦截器，处理i-scheduler-admin传递的调度请求，以反射的方式调用实际需要执行的任务方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HandlerPoolHelper handlerPoolHelper;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String servletPath = request.getServletPath();</span><br><span class="line">        <span class="keyword">if</span> (!servletPath.startsWith(<span class="string">&quot;/i_scheduler&quot;</span>))</span><br><span class="line">            <span class="comment">// 非调度请求，执行其它的拦截器</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        String path = servletPath.replaceAll(<span class="string">&quot;/i_scheduler/&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;ping&quot;</span>.equals(path)) &#123;</span><br><span class="line">            response.setStatus(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (path.startsWith(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">            Long id;</span><br><span class="line">            String idStr = path.substring(path.indexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                id = Long.valueOf(Long.parseLong(idStr));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            SchedulerContext schedulerContext = ScheduleAspect.getSchedulerContext(id);</span><br><span class="line">            <span class="keyword">if</span> (schedulerContext != <span class="keyword">null</span>)</span><br><span class="line">                schedulerContext.setStop(<span class="keyword">true</span>); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射 获取BaseSchedule</span></span><br><span class="line">        MethodHandler methodHandler = ScheduleExecutor.getMethod(path);</span><br><span class="line">        <span class="keyword">if</span> (methodHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.setStatus(<span class="number">404</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">byte</span>[] bodyBytes = StreamUtils.copyToByteArray((InputStream)request.getInputStream());</span><br><span class="line">        String body = <span class="keyword">new</span> String(bodyBytes, request.getCharacterEncoding());</span><br><span class="line">        Parameter parameter = (Parameter)JacksonUtil.readValue(body, Parameter.class);</span><br><span class="line">        <span class="comment">// 调度任务线程池执行任务</span></span><br><span class="line">        <span class="keyword">this</span>.handlerPoolHelper.addBiz(methodHandler, <span class="keyword">new</span> Object[] &#123; parameter &#125;);</span><br><span class="line">        response.setStatus(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止拦截器的链式调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ScheduleExecutor"><a href="#ScheduleExecutor" class="headerlink" title="ScheduleExecutor"></a>ScheduleExecutor</h4><ol><li>ApplicationContextAware<br> 应用程序上下文感知接口。通过实现该接口,我们可以获取ApplicationContext对象,进而获取BeanDefinitionRegistry等底层结构。<br> 通过重写 void setApplicationContext(ApplicationContext context) 方法,我们可以在Bean初始化之后立即获取ApplicationContext。</li><li>SmartInitializingSingleton<br> Spring的一个感知接口,用于在Spring容器完成所有的初始化Bean之后,执行一段代码。<br> 通过实现SmartInitializingSingleton接口并重写afterSingletonsInstantiated()方法,我们可以在容器初始化完成后立即执行一段逻辑。</li><li>DisposableBean<br> 在Bean生命周期结束前调用destory()方法做一些收尾工作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleExecutor</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">SmartInitializingSingleton</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(ScheduleExecutor.class);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, MethodHandler&gt; schedulerMethods = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String port;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String adminAddress;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String contextPath;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Boolean open;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Boolean jobOpen;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ReportPoolHelper reportPoolHelper;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> HandlerPoolHelper handlerPoolHelper;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ScheduleExecutor</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ScheduleExecutor</span><span class="params">(String port, String adminAddress, String contextPath, Boolean open, Boolean jobOpen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.port = port;</span><br><span class="line">    <span class="keyword">this</span>.adminAddress = adminAddress;</span><br><span class="line">    <span class="keyword">this</span>.contextPath = contextPath;</span><br><span class="line">    <span class="keyword">this</span>.open = open;</span><br><span class="line">    <span class="keyword">this</span>.jobOpen = jobOpen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结束执行器</span></span><br><span class="line">    <span class="keyword">this</span>.handlerPoolHelper.stop();</span><br><span class="line">    <span class="comment">// 结束上报器</span></span><br><span class="line">    <span class="keyword">this</span>.reportPoolHelper.stop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在容器初始化完成后立即执行一段逻辑</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.open != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.open.booleanValue())</span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">    Map&lt;String, BaseSchedule&gt; schedulerBeans = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.jobOpen == <span class="keyword">null</span> || <span class="keyword">this</span>.jobOpen.booleanValue())</span><br><span class="line">      schedulerBeans = applicationContext.getBeansOfType(BaseSchedule.class); </span><br><span class="line">    RegisterParam register = <span class="keyword">new</span> RegisterParam();</span><br><span class="line">    register.setPort(<span class="keyword">this</span>.port);</span><br><span class="line">    register.setAppName(System.getenv(<span class="string">&quot;APP_NAME&quot;</span>));</span><br><span class="line">    register.setClusterName(System.getenv(<span class="string">&quot;CLUSTER_NAME&quot;</span>));</span><br><span class="line">    register.setProject(System.getenv(<span class="string">&quot;TENANT_NAME&quot;</span>));</span><br><span class="line">    register.setNamespace(System.getenv(<span class="string">&quot;POD_NAMESPACE&quot;</span>));</span><br><span class="line">    register.setContextPath(<span class="keyword">this</span>.contextPath);</span><br><span class="line">    register.setSchedulerList(<span class="keyword">new</span> ArrayList());</span><br><span class="line">    <span class="keyword">if</span> (schedulerBeans != <span class="keyword">null</span> &amp;&amp; !schedulerBeans.isEmpty())</span><br><span class="line">      <span class="keyword">for</span> (BaseSchedule scheduler : schedulerBeans.values()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Method doWork = scheduler.getClass().getDeclaredMethod(<span class="string">&quot;doWork&quot;</span>, <span class="keyword">new</span> Class[] &#123; Parameter.class &#125;);</span><br><span class="line">          <span class="keyword">if</span> (doWork == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">          String name = <span class="keyword">null</span>;</span><br><span class="line">          String cron = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">boolean</span> cover = <span class="keyword">false</span>;</span><br><span class="line">          Scheduler annotation = (Scheduler)AnnotationUtils.findAnnotation(doWork, Scheduler.class);</span><br><span class="line">          <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = annotation.value();</span><br><span class="line">            cron = annotation.cron();</span><br><span class="line">            cover = annotation.cover();</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            name = ClassUtils.getUserClass(scheduler.getClass()).getSimpleName();</span><br><span class="line">            name = decapitalize(name);</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">if</span> (schedulerMethods.containsKey(name))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;存在重名任务，请修改&quot;</span>); </span><br><span class="line">          register.getSchedulerList().add(<span class="keyword">new</span> SchedulerConf(name, cron, Boolean.valueOf(cover)));</span><br><span class="line">          schedulerMethods.put(name, <span class="keyword">new</span> MethodHandler(scheduler, doWork));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向i-scheduler-admin注册任务信息</span></span><br><span class="line">    HttpUtil.post(<span class="keyword">this</span>.adminAddress + <span class="string">&quot;/register&quot;</span>, register);</span><br><span class="line">    log.info(<span class="string">&quot;定时任务信息注册完成&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.reportPoolHelper.start();</span><br><span class="line">    <span class="keyword">this</span>.handlerPoolHelper.start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>;</span><br><span class="line">    ScheduleExecutor.applicationContext = applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodHandler <span class="title">getMethod</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> schedulerMethods.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">decapitalize</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> name; </span><br><span class="line">    <span class="keyword">if</span> (name.length() &gt; <span class="number">1</span> &amp;&amp; Character.isUpperCase(name.charAt(<span class="number">1</span>)) &amp;&amp; </span><br><span class="line">      Character.isUpperCase(name.charAt(<span class="number">0</span>)))</span><br><span class="line">      <span class="keyword">return</span> name; </span><br><span class="line">    <span class="keyword">char</span>[] chars = name.toCharArray();</span><br><span class="line">    chars[<span class="number">0</span>] = Character.toLowerCase(chars[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SchedulerRunner"><a href="#SchedulerRunner" class="headerlink" title="SchedulerRunner"></a>SchedulerRunner</h4><ul><li>ApplicationRunner<br>  应用程序运行器接口。通过实现该接口,我们可以在应用启动后立即运行一段代码。<br>  需要重写 void run(ApplicationArguments args)方法,该方法会在SpringApplication启动后直接调用。</li></ul><p>SpringBootApplication启动成功，向i-scheduler-admin调度中心注册应用程序执行器信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(SchedulerRunner.class);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String adminUrl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String contextPath;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String port;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Boolean open;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SchedulerRunner</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SchedulerRunner</span><span class="params">(String adminUrl, String contextPath, String port, Boolean open)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.adminUrl = adminUrl;</span><br><span class="line">    <span class="keyword">this</span>.contextPath = contextPath;</span><br><span class="line">    <span class="keyword">this</span>.port = port;</span><br><span class="line">    <span class="keyword">this</span>.open = open;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.open != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.open.booleanValue())</span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">    RegisterParam register = <span class="keyword">new</span> RegisterParam();</span><br><span class="line">    register.setPort(<span class="keyword">this</span>.port);</span><br><span class="line">    register.setContextPath(<span class="keyword">this</span>.contextPath);</span><br><span class="line">    register.setAppName(System.getenv(<span class="string">&quot;APP_NAME&quot;</span>));</span><br><span class="line">    register.setClusterName(System.getenv(<span class="string">&quot;CLUSTER_NAME&quot;</span>));</span><br><span class="line">    register.setAddress(String.format(<span class="string">&quot;http://%s:%s&quot;</span>, <span class="keyword">new</span> Object[] &#123; System.getenv(<span class="string">&quot;POD_IP&quot;</span>), <span class="keyword">this</span>.port &#125;));</span><br><span class="line">    register.setProject(System.getenv(<span class="string">&quot;TENANT_NAME&quot;</span>));</span><br><span class="line">    register.setNamespace(System.getenv(<span class="string">&quot;POD_NAMESPACE&quot;</span>));</span><br><span class="line">    register.setPodName(System.getenv(<span class="string">&quot;POD_NAME&quot;</span>));</span><br><span class="line">    HttpUtil.post(<span class="keyword">this</span>.adminUrl + <span class="string">&quot;/exec/register&quot;</span>, register);</span><br><span class="line">    log.info(<span class="string">&quot;执行器信息注册完成&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleAspect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String adminAddress;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, SchedulerContext&gt; schedulerContextMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ScheduleAspect</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ScheduleAspect</span><span class="params">(String adminAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.adminAddress = adminAddress;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SchedulerContext <span class="title">getSchedulerContext</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">return</span> schedulerContextMap.get(id);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// @Scheduler注解切面</span></span><br><span class="line">  <span class="meta">@Around(&quot;@annotation(com.haier.schedule.core.annotation.Scheduler)&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> </span>&#123;</span><br><span class="line">    Long execId = <span class="keyword">null</span>;</span><br><span class="line">    CallbackParam callbackParam = <span class="keyword">new</span> CallbackParam();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object arg = point.getArgs()[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (!(arg <span class="keyword">instanceof</span> Parameter)) &#123;</span><br><span class="line">        point.proceed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; </span><br><span class="line">      Parameter param = (Parameter)arg;</span><br><span class="line">      callbackParam.setId(param.getId());</span><br><span class="line">      callbackParam.setTriggerId(param.getTriggerId());</span><br><span class="line">      callbackParam.setJobId(param.getJobId());</span><br><span class="line">      SchedulerContext schedulerContext = <span class="keyword">new</span> SchedulerContext(param.getId().longValue(), param.getShardIndex().intValue(), param.getShardTotal().intValue());</span><br><span class="line">      SchedulerContext.setScheduleContext(schedulerContext);</span><br><span class="line">      execId = param.getId();</span><br><span class="line">      schedulerContextMap.put(execId, schedulerContext);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行过程</span></span><br><span class="line">      point.proceed();</span><br><span class="line"></span><br><span class="line">      callbackParam.setStatus(Integer.valueOf(<span class="number">200</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      callbackParam.setStatus(Integer.valueOf(<span class="number">500</span>));</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (execId != <span class="keyword">null</span>)</span><br><span class="line">        schedulerContextMap.remove(execId); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// callback 回传本次任务执行情况</span></span><br><span class="line">    HttpUtil.post(<span class="keyword">this</span>.adminAddress + <span class="string">&quot;/callback&quot;</span>, callbackParam);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="i-scheduler-admin"><a href="#i-scheduler-admin" class="headerlink" title="i-scheduler-admin"></a>i-scheduler-admin</h3><h3 id="i-scheduler-core"><a href="#i-scheduler-core" class="headerlink" title="i-scheduler-core"></a>i-scheduler-core</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 架构 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-AOP-实现原理详解</title>
      <link href="/posts/45858.html"/>
      <url>/posts/45858.html</url>
      
        <content type="html"><![CDATA[<h2 id="AOP的实现过程-前言"><a href="#AOP的实现过程-前言" class="headerlink" title="AOP的实现过程 - 前言"></a>AOP的实现过程 - 前言</h2><p>主业务在A类中，辅助业务在切面B类中，在Spring项目的启动过程中，会将A和B类“组合”成一个新的类C，C在执行A的主业务逻辑时，在恰当的时机，会调用B中的方法，C就是代理类。</p><ul><li><strong>主业务类A叫做目标类，A中的方法叫做目标方法</strong></li><li><strong>辅助业务类B叫做切面</strong>，切面（<code>@Aspect</code>）中有切点（<code>@Pointcut</code>）和通知（@Before、@After、@Around等）</li><li><strong>C类叫做代理类</strong></li></ul><p>所以，AOP的实现过程有两个阶段：</p><ol><li>目标对象是如何变成代理对象的？</li><li>代理对象是怎么执行目标方法的？</li></ol><h2 id="AOP的实现过程-1、目标对象变成代理对象的过程"><a href="#AOP的实现过程-1、目标对象变成代理对象的过程" class="headerlink" title="AOP的实现过程 - 1、目标对象变成代理对象的过程"></a>AOP的实现过程 - 1、目标对象变成代理对象的过程</h2><p>首先是目标类实例化为目标对象，这个过程是IoC容器初始化、创建bean的过程。</p><h3 id="相关方法调用"><a href="#相关方法调用" class="headerlink" title="相关方法调用"></a>相关方法调用</h3><h4 id="doCreateBean-gt-initializeBean"><a href="#doCreateBean-gt-initializeBean" class="headerlink" title="doCreateBean -&gt; initializeBean"></a>doCreateBean -&gt; initializeBean</h4><p>来看一下<strong>AbstractAutowireCapableBeanFactory</strong>的<strong>doCreateBean</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#doCreateBean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化bean</span></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        <span class="comment">// 先尝试从缓存中取</span></span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用构造方法创建一个空实例对象，并用BeanWrapper进行包装</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里，目标类A的bean被创建出来，此时仅仅是一个内存空间，属性值都是默认的初始零值</span></span><br><span class="line">    Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 中间代码省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始对Bean实例进行初始化</span></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对bean进行属性填充，在这里面完成依赖注入的相关内容</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果bean被aop“切”了，在initializeBean方法中bean会变成代理对象返回！！！</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 后续代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先有的目标类bean，然后再为其创建代理对象。</p><h4 id="initializeBean-gt-applyBeanPostProcessorsAfterInitialization"><a href="#initializeBean-gt-applyBeanPostProcessorsAfterInitialization" class="headerlink" title="initializeBean -&gt; applyBeanPostProcessorsAfterInitialization"></a>initializeBean -&gt; applyBeanPostProcessorsAfterInitialization</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoWireCapableBeanFactory#initializeBean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果实现了Aware接口，就对该bean进行一些设置</span></span><br><span class="line"><span class="comment">// 比如实现了BeanNameAware接口，那么对其bean的属性beanName上设置对应的beanName</span></span><br><span class="line"><span class="comment">// 如果实现了BeanFactoryAware接口，那么对其beanFactory属性设置上创建该bean使用的bean工厂</span></span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 如果bean实现了InitializingBean或者用户自定义的init方法方法，那么调用这些初始化方法对bean的属性进行一些个性化设置</span></span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 执行后置处理器的postProcessAfterInitialization方法。AOP的原理和实现就在其中！！！</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// 初始化返回结果为existingBean</span></span><br><span class="line">Object result = existingBean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的 beanPostProcessor</span></span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="comment">// 在 bean 上执行每一个 beanPostProcessor 的 postProcessAfterInitialization() 方法。</span></span><br><span class="line">Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bean被创建后，会调用所有的<strong>BeanPostProcessor</strong>作用在bean上，其中有一个名叫<strong>AnnotationAwareAspectJAutoProxyCreator</strong>的BeanPostProcessor，<strong>是它将bean变成了对应的代理类</strong>。</p><h4 id="AnnotationAwareAspectJAutoProxyCreator类"><a href="#AnnotationAwareAspectJAutoProxyCreator类" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator类"></a>AnnotationAwareAspectJAutoProxyCreator类</h4><p>先看下<strong>AnnotationAwareAspectJAutoProxyCreator</strong>的类关系图：<br><img src="/posts/45858/AnnotationAwareAspectJAutoProxyCreator-%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><h4 id="postProcessAfterInitialization-gt-wrapIfNecessary"><a href="#postProcessAfterInitialization-gt-wrapIfNecessary" class="headerlink" title="postProcessAfterInitialization -&gt; wrapIfNecessary"></a>postProcessAfterInitialization -&gt; wrapIfNecessary</h4><p>接下来看下代理对象是怎么生成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator#postProcessAfterInitialization</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果是普通bean，则返回beanName，如果是FactoryBean,则返回加上前缀&amp;的&amp;beanName</span></span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// earlyProxyReferences中缓存的是已经创建好的代理对象</span></span><br><span class="line"><span class="comment">// 如果 bean 已经生成了代理，那就跳过，不再重复生成。</span></span><br><span class="line"><span class="comment">// 为什么要判断 bean 是否已经生成了代理？</span></span><br><span class="line"><span class="comment">// 因为在工程启动过程中有两个地方可以将目标对象变成 aop 代理：一个在这里；另一个是目标对象从三级缓存转到二级缓存的时候</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="comment">// wrapIfNecessary方法为 bean 创建代理对象并返回。</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator#wrapIfNecessary</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 看看有没有缓存，有缓存对象就直接返回了</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果该bean不需要被代理，则直接返回原始的bean对象</span></span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line"><span class="comment">// 获取 bean 的 advices（通知或增强器），每一个通知都会被构建成一个增强器</span></span><br><span class="line"><span class="comment">// getAdvicesAndAdvisorsForBean 获取切面信息</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 specificInterceptors 不为空。如果不为空，说明当前 bean 被”切“了。</span></span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="comment">// 通过createProxy方法创建代理对象！！！</span></span><br><span class="line">Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果拿不到 advices，标识 bean 不需要增强。（都没被切，增强个毛线）</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 bean 或者 bean的代理对象。</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>wrapIfNecessary</strong>判断有没有针对当前bean的切面。如果没有，直接将bean返回；如果有，为bean创建代理对象。</p><p>思考一下问题：</p><ol><li>切面信息是怎么拿到的？更确切的说，切面是怎么被解析的</li><li>怎么判断有没有针对当前bean的切面？其实找的是有没有作用在当前bean上的通知。</li></ol><h3 id="获取切面信息"><a href="#获取切面信息" class="headerlink" title="获取切面信息"></a>获取切面信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator#getAdvicesAndAdvisorsForBean</span></span><br><span class="line"><span class="comment">// 但是因为被继承了，所以此时应该是是在 AnnotationAwareAspectJAutoProxyCreator.java 中</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">    Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line">    <span class="comment">// 为 beanClass 寻找符合条件的增强器（advisors），增强器就是通知，这个后面有解释。</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="comment">// 如果找不到</span></span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 返回 null</span></span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了增强器，以数组格式将这些增强器返回。</span></span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator#findEligibleAdvisors</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到所有的 advisors，包括事务的 advisor 和 普通 aop 的 advisor。。</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// 在所有的 advisors 中筛选符合 beanClass 使用的 advisor。（通过切点那块的表达式判定有没有切到 beanClass）</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    <span class="comment">// 向 eligibleAdvisors 中额外再添加一个 ExposeInvocationInterceptor 类型的 advisor。</span></span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 如果有多个 advisor，谁先谁后，在这里排序。</span></span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  返回符合条件的 advisor</span></span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里一定要进到 AnnotationAwareAspectJAutoProxyCreator.java 中，走错地方就找不到这个方法了。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这是是找事务相关的 advisor。因为事务相关的 advisor 少，而且是现成的。</span></span><br><span class="line"><span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 接下来才找 aspectJ 的 advisor。</span></span><br><span class="line">        advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回找到的所有通知。</span></span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切面是怎么被解析的"><a href="#切面是怎么被解析的" class="headerlink" title="切面是怎么被解析的"></a>切面是怎么被解析的</h3><p><code>切面@Aspect</code>最开始也只是个class文件，只有被注入、解析后才能使用。<br>大概简述下切面被注入和解析的思路：</p><ol><li>切面被注入的过程：<br> 切面类上有<code>@Component</code>注解，所以在工程启动时<code>ConfigurationClassPostProcessor</code>会加载切面的class文件，创建对应的BeanDefinition，为其创建对应的bean保存到<code>applicationContext</code>中的<code>beanFactory</code>属性的<code>beanDefinitionMap</code>中，切面就这样被注入了。</li><li>解析切面，最终解析到切面的通知上去，因为辅助的aop逻辑都在通知里面<br> 去<code>beanFactory</code>中拿所有的object的beanName，即获取所有bean的名字，为每一个beanName创建Class对象，判断该Class对象上有没有<code>@Aspect</code>注解，如果有，那这个类就是切面类。<br> 获取类中的方法，判断类的方法上有没有@Before、@After、@Around等注解，如果有，那这个方法就是通知，为每一个通知创建一个<code>Advisor</code>对象，将所有的Advisor对象保存到advisors列表中。</li></ol><h3 id="解析切面的执行时机"><a href="#解析切面的执行时机" class="headerlink" title="解析切面的执行时机"></a>解析切面的执行时机</h3><p>todo</p><h3 id="筛选作用于当前bean的增强器"><a href="#筛选作用于当前bean的增强器" class="headerlink" title="筛选作用于当前bean的增强器"></a>筛选作用于当前bean的增强器</h3><p>todo</p><h3 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h3><p>目标类的bean有了，作用在这个bean上的增强器也找到了，接下来就是拿着这两个东西创建代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator#createProxy</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建代理工厂</span></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line"><span class="comment">// 将目标对象和它的增强器都 set 到 代理工厂中</span></span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理工厂创建代理对象，并返回</span></span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理工厂返回的是<strong>AopProxy</strong>接口，它有两个实现<strong>CglibAopProxy</strong>和<strong>JdkDynamicAopProxy</strong>。至于创建的到底是哪一个，要根据条件判断的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProxyFactory#getProxy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ProxyFactory#getProxyClass</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getProxyClass(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxyClass(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AopProxy#getProxy</span></span><br><span class="line"><span class="function">Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span></span>;</span><br><span class="line"><span class="comment">// JdkDynamicAopProxy#getProxy</span></span><br><span class="line"><span class="comment">// CglibAopProxy#getProxy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultAopProxyFactory implements AopProxyFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line"><span class="comment">// 获得被代理类的类型，以确定代理的方式</span></span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line"><span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果目标类有接口，或者本身就是一个代理类，或者是lambada表达式生成的类</span></span><br><span class="line"><span class="comment">//以上三种情况走jdk代理</span></span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则使用CGLIB生成代理对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AnnotationAwareAspectJAutoProxyCreator是怎么被加载的？"><a href="#AnnotationAwareAspectJAutoProxyCreator是怎么被加载的？" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator是怎么被加载的？"></a>AnnotationAwareAspectJAutoProxyCreator是怎么被加载的？</h3><p>前面写到<strong>AnnotationAwareAspectJAutoProxyCreator</strong>解析了切面，创建了增强器，最后将目标对象变成了代理对象，那这个类是怎么被加载到的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@EnableAspectJAutoProxy</strong>注解将<strong>AnnotationAwareAspectJAutoProxyCreator的beanDefinition</strong>注入了<strong>applicationContext</strong>中。</li><li>接下来通过 beanDefinition 创建对应 bean 的过程，<strong>AnnotationAwareAspectJAutoProxyCreator的bean</strong>也就注入了<strong>applicationConext</strong>中。</li><li><strong>AnnotationAwareAspectJAutoProxyCreator</strong>实现了<strong>BeanPostProcessor</strong>接口，所以在对目标类的 bean 执行初始化时，会调用所有的 BeanPostProcessor，当然少不了 annotationAwareAspectJAutoProxyCreator，它执行 postProcessAfterInitialization(Object bean, String beanName) 方法，将目标类变成了代理类。（它解析切面的时机，不在赘述了）</li><li>至于@Import 注解是什么时候执行的，不用猜都知道它在 ConfigurationClassPostProcessor 类的processConfigBeanDefinitions() 方法中执行的。</li></ol><h2 id="AOP的实现过程-2、代理对象执行目标方法的过程"><a href="#AOP的实现过程-2、代理对象执行目标方法的过程" class="headerlink" title="AOP的实现过程 - 2、代理对象执行目标方法的过程"></a>AOP的实现过程 - 2、代理对象执行目标方法的过程</h2><p>代理对象创建好了，最关键的时刻来了：<strong>代理对象执行目标方法并在恰当时机将通知织入</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-调试排错-汇总</title>
      <link href="/posts/20737.html"/>
      <url>/posts/20737.html</url>
      
        <content type="html"><![CDATA[<h2 id="JVM调优参数"><a href="#JVM调优参数" class="headerlink" title="JVM调优参数"></a>JVM调优参数</h2><h3 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h3><ul><li>-Xms 堆最小值</li><li>-Xmx 堆最大堆值。-Xms与-Xmx 的单位默认字节都是以k、m做单位的。</li><li>-Xmn 新生代大小</li><li>-Xss 设置每个线程可使用的内存大小，即栈的大小。<br>  在相同物理内存下，减小这个值能生成更多的线程，但操作系统对一个进程内的线程数还是有限制的，不能无限生成。<br>  线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大；如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。</li><li>-XX:NewRatio</li><li>-XX:PermSize</li><li>-XX:MaxPermSize</li><li>-XX:MaxTenuringThreshold</li><li>-XX:SurvivorRatio</li><li>-XX:+UseFastAccessorMethods</li><li>-XX:+AggressiveOpts</li><li>-XX:PretenureSizeThreshold 对象超过多大值时直接在老年代中分配</li></ul><p>经验：</p><ul><li><code>Xmn</code>用于设置新生代的大小。过小会增加Minor GC频率，过大会减小老年代的大小。一般设为整个堆空间的1/4或1/3。</li><li><code>XX:SurvivorRatio</code>用于设置新生代中survivor空间(from/to)和eden空间的大小比例； <code>XX:TargetSurvivorRatio</code>表示，当经历Minor GC后，survivor空间占有量(百分比)超过它的时候，就会压缩进入老年代(当然，如果survivor空间不够，则直接进入老年代)。默认值为50%。</li><li>为了性能考虑，一开始尽量将新生代对象留在新生代，避免新生的大对象直接进入老年代。因为新生对象大部分都是短期的，这就造成了老年代的内存浪费，并且回收代价也高(Full GC发生在老年代和方法区Perm)。</li><li>当<code>Xms=Xmx</code>，可以使得堆相对稳定，避免不停震荡</li><li>一般来说，MaxPermSize设为64MB可以满足绝大多数的应用了。若依然出现方法区溢出，则可以设为128MB。若128MB还不能满足需求，那么就应该考虑程序优化了，减少<strong>动态类</strong>的产生。</li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="GC考虑的指标"><a href="#GC考虑的指标" class="headerlink" title="GC考虑的指标"></a>GC考虑的指标</h4><ul><li>吞吐量: 应用耗时和实际耗时的比值；</li><li>停顿时间: 垃圾回收的时候，由于Stop the World，应用程序的所有线程会挂起，造成应用停顿。</li></ul><p>吞吐量和停顿时间是互斥的。<br>对于后端服务(比如后台计算任务)，吞吐量优先考虑(并行垃圾回收)；<br>对于前端应用，RT响应时间优先考虑，减少垃圾收集时的停顿时间，适用场景是Web系统(并发垃圾回收)</p><h4 id="垃圾收集器的JVM参数"><a href="#垃圾收集器的JVM参数" class="headerlink" title="垃圾收集器的JVM参数"></a>垃圾收集器的JVM参数</h4><h2 id="问题排查-Linux命令"><a href="#问题排查-Linux命令" class="headerlink" title="问题排查 - Linux命令"></a>问题排查 - Linux命令</h2><p><a href="https://www.pdai.tech/md/java/jvm/java-jvm-debug-tools-linux.html">https://www.pdai.tech/md/java/jvm/java-jvm-debug-tools-linux.html</a></p><h2 id="问题排查-工具"><a href="#问题排查-工具" class="headerlink" title="问题排查 - 工具"></a>问题排查 - 工具</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出 Java 应用程序中线程堆栈信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基本</span></span><br><span class="line">jstack 2815</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> java和native c/c++框架的所有栈信息</span></span><br><span class="line">jstack -m 2815</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 额外的锁信息列表，查看是否死锁</span></span><br><span class="line">jstack -l 2815</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-l 长列表. 打印关于锁的附加信息,例如属于java.util.concurrent 的 ownable synchronizers列表.</span><br><span class="line">-F 当’jstack [-l] pid’没有相应的时候强制打印栈信息</span><br><span class="line">-m 打印java和native c/c++框架的所有栈信息.</span><br><span class="line">-h | -help 打印帮助信息</span><br></pre></td></tr></table></figure><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看堆的情况</span></span><br><span class="line">jmap -heap 2815</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dump</span></span><br><span class="line">jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</span><br><span class="line">jmap -dump:format=b,file=/tmp/heap3.bin 2815</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看堆的占用</span></span><br><span class="line">jmap -histo 2815 | head -10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">no option： 查看进程的内存映像信息,类似 Solaris pmap 命令。</span><br><span class="line">heap： 显示Java堆详细信息</span><br><span class="line">histo[:live]： 显示堆中对象的统计信息</span><br><span class="line">clstats：打印类加载器信息</span><br><span class="line">finalizerinfo： 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">dump:&lt;dump-options&gt;：生成堆转储快照</span><br><span class="line">F： 当-dump没有响应时，使用-dump或者-histo参数. 在这个模式下,live子参数无效.</span><br><span class="line">help：打印帮助信息</span><br><span class="line">J&lt;flag&gt;：指定传递给运行jmap的JVM的参数</span><br></pre></td></tr></table></figure><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>jps是jdk提供的一个查看当前java进程的小工具， 可以看做是JavaVirtual Machine Process Status Tool的缩写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jps # 显示进程的ID 和 类的名称</span><br><span class="line">jps –l # 输出输出完全的包名，应用主类名，jar的完全路径名 </span><br><span class="line">jps –v # 输出jvm参数</span><br><span class="line">jps –q # 显示java进程号</span><br><span class="line">jps -m # main 方法</span><br><span class="line">jps -l xxx.xxx.xx.xx # 远程查看 </span><br><span class="line"></span><br><span class="line">-q：仅输出VM标识符，不包括classname,jar name,arguments in main method </span><br><span class="line">-m：输出main method的参数 </span><br><span class="line">-l：输出完全的包名，应用主类名，jar的完全路径名 </span><br><span class="line">-v：输出jvm参数 </span><br><span class="line">-V：输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件 </span><br><span class="line">-Joption：传递参数到vm,例如:-J-Xms512m</span><br></pre></td></tr></table></figure><p>java程序在启动以后，会在java.io.tmpdir指定的目录下，就是临时文件夹里，生成一个类似于hsperfdata_User的文件夹，这个文件夹里（在Linux中为/tmp/hsperfdata_{userName}/），有几个文件，名字就是java进程的pid，因此列出当前运行的java进程，只是把这个目录里的文件名列一下而已。 至于系统的参数什么，就可以解析这几个文件获得。</p><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>jinfo 是 JDK 自带的命令，可以用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的 JVM 一些参数。当系统崩溃时，jinfo可以从core文件里面知道崩溃的Java应用程序的配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出当前 jvm 进程的全部参数和系统属性</span></span><br><span class="line">jinfo 2815</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出所有的参数</span></span><br><span class="line">jinfo -flags 2815</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定的 jvm 参数的值</span></span><br><span class="line">jinfo -flag PrintGC 2815</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启/关闭指定的JVM参数</span></span><br><span class="line">jinfo -flag +PrintGC 2815</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置flag的参数</span></span><br><span class="line">jinfo -flag name=value 2815</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出当前 jvm 进行的全部的系统属性</span></span><br><span class="line">jinfo -sysprops 2815</span><br><span class="line"></span><br><span class="line">no option 输出全部的参数和系统属性</span><br><span class="line">-flag name 输出对应名称的参数</span><br><span class="line">-flag [+|-]name 开启或者关闭对应名称的参数</span><br><span class="line">-flag name=value 设定对应名称的参数</span><br><span class="line">-flags 输出全部的参数</span><br><span class="line">-sysprops 输出系统属性</span><br></pre></td></tr></table></figure><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>jstat参数众多，但是使用一个就够了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 2815 1000 </span><br></pre></td></tr></table></figure><h4 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h4><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h2 id="Java内存分析-堆内内存和MetaSpace内存"><a href="#Java内存分析-堆内内存和MetaSpace内存" class="headerlink" title="Java内存分析 - 堆内内存和MetaSpace内存"></a>Java内存分析 - 堆内内存和MetaSpace内存</h2><h2 id="Java内存分析-堆外内存"><a href="#Java内存分析-堆外内存" class="headerlink" title="Java内存分析 - 堆外内存"></a>Java内存分析 - 堆外内存</h2><h2 id="Java线程分析-线程Dump分析"><a href="#Java线程分析-线程Dump分析" class="headerlink" title="Java线程分析 - 线程Dump分析"></a>Java线程分析 - 线程Dump分析</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC锁-锁核心AQS-CLH前言</title>
      <link href="/posts/17182.html"/>
      <url>/posts/17182.html</url>
      
        <content type="html"><![CDATA[<p>相信大部分人在看AQS的时候都能看到注释上有这么一段话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wait queue node class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and</span></span><br><span class="line"><span class="comment"> * Hagersten) lock queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>为了更好的理解AQS中使用锁的思想，所以有必要好好了解下CLH锁。</p><h2 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>在了解CLH Node FIFO队列之前，首先要了解这种队列的几个要素之一：自旋锁。</p><p>所谓<strong>自旋锁</strong>，就是某一线程去尝试获取某个锁时，如果该锁已经被其他线程占用的话，当前线程将不断循环检查该锁是否被释放，而不是让当前线程挂起或睡眠。</p><p>自旋锁属于为了保证共享资源而提出的一种锁机制，与互斥锁类似，保证了公共资源在任意时刻最多只能由一个线程获取使用。不同的是，互斥锁在获取锁失败后线程将进入睡眠或阻塞状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            unsafe = getUnsafeInstance();</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(SpinLock.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafeInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Field theUnsafeInstance = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        ReflectionUtils.makeAccessible(theUnsafeInstance);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe) theUnsafeInstance.get(Unsafe.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; spinlock try&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> newV = value + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (newV == <span class="number">1</span> &amp;&amp; (unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, <span class="number">0</span>, newV))) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SpinLock spinLock = <span class="keyword">new</span> SpinLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    spinLock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; spinlock success&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    spinLock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; unlock&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很简单的自旋锁。<br>对于<strong>lock方法</strong>，假如有若干线程竞争，能成功通过CAS操作修改value值为newV的线程即是成功获取锁的线程，将直接通过，而其他的线程则<strong>不断循环</strong>检测value值是否又改回0。<br>而将value改为0的操作就是获取锁的线程执行完后对该锁进行释放，通过<strong>unlock方法</strong>释放锁，释放后若干线程又对该锁竞争。</p><h3 id="CLH核心思想"><a href="#CLH核心思想" class="headerlink" title="CLH核心思想"></a>CLH核心思想</h3><p><strong>CLH的作者：Craig, Landin, and Hagersten。</strong></p><blockquote><p>CLH lock is Craig, Landin, and Hagersten (CLH) locks,<br>CLH lock is a spin lock, can ensure no hunger, provide fairness first come first service.<br>The CLH lock is a scalable, high performance, fairness and spin lock based on the list,<br>the application thread spin only on a local variable, it constantly polling the precursor state,<br>if it is found that the pre release lock end spin.</p></blockquote><p>我们能看到它是一个自旋锁，能确保无饥饿性，提供先来先服务的公平性。同时它也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p><p>其核心思想是：通过一定手段将<strong>所有线程对某一共享变量轮询竞争</strong>转化为<strong>一个线程队列且队列中的线程各自轮询自己的本地变量</strong>。</p><p>这个转化过程有两个要点：</p><ul><li>一是构建怎样的队列、如何构建队列。<br>  为了保证公平性，构建的是一个FIFO队列，构建的时候主要通过移动尾部节点tail实现队列的排队，每个想获取锁的线程创建一个新节点并通过CAS原子操作将新节点赋予tail，然后让当前线程轮询前一节点的某个状态位。</li><li>二是如何释放锁。<br>  线程执行完后只需将当前线程对应的节点状态位更新为解锁状态，由于下一节点一直在轮询，下个线程便可获取到锁。</li></ul><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><p><img src="/posts/17182/CLH-java%E4%BB%A3%E7%A0%81%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p><ul><li>实现juc的Lock接口</li><li>定义CLHLock<br>  节点之间是通过隐形的链表相连，之所以叫隐形的链表是因为这些节点之间没有明显的next指针，而是通过myPred所指向的节点的变化情况来影响myNode的行为。<br>  CLHLock上还有一个尾指针tail，始终指向队列的最后一个节点。</li><li>定义QNode内部类<br>  CLH队列中的节点QNode中含有一个locked字段，该字段若为true表示该线程需要获取锁，且不释放锁，为false表示线程释放了锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CLH锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node节点内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CLH队列尾节点</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&gt; tail;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Node&gt; myPrev;</span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Node&gt; myNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLHLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化一个释放锁的节点，用作当前隐式队列的尾节点</span></span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">new</span> Node());</span><br><span class="line">        <span class="keyword">this</span>.myNode = ThreadLocal.withInitial(Node::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">this</span>.myPrev = ThreadLocal.withInitial(() -&gt; <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; try lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Node node = myNode.get();</span><br><span class="line">        node.locked = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将tail中缓存的node拿出来赋值给prev，将current放入tail中</span></span><br><span class="line">        Node prev = tail.getAndSet(node);</span><br><span class="line">        <span class="keyword">this</span>.myPrev.set(prev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋判断上一个节点是否释放锁，直至获取到锁</span></span><br><span class="line">        <span class="comment">// locked == true  表示当前节点期望获取锁</span></span><br><span class="line">        <span class="comment">// locked == false 表示当前节点已经释放锁</span></span><br><span class="line">        <span class="comment">// prev.locked == true  表示上一个节点未释放锁</span></span><br><span class="line">        <span class="comment">// prev.locked == false 表示上一个节点释放锁了, 也就意味着自己竞争到锁了</span></span><br><span class="line">        <span class="keyword">while</span> (prev.locked) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node node = myNode.get();</span><br><span class="line">        node.locked = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; unlock&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.myNode.remove();</span><br><span class="line">        <span class="keyword">this</span>.myPrev.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> CLHLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CLHLock的获取锁、释放锁过程"><a href="#CLHLock的获取锁、释放锁过程" class="headerlink" title="CLHLock的获取锁、释放锁过程"></a>CLHLock的获取锁、释放锁过程</h3><ul><li>获取锁<ol><li>当一个线程需要获取锁时，会创建一个新的QNode，</li><li>将其中的locked设置为true表示需要获取锁，</li><li>然后当前线程对tail域调用getAndSet方法，使自己(当前线程)成为队列的尾部，同时tail域返回旧的尾部节点作为当前线程的前驱引用myPred，</li><li>然后该线程就在前驱节点的locked字段上自旋，直到前驱节点释放锁。</li></ol></li><li>释放锁<br>  当一个线程需要释放锁时，将当前节点的locked域设置为false，同时回收前驱节点（把当前节点从链表的头部删除）。</li></ul><p>如下图所示，线程A需要获取锁，其myNode域为true，此时tail指向线程A的节点，然后线程B也加入到线程A后面，tail指向线程B的节点。然后线程A和B都在它的myPred域上旋转，一旦它的myPred节点的locked字段变为false，它就可以获取到锁。明显线程A的myPred locked值为false，此时线程A获取到了锁。</p><p><img src="/posts/17182/CLH-%E5%8A%A0%E9%94%81%E9%87%8A%E6%94%BE%E9%94%81%E8%BF%87%E7%A8%8B.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础-集合-TreeMap</title>
      <link href="/posts/36194.html"/>
      <url>/posts/36194.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。</p><p>TreeMap底层通过<strong>红黑树（Red-Black tree）</strong>实现，也就意味着containsKey()、get()、put()、remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><img src="/posts/36194/TreeMap-%E7%BB%93%E6%9E%84.png"></p><p>出于性能原因，TreeMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；<br>或者通过如下方式将TreeMap包装成(wrapped)同步的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedMap m = Collections.synchronizedSortedMap(<span class="keyword">new</span> TreeMap(...));</span><br></pre></td></tr></table></figure><p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。</strong><br>具体来说，红黑树是满足如下条件的二叉查找树(binary search tree)：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至null(树尾端)的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p><h2 id="左旋-amp-右旋"><a href="#左旋-amp-右旋" class="headerlink" title="左旋 &amp; 右旋"></a>左旋 &amp; 右旋</h2><p>当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。</p><p>调整可以分为两类:<br>一类是颜色调整，即改变某个节点的颜色；<br>另一类是结构调整，即改变检索树的结构关系。结构调整过程包含两个基本操作: **左旋(Rotate Left)<strong>、</strong>右旋(RotateRight)**。</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>左旋的过程是将<strong>x</strong>的右子树绕<strong>x</strong>逆时针旋转，使得<strong>x</strong>的右子树成为<strong>x</strong>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/posts/36194/TreeMap-rotateLeft.png"></p><p>TreeMap中左旋代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rotate Left</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>右旋的过程是将<strong>x</strong>的左子树绕<strong>x</strong>顺时针旋转，使得<strong>x</strong>的左子树成为<strong>x</strong>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/posts/36194/TreeMap-rotateRight.png"></p><p>TreeMap中右旋代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rotate Right</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找节点后继"><a href="#寻找节点后继" class="headerlink" title="寻找节点后继"></a>寻找节点后继</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-基础-集合-PriorityQueue</title>
      <link href="/posts/62869.html"/>
      <url>/posts/62869.html</url>
      
        <content type="html"><![CDATA[<p>优先队列的作用是能保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。<br>这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><p>Java中PriorityQueue实现了Queue接口，不允许放入<code>null</code>元素。<br>其通过<strong>堆</strong>实现，具体说是通过**完全二叉树(complete binary tree)<strong>实现的</strong>小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)**，也就意味着可以通过数组来作为PriorityQueue的底层实现。</p><p><img src="/posts/62869/PriorityQueue-%E7%BB%93%E6%9E%84.png"></p><p>父子节点的编号之间有如下关系：</p><ol><li>leftNo = parentNo*2+1</li><li>rightNo = parentNo*2+2</li><li>parentNo = (nodeNo-1)/2</li></ol><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。<br>这也就是为什么可以直接用数组来存储堆的原因。</p><p>PriorityQueue的peek()和element()操作是常数时间；add()、offer()、无参数的remove()以及poll()方法的时间复杂度都是log(N)。</p><h2 id="PriorityQueue方法剖析"><a href="#PriorityQueue方法剖析" class="headerlink" title="PriorityQueue方法剖析"></a>PriorityQueue方法剖析</h2><h3 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h3><h3 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h3><h3 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h3><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><h2 id="top-K问题"><a href="#top-K问题" class="headerlink" title="top-K问题"></a>top-K问题</h2><blockquote><p><strong>给你100w个数据，设计一个算法找到你前10个最大的元素</strong></p></blockquote><ol><li>思路一<br> 从小到大排序，再输出后10个元素，这虽然是一种解决方法，但面试官一般不会让你这样做，那样这个问题就没有意义了</li><li>思路二<br> 将这一百万个元素整体建成一个大根堆，再依次出队10个元素即可，但占用的内存是不是有点多呢？</li><li><strong>最优解</strong><br> <strong>只建k个元素的小根堆，如果后续元素比堆顶元素大，那么先出队，然后再将这个元素入队，当遍历完整个数据时，最后小根堆上即为我们的top-k。</strong></li></ol><p><strong>延伸问题</strong>：</p><ol><li>求前k个最大元素，建一个k个元素的小根堆，如果后续元素比堆顶元素大，那么先出队，然后再将这个元素入队</li><li>求前k个最小元素，建一个k个元素的大根堆，如果后续元素比堆顶元素小，那么先出队，然后再将这个元素入队</li><li>求第k大的元素，建一个小堆，堆顶元素就是第k大的元素</li><li>求第k小的元素，建一个大堆，堆顶元素就是第k小的元素</li></ol><h3 id="代码实现：求数组中前K个最小的元素-大根堆"><a href="#代码实现：求数组中前K个最小的元素-大根堆" class="headerlink" title="代码实现：求数组中前K个最小的元素 - 大根堆"></a>代码实现：求数组中前K个最小的元素 - 大根堆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopK</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求数组中前K个最小的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topk(<span class="keyword">int</span>[] array ,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="comment">//1.创建一个大小为k的大根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//2.遍历数组中当中的元素，前k个元素放到队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxHeap.size() &lt; k)&#123;</span><br><span class="line">                maxHeap.offer(array[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> top = maxHeap.peek();</span><br><span class="line">                <span class="keyword">if</span> (top &gt; array[i])&#123;</span><br><span class="line">                    maxHeap.poll();</span><br><span class="line">                    maxHeap.offer(array[i]);<span class="comment">//将新元素放入其中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ret[i] = maxHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">18</span>,<span class="number">21</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">34</span>,<span class="number">21</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ret = topk(array, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(ret));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Collection - Stack &amp; Queue &amp; Deque</title>
      <link href="/posts/6320.html"/>
      <url>/posts/6320.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java里有一个叫做Stack的类，却没有叫做Queue的类(它是个接口名字)。</p><p>当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；<br>既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了(次选是LinkedList)。</p><p><strong>为什么Stack被弃用</strong><br>Java 中的 Stack 实现，是被业界一直认为非常糟糕的实现。<br>实际上，它犯了面向对象设计领域的一个基本错误：Stack 和 Vector 之间的关系，不应该是继承关系，而应该是组合关系（composition）。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的insertion, extraction和inspection操作。<br>这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p><table><thead><tr><th align="left"></th><th align="left">Throws exception</th><th align="left">Returns special value</th></tr></thead><tbody><tr><td align="left">Insert</td><td align="left">add(e)</td><td align="left">offer(e)</td></tr><tr><td align="left">Remove</td><td align="left">remove()</td><td align="left">poll()</td></tr><tr><td align="left">Examine</td><td align="left">element()</td><td align="left">peek()</td></tr></tbody></table><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code>是”double ended queue”，表示双向的队列，英文读作”deck”。<br>Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持insert，remove和examine操作。<br>由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p><table><thead><tr><th align="left"></th><th align="left">First Element - Head</th><th align="left"></th><th align="left">Last Element - Tail</th><th align="left"></th></tr></thead><tbody><tr><td align="left"></td><td align="left">Throws exception</td><td align="left">Special value</td><td align="left">Throws exception</td><td align="left">Special value</td></tr><tr><td align="left">Insert</td><td align="left">addFirst(e)</td><td align="left">offerFirst(e)</td><td align="left">addLast(e)</td><td align="left">offerLast(e)</td></tr><tr><td align="left">Remove</td><td align="left">removeFirst()</td><td align="left">pollFirst()</td><td align="left">removeLast()</td><td align="left">pollLast()</td></tr><tr><td align="left">Examine</td><td align="left">getFirst()</td><td align="left">peekFirst()</td><td align="left">getLast()</td><td align="left">peekLast()</td></tr></tbody></table><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p><code>ArrayDeque</code>和<code>LinkedList</code>是<code>Deque</code>的两个通用实现，官方更推荐使用<code>AarryDeque</code>用作栈和队列。</p><p>从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组(circular array)，也就是说数组的任何一点都可能被看作起点或者终点。<br>ArrayDeque是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。</p><p><img src="/posts/6320/ArrayDeque-%E7%BB%93%E6%9E%84.png"><br>head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-GC-垃圾回收基础知识</title>
      <link href="/posts/38537.html"/>
      <url>/posts/38537.html</url>
      
        <content type="html"><![CDATA[<p>垃圾收集主要是针对堆和方法区进行。<br>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。</p><h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><h3 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h3><h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。<br>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 具有四种强度不同的引用类型。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来实现弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。<br>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">------</span><br><span class="line">著作权归<span class="meta">@pdai</span>所有</span><br><span class="line">原文链接：https:<span class="comment">//pdai.tech/md/java/jvm/java-jvm-gc.html</span></span><br></pre></td></tr></table></figure><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/posts/38537/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-%E6%B1%87%E6%80%BB.jpg"><br>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li><li>串行与并行: 串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h3><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）</p><ul><li><strong>部分收集</strong><br>  不是完整收集整个 Java 堆的垃圾收集。<br>  其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集<ul><li>目前只有 G1 GC 会有这种行为</li></ul></li></ul></li><li><strong>整堆收集</strong><br>  收集整个 Java 堆和方法区的垃圾</li></ul><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ol><li>对象优先在Eden分配<br> 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</li><li>大对象直接进入老年代<br> 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。<br> 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。<br> -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</li><li>长期存活的对象进入老年代<br> 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。<br> -XX:MaxTenuringThreshold 用来定义年龄的阈值。</li><li>动态对象年龄判定<br> 虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</li><li>空间分配担保<br> 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。<br> 如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</li></ol><h3 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。</p><p>而 Full GC 则相对复杂，有以下条件：</p><ol><li>调用 System.gc()<br> 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。<br> 不建议使用这种方式，而是让虚拟机管理内存。</li><li>老年代空间不足<br> 老年代空间不足的常见场景为前文所讲的<strong>大对象直接进入老年代</strong>、<strong>长期存活的对象进入老年代</strong>等。<br> 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。<br> 除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。<br> 还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</li><li>空间分配担保失败<br> 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</li><li>JDK 1.7 及以前的永久代空间不足、<br> 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。<br> 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。<br> 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</li><li>Concurrent Mode Failure<br> 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-基础-Java内存模型</title>
      <link href="/posts/10759.html"/>
      <url>/posts/10759.html</url>
      
        <content type="html"><![CDATA[<h2 id="JMM引入"><a href="#JMM引入" class="headerlink" title="JMM引入"></a>JMM引入</h2><h2 id="JMM与硬件内存结构关系"><a href="#JMM与硬件内存结构关系" class="headerlink" title="JMM与硬件内存结构关系"></a>JMM与硬件内存结构关系</h2><h3 id="硬件内存结构简介"><a href="#硬件内存结构简介" class="headerlink" title="硬件内存结构简介"></a>硬件内存结构简介</h3><h3 id="JMM与硬件内存连接-引入"><a href="#JMM与硬件内存连接-引入" class="headerlink" title="JMM与硬件内存连接 - 引入"></a>JMM与硬件内存连接 - 引入</h3><p><img src="/posts/10759/jmm-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E8%BF%9E%E6%8E%A5-%E5%BC%95%E5%85%A5.png"></p><h3 id="JMM与硬件内存连接-对象共享后的可见性"><a href="#JMM与硬件内存连接-对象共享后的可见性" class="headerlink" title="JMM与硬件内存连接 - 对象共享后的可见性"></a>JMM与硬件内存连接 - 对象共享后的可见性</h3><p><img src="/posts/10759/jmm-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E8%BF%9E%E6%8E%A5-%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E5%90%8E%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7.png"></p><h3 id="JMM与硬件内存连接-竞态条件"><a href="#JMM与硬件内存连接-竞态条件" class="headerlink" title="JMM与硬件内存连接 - 竞态条件"></a>JMM与硬件内存连接 - 竞态条件</h3><p>如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能会出现竞态。</p><p><img src="/posts/10759/jmm-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E8%BF%9E%E6%8E%A5-%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-基础-JVM内存结构</title>
      <link href="/posts/28482.html"/>
      <url>/posts/28482.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/28482/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F-%E7%9F%A5%E8%AF%86%E7%82%B9.jpg"></p><p><a href="https://www.pdai.tech/md/java/jvm/java-jvm-struct.html">https://www.pdai.tech/md/java/jvm/java-jvm-struct.html</a></p><h2 id="运行时数据区域总览"><a href="#运行时数据区域总览" class="headerlink" title="运行时数据区域总览"></a>运行时数据区域总览</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。<br>JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p><p>下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。<br><img src="/posts/28482/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F-JVM%E6%9E%B6%E6%9E%84%E5%9B%BE%E7%A4%BA.jpg"></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p><ul><li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法栈</li><li><strong>线程共享</strong>：堆、方法区、堆外内存（<strong>Java7的永久代</strong>或<strong>JDK8的元空间、代码缓存</strong>）</li></ul><blockquote><p>栈是运行时的单位，而堆是存储的单位。<br>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p></blockquote><h2 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h2><p>程序计数寄存器（Program Counter Register），Register的命名源于CPU的寄存器，寄存器存储指令相关的线程信息，CPU只有把数据装载到寄存器才能够运行。<br>这里，并非是广义上所指的物理寄存器，叫程序计数器（或PC计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</strong></p><p><strong>程序计数器</strong>是一块较小的内存空间，可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>PC寄存器用来存储指向下一条指令的地址，即将要执行的指令代码，由执行引擎读取下一条指令。</p><p><img src="/posts/28482/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-%E5%9B%BE%E7%A4%BA.jpg"><br>（分析：进入class文件所在目录，执行 <code>javap -v xx.class</code> 反解析（或者通过 IDEA 插件 <code>Jclasslib</code> 直接查看，上图），可以看到当前类对应的Code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。）</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>通过下面两个问题，理解下PC计数器。</p><ol><li><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前现成的执行地址呢？</strong><br> 因为CPU需要不停的切换各个线程，这时候切换回来以后，需要知道接着从哪条指令开始继续执行。<br> JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p></li><li><p><strong>PC寄存器为什么会被设定为线程私有的？</strong><br> 多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停地做时间片切换，这样必然会导致频繁的中断或恢复。<br> 为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p></li></ol><p>相关总结如下：</p><ul><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li><li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li><strong>它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域</strong></li></ul><h2 id="二、虚拟机栈"><a href="#二、虚拟机栈" class="headerlink" title="二、虚拟机栈"></a>二、虚拟机栈</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Java 虚拟机栈(Java Virtual Machine Stacks)，早期也叫 Java 栈。<br>每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，对应着一次次 Java 方法调用；是线程私有的，生命周期和线程一致。</p><p><strong>作用</strong>：主管Java程序的运行，虚拟机栈保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><p><strong>特点</strong>：</p><ul><li>虚拟机栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM直接对虚拟机栈的操作只有两个：<strong>每个方法执行伴随着入栈(进栈/压栈)<strong>，</strong>方法执行结束出栈</strong></li><li><strong>栈不存在垃圾回收问题</strong></li></ul><p><strong>栈中可能出现的异常</strong>：<br>JVM虚拟机规范允许虚拟机栈的大小是动态的或者是固定不变的。</p><ul><li>如果采用<strong>固定大小</strong>的Java虚拟机栈<br>  固定大小时，每个线程的虚拟机栈的容器可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，JVM将会抛出<strong>StackOverflowError</strong>异常。</li><li>如果允许Java虚拟机栈<strong>动态扩展</strong><br>  允许动态扩展时，若线程在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，JVM将会抛出<strong>OutOfMemoryError</strong>异常。</li></ul><p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><p>栈中存储什么？</p><ul><li>每个线程都有自己的栈，栈中的数据都是以**栈帧(Stack Frame)**的格式存在</li><li>在这个线程上，正在执行的每个方法都各自有应对的一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><ol><li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈和出栈</strong>，遵循“先进后出/后进先出”原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。<br> 即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧、</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li></ol><p>IDEA 在 debug 时候，可以在 debug 窗口看到 Frames 中各种方法的压栈和出栈情况。<br><img src="/posts/28482/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-%E6%A0%88%E5%B8%A7-debug.jpg"></p><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个<strong>栈帧（Stack Frame）</strong>中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）(或称为表达式栈)</li><li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li><li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li><li>附加信息</li></ul><p><img src="/posts/28482/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-%E6%A0%88%E5%B8%A7-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg"></p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表也被称为局部变量数组或者本地变量表，是一组变量值存储空间，主要用于存储<strong>方法参数</strong>和<strong>定义在方法体内的局部变量</strong>，包括编译器可知的各种 Java 虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong>。</p><p><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p><p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束。</p><h5 id="槽-Slot"><a href="#槽-Slot" class="headerlink" title="槽 Slot"></a>槽 Slot</h5><p>局部变量表最基本的存储单元是 Slot（变量槽）。</p><p>在局部变量表中，32 位以内的类型只占用一个 Slot(包括returnAddress类型)，64 位的类型（long和double）占用两个连续的 Slot</p><ul><li>byte(1B)、short(2B)、char(2B) 在存储前被转换为int，boolean也被转换为int，0 表示 false，非 0 表示 true</li><li>long 和 double 则占据两个 Slot</li></ul><p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量。</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 Slot 上。</p><p>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）。</p><p>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：<strong>静态方法中为什么不可以引用 this，就是因为this 变量不存在于当前静态方法的局部变量表中</strong>）。</p><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。（下图中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽）。<br><img src="/posts/28482/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-%E6%A0%88%E5%B8%A7-%E6%A7%BD.jpg"></p><p>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。<br><strong>局部变量表中的变量</strong>也是重要的<strong>垃圾回收根节点</strong>，<strong>只要被局部变量表中直接或间接引用的对象都不会被回收</strong>。</p><h4 id="操作数栈（表达式栈）"><a href="#操作数栈（表达式栈）" class="headerlink" title="操作数栈（表达式栈）"></a>操作数栈（表达式栈）</h4><p>每个独立的栈帧中除了局部变量表之外，还包含一个先进后出的操作数栈，也可以称为表达式栈。</p><p><strong>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。<br>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的<code>max_stack</code>数据项中。</p><p>栈中的任何一个元素都可以是任意的 Java 数据类型。32bit 的类型占用一个栈单位深度，64bit 的类型占用两个栈单位深度。</p><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>。</p><h5 id="栈顶缓存-Top-of-stack-Cashing"><a href="#栈顶缓存-Top-of-stack-Cashing" class="headerlink" title="栈顶缓存 Top-of-stack-Cashing"></a>栈顶缓存 Top-of-stack-Cashing</h5><p>HotSpot 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 HotSpot VM 的实现并没有间接利用到寄存器资源。寄存器是物理 CPU 中的组成部分之一，它同时也是 CPU 中非常重要的高速存储资源。一般来说，寄存器的读/写速度非常迅速，甚至可以比内存的读/写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的CPU 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。<br>为了解决这个问题，<strong>HotSpot JVM</strong>设计者们提出了<strong>栈顶缓存</strong>技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong>。</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。</p><p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用（Symbolic Reference）</strong>保存在 Class 文件的常量池中。<br>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。<br><img src="/posts/28482/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.jpg"></p><p><strong>Q：JVM是如何执行方法调用的？</strong><br>方法调用不同于方法执行，<strong>方法调用阶段</strong>的唯一任务就是<strong>确定被调用方法的版本（即调用哪一个方法）</strong>，暂时还不涉及方法内部的具体运行过程。<br>Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在Class文件里面存储的都是<strong>符号引用</strong>，而不是<strong>方法在实际运行时内存布局中的入口地址（直接引用）</strong>。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p><p>在 JVM 中，将<strong>符号引用转换为调用方法的直接引用</strong>与<strong>方法的绑定机制</strong>有关，<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p><ul><li>静态链接 - 早期绑定<br>  当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在<strong>编译期</strong>可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li><li>动态链接 - 晚期绑定<br>  如果被调用的方法在编译期无法被确定下来，也就是说，<strong>只能在程序运行期</strong>将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li></ul><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>方法返回地址（return address），用来存放调用该方法的 PC 寄存器的值。</p><p>一个方法的结束，有两种方式：1、正常执行完成；2、出现未处理的异常，非正常退出。</p><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。<br>方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。<br>而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。</p><p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。<br>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h2 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h2><p>本地方法栈（Native Method Stack），Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用，本地方法是使用 C 语言实现的。<br>本地方法栈也是线程私有的。<br>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><h3 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h3><p>简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p><p><strong>Q：为什么要使用本地方法（Native Method）?</strong></p><h2 id="四、堆内存"><a href="#四、堆内存" class="headerlink" title="四、堆内存"></a>四、堆内存</h2><h3 id="内存划分：年轻代、老年代、永久代-元空间"><a href="#内存划分：年轻代、老年代、永久代-元空间" class="headerlink" title="内存划分：年轻代、老年代、永久代/元空间"></a>内存划分：年轻代、老年代、永久代/元空间</h3><p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。<br>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>在逻辑上</strong>划分成三块区域（<strong>分代的唯一理由就是优化 GC 性能</strong>）：</p><ul><li>新生代（年轻代）：新对象和没达到一定年龄的对象都在新生代</li><li>老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li><li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</li></ul><p><img src="/posts/28482/%E5%A0%86%E5%86%85%E5%AD%98-%E5%88%86%E4%BB%A3%E7%BB%93%E6%9E%84.jpg"><br><img src="/posts/28482/%E5%A0%86%E5%86%85%E5%AD%98-%E5%88%86%E4%BB%A3%E7%BB%93%E6%9E%842.jpg"></p><p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过<code>-Xmx</code>和<code>-Xms</code>控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。<br><code>-Xms</code> 用来表示堆的<strong>起始内存</strong>，等价于 -XX:InitialHeapSize<br><code>-Xmx</code> 用来表示堆的<strong>最大内存</strong>，等价于 -XX:MaxHeapSize</p><h4 id="年轻代-Yound-Generation"><a href="#年轻代-Yound-Generation" class="headerlink" title="年轻代 Yound Generation"></a>年轻代 Yound Generation</h4><p>年轻代是所有新对象创建的地方。<br>当年轻代不够分配时，执行垃圾收集，发生在年轻代的垃圾收集称为<code>Minor GC</code>。<br>年轻代被分为三个部分：伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory，被称为from/to或s0/s1</strong>），默认比例是<code>8:1:1</code>。</p><h4 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代 Old Generation"></a>老年代 Old Generation</h4><p>老年代内存包含那些经过许多轮小型 GC 后仍然存活的对象。<br>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝。</p><p>通常，垃圾收集是在老年代内存满时执行的，老年代垃圾收集称为<code>主GC（Major GC）</code>，通常需要更长的时间。</p><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><p><strong>什么是 TLAB （Thread Local Allocation Buffer）?</strong></p><ul><li>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</li><li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策略</li><li>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</li></ul><p><strong>为什么要有 TLAB ?</strong></p><ul><li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>在程序中，可以通过<code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。<br>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过<code>-XX:TLABWasteTargetPercent</code>设置 TLAB 空间所占用 Eden 空间的百分比大小。<br>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p><h3 id="堆是分配对象存储的唯一选择吗"><a href="#堆是分配对象存储的唯一选择吗" class="headerlink" title="堆是分配对象存储的唯一选择吗"></a>堆是分配对象存储的唯一选择吗</h3><blockquote><p>随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 ——《深入理解 Java 虚拟机》</p></blockquote><h2 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h2><p>方法区（Method Area）与 Java 堆一样，是所有<strong>线程共享</strong>的内存区域。<br>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。<br>Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。<br>运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 String.intern()方法。</p><p>受方法区内存的限制，当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。JVM 关闭后方法区即被释放。</p><p><strong>方法区（method area）只是 JVM 规范中定义的一个概念</strong>，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。</p><p>永久代（PermGen）是 <code>Hotspot</code> 虚拟机特有的概念， Java8的时候又被元空间取代了。永久代和元空间都可以理解为方法区的落地实现。<br>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）。</p><h3 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><ul><li>类型信息<br>  对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：<ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul></li><li>域Field信息<ul><li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li></ul></li><li>方法信息<ul><li>方法名称</li><li>方法的返回类型</li><li>方法参数的数量和类型</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）。</p><h4 id="字节码文件的常量池"><a href="#字节码文件的常量池" class="headerlink" title="字节码文件的常量池"></a>字节码文件的常量池</h4><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。<br><strong>Q：为什么需要常量池？</strong><br>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p><p>如下，我们通过 jclasslib 查看一个只有 Main 方法的简单类，字节码中的 #2 指向的就是 Constant Pool<br><img src="/posts/28482/%E6%96%B9%E6%B3%95%E5%8C%BA-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0.jpg"><br>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>在加载类和结构到虚拟机后，就会创建对应的运行时常量池。</p><p><strong>常量池表（Constant Pool Table）</strong>是<strong>Class字节码文件</strong>的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</p><p>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><h3 id="方法区在JDK6、7、8中的演进细节"><a href="#方法区在JDK6、7、8中的演进细节" class="headerlink" title="方法区在JDK6、7、8中的演进细节"></a>方法区在JDK6、7、8中的演进细节</h3><p>只有 HotSpot 才有永久代的概念。</p><ul><li>jdk1.6及之前有永久代，静态变量存放在永久代上</li><li>jdk1.7有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</li><li>jdk1.8及之后取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</li></ul><p><strong>HotSpot中字符串常量池保存哪里？永久代？方法区还是堆区？</strong></p><ul><li>运行时常量池（Runtime Constant Pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个逻辑上的概念；而堆区、永久代以及元空间是实际的存放位置。</li><li>不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 HotSpot 才有永久代的概念。</li><li>HotSpot也是发展的，由于一些问题的存在，HotSpot考虑逐渐去永久代，对于不同版本的JDK，实际的存储位置是有差异的，具体看如下表格：<table><thead><tr><th align="left">JDK版本</th><th align="left">是否有永久代，字符串常量池放在哪里？</th><th align="left">方法区逻辑上规范，由哪些实际的部分实现的？</th></tr></thead><tbody><tr><td align="left">jdk1.6及之前</td><td align="left">有永久代，运行时常量池（包括字符串常量池）、静态变量存放在永久代上</td><td align="left">这个时期方法区在HotSpot中是由永久代来实现的，以至于这个时期说方法区就是指永久代</td></tr><tr><td align="left">jdk1.7</td><td align="left">有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</td><td align="left">这个时期方法区在HotSpot中由永久代（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现</td></tr><tr><td align="left">jdk1.8及之后</td><td align="left">取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td><td align="left">这个时期方法区在HotSpot中由本地内存的元空间（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-知识体系</title>
      <link href="/posts/33596.html"/>
      <url>/posts/33596.html</url>
      
        <content type="html"><![CDATA[<h2 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h2><p><img src="/posts/33596/jvm-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.png"></p><h2 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h2><p>不同的虚拟机实现方式上也有差别，如果没有特别指出，这里的JVM指的是sun的HotSpot<br>不同的JDK版本略有差别，这里主要以1.8为主。</p><p><img src="/posts/33596/jvm-jdk8.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-基础-类字节码详解</title>
      <link href="/posts/13008.html"/>
      <url>/posts/13008.html</url>
      
        <content type="html"><![CDATA[<p>Java源代码通过编译器编译为字节码，再通过类加载子系统进行加载到JVM中运行。</p><h2 id="多语言编译为字节码在JVM运行"><a href="#多语言编译为字节码在JVM运行" class="headerlink" title="多语言编译为字节码在JVM运行"></a>多语言编译为字节码在JVM运行</h2><p>计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。<br>这个编译后的java代码，就是本文要介绍的java字节码。</p><p>为什么jvm不能直接运行java代码呢，这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的，所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。</p><ul><li>Java代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li><li>JVM不只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。</li></ul><p><img src="/posts/13008/JVM-%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81.png"></p><h2 id="Java字节码文件"><a href="#Java字节码文件" class="headerlink" title="Java字节码文件"></a>Java字节码文件</h2><p>class文件本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。</p><p>Class文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。这里暂不详细的讲。</p><p>本文将通过简单的java例子编译后的文件来理解。</p><h3 id="Class文件的结构属性"><a href="#Class文件的结构属性" class="headerlink" title="Class文件的结构属性"></a>Class文件的结构属性</h3><p>在理解之前先从整体看下java字节码文件包含了哪些类型的数据：<br><img src="/posts/13008/JVM-class%E6%96%87%E4%BB%B6.png"></p><h3 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h3><p>下面以一个简单的例子来逐步讲解字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下命令, 可以在当前所在路径下生成一个Main.class文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br></pre></td></tr></table></figure><p>以文本的形式打开生成的class文件，内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cafe babe 0000 0034 0013 0a00 0400 0f09</span><br><span class="line">0003 0010 0700 1107 0012 0100 016d 0100</span><br><span class="line">0149 0100 063c 696e 6974 3e01 0003 2829</span><br><span class="line">5601 0004 436f 6465 0100 0f4c 696e 654e</span><br><span class="line">756d 6265 7254 6162 6c65 0100 0369 6e63</span><br><span class="line">0100 0328 2949 0100 0a53 6f75 7263 6546</span><br><span class="line">696c 6501 0009 4d61 696e 2e6a 6176 610c</span><br><span class="line">0007 0008 0c00 0500 0601 0010 636f 6d2f</span><br><span class="line">7268 7974 686d 372f 4d61 696e 0100 106a</span><br><span class="line">6176 612f 6c61 6e67 2f4f 626a 6563 7400</span><br><span class="line">2100 0300 0400 0000 0100 0200 0500 0600</span><br><span class="line">0000 0200 0100 0700 0800 0100 0900 0000</span><br><span class="line">1d00 0100 0100 0000 052a b700 01b1 0000</span><br><span class="line">0001 000a 0000 0006 0001 0000 0003 0001</span><br><span class="line">000b 000c 0001 0009 0000 001f 0002 0001</span><br><span class="line">0000 0007 2ab4 0002 0460 ac00 0000 0100</span><br><span class="line">0a00 0000 0600 0100 0000 0800 0100 0d00</span><br><span class="line">0000 0200 0e</span><br></pre></td></tr></table></figure><ul><li>文件开头的4个字节(“cafe babe”)称之为<code>魔数</code>，唯有以”cafe babe”开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。</li><li>0000是编译器jdk版本的次版本号0，0034转化为十进制是52，是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外了，以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。</li><li>继续往下是常量池…</li></ul><h3 id="反编译字节码文件"><a href="#反编译字节码文件" class="headerlink" title="反编译字节码文件"></a>反编译字节码文件</h3><p>使用到java内置的一个反编译工具javap可以反编译字节码文件, 用法: <code>javap &lt;options&gt; &lt;classes&gt;</code><br>其中<code>&lt;options&gt;</code>选项包括:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-help  --help  -?        输出此用法消息</span><br><span class="line">-version                 版本信息</span><br><span class="line">-v  -verbose             输出附加信息</span><br><span class="line">-l                       输出行号和本地变量表</span><br><span class="line">-public                  仅显示公共类和成员</span><br><span class="line">-protected               显示受保护的/公共类和成员</span><br><span class="line">-package                 显示程序包/受保护的/公共类</span><br><span class="line">                         和成员 (默认)</span><br><span class="line">-p  -private             显示所有类和成员</span><br><span class="line">-c                       对代码进行反汇编</span><br><span class="line">-s                       输出内部类型签名</span><br><span class="line">-sysinfo                 显示正在处理的类的</span><br><span class="line">                         系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">-constants               显示最终常量</span><br><span class="line">-classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">-cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">-bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><p>输入命令<code>javap -verbose -p Main.class</code>查看输出内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class</span><br><span class="line">  Last modified <span class="number">2018</span>-<span class="number">4</span>-<span class="number">7</span>; size <span class="number">362</span> bytes</span><br><span class="line">  MD5 checksum 4aed8540b098992663b7ba08c65312de</span><br><span class="line">  Compiled from <span class="string">&quot;Main.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">rhythm7</span>.<span class="title">Main</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">4.</span>#<span class="number">18</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">19</span>         <span class="comment">// com/rhythm7/Main.m:I</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">20</span>            <span class="comment">// com/rhythm7/Main</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               m</span><br><span class="line">   #<span class="number">6</span> = Utf8               I</span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lcom/rhythm7/Main;</span><br><span class="line">  #<span class="number">14</span> = Utf8               inc</span><br><span class="line">  #<span class="number">15</span> = Utf8               ()I</span><br><span class="line">  #<span class="number">16</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">17</span> = Utf8               Main.java</span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">19</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// m:I</span></span><br><span class="line">  #<span class="number">20</span> = Utf8               com/rhythm7/Main</span><br><span class="line">  #<span class="number">21</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.rhythm7.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/rhythm7/Main;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field m:I</span></span><br><span class="line">         <span class="number">4</span>: iconst_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/rhythm7/Main;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Main.java&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字节码文件信息"><a href="#字节码文件信息" class="headerlink" title="字节码文件信息"></a>字节码文件信息</h3><p>开头的7行信息包括：Class文件当前所在位置，最后修改时间，文件大小，MD5值，编译自哪个文件，类的全限定名，jdk次版本号，主版本号。<br>然后紧接着的是该类的<strong>访问标志</strong>。</p><table><thead><tr><th align="left">标志名称</th><th align="left">标志值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">ACC_PUBLIC</td><td align="left">0x0001</td><td align="left">是否为Public类型</td></tr><tr><td align="left">ACC_FINAL</td><td align="left">0x0010</td><td align="left">是否被声明为final，只有类可以设置</td></tr><tr><td align="left">ACC_SUPER</td><td align="left">0x0020</td><td align="left">是否允许使用invokespecial字节码指令的新语义</td></tr><tr><td align="left">ACC_INTERFACE</td><td align="left">0x0200</td><td align="left">标志这是一个接口</td></tr><tr><td align="left">ACC_ABSTRACT</td><td align="left">0x0400</td><td align="left">是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td align="left">ACC_SYNTHETIC</td><td align="left">0x1000</td><td align="left">标志这个类并非由用户代码产生</td></tr><tr><td align="left">ACC_ANNOTATION</td><td align="left">0x2000</td><td align="left">标志这是一个注解</td></tr><tr><td align="left">ACC_ENUM</td><td align="left">0x4000</td><td align="left">标志这是一个枚举</td></tr></tbody></table><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><code>Constant pool</code>意为常量池。</p><p>常量池可以理解成Class文件中的资源仓库。主要存放的是两大类常量：字面量(Literal)和符号引用(Symbolic References)。<br>字面量类似于java中的常量概念，如文本字符串，final常量等。<br>符号引用则属于编译原理方面的概念，包括以下三种：</p><ul><li>类和接口的全限定名(Fully Qualified Name)</li><li>字段的名称和描述符号(Descriptor)</li><li>方法的名称和描述符</li></ul><p>不同于C/C++, JVM是在加载Class文件的时候才进行的动态链接，也就是说这些字段和方法符号引用只有在运行期转换后才能获得真正的内存入口地址。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时解析并翻译到具体的内存地址中。 </p><p>直接通过反编译文件来查看字节码内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">18</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">#<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">#<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">#<span class="number">8</span> = Utf8               ()V</span><br><span class="line">#<span class="number">18</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">#<span class="number">21</span> = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure><p><strong>第一个常量</strong>是一个方法定义，指向了第4和第18个常量。以此类推查看第4和第18个常量。最后可以拼接成第一个常量右侧的注释内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java/lang/Object.<span class="string">&quot;&lt;init&gt;&quot;</span>:()V</span><br></pre></td></tr></table></figure><p>这段可以理解为该类的实例构造器的声明，由于Main类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了Main类的直接父类是Object。 该方法默认返回值是V, 也就是void，无返回值。</p><p><strong>第二个常量</strong>同理可得：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">19</span>         <span class="comment">// com/rhythm7/Main.m:I</span></span><br><span class="line">#<span class="number">3</span> = Class              #<span class="number">20</span>            <span class="comment">// com/rhythm7/Main</span></span><br><span class="line">#<span class="number">5</span> = Utf8               m</span><br><span class="line">#<span class="number">6</span> = Utf8               I</span><br><span class="line">#<span class="number">19</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// m:I</span></span><br><span class="line">#<span class="number">20</span> = Utf8               com/rhythm7/Main</span><br></pre></td></tr></table></figure><p>关于字节码的类型对应如下：<br>| 标识字符 | 含义                                       |<br>| :——- | :—————————————– |<br>| B        | 基本类型byte                               |<br>| C        | 基本类型char                               |<br>| D        | 基本类型double                             |<br>| F        | 基本类型float                              |<br>| I        | 基本类型int                                |<br>| J        | 基本类型long                               |<br>| S        | 基本类型short                              |<br>| Z        | 基本类型boolean                            |<br>| V        | 特殊类型void                               |<br>| L        | 对象类型，以分号结尾，如Ljava/lang/Object; |</p><p>对于数组类型，每一位使用一个前置的<code>[</code>字符来描述，如定义一个**java.lang.String[][]**类型的维数组，将被记录为<code>[[Ljava/lang/String;</code></p><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的16进制文件内容如何，我们直接看反编译后的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">descriptor: I</span><br><span class="line">flags: ACC_PRIVATE</span><br></pre></td></tr></table></figure><p>此处声明了一个私有变量m，类型为int，返回值为int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> com.rhythm7.Main();</span><br><span class="line">descriptor: ()V</span><br><span class="line">flags: ACC_PUBLIC</span><br><span class="line">Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">    line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">    Start  Length  Slot  Name   Signature</span><br><span class="line">        <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/rhythm7/Main;</span><br></pre></td></tr></table></figure><p>这里是构造方法：Main()，返回值为void, 公开方法。</p><p>code内的主要属性为：</p><ul><li>stack: 最大操作数栈，JVM运行时会根据这个值来分配栈帧(Frame)中的操作栈深度,此处为1</li><li>locals: 局部变量所需的存储空间，单位为Slot, Slot是虚拟机为局部变量分配内存时所使用的最小单位，为4个字节大小。方法参数(包括实例方法中的隐藏参数this)，显示异常处理器的参数(try catch中的catch块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。</li><li>args_size: 方法参数的个数，这里是1，因为每个实例方法都会有一个隐藏参数this</li><li>attribute_info: 方法体内容，0,1,4为字节码”行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的java/lang/Object.””:()V, 然后执行返回语句，结束方法。</li><li>LineNumberTable: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。可以使用 -g:none 或-g:lines选项来取消或要求生成这项信息，如果选择不生成LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</li><li>LocalVariableTable: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0, arg1这样的占位符。 start 表示该局部变量在哪一行开始可见，length表示可见行数，Slot代表所在帧栈位置，Name是变量名称，然后是类型签名。</li></ul><h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><p>最后很显然是源码文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SourceFile: <span class="string">&quot;Main.java&quot;</span></span><br></pre></td></tr></table></figure><h2 id="再看两个示例"><a href="#再看两个示例" class="headerlink" title="再看两个示例"></a>再看两个示例</h2><h3 id="分析try-catch-finally"><a href="#分析try-catch-finally" class="headerlink" title="分析try-catch-finally"></a>分析try-catch-finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            x = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            x = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试问当不发生异常和发生异常的情况下，foo()的返回值分别是多少。</p><p>查看字节码的foo方法内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac TestCode.java</span><br><span class="line">javap -verbose TestCode.class</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_1 <span class="comment">//int型1入栈 -&gt;栈顶=1</span></span><br><span class="line">         <span class="number">1</span>: istore_1 <span class="comment">//将栈顶的int型数值存入第二个局部变量 -&gt;局部2=1</span></span><br><span class="line">         <span class="number">2</span>: iload_1 <span class="comment">//将第二个int型局部变量推送至栈顶 -&gt;栈顶=1</span></span><br><span class="line">         <span class="number">3</span>: istore_2 <span class="comment">//!!将栈顶int型数值存入第三个局部变量 -&gt;局部3=1</span></span><br><span class="line">         </span><br><span class="line">         <span class="number">4</span>: iconst_3 <span class="comment">//int型3入栈 -&gt;栈顶=3</span></span><br><span class="line">         <span class="number">5</span>: istore_1 <span class="comment">//将栈顶的int型数值存入第二个局部变量 -&gt;局部2=3</span></span><br><span class="line">         <span class="number">6</span>: iload_2 <span class="comment">//!!将第三个int型局部变量推送至栈顶 -&gt;栈顶=1</span></span><br><span class="line">         <span class="number">7</span>: ireturn <span class="comment">//从当前方法返回栈顶int数值 -&gt;1</span></span><br><span class="line">         </span><br><span class="line">         <span class="number">8</span>: astore_2 <span class="comment">// -&gt;局部3=Exception</span></span><br><span class="line">         <span class="number">9</span>: iconst_2 <span class="comment">// -&gt;栈顶=2</span></span><br><span class="line">        <span class="number">10</span>: istore_1 <span class="comment">// -&gt;局部2=2</span></span><br><span class="line">        <span class="number">11</span>: iload_1 <span class="comment">//-&gt;栈顶=2</span></span><br><span class="line">        <span class="number">12</span>: istore_3 <span class="comment">//!! -&gt;局部4=2</span></span><br><span class="line">        </span><br><span class="line">        <span class="number">13</span>: iconst_3 <span class="comment">// -&gt;栈顶=3</span></span><br><span class="line">        <span class="number">14</span>: istore_1 <span class="comment">// -&gt;局部1=3</span></span><br><span class="line">        <span class="number">15</span>: iload_3 <span class="comment">//!! -&gt;栈顶=2</span></span><br><span class="line">        <span class="number">16</span>: ireturn <span class="comment">// -&gt; 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="number">17</span>: astore        <span class="number">4</span> <span class="comment">//将栈顶引用型数值存入第五个局部变量=any</span></span><br><span class="line">        <span class="number">19</span>: iconst_3 <span class="comment">//将int型数值3入栈 -&gt; 栈顶3</span></span><br><span class="line">        <span class="number">20</span>: istore_1 <span class="comment">//将栈顶第一个int数值存入第二个局部变量 -&gt; 局部2=3</span></span><br><span class="line">        <span class="number">21</span>: aload         <span class="number">4</span> <span class="comment">//将局部第五个局部变量(引用型)推送至栈顶</span></span><br><span class="line">        <span class="number">23</span>: athrow <span class="comment">//将栈顶的异常抛出</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">0</span>     <span class="number">4</span>     <span class="number">8</span>   Class java/lang/Exception <span class="comment">//0到4行对应的异常，对应#8中储存的异常</span></span><br><span class="line">             <span class="number">0</span>     <span class="number">4</span>    <span class="number">17</span>   any <span class="comment">//Exeption之外的其他异常</span></span><br><span class="line">             <span class="number">8</span>    <span class="number">13</span>    <span class="number">17</span>   any</span><br><span class="line">            <span class="number">17</span>    <span class="number">19</span>    <span class="number">17</span>   any</span><br></pre></td></tr></table></figure><p>在字节码的4,5，以及13,14中执行的是同一个操作，就是将int型的3入操作数栈顶，并存入第二个局部变量。这正是我们源码在finally语句块中内容。也就是说，JVM在处理异常时，会在每个可能的分支都将finally语句重复执行一遍。</p><p>通过一步步分析字节码，可以得出最后的运行结果是：</p><ul><li>不发生异常时: return 1</li><li>发生异常时: return 2</li><li>发生非Exception及其子类的异常，抛出异常，不返回值</li></ul><h3 id="Kotlin函数扩展的实现"><a href="#Kotlin函数扩展的实现" class="headerlink" title="Kotlin函数扩展的实现"></a>Kotlin函数扩展的实现</h3><h2 id="字节码的增强技术"><a href="#字节码的增强技术" class="headerlink" title="字节码的增强技术"></a>字节码的增强技术</h2><p>字节码增强技术就是一类对现有字节码进行修改或者动态生成全新字节码文件的技术。<br><img src="/posts/13008/%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF.png"></p><h3 id="实现方式-ASM"><a href="#实现方式-ASM" class="headerlink" title="实现方式 - ASM"></a>实现方式 - ASM</h3><p>对于需要手动操纵字节码的需求，可以使用ASM，它可以直接生产<code>.class</code>字节码文件，也可以在类被加载入JVM之前动态修改类行为（如下图所示）。</p><p>ASM的应用场景有AOP（Cglib就是基于ASM）、热部署、修改其他jar包中的类等。当然，涉及到如此底层的步骤，实现起来也比较麻烦。</p><p>接下来，本文将介绍ASM的两种API，并用ASM来实现一个比较粗糙的AOP。<br>但在此之前，为了让大家更快地理解ASM的处理流程，强烈建议读者先对<strong>访问者模式</strong>进行了解。<br>简单来说，<strong>访问者模式</strong>主要用于修改或操作一些数据结构比较稳定的数据。我们知道字节码文件的结构是由JVM固定的，所以很适合利用访问者模式对字节码文件进行修改。</p><p><img src="/posts/13008/%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF-ASM.png"></p><h4 id="ASM-API"><a href="#ASM-API" class="headerlink" title="ASM API"></a>ASM API</h4><ul><li>核心API<br>  ASM Core API可以类比解析XML文件中的SAX(Simple API for XML)方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。<br>  好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用Core API。<br>  在Core API中有以下几个关键类：<ul><li>ClassReader：用于读取已经编译好的.class文件。</li><li>ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</li><li>各种Visitor类：如上所述，CoreAPI根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的Visitor，比如用于访问方法的MethodVisitor、用于访问类变量的FieldVisitor、用于访问注解的AnnotationVisitor等。为了实现AOP，重点要使用的是MethodVisitor。</li></ul></li><li>树形API<br>  ASM Tree API可以类比解析XML文件中的DOM方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。<br>  TreeApi不同于CoreAPI，TreeAPI通过各种Node类来映射字节码的各个区域，类比DOM节点，就可以很好地理解这种编程方式。</li></ul><h4 id="直接利用ASM实现AOP"><a href="#直接利用ASM实现AOP" class="headerlink" title="直接利用ASM实现AOP"></a>直接利用ASM实现AOP</h4><p>利用ASM的CoreAPI来增强类。<br>这里不纠结于AOP的专业名词如切片、通知，只实现在方法调用前、后增加逻辑，通俗易懂且方便理解。</p><p>首先定义需要被增强的Base类：其中只包含一个process()方法，方法内输出一行“process”。<br>增强后，我们期望的是，方法执行前输出“start”，之后输出”end”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;process&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了利用ASM实现AOP，需要定义两个类：</p><ul><li>一个是MyClassVisitor类，用于对字节码的visit以及修改；</li><li>另一个是Generator类，在这个类中定义ClassReader和ClassWriter，其中的逻辑是，classReader读取字节码，然后交给MyClassVisitor类处理，处理完成后由ClassWriter写字节码并将旧的字节码替换掉。</li></ul><p>Generator类较简单，先看一下它的实现，如下所示，然后重点解释MyClassVisitor类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line">        ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">&quot;meituan/bytecode/asm/Base&quot;</span>);</span><br><span class="line">        ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">        ClassVisitor classVisitor = <span class="keyword">new</span> MyClassVisitor(classWriter);</span><br><span class="line">        classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);</span><br><span class="line">        <span class="keyword">byte</span>[] data = classWriter.toByteArray();</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;operation-server/target/classes/meituan/bytecode/asm/Base.class&quot;</span>);</span><br><span class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">        fout.write(data);</span><br><span class="line">        fout.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;now generator cc success!!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyClassVisitor继承自ClassVisitor，用于对字节码的观察。它还包含一个内部类MyMethodVisitor，继承自MethodVisitor用于对类内方法的观察，它的整体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.MethodVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassVisitor</span><span class="params">(ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ASM5, cv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature,</span></span></span><br><span class="line"><span class="params"><span class="function">                      String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        cv.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        MethodVisitor mv = cv.visitMethod(access, name, desc, signature,</span><br><span class="line">                exceptions);</span><br><span class="line">        <span class="comment">//Base类中有两个方法：无参构造以及process方法，这里不增强构造方法</span></span><br><span class="line">        <span class="keyword">if</span> (!name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>) &amp;&amp; mv != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mv = <span class="keyword">new</span> MyMethodVisitor(mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyMethodVisitor</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyMethodVisitor</span><span class="params">(MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(Opcodes.ASM5, mv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.visitCode();</span><br><span class="line">            mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line">            mv.visitLdcInsn(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)</span><br><span class="line">                    || opcode == Opcodes.ATHROW) &#123;</span><br><span class="line">                <span class="comment">//方法在返回之前，打印&quot;end&quot;</span></span><br><span class="line">                mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line">                mv.visitLdcInsn(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">                mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mv.visitInsn(opcode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用这个类就可以实现对字节码的修改。详细解读其中的代码，对字节码做修改的步骤是：</p><ul><li>首先通过MyClassVisitor类中的visitMethod方法，判断当前字节码读到哪一个方法了。跳过构造方法 <code>&lt;init&gt;</code> 后，将需要被增强的方法交给内部类MyMethodVisitor来进行处理。</li><li>接下来，进入内部类MyMethodVisitor中的visitCode方法，它会在ASM开始访问某一个方法的Code区时被调用，重写visitCode方法，将AOP中的前置逻辑就放在这里。 MyMethodVisitor继续读取字节码指令，每当ASM访问到无参数指令时，都会调用MyMethodVisitor中的visitInsn方法。我们判断了当前指令是否为无参数的“return”指令，如果是就在它的前面添加一些指令，也就是将AOP的后置逻辑放在该方法中。</li><li>综上，重写MyMethodVisitor中的两个方法，就可以实现AOP了，而重写方法时就需要用ASM的写法，手动写入或者修改字节码。通过调用methodVisitor的visitXXXXInsn()方法就可以实现字节码的插入，XXXX对应相应的操作码助记符类型，比如mv.visitLdcInsn(“end”)对应的操作码就是ldc “end”，即将字符串“end”压入栈。 完成这两个visitor类后，运行Generator中的main方法完成对Base类的字节码增强，增强后的结果可以在编译后的target文件夹中找到Base.class文件进行查看，可以看到反编译后的代码已经改变了。</li></ul><h3 id="实现方式-Javassist"><a href="#实现方式-Javassist" class="headerlink" title="实现方式 - Javassist"></a>实现方式 - Javassist</h3><p>ASM是在指令层次上操作字节码的，直观感受是在指令层次上操作字节码的框架实现起来比较晦涩。故除此之外，简单介绍另外一类框架：<strong>强调源代码层次操作字节码的框架Javassist。</strong></p><p>利用Javassist实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是ClassPool、CtClass、CtMethod、CtField这四个类：</p><ul><li>CtClass（compile-time class）：编译时类信息，它是一个class文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个CtClass对象，用来表示这个类文件。</li><li>ClassPool：从开发视角来看，ClassPool是一张保存CtClass信息的HashTable，key为类名，value为类名对应的CtClass对象。当需要对某个类进行修改时，就是通过pool.getCtClass(“className”)方法从pool中获取到相应的CtClass。</li><li>CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mtrace.agent.javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IllegalAccessException, InstantiationException, IOException </span>&#123;</span><br><span class="line">        ClassPool cp = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = cp.get(<span class="string">&quot;meituan.bytecode.javassist.Base&quot;</span>);</span><br><span class="line">        CtMethod m = cc.getDeclaredMethod(<span class="string">&quot;process&quot;</span>);</span><br><span class="line">        m.insertBefore(<span class="string">&quot;&#123; System.out.println(\&quot;start\&quot;); &#125;&quot;</span>);</span><br><span class="line">        m.insertAfter(<span class="string">&quot;&#123; System.out.println(\&quot;end\&quot;); &#125;&quot;</span>);</span><br><span class="line">        Class c = cc.toClass();</span><br><span class="line">        cc.writeFile(<span class="string">&quot;/Users/zen/projects&quot;</span>);</span><br><span class="line">        Base h = (Base)c.newInstance();</span><br><span class="line">        h.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行时类的重载"><a href="#运行时类的重载" class="headerlink" title="运行时类的重载"></a>运行时类的重载</h3><p>如果我们在一个JVM中，先加载了一个类，然后又对其进行字节码增强并重新加载会发生什么呢？</p><p>模拟这种情况，只需要我们在上文中Javassist的Demo中main()方法的第一行添加<code>Base b=new Base()</code>，即在增强前就先让JVM加载Base类，然后在执行到cc.toClass()方法时会抛出错误。<br>跟进cc.toClass()方法中，我们会发现它是在最后调用了ClassLoader的native方法defineClass()时报错。<br>也就是说，<strong>JVM是不允许在运行时动态重载一个类的</strong>。<br><img src="/posts/13008/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E9%87%8D%E8%BD%BD-error.png"></p><p>显然，如果只能在类加载前对类进行强化，那字节码增强技术的使用场景就变得很窄了。<br>我们期望的效果是：在一个持续运行并已经加载了所有类的JVM中，还能利用字节码增强技术对其中的类行为做替换并重新加载。</p><p>那如何解决JVM不允许运行时重加载类信息的问题呢？</p><h4 id="Instrument"><a href="#Instrument" class="headerlink" title="Instrument"></a>Instrument</h4><h4 id="JVMTI-amp-Agent-amp-Attach-API"><a href="#JVMTI-amp-Agent-amp-Attach-API" class="headerlink" title="JVMTI &amp; Agent &amp; Attach API"></a>JVMTI &amp; Agent &amp; Attach API</h4><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>通过上述几个类库，我们可以在运行时对JVM中的类进行修改并重载了。通过这种手段，可以做的事情就变得很多了：</p><ul><li>热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。</li><li>Mock：测试时候对某些服务做Mock。</li><li>性能诊断工具：比如bTrace就是利用Instrument，实现无侵入地跟踪一个正在运行的JVM，监控到类和方法级别的状态信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-基础-Java类加载机制</title>
      <link href="/posts/21676.html"/>
      <url>/posts/21676.html</url>
      
        <content type="html"><![CDATA[<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>其中类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段。<br>在这五个阶段中，<strong>加载、验证、准备和初始化</strong>这四个阶段发生的顺序是确定的，而<strong>解析</strong>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img src="/posts/21676/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png"></p><h3 id="类的加载：查找并加载类的二进制数据"><a href="#类的加载：查找并加载类的二进制数据" class="headerlink" title="类的加载：查找并加载类的二进制数据"></a>类的加载：查找并加载类的二进制数据</h3><p>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul><p><img src="/posts/21676/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%8A%A0%E8%BD%BD.png"></p><p>相对于类加载的其他阶段而言，加载阶段(准确地说，是<strong>加载阶段获取类的二进制字节流的动作</strong>)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了<code>.class文件缺失或存在错误</code>，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><p>加载.class文件的方式：</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li><strong>文件格式验证</strong><br>  验证字节流是否符合Class文件格式的规范。<br>  例如: 是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><strong>元数据验证</strong><br>  对字节码描述的信息进行语义分析(注意: 对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了java.lang.Object之外。</li><li><strong>字节码验证</strong><br>  通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><strong>符号引用验证</strong><br>  确保解析动作能正确执行。</li></ul><h4 id="准备-为类的静态变量分配内存，并将其初始化为默认值、"><a href="#准备-为类的静态变量分配内存，并将其初始化为默认值、" class="headerlink" title="准备: 为类的静态变量分配内存，并将其初始化为默认值、"></a>准备: 为类的静态变量分配内存，并将其初始化为默认值、</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。<br>对于该阶段有以下几点需要注意:</p><ul><li>这时候进行内存分配的仅包括**类变量(static)**，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>这里所设置的初始值通常情况下是<strong>数据类型默认的零值(如0、0L、null、false等)<strong>，而不是被在Java代码中被显式地赋予的值。<br>  假设一个类变量的定义为: <code>public static int value = 3；</code><br>  那么变量value在准备阶段过后的初始值为0，而不是3。<br>  因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把value赋值为3的动作将在</strong>初始化阶段</strong>才会执行。</li></ul><h4 id="解析-把类中的符号引用转换为直接引用"><a href="#解析-把类中的符号引用转换为直接引用" class="headerlink" title="解析: 把类中的符号引用转换为直接引用"></a>解析: 把类中的符号引用转换为直接引用</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<br>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p><p>在Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量时指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p>JVM初始化步骤：</p><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p>类初始化时机: 只有当对类的<strong>主动使用</strong>的时候才会导致类的初始化。<br>类的主动使用包括以下六种:</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射(如Class.forName(“com.pdai.jvm.Test”))</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>Java虚拟机将结束生命周期的几种情况：</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类加载器的层次"><a href="#类加载器的层次" class="headerlink" title="类加载器的层次"></a>类加载器的层次</h3><p><img src="/posts/21676/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E5%B1%82%E6%AC%A1.png"></p><p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p><p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器: </p><ul><li>启动类加载器<br>  它使用C++实现(这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，是虚拟机自身的一部分；</li><li>所有其他的类加载器<br>  这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li></ul><p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p><ul><li><strong>启动类加载器</strong><br>  <code>Bootstrap ClassLoader</code>，负责加载存放在<strong>JDK\jre\lib</strong>(JDK代表JDK的安装目录，下同)下，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，*<em>所有的java.<em>开头的类均被Bootstrap ClassLoader加载</em></em>)。<br>  启动类加载器是无法被Java程序直接引用的。</li><li><strong>扩展类加载器</strong><br>  <code>Extension ClassLoader</code>，该加载器由<strong>sun.misc.Launcher$ExtClassLoader</strong>实现，它负责加载<strong>JDK\jre\lib\ext</strong>目录中，或者由<strong>java.ext.dirs</strong>系统变量指定的路径中的所有类库(如**javax.***开头的类)。<br>  开发者可以直接使用扩展类加载器。</li><li><strong>应用程序类加载器</strong><br>  <code>Application ClassLoader</code>，该类加载器由<strong>sun.misc.Launcher$AppClassLoader</strong>来实现，它负责加载用户类路径(ClassPath)所指定的类。<br>  开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中<strong>默认的类加载器</strong>。</li></ul><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。<br>因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul><h3 id="寻找类加载器"><a href="#寻找类加载器" class="headerlink" title="寻找类加载器"></a>寻找类加载器</h3><p>寻找类加载器小例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.jvm.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@64fef26a</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1ddd40f3</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>从上面的结果可以看出，并没有获取到<strong>ExtClassLoader</strong>的父Loader，原因是<strong>BootstrapLoader</strong>(引导类加载器)是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回<strong>null</strong>。</p><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>类加载有三种方式:</p><ol><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.jvm.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">loaderTest</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123; </span><br><span class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                <span class="comment">//1. 使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">                loader.loadClass(<span class="string">&quot;Test2&quot;</span>); </span><br><span class="line">                <span class="comment">//2. 使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line">                Class.forName(<span class="string">&quot;Test2&quot;</span>); </span><br><span class="line">                <span class="comment">//3. 使用Class.forName()来加载类，并指定ClassLoader，initialize=false初始化时不执行静态块 </span></span><br><span class="line">                Class.forName(<span class="string">&quot;Test2&quot;</span>, <span class="keyword">false</span>, loader); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123; </span><br><span class="line">        <span class="keyword">static</span> &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;静态初始化块执行了！&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class.forName()和ClassLoader.loadClass()区别？</p><ul><li>Class.forName()<br>  将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。</li><li>ClassLoader.loadClass()<br>  只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。</li></ul><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><ul><li><strong>全盘负责</strong><br>  当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</li><li><strong>父类委托</strong><br>  先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</li><li><strong>缓存机制</strong><br>  缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。<br>  这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</li><li><strong>双亲委派机制</strong><br>  如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>双亲委派机制过程：</p><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常<strong>ClassNotFoundException</strong>。</li></ol><p>双亲委派代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先判断该类型是否已经被加载</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果存在父类加载器，就委派给父类加载器加载</span></span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span></span><br><span class="line">                c = findBootstrapClass0(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双亲委派优势：</p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。</p><p>比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。</p><p>自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 <code>findClass</code> 方法即可。<br>下面通过一个示例来演示自定义类加载器的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.jvm.classloader;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        String fileName = root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        classLoader.setRoot(<span class="string">&quot;D:\\temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">&quot;com.pdai.jvm.classloader.Test2&quot;</span>);</span><br><span class="line">            Object object = testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。</p><p>有几点需要注意：</p><ul><li>这里传递的文件名需要是类的全限定性名称，即com.pdai.jvm.classloader.Test2格式的，因为 defineClass 方法是按这种格式进行处理的。</li><li>最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</li><li>这类Test 类本身可以被 AppClassLoader 类加载，因此不能把com/pdai/jvm/classloader/Test2.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础-泛型</title>
      <link href="/posts/54026.html"/>
      <url>/posts/54026.html</url>
      
        <content type="html"><![CDATA[<p>Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。</p><h2 id="为什么会引入泛型"><a href="#为什么会引入泛型" class="headerlink" title="为什么会引入泛型"></a>为什么会引入泛型</h2><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p>引入泛型的意义在于：</p><ul><li><strong>适用于多种数据类型执行相同的代码（代码复用）</strong></li><li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li></ul><h2 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul><li>简单泛型类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">T</span>&gt;</span>&#123;         <span class="comment">// 此处可以随便写标识符号，T是type的简称  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// var的类型由T指定，即：由外部指定  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;  <span class="comment">// 返回值的类型由外部决定  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;  <span class="comment">// 设置的类型也由外部决定  </span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> Point&lt;String&gt;() ;     <span class="comment">// 里面的var类型为String类型  </span></span><br><span class="line">        p.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置字符串  </span></span><br><span class="line">        System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多元泛型  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notepad</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;       <span class="comment">// 此处指定了两个泛型类型  </span></span><br><span class="line">    <span class="keyword">private</span> K key ;     <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">private</span> V value ;   <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo09</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        Notepad&lt;String,Integer&gt; t = <span class="keyword">null</span> ;        <span class="comment">// 定义两个泛型类型的对象  </span></span><br><span class="line">        t = <span class="keyword">new</span> Notepad&lt;String,Integer&gt;() ;       <span class="comment">// 里面的key为String，value为Integer  </span></span><br><span class="line">        t.setKey(<span class="string">&quot;汤姆&quot;</span>) ;        <span class="comment">// 设置第一个内容  </span></span><br><span class="line">        t.setValue(<span class="number">20</span>) ;            <span class="comment">// 设置第二个内容  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名；&quot;</span> + t.getKey()) ;      <span class="comment">// 取得信息  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;，年龄；&quot;</span> + t.getValue()) ;       <span class="comment">// 取得信息  </span></span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;        <span class="comment">// 在接口上定义泛型  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span> </span>; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;   <span class="comment">// 定义泛型接口的子类  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;             <span class="comment">// 定义属性  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;     <span class="comment">// 通过构造方法设置属性内容  </span></span><br><span class="line">        <span class="keyword">this</span>.setVar(<span class="keyword">var</span>) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo24</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arsg[])</span></span>&#123;  </span><br><span class="line">        Info&lt;String&gt; i = <span class="keyword">null</span>;        <span class="comment">// 声明接口对象  </span></span><br><span class="line">        i = <span class="keyword">new</span> InfoImpl&lt;String&gt;(<span class="string">&quot;汤姆&quot;</span>) ;  <span class="comment">// 通过子类实例化对象  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + i.getVar()) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p><ul><li>定义泛型方法<br>  <img src="/posts/54026/%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8-%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.png"></li><li>调用泛型方法<br>  <img src="/posts/54026/%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8-%E8%B0%83%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.png"></li></ul><p>定义泛型方法时，必须在返回值前边加一个<code>&lt;T&gt;</code>，来声明这是一个泛型方法，持有一个泛型<code>T</code>，然后才可以用泛型T作为方法的返回值。<br><code>Class&lt;T&gt;</code>的作用就是指明泛型的具体类型，而<code>Class&lt;T&gt;</code>类型的变量c，可以用来创建泛型类的对象。</p><h3 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="泛型的上下限"></a>泛型的上下限</h3><p>先看下如下的代码，很明显是会报错的 （具体错误原因请参考后文）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下两个方法不会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    funA(b);</span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下funD方法会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">(List&lt;A&gt; listA)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funD</span><span class="params">(List&lt;B&gt; listB)</span> </span>&#123;</span><br><span class="line">    funC(listB); <span class="comment">// Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;)</span></span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何解决呢？<br>为了解决泛型中隐含的转换问题，Java泛型加入了<strong>类型参数的上下边界机制</strong>。<code>&lt;? extends A&gt;</code>表示该类型参数可以是<strong>A(上边界)<strong>或者</strong>A的子类类型</strong>。<strong>编译时擦除到类型A，即用A类型代替类型参数</strong>。<br>这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">(List&lt;? extends A&gt; listA)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funD</span><span class="params">(List&lt;B&gt; listB)</span> </span>&#123;</span><br><span class="line">    funC(listB); <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型上下限的引入"><a href="#泛型上下限的引入" class="headerlink" title="泛型上下限的引入"></a>泛型上下限的引入</h4><p>在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><ul><li>上限  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;    <span class="comment">// 此处泛型只能是数字类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Info&lt;Integer&gt; i1 = <span class="keyword">new</span> Info&lt;Integer&gt;() ;        <span class="comment">// 声明Integer的泛型对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>下限  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo21</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> Info&lt;String&gt;() ;        <span class="comment">// 声明String的泛型对象</span></span><br><span class="line">        Info&lt;Object&gt; i2 = <span class="keyword">new</span> Info&lt;Object&gt;() ;        <span class="comment">// 声明Object的泛型对象</span></span><br><span class="line">        i1.setVar(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        i2.setVar(<span class="keyword">new</span> Object()) ;</span><br><span class="line">        fun(i1) ;</span><br><span class="line">        fun(i2) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Info&lt;? <span class="keyword">super</span> String&gt; temp)</span></span>&#123;    <span class="comment">// 只能接收String或Object类型的泛型，String类的父类只有Object类</span></span><br><span class="line">        System.out.print(temp + <span class="string">&quot;, &quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>&lt;?&gt;</code> 无限制通配符<br><code>&lt;? extends E&gt;</code> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类<br><code>&lt;? super E&gt;</code> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类</p><p>// 使用原则《Effictive Java》<br>// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限</p><ol><li>如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;</li><li>如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；</li><li>如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</li></ol><h4 id="加深印象"><a href="#加深印象" class="headerlink" title="加深印象"></a>加深印象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">E <span class="title">max</span><span class="params">(List&lt;? extends E&gt; e1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器返回的元素属于 E 的某个子类型</span></span><br><span class="line">    Iterator&lt;? extends E&gt; iterator = e1.iterator();</span><br><span class="line">    E result = iterator.next();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        E next = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (next.compareTo(result) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的类型参数 E 的范围是<code>&lt;E extends Comparable&lt;? super E&gt;&gt;</code>，我们可以分步查看：</p><ul><li>要进行比较，所以 E 需要是可比较的类，因此需要 <code>extends Comparable&lt;…&gt;</code>（注意这里不要和继承的 extends 搞混了，不一样）</li><li><code>Comparable&lt; ? super E&gt;</code> 要对 E 进行比较，即 E 的消费者，所以需要用 super</li><li>而参数 <code>List&lt; ? extends E&gt;</code> 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大</li></ul><h4 id="多个限制"><a href="#多个限制" class="headerlink" title="多个限制"></a>多个限制</h4><p>使用&amp;符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">//工资低于2500元的上斑族并且站立的乘客车票打8折</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Staff &amp; Passenger&gt; <span class="function"><span class="keyword">void</span> <span class="title">discount</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.getSalary()&lt;<span class="number">2500</span> &amp;&amp; t.isStanding())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜你！您的车票打八折！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        discount(<span class="keyword">new</span> Me());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] list11 = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;String&gt;[] list12 = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，需要强转类型 </span></span><br><span class="line">List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告 </span></span><br><span class="line">List&lt;?&gt;[] list14 = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;?&gt;[] list15 = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] list6 = <span class="keyword">new</span> ArrayList[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告</span></span><br></pre></td></tr></table></figure><p>如何使用？<br>我们在使用到泛型数组的场景下应该尽量使用列表集合替换，此外也可以通过使用 java.lang.reflect.Array.newInstance(Class<T> componentType, int length) 方法来创建一个具有指定类型和维度的数组，如下：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayWithTypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] create() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">ArrayWithTypeToken&lt;Integer&gt; arrayToken = <span class="keyword">new</span> ArrayWithTypeToken&lt;Integer&gt;(Integer.class, <span class="number">100</span>);</span><br><span class="line">Integer[] array = arrayToken.create();</span><br></pre></td></tr></table></figure><h2 id="深入理解泛型"><a href="#深入理解泛型" class="headerlink" title="深入理解泛型"></a>深入理解泛型</h2><p><strong>如何理解Java中的泛型是伪泛型？</strong><br>泛型的类型擦除原则是：</p><ul><li>消除类型参数声明，即删除<code>&lt;&gt;</code>及其包围的部分。</li><li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：<br>  如果类型参数是无限制通配符或没有上下界限定，则替换为Object；<br>  如果存在上下界限定，则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li><li>为了保证类型安全，必要时插入强制类型转换代码。</li><li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li></ul><p>如何进行擦除的？</p><ul><li>擦除类定义中的类型参数 - 无限制类型擦除<br>  当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如<code>&lt;T&gt;</code>和<code>&lt;?&gt;</code>的类型参数都被替换为Object。<br>  <img src="/posts/54026/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E6%97%A0%E9%99%90%E5%88%B6%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4.png"></li><li>擦除类定义中的类型参数 - 有限制类型擦除<br>  当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如<code>&lt;T extends Number&gt;</code>和<code>&lt;? extends Number&gt;</code>的类型参数被替换为Number，<code>&lt;? super Number&gt;</code>被替换为Object。<br>  <img src="/posts/54026/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E6%9C%89%E9%99%90%E5%88%B6%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4.png"></li><li>擦除方法定义中的类型参数<br>  擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的。</li></ul><p><strong>如何证明类型的擦除呢？</strong></p><ul><li>原始类型相等  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  在这个例子中，我们定义了两个ArrayList数组，不过一个是<code>&lt;String&gt;泛型类型</code>的，只能存储字符串；一个是<code>&lt;Integer&gt;泛型类型</code>的，只能存储整数，最后，我们通过list1对象和list2对象的getClass()方法获取他们的类的信息，最后发现结果为true。说明泛型类型String和Integer都被擦除掉了，只剩下原始类型。</li><li>通过反射添加其它类型元素  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">1</span>);  <span class="comment">//这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span></span><br><span class="line"></span><br><span class="line">        list.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="string">&quot;asd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  在程序中定义了一个ArrayList泛型类型实例化为Integer对象，如果直接调用add()方法，那么只能存储整数数据，不过当我们利用反射调用add()方法的时候，却可以存储字符串，这说明了Integer泛型实例在编译之后被擦除掉了，只保留了原始类型。</li></ul><p><strong>如何理解类型擦除后保留的原始类型？</strong><br>原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p><p><strong>如何理解泛型的编译器检查？</strong></p><p><strong>如何理解泛型的多态？泛型的桥接方法</strong><br>类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。</p><p><strong>如何理解基本类型不能作为泛型类型？</strong></p><p><strong>如何理解泛型类型不能实例化？</strong><br>不能实例化泛型类型, 这本质上是由于类型擦除决定的。</p><p>可以看到如下代码会在编译器中报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T test = <span class="keyword">new</span> T(); <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure><p>因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于T 被擦除为 Object，如果可以 new T() 则就变成了 new Object()，失去了本意。</p><p>如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newTclass</span> <span class="params">(Class &lt; T &gt; clazz)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    T obj = clazz.newInstance();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何理解泛型类中的静态方法和静态常量？</strong><br>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p><p><strong>如何理解异常中使用泛型？</strong><br><strong>如何获取泛型的参数类型？</strong></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础-反射</title>
      <link href="/posts/2307.html"/>
      <url>/posts/2307.html</url>
      
        <content type="html"><![CDATA[<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>Java反射机制在框架设计中极为广泛，需要深入理解。</p><h2 id="反射基础"><a href="#反射基础" class="headerlink" title="反射基础"></a>反射基础</h2><p>RTTI（Run-Time Type Identification）运行时类型识别。在《Thinking in Java》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。</p><p>反射就是把java类中的各种成分映射成一个个的Java对象<br>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p><p>首先需要理解 Class类，以及类的加载机制； 然后基于此如何通过反射获取Class类以及类中的成员变量、方法、构造方法等。</p><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>Class类，Class类是一个实实在在的类，存在于JDK的<code>java.lang</code>包中。<br>Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(“类名”)等方法获取class对象）。<br>数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。<br>基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ANNOTATION= <span class="number">0x00002000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENUM      = <span class="number">0x00004000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNTHETIC = <span class="number">0x00001000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private constructor. Only the Java Virtual Machine creates Class objects.   //私有构造器，只有JVM才能调用创建Class对象</span></span><br><span class="line"><span class="comment">     * This constructor is not used and prevents the default constructor being</span></span><br><span class="line"><span class="comment">     * generated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Initialize final field for classLoader.  The initialization value of non-null</span></span><br><span class="line">        <span class="comment">// prevents future JIT optimizations from assuming this final field is null.</span></span><br><span class="line">        classLoader = loader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Class类也是类的一种，与class关键字是不一样的</li><li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</li><li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是同一个Class对象</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要</li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>类加载机制和类字节码技术</p><ul><li>JVM基础 - 类字节码详解<br>  源代码通过编译器编译为字节码，再通过类加载子系统进行加载到JVM中运行</li><li>JVM基础 - Java类加载机制</li></ul><ol><li>类加载机制流程<br> <img src="/posts/2307/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png"></li><li>类的加载<br> <img src="/posts/2307/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD.png"></li></ol><h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><p>在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。<br>在反射包中，我们常用的类主要有：</p><ul><li>Class类</li><li>Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象</li><li>Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、</li><li>Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)</li></ul><h3 id="Class类对象的获取"><a href="#Class类对象的获取" class="headerlink" title="Class类对象的获取"></a>Class类对象的获取</h3><p>在类加载的时候，jvm会创建一个class对象。<br>class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种：</p><ul><li>根据类名：类名.class</li><li>根据对象：对象.getClass()</li><li>根据全限定类名：Class.forName(全限定类名)</li></ul><h3 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="Constructor类及其用法"></a>Constructor类及其用法</h3><h3 id="Field类及其用法"><a href="#Field类及其用法" class="headerlink" title="Field类及其用法"></a>Field类及其用法</h3><h3 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="Method类及其用法"></a>Method类及其用法</h3><p>存在于<code>java.lang.reflect</code>包中。</p><h2 id="反射机制执行的流程"><a href="#反射机制执行的流程" class="headerlink" title="反射机制执行的流程"></a>反射机制执行的流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 使用外部配置的实现，进行动态加载类</span></span><br><span class="line">            TempFunctionTest test = (TempFunctionTest)Class.forName(<span class="string">&quot;com.tester.HelloReflect&quot;</span>).newInstance();</span><br><span class="line">            test.sayHello(<span class="string">&quot;call directly&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 根据配置的函数名，进行方法调用（不需要通用的接口抽象）</span></span><br><span class="line">            Object t2 = <span class="keyword">new</span> TempFunctionTest();</span><br><span class="line">            Method method = t2.getClass().getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line">            method.invoke(test, <span class="string">&quot;method invoke&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,&quot;</span> + word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/2307/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><h3 id="反射获取类实例"><a href="#反射获取类实例" class="headerlink" title="反射获取类实例"></a>反射获取类实例</h3><p>首先调用了java.lang.Class的静态方法，获取类信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 先通过反射，获取调用进来的类信息，从而获取当前的 classLoader</span></span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 调用native方法进行获取class信息</span></span><br><span class="line">    <span class="comment">// forName0是native方法</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forName()反射获取类信息，并没有将实现留给了java，而是交给了jvm去加载。<br>主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader。<br>最后，jvm又会回调 ClassLoader 进类加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// java.lang.ClassLoader</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先获取锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 如果已经加载了的话，就不用再加载了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 双亲委托加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 父类没有加载到时，再自己加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getClassLoadingLock</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelLockMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 ConcurrentHashMap来保存锁</span></span><br><span class="line">        Object newLock = <span class="keyword">new</span> Object();</span><br><span class="line">        lock = parallelLockMap.putIfAbsent(className, newLock);</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lock = newLock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取方法"><a href="#反射获取方法" class="headerlink" title="反射获取方法"></a>反射获取方法</h3><h3 id="调用method-invoke-方法"><a href="#调用method-invoke-方法" class="headerlink" title="调用method.invoke()方法"></a>调用method.invoke()方法</h3><h3 id="反射调用流程小结"><a href="#反射调用流程小结" class="headerlink" title="反射调用流程小结"></a>反射调用流程小结</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合 - 类汇总</title>
      <link href="/posts/54442.html"/>
      <url>/posts/54442.html</url>
      
        <content type="html"><![CDATA[<p>JDK中Collection和Map相关知识体系概览。</p><h2 id="集合框架体系结构"><a href="#集合框架体系结构" class="headerlink" title="集合框架体系结构"></a>集合框架体系结构</h2><p><img src="/posts/54442/java-collections-overview.png"></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li>ArrayList</li><li>Vector</li><li>LinkedList</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>TreeSet</li><li>HashSet</li><li>LinkedHashSet</li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ul><li>LinkedList</li><li>PriorityQueue</li></ul><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构-Kubernetes</title>
      <link href="/posts/11340.html"/>
      <url>/posts/11340.html</url>
      
        <content type="html"><![CDATA[<h2 id="服务注册发现与负载均衡-Service"><a href="#服务注册发现与负载均衡-Service" class="headerlink" title="服务注册发现与负载均衡 - Service"></a>服务注册发现与负载均衡 - Service</h2><p>如果使用 Deployment 来运行应用服务，Deployment 可以动态的创建和销毁 Pod。每个 Pod 获取其自己的 IP 地址（K8S期待网络插件确保IP地址分配）。<br>对于集群中给定的 Deployment，这一刻运行的这组 Pod 可能不同于下一刻运行应用程序的另一组 Pod。<br>由此引出的的问题是：</p><ul><li>如果一组Pod（称为”后端“）为<strong>同一集群</strong>内的其它Pod（称为”前端”）提供功能，那么前端如何找出并跟踪要连接的IP地址，以便前端可以使用提供能力的后端部分？</li><li>如果一组前端Pod要调用<strong>不同集群</strong>的一组后端Pod呢？</li></ul><p>Kubernetes 中 Service 是一种抽象，通过网络暴露Pod组合。每个Service对象定义一组Pod以及如何访问这些Pod的策略。</p><p>Kubernetes Service 是集群中提供相同功能的一组 Pod 的抽象表达。 当每个 Service 创建时，会被分配一个唯一的 IP 地址（也称为 clusterIP）。 这个 IP 地址与 Service 的生命周期绑定在一起，只要 Service 存在，它就不会改变。 可以配置 Pod 使它与 Service 进行通信，Pod 知道与 Service 通信将被自动地负载均衡到该 Service 中的某些 Pod 上。</p><h3 id="定义Service"><a href="#定义Service" class="headerlink" title="定义Service"></a>定义Service</h3><p>Service 在 Kubernetes 中是一个对象 （与 Pod 或 ConfigMap 类似的对象）。可以使用 Kubernetes API 创建、查看或修改 Service 定义。 通常使用 <code>kubectl</code> 这类工具来进行这些 API 调用。</p><h4 id="EndpointPoints-amp-EndpointSlices"><a href="#EndpointPoints-amp-EndpointSlices" class="headerlink" title="EndpointPoints &amp; EndpointSlices"></a>EndpointPoints &amp; EndpointSlices</h4><p><strong>Endpoint</strong>: pod和service之间的关联关系，是通过<code>endpoint</code>实现的。<br>Endpoints表示了一个Service对应的所有Pod副本的访问地址；而Endpoints Controller负责生成和维护所有Endpoints对象的控制器，它负责监听Service和对应的Pod副本的变化。</p><p>在 Kubernetes API 中，Endpoints （该资源类别为复数）定义了网络端点的列表，通常由 Service 引用，以定义可以将流量发送到哪些 Pod。<br>推荐用 EndpointSlice API 替换 Endpoints。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>Kubernetes 支持两种查找服务的主要模式：环境变量和 DNS。前者开箱即用，而后者则需要 CoreDNS 集群插件。</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>当 Pod 在节点上运行时，kubelet 会针对每个活跃的 Service 为 Pod 添加一组环境变量。<br>kubelet 为 Pod 添加环境变量 <code>&#123;SVCNAME&#125;_SERVICE_HOST</code> 和 <code>&#123;SVCNAME&#125;_SERVICE_PORT</code>。</p><p>使用<strong>环境变量方法</strong>将端口和集群 IP 发布到客户端 Pod 时，<strong>必须在客户端 Pod 出现 之前 创建服务</strong>。 否则，这些客户端 Pod 将不会设定其环境变量。<br>如果仅使用 DNS 查找服务的集群 IP，则无需担心此设定问题。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>支持集群的 DNS 服务器（例如 CoreDNS：kube-dns）监视 Kubernetes API 中的新服务，并为每个服务创建一组 DNS 记录。 如果在整个集群中都启用了 DNS，则所有 Pod 都应该能够通过其 DNS 名称自动解析服务。</p><p>例如，如果你在 Kubernetes <strong>命名空间 my-ns</strong> 中有一个<strong>名为 my-service 的服务</strong>， 则控制平面和 DNS 服务共同为 <strong>my-service.my-ns</strong> 创建 DNS 记录。 <strong>my-ns 命名空间</strong>中的 Pod 应该能够通过<code>按名检索 my-service</code> 来找到服务 （my-service.my-ns 也可以工作）。<br>同一集群下<strong>其他命名空间中的 Pod</strong> 必须将名称限定为 <code>my-service.my-ns</code>，<strong>这些名称将解析为为服务分配的集群 IP</strong>。</p><p>kube-dns记录service和为服务分配的集群IP的对应关系。</p><p>Kubernetes 提供了一个自动为其它Service分配DNS名字的DNS插件Service：kube-dns。<br>可以通过如下命令检查它是否在工作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services kube-dns --namespace=kube-system</span><br><span class="line"></span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m</span><br></pre></td></tr></table></figure><h3 id="发布服务（服务类型）"><a href="#发布服务（服务类型）" class="headerlink" title="发布服务（服务类型）"></a>发布服务（服务类型）</h3><p>对一些应用的某些部分（如前端），可能希望将其暴露给K8S集群外部的IP地址从而能够外网访问。</p><p>Kubernetes <code>ServiceTypes</code> 允许指定所需要的 Service 类型。</p><ul><li>ClusterIP<br>  通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。<br>  这也是没有为服务显式指定 type 时使用的<strong>默认值</strong>。<br>  可以使用 Ingress 或者 Gateway API 向公众暴露服务。</li><li>NodePort<br>  通过每个节点上的 IP 和静态端口（NodePort）暴露服务。<br>  为了让节点端口可用，Kubernetes 设置了集群 IP 地址，这等同于请求 <code>type: ClusterIP</code> 的服务。</li><li>LoadBalancer<br>  使用云提供商的负载均衡器向外部暴露服务。<br>  外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上。</li><li>ExternalName<br>  通过返回 <code>CNAME</code> 记录和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，foo.bar.example.com）。 无需创建任何类型代理。<br>  要使用 kube-dns 1.7 及以上版本或者 CoreDNS 0.0.8 及以上版本才能使用 <code>ExternalName</code> 类型。</li></ul><p>可以使用 <code>Ingress</code> 来暴露自己的服务。<br><code>Ingress</code> 不是一种服务类型，但它充当集群的入口点。它可以将路由规则整合到一个资源中，因为它可以在同一 IP 地址下公开多个服务。</p><h4 id="ClusterIP类型"><a href="#ClusterIP类型" class="headerlink" title="ClusterIP类型"></a>ClusterIP类型</h4><p>使用 type: ClusterIP 的 Service时，Service 可以具有集群作用域的虚拟 IP 地址。<br>客户端可以使用该虚拟 IP 地址进行连接，Kubernetes 通过不同的后台 Pod 对该 Service 的流量进行负载均衡。</p><p>Service ClusterIP 是如何分配的？</p><ul><li>动态分配<br>  集群的控制面自动从所配置的 IP 范围内为 <code>type: ClusterIP</code> 选择一个空闲 IP 地址。</li><li>静态分配<br>  根据为 Service 所配置的 IP 范围，选定并设置你的 IP 地址。</li></ul><p>在整个集群中，每个 Service 的 ClusterIP 都必须是唯一的。 尝试使用已分配的 ClusterIP 创建 Service 将返回错误。</p><h4 id="NodePort类型"><a href="#NodePort类型" class="headerlink" title="NodePort类型"></a>NodePort类型</h4><h2 id="服务注册发现与负载均衡-Ingress"><a href="#服务注册发现与负载均衡-Ingress" class="headerlink" title="服务注册发现与负载均衡 - Ingress"></a>服务注册发现与负载均衡 - Ingress</h2><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。<br>Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。</p><p>Ingress 公开从集群外部到集群内服务的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。</p><p>下面是一个将所有流量都发送到同一 Service 的简单 Ingress 示例：<br><img src="/posts/11340/k8s-ingress-%E5%9B%BE%E7%A4%BA.png"></p><p>Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及基于名称的虚拟托管。<br><strong>Ingress 控制器</strong> 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。<br>Ingress 不会公开任意端口或协议。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 Service.Type=NodePort 或 Service.Type=LoadBalancer 类型的 Service。</p><h4 id="Ingress资源"><a href="#Ingress资源" class="headerlink" title="Ingress资源"></a>Ingress资源</h4><p>一个Ingress资源示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-wildcard-host</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;foo.bar.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/bar&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;*.foo.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/foo&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>Ingress 对象的命名必须是合法的 DNS 子域名名称。 </p><h4 id="Ingress类"><a href="#Ingress类" class="headerlink" title="Ingress类"></a>Ingress类</h4><p>Ingress 可以由不同的控制器实现，通常使用不同的配置。 每个 Ingress 应当指定一个类，也就是一个对 IngressClass 资源的引用。 IngressClass 资源包含额外的配置，其中包括应当实现该类的控制器名称。</p><h5 id="IngressClass的作用域"><a href="#IngressClass的作用域" class="headerlink" title="IngressClass的作用域"></a>IngressClass的作用域</h5><p>取决于 Ingress 控制器，可以使用集群范围设置的参数或某个名字空间范围的参数。</p><ul><li>集群作用域<br>  IngressClass 的参数默认是集群范围的。</li><li>命名空间作用域  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">external-lb-2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">controller:</span> <span class="string">example.com/ingress-controller</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">    <span class="comment"># 此 IngressClass 的配置定义在一个名为 “external-config” 的</span></span><br><span class="line">    <span class="comment"># IngressParameter（API 组为 k8s.example.com）资源中，</span></span><br><span class="line">    <span class="comment"># 该资源位于 “external-configuration” 命名空间中。</span></span><br><span class="line">    <span class="attr">scope:</span> <span class="string">Namespace</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">k8s.example.com</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">IngressParameter</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">external-configuration</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">external-config</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h3><p>为了让 Ingress 资源工作，集群必须有一个正在运行的 Ingress 控制器。</p><p>与作为 kube-controller-manager 可执行文件的一部分运行的其他类型的控制器不同， Ingress 控制器不是随集群自动启动的。<br>Kubernetes 作为一个项目，目前支持和维护 AWS、 GCE 和 <strong>Nginx</strong> Ingress 控制器。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/posts/65385.html"/>
      <url>/posts/65385.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p>单体应用是所有的代码都放在同一个工程中、部署在同一个服务器、同一项目的不同模块不同功能互相抢占资源。<br><img src="/posts/65385/%E6%A6%82%E5%BF%B5-%E5%8D%95%E4%BD%931.0.png" alt="单体1.0"></p><p>单台服务器的压力扛不住的时候，就要用到负载均衡技术，增加多台服务器来抗压，后端的数据库也可以用主从的方式来增加并发量。<br><img src="/posts/65385/%E6%A6%82%E5%BF%B5-%E5%8D%95%E4%BD%932.0.png" alt="单体2.0"></p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务就是将工程根据不同的业务规则拆分成微服务，部署在不同的服务器上，服务之间相互调用。</p><h2 id="微服务的技术选型"><a href="#微服务的技术选型" class="headerlink" title="微服务的技术选型"></a>微服务的技术选型</h2><h3 id="Dubbo-（阿里巴巴）"><a href="#Dubbo-（阿里巴巴）" class="headerlink" title="Dubbo （阿里巴巴）"></a>Dubbo （阿里巴巴）</h3><p>Dubbo是阿里开源的一个高性能RPC分布式服务框架，借助zookeeper来实现服务注册和发现。</p><h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><h4 id="第一代-Spring-Cloud-Netflix"><a href="#第一代-Spring-Cloud-Netflix" class="headerlink" title="第一代 Spring Cloud Netflix"></a>第一代 Spring Cloud Netflix</h4><h4 id="第二代-Spring-Cloud-Alibaba"><a href="#第二代-Spring-Cloud-Alibaba" class="headerlink" title="第二代 Spring Cloud Alibaba"></a>第二代 Spring Cloud Alibaba</h4><h3 id="Kubernetes-（Google）"><a href="#Kubernetes-（Google）" class="headerlink" title="Kubernetes （Google）"></a>Kubernetes （Google）</h3><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li>访问xxxx-dev.qingdao-xx.haier.net<ol><li>通过 DNS 解析出<code>*.qingdao-xx.haier.net</code>的 IP 地址（qingdao-xx k8s集群，域名为*.qingdao-xx.haier.net），三次握手建立TCP连接，发送http请求；</li><li>通过集群的负载均衡（ingress-nginx），根据路由规则找到<code>xxxx-dev.qingdao-xx.haier.net</code>所对应的<code>k8s service</code>；</li><li>通过<code>kube-proxy</code>，负载均衡到<code>service</code>相应的<code>Pod</code>。</li></ol></li><li>访问xxxx.haier.net/api/v1/xx-center/*<ol><li>通过 DNS 解析出 <code>xxxx.haier.net</code> 的IP地址，三次握手建立TCP连接，发送http请求；</li><li>通过反向代理，把<code>/api</code>的请求反向代理到<strong>API网关</strong>服务；</li><li><strong>API网关</strong>服务根据路由规则，转发到<code>api/v1/xx-center</code>相应的服务。</li></ol></li></ul><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p><a href="https://zhuanlan.zhihu.com/p/161277955">https://zhuanlan.zhihu.com/p/161277955</a><br><a href="https://juejin.cn/post/7138975184114941965">https://juejin.cn/post/7138975184114941965</a></p><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p><a href="https://zhuanlan.zhihu.com/p/519786231">https://zhuanlan.zhihu.com/p/519786231</a></p><p>API网关，是一个系统的后端总入口。</p><h3 id="HDS的API网关的实现方式"><a href="#HDS的API网关的实现方式" class="headerlink" title="HDS的API网关的实现方式"></a>HDS的API网关的实现方式</h3><p>Golang + Gin + ReverseProxy</p><p><img src="/posts/65385/microservice-gateway-hds.png"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>微服务多个实例，如何将流量合理的分摊到每个实例上。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-线程池-Fork/Join</title>
      <link href="/posts/38805.html"/>
      <url>/posts/38805.html</url>
      
        <content type="html"><![CDATA[<p>ForkJoinPool 是JDK 7加入的一个线程池类。Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。</p><h2 id="带着BAT大厂的面试问题去理解"><a href="#带着BAT大厂的面试问题去理解" class="headerlink" title="带着BAT大厂的面试问题去理解"></a>带着BAT大厂的面试问题去理解</h2><ul><li>Fork/Join主要用来解决什么样的问题?</li><li>Fork/Join框架是在哪个JDK版本中引入的?</li><li>Fork/Join框架主要包含哪三个模块? 模块之间的关系是怎么样的?</li><li>ForkJoinPool类继承关系?</li><li>ForkJoinTask抽象类继承关系? 在实际运用中，我们一般都会继承 RecursiveTask 、RecursiveAction 或 CountedCompleter 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。</li><li>整个Fork/Join 框架的执行流程/运行机制是怎么样的?</li><li>具体阐述Fork/Join的分治思想和work-stealing 实现方式?</li><li>有哪些JDK源码中使用了Fork/Join思想?</li><li>如何使用Executors工具类创建ForkJoinPool?</li><li>写一个例子: 用ForkJoin方式实现1+2+3+…+100000?</li><li>Fork/Join在使用时有哪些注意事项? 结合JDK中的斐波那契数列实例具体说明。</li></ul><h2 id="Fork-Join框架简介"><a href="#Fork-Join框架简介" class="headerlink" title="Fork/Join框架简介"></a>Fork/Join框架简介</h2><p>Fork/Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。</p><h3 id="三个模块及关系"><a href="#三个模块及关系" class="headerlink" title="三个模块及关系"></a>三个模块及关系</h3><p>Fork/Join框架主要包含三个模块:</p><ul><li>任务对象: <code>ForkJoinTask</code> (包括<code>RecursiveTask``、RecursiveAction</code> 和 <code>CountedCompleter</code>)</li><li>执行Fork/Join任务的线程: <code>ForkJoinWorkerThread</code></li><li>线程池: <code>ForkJoinPool</code></li></ul><p>这三者的关系是: ForkJoinPool可以通过池中的ForkJoinWorkerThread来处理ForkJoinTask任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from 《A Java Fork/Join Framework》Dong Lea</span></span><br><span class="line"><span class="function">Result <span class="title">solve</span><span class="params">(Problem problem)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (problem is small)</span><br><span class="line"> directly solve problem</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> split problem into independent parts</span><br><span class="line"> fork <span class="keyword">new</span> subtasks to solve each part</span><br><span class="line"> join all subtasks</span><br><span class="line"> compose result from subresults</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoinPool 只接收 ForkJoinTask 任务(在实际使用中，也可以接收 Runnable/Callable 任务，但在真正运行时，也会把这些任务封装成 ForkJoinTask 类型的任务)，RecursiveTask 是 ForkJoinTask 的子类，是一个可以递归执行的 ForkJoinTask，RecursiveAction 是一个无返回值的 RecursiveTask，CountedCompleter 在任务完成执行后会触发执行一个自定义的钩子函数。</p><p>在实际运用中，我们一般都会继承 <code>RecursiveTask</code> <code>、RecursiveAction</code> 或 <code>CountedCompleter</code> 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。</p><h3 id="核心思想：分治算法"><a href="#核心思想：分治算法" class="headerlink" title="核心思想：分治算法"></a>核心思想：分治算法</h3><h3 id="核心思想：work-stealing（工作窃取）"><a href="#核心思想：work-stealing（工作窃取）" class="headerlink" title="核心思想：work-stealing（工作窃取）"></a>核心思想：work-stealing（工作窃取）</h3><h3 id="Fokr-Join框架的执行流程"><a href="#Fokr-Join框架的执行流程" class="headerlink" title="Fokr/Join框架的执行流程"></a>Fokr/Join框架的执行流程</h3><h2 id="Fork-Join类关系"><a href="#Fork-Join类关系" class="headerlink" title="Fork/Join类关系"></a>Fork/Join类关系</h2><h3 id="ForkJoinPool继承关系"><a href="#ForkJoinPool继承关系" class="headerlink" title="ForkJoinPool继承关系"></a>ForkJoinPool继承关系</h3><p><img src="/posts/38805/forkjoin-ForkJoinPool.png"></p><h3 id="ForkJoinTask继承关系"><a href="#ForkJoinTask继承关系" class="headerlink" title="ForkJoinTask继承关系"></a>ForkJoinTask继承关系</h3><p><img src="/posts/38805/forkjoin-ForkJoinTask.png"></p><h2 id="再深入理解"><a href="#再深入理解" class="headerlink" title="再深入理解"></a>再深入理解</h2><h3 id="有哪些JDK源码中使用了Fork-Join思想？"><a href="#有哪些JDK源码中使用了Fork-Join思想？" class="headerlink" title="有哪些JDK源码中使用了Fork/Join思想？"></a>有哪些JDK源码中使用了Fork/Join思想？</h3><p>数组工具类 Arrays 在JDK 8之后新增的并行排序方法(parallelSort)就运用了 ForkJoinPool 的特性。<br>还有 ConcurrentHashMap 在JDK 8之后添加的函数式方法(如forEach等)也有运用。</p><h3 id="使用Executors工具类创建ForkJoinPool"><a href="#使用Executors工具类创建ForkJoinPool" class="headerlink" title="使用Executors工具类创建ForkJoinPool"></a>使用Executors工具类创建ForkJoinPool</h3><p>Java8在Executors工具类中新增了两个工厂方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parallelism定义并行级别</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span></span>;</span><br><span class="line"><span class="comment">// 默认并行级别为JVM可用的处理器个数</span></span><br><span class="line"><span class="comment">// Runtime.getRuntime().availableProcessors()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="关于Fork-Join异常处理"><a href="#关于Fork-Join异常处理" class="headerlink" title="关于Fork/Join异常处理"></a>关于Fork/Join异常处理</h3><h2 id="Fork-Join例子"><a href="#Fork-Join例子" class="headerlink" title="Fork/Join例子"></a>Fork/Join例子</h2><h3 id="采用Fork-Join来异步计算1-2-3-…-10000的结果"><a href="#采用Fork-Join来异步计算1-2-3-…-10000的结果" class="headerlink" title="采用Fork/Join来异步计算1+2+3+…+10000的结果"></a>采用Fork/Join来异步计算1+2+3+…+10000的结果</h3><h3 id="实现斐波那契数列"><a href="#实现斐波那契数列" class="headerlink" title="实现斐波那契数列"></a>实现斐波那契数列</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-线程池-FutureTask</title>
      <link href="/posts/63110.html"/>
      <url>/posts/63110.html</url>
      
        <content type="html"><![CDATA[<p>Future 表示了一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对其结果的访问。在并发包中许多异步任务类都继承自Future，其中最典型的就是 FutureTask。</p><h2 id="带着BAT大厂的面试问题去理解"><a href="#带着BAT大厂的面试问题去理解" class="headerlink" title="带着BAT大厂的面试问题去理解"></a>带着BAT大厂的面试问题去理解</h2><ul><li>FutureTask用来解决什么问题的? 为什么会出现?</li><li>FutureTask类结构关系怎么样的?</li><li>FutureTask的线程安全是由什么保证的?</li><li>FutureTask结果返回机制?</li><li>FutureTask内部运行状态的转变?</li><li>FutureTask通常会怎么用? 举例说明。</li></ul><h2 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h2><p>FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。<br>如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。<br>FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。<br>除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。<br>FutureTask 的线程安全由CAS来保证。</p><h2 id="FutureTask类关系"><a href="#FutureTask类关系" class="headerlink" title="FutureTask类关系"></a>FutureTask类关系</h2><p><img src="/posts/63110/futuretask-%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p><p>FutureTask实现了RunnableFuture接口，则RunnableFuture接口继承了Runnable接口和Future接口。<br>所以FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。</p><h2 id="FutureTask源码解析"><a href="#FutureTask源码解析" class="headerlink" title="FutureTask源码解析"></a>FutureTask源码解析</h2><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable是个泛型接口，泛型V就是要call()方法返回的类型。<br>对比Runnable接口，Runnable不会返回数据也不能抛出异常。</p><h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>Future接口代表异步计算的结果，通过Future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。</p><p>Future接口的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cancel()<br>  cancel()方法用来取消异步任务的执行。<br>  如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。<br>  如果任务还没有被执行，则会返回true并且异步任务不会被执行。<br>  如果任务已经开始执行了但是还没有执行完成，若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true，若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。</li><li>isCanceled()<br>  判断任务是否被取消，如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true，否则返回false。</li><li>isDone()<br>  判断任务是否已经完成，如果完成则返回true，否则返回false。<br>  需要注意的是：任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回true。</li><li>get()<br>  获取任务执行结果。<br>  如果任务还没完成则会阻塞等待直到任务执行完成。<br>  如果任务被取消则会抛出CancellationException异常，如果任务执行过程发生异常则会抛出ExecutionException异常，如果阻塞等待过程中被中断则会抛出InterruptedException异常。</li><li>get(long timeout,Timeunit unit)<br>  带超时时间的get()版本，如果阻塞等待过程中超时则会抛出TimeoutException异常。</li></ul><h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部持有的callable任务，运行完毕后置空</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从get()中返回的结果或抛出的异常</span></span><br><span class="line"><span class="comment">// outcome的赋值过程：run() -&gt; set(V v)</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行callable的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Treiber栈保存等待线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="FutureTask-Callable-callable"><a href="#FutureTask-Callable-callable" class="headerlink" title="FutureTask(Callable callable)"></a>FutureTask(Callable<V> callable)</V></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数会把传入的Callable变量保存在this.callable字段中，该字段定义为<code>private Callable&lt;V&gt; callable;</code>用来保存底层的调用，在被执行完成以后会指向null，接着会初始化state字段为NEW。</p><h4 id="FutureTask-Runnable-runnable-V-result"><a href="#FutureTask-Runnable-runnable-V-result" class="headerlink" title="FutureTask(Runnable runnable, V result)"></a>FutureTask(Runnable runnable, V result)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数会把传入的Runnable封装成一个Callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。这种情况下如果不需要返回值的话可以传入一个null。</p><p>看下Executors.callable()这个方法，这个方法的功能是把Runnable转换成Callable。<br>采用适配器模式，调用<code>RunnableAdapter&lt;T&gt;(task, result)</code>方法来适配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors.callable()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors.RunnableAdapter</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法-run"><a href="#核心方法-run" class="headerlink" title="核心方法 run()"></a>核心方法 run()</h3><p>在new了一个FutureTask对象之后，接下来就是在另一个线程中执行这个Task,无论是通过直接new一个Thread还是通过线程池，执行的都是run()方法，接下来就看看run()方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务状态为NEW状态，则CAS替换runner为当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">// 设置执行结果，将result set给outcome</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);<span class="comment">//处理中断逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法说明：</p><ol><li>运行任务，如果任务状态为NEW，则CAS替换runner为当前线程。执行完毕调用<code>set(result)</code>方法设置执行结果。<br> 首先利用cas修改state状态为COMPLETING，设置返回结果，然后使用 lazySet(UNSAFE.putOrderedInt)的方式设置state状态为NORMAL。结果设置完毕后，调用finishCompletion()方法唤醒等待线程。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();<span class="comment">//执行完毕，唤醒等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;<span class="comment">//移除等待线程</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋遍历等待线程</span></span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);<span class="comment">//唤醒等待线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//任务完成后调用函数，自定义扩展</span></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果在 run 期间被中断，此时需要调用handlePossibleCancellationInterrupt方法来处理中断逻辑，确保任何中断(例如cancel(true))只停留在当前run或runAndReset的任务中。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在中断者中断线程之前可能会延迟，所以我们只需要让出CPU时间片自旋等待</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="核心方法-get"><a href="#核心方法-get" class="headerlink" title="核心方法 get()"></a>核心方法 get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 通过<code>get()</code>方法获取任务执行结果。如果任务处于未完成的状态<code>(state &lt;= COMPLETING)</code>，就调用<code>awaitDone</code>方法(后面单独讲解)等待任务完成。任务完成后，通过<code>report</code>方法获取执行结果或抛出执行期间的异常。</p><p>report源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回执行结果或抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法-awaitDone-boolean-timed-long-nanos"><a href="#核心方法-awaitDone-boolean-timed-long-nanos" class="headerlink" title="核心方法 - awaitDone(boolean timed, long nanos)"></a>核心方法 - awaitDone(boolean timed, long nanos)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;<span class="comment">//获取并清除中断状态</span></span><br><span class="line">            removeWaiter(q);<span class="comment">//移除等待WaitNode</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;<span class="comment">//置空等待节点的线程</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//CAS修改waiter</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);<span class="comment">//超时，移除等待节点</span></span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);<span class="comment">//阻塞当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);<span class="comment">//阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法-cancel-boolean-mayInterruptIfRunning"><a href="#核心方法-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="核心方法 - cancel(boolean mayInterruptIfRunning)"></a>核心方法 - cancel(boolean mayInterruptIfRunning)</h3><h2 id="FutureTask使用示例"><a href="#FutureTask使用示例" class="headerlink" title="FutureTask使用示例"></a>FutureTask使用示例</h2><p>常用使用方式：</p><ul><li>第一种方式: Future + ExecutorService</li><li>第二种方式: FutureTask + ExecutorService</li><li>第三种方式: FutureTask + Thread</li></ul><h3 id="Future例子"><a href="#Future例子" class="headerlink" title="Future例子"></a>Future例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">          Future future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  Long start = System.currentTimeMillis();</span><br><span class="line">                  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                      Long current = System.currentTimeMillis();</span><br><span class="line">                     <span class="keyword">if</span> ((current - start) &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Integer result = (Integer)future.get();</span><br><span class="line">             System.out.println(result);</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FutureTask例子"><a href="#FutureTask例子" class="headerlink" title="FutureTask例子"></a>FutureTask例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一种方式:Future + ExecutorService</span></span><br><span class="line"><span class="comment">         * Task task = new Task();</span></span><br><span class="line"><span class="comment">         * ExecutorService service = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">         * Future&lt;Integer&gt; future = service.submit(task1);</span></span><br><span class="line"><span class="comment">         * service.shutdown();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二种方式: FutureTask + ExecutorService</span></span><br><span class="line"><span class="comment">         * ExecutorService executor = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">         * Task task = new Task();</span></span><br><span class="line"><span class="comment">         * FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">         * executor.submit(futureTask);</span></span><br><span class="line"><span class="comment">         * executor.shutdown();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第三种方式:FutureTask + Thread</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2. 新建FutureTask,需要一个实现了Callable接口的类的实例作为构造函数参数</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Task());</span><br><span class="line">        <span class="comment">// 3. 新建Thread对象并启动</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.setName(<span class="string">&quot;Task thread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;Thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is running&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4. 调用isDone()判断任务是否结束</span></span><br><span class="line">        <span class="keyword">if</span>(!futureTask.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task is not done&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5. 调用get()方法获取任务结果,如果任务没有执行完成则阻塞等待</span></span><br><span class="line">            result = futureTask.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;result is &quot;</span> + result);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1. 继承Callable接口,实现call()方法,泛型参数为要返回的类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span>  <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is running&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;++i) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC-类汇总</title>
      <link href="/posts/15409.html"/>
      <url>/posts/15409.html</url>
      
        <content type="html"><![CDATA[<h2 id="带着BAT大厂的面试问题去理解"><a href="#带着BAT大厂的面试问题去理解" class="headerlink" title="带着BAT大厂的面试问题去理解"></a>带着BAT大厂的面试问题去理解</h2><ul><li>JUC框架包含几个部分?</li><li>每个部分有哪些核心的类?</li><li>最最核心的类有哪些?</li></ul><p><img src="/posts/15409/java-juc-overview.png"><br>主要包含: (注意: 上图是网上找的图，无法表述一些继承关系，同时少了部分类；但是主体上可以看出其分类关系也够了)</p><ul><li>Lock框架和Tools类(把图中这两个放到一起理解)</li><li>Collections: 并发集合</li><li>Atomic: 原子类</li><li>Executors: 线程池</li></ul><h2 id="Lock框架和Tools类"><a href="#Lock框架和Tools类" class="headerlink" title="Lock框架和Tools类"></a>Lock框架和Tools类</h2><h3 id="类结构概览"><a href="#类结构概览" class="headerlink" title="类结构概览"></a>类结构概览</h3><p><img src="/posts/15409/juc-overview-lock.png"></p><p><img src="/posts/15409/AQS%E7%9B%B8%E5%85%B3%E7%B1%BB.png"></p><h3 id="接口-Condition"><a href="#接口-Condition" class="headerlink" title="接口: Condition"></a>接口: Condition</h3><p>Condition为接口类型，它将 Object 监视器方法(wait、notify 和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。可以通过await(),signal()来休眠/唤醒线程。</p><h3 id="接口-Lock"><a href="#接口-Lock" class="headerlink" title="接口: Lock"></a>接口: Lock</h3><p>Lock为接口类型，Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。</p><h3 id="接口-ReadWriteLock"><a href="#接口-ReadWriteLock" class="headerlink" title="接口: ReadWriteLock"></a>接口: ReadWriteLock</h3><p>ReadWriteLock为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。</p><h3 id="抽象类-AbstractOwnableSynchonizer"><a href="#抽象类-AbstractOwnableSynchonizer" class="headerlink" title="抽象类: AbstractOwnableSynchonizer"></a>抽象类: AbstractOwnableSynchonizer</h3><p>AbstractOwnableSynchonizer为抽象类，可以由线程以独占方式拥有的同步器。此类为创建锁和相关同步器(伴随着所有权的概念)提供了基础。AbstractOwnableSynchronizer 类本身不管理或使用此信息。但是，子类和工具可以使用适当维护的值帮助控制和监视访问以及提供诊断。</p><h3 id="抽象类-long-AbstractQueuedLongSynchronizer"><a href="#抽象类-long-AbstractQueuedLongSynchronizer" class="headerlink" title="抽象类(long): AbstractQueuedLongSynchronizer"></a>抽象类(long): AbstractQueuedLongSynchronizer</h3><p>AbstractQueuedLongSynchronizer为抽象类，以 long 形式维护同步状态的一个 AbstractQueuedSynchronizer 版本。此类具有的结构、属性和方法与 AbstractQueuedSynchronizer 完全相同，但所有与状态相关的参数和结果都定义为 long 而不是 int。当创建需要 64 位状态的多级别锁和屏障等同步器时，此类很有用。</p><h3 id="核心抽象类-int-AbstractQueuedSynchronizer"><a href="#核心抽象类-int-AbstractQueuedSynchronizer" class="headerlink" title="核心抽象类(int): AbstractQueuedSynchronizer"></a>核心抽象类(int): AbstractQueuedSynchronizer</h3><p>AbstractQueuedSynchronizer为抽象类，其为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器(信号量、事件，等等)提供一个框架。此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。</p><h3 id="锁常用类-LockSupport"><a href="#锁常用类-LockSupport" class="headerlink" title="锁常用类: LockSupport"></a>锁常用类: LockSupport</h3><p>LockSupport为常用类，用来创建锁和其他同步类的基本线程阻塞原语。LockSupport的功能和”Thread中的 Thread.suspend()和Thread.resume()有点类似”，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。</p><h3 id="锁常用类-ReentrantLock"><a href="#锁常用类-ReentrantLock" class="headerlink" title="锁常用类: ReentrantLock"></a>锁常用类: ReentrantLock</h3><p>ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</p><h3 id="锁常用类-ReentrantReadWriteLock"><a href="#锁常用类-ReentrantReadWriteLock" class="headerlink" title="锁常用类: ReentrantReadWriteLock"></a>锁常用类: ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括Lock子类ReadLock和WriteLock。ReadLock是共享锁，WriteLock是独占锁。</p><h3 id="锁常用类-StampedLock"><a href="#锁常用类-StampedLock" class="headerlink" title="锁常用类: StampedLock"></a>锁常用类: StampedLock</h3><p>它是java8在java.util.concurrent.locks新增的一个API。StampedLock控制锁有三种模式(写，读，乐观读)，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p><h3 id="工具常用类-CountDownLatch"><a href="#工具常用类-CountDownLatch" class="headerlink" title="工具常用类: CountDownLatch"></a>工具常用类: CountDownLatch</h3><p>CountDownLatch为常用类，它是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p><h3 id="工具常用类-CyclicBarrier"><a href="#工具常用类-CyclicBarrier" class="headerlink" title="工具常用类: CyclicBarrier"></a>工具常用类: CyclicBarrier</h3><p>CyclicBarrier为常用类，其是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p><h3 id="工具常用类-Phaser"><a href="#工具常用类-Phaser" class="headerlink" title="工具常用类: Phaser"></a>工具常用类: Phaser</h3><p>Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。</p><h3 id="工具常用类-Semaphore"><a href="#工具常用类-Semaphore" class="headerlink" title="工具常用类: Semaphore"></a>工具常用类: Semaphore</h3><p>Semaphore为常用类，其是一个计数信号量，从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。通常用于限制可以访问某些资源(物理或逻辑的)的线程数目。</p><h3 id="工具常用类-Exchanger"><a href="#工具常用类-Exchanger" class="headerlink" title="工具常用类: Exchanger"></a>工具常用类: Exchanger</h3><p>Exchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。</p><h2 id="Collections-并发集合"><a href="#Collections-并发集合" class="headerlink" title="Collections: 并发集合"></a>Collections: 并发集合</h2><h3 id="类结构关系"><a href="#类结构关系" class="headerlink" title="类结构关系"></a>类结构关系</h3><p><img src="/posts/15409/juc-overview-collection.png"></p><h3 id="Queue-ArrayBlockingQueue"><a href="#Queue-ArrayBlockingQueue" class="headerlink" title="Queue: ArrayBlockingQueue"></a>Queue: ArrayBlockingQueue</h3><p>一个由数组支持的有界阻塞队列。此队列按 FIFO(先进先出)原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。</p><h3 id="Queue-LinkedBlockingQueue"><a href="#Queue-LinkedBlockingQueue" class="headerlink" title="Queue: LinkedBlockingQueue"></a>Queue: LinkedBlockingQueue</h3><p>一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO(先进先出)排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。</p><h3 id="Queue-LinkedBlockingDeque"><a href="#Queue-LinkedBlockingDeque" class="headerlink" title="Queue: LinkedBlockingDeque"></a>Queue: LinkedBlockingDeque</h3><p>一个基于已链接节点的、任选范围的阻塞双端队列。</p><h3 id="Queue-ConcurrentLinkedQueue"><a href="#Queue-ConcurrentLinkedQueue" class="headerlink" title="Queue: ConcurrentLinkedQueue"></a>Queue: ConcurrentLinkedQueue</h3><p>一个基于链接节点的无界线程安全队列。此队列按照 FIFO(先进先出)原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。</p><h3 id="Queue-ConcurrentLinkedDeque"><a href="#Queue-ConcurrentLinkedDeque" class="headerlink" title="Queue: ConcurrentLinkedDeque"></a>Queue: ConcurrentLinkedDeque</h3><p>是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。</p><h3 id="Queue-DelayQueue"><a href="#Queue-DelayQueue" class="headerlink" title="Queue: DelayQueue"></a>Queue: DelayQueue</h3><p>延时无界阻塞队列，使用Lock机制实现并发访问。队列里只允许放可以“延期”的元素，队列中的head是最先“到期”的元素。如果队里中没有元素到“到期”，那么就算队列中有元素也不能获取到。</p><h3 id="Queue-PriorityBlockingQueue"><a href="#Queue-PriorityBlockingQueue" class="headerlink" title="Queue: PriorityBlockingQueue"></a>Queue: PriorityBlockingQueue</h3><p>无界优先级阻塞队列，使用Lock机制实现并发访问。priorityQueue的线程安全版，不允许存放null值，依赖于comparable的排序，不允许存放不可比较的对象类型。</p><h3 id="Queue-SynchronousQueue"><a href="#Queue-SynchronousQueue" class="headerlink" title="Queue: SynchronousQueue"></a>Queue: SynchronousQueue</h3><p>没有容量的同步队列，通过CAS实现并发访问，支持FIFO和FILO。</p><h3 id="Queue-LinkedTransferQueue"><a href="#Queue-LinkedTransferQueue" class="headerlink" title="Queue: LinkedTransferQueue"></a>Queue: LinkedTransferQueue</h3><p>JDK 7新增，单向链表实现的无界阻塞队列，通过CAS实现并发访问，队列元素使用 FIFO(先进先出)方式。LinkedTransferQueue可以说是ConcurrentLinkedQueue、SynchronousQueue(公平模式)和LinkedBlockingQueue的超集, 它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。</p><h3 id="List-CopyOnWriteArrayList"><a href="#List-CopyOnWriteArrayList" class="headerlink" title="List: CopyOnWriteArrayList"></a>List: CopyOnWriteArrayList</h3><p>ArrayList 的一个线程安全的变体，其中所有可变操作(add、set 等等)都是通过对底层数组进行一次新的复制来实现的。这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，它也很有用。</p><h3 id="Set-CopyOnWriteArraySet"><a href="#Set-CopyOnWriteArraySet" class="headerlink" title="Set: CopyOnWriteArraySet"></a>Set: CopyOnWriteArraySet</h3><p>对其所有操作使用内部CopyOnWriteArrayList的Set。即将所有操作转发至CopyOnWriteArayList来进行操作，能够保证线程安全。在add时，会调用addIfAbsent，由于每次add时都要进行数组遍历，因此性能会略低于CopyOnWriteArrayList。</p><h3 id="Set-ConcurrentSkipListSet"><a href="#Set-ConcurrentSkipListSet" class="headerlink" title="Set: ConcurrentSkipListSet"></a>Set: ConcurrentSkipListSet</h3><p>一个基于ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的 Comparator 进行排序，具体取决于使用的构造方法。</p><h3 id="Map-ConcurrentHashMap"><a href="#Map-ConcurrentHashMap" class="headerlink" title="Map: ConcurrentHashMap"></a>Map: ConcurrentHashMap</h3><p>是线程安全HashMap的。ConcurrentHashMap在JDK 7之前是通过Lock和segment(分段锁)实现，JDK 8 之后改为CAS+synchronized来保证并发安全。</p><h3 id="Map-ConcurrentSkipListMap"><a href="#Map-ConcurrentSkipListMap" class="headerlink" title="Map: ConcurrentSkipListMap"></a>Map: ConcurrentSkipListMap</h3><p>线程安全的有序的哈希表(相当于线程安全的TreeMap);映射可以根据键的自然顺序进行排序，也可以根据创建映射时所提供的 Comparator 进行排序，具体取决于使用的构造方法。</p><h2 id="Atomic：原子类"><a href="#Atomic：原子类" class="headerlink" title="Atomic：原子类"></a>Atomic：原子类</h2><p>其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。</p><h3 id="基础类型：AtomicBoolean，AtomicInteger，AtomicLong"><a href="#基础类型：AtomicBoolean，AtomicInteger，AtomicLong" class="headerlink" title="基础类型：AtomicBoolean，AtomicInteger，AtomicLong"></a>基础类型：AtomicBoolean，AtomicInteger，AtomicLong</h3><p>AtomicBoolean，AtomicInteger，AtomicLong是类似的，分别针对bool，interger，long的原子类。</p><h3 id="数组：AtomicIntegerArray，AtomicLongArray，AtomicBooleanArray"><a href="#数组：AtomicIntegerArray，AtomicLongArray，AtomicBooleanArray" class="headerlink" title="数组：AtomicIntegerArray，AtomicLongArray，AtomicBooleanArray"></a>数组：AtomicIntegerArray，AtomicLongArray，AtomicBooleanArray</h3><p>AtomicIntegerArray，AtomicLongArray，AtomicBooleanArray是数组原子类。</p><h3 id="引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference"><a href="#引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference" class="headerlink" title="引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference"></a>引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference</h3><p>AtomicReference，AtomicMarkedReference，AtomicStampedReference是引用相关的原子类。</p><h3 id="FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater"><a href="#FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater" class="headerlink" title="FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater"></a>FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</h3><p>AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater是FieldUpdater原子类。</p><h2 id="Executors：线程池"><a href="#Executors：线程池" class="headerlink" title="Executors：线程池"></a>Executors：线程池</h2><h3 id="类结构关系-1"><a href="#类结构关系-1" class="headerlink" title="类结构关系"></a>类结构关系</h3><p><img src="/posts/15409/juc-overview-executors.png"></p><h3 id="接口-Executor"><a href="#接口-Executor" class="headerlink" title="接口: Executor"></a>接口: Executor</h3><p>Executor接口提供一种将任务提交与每个任务将如何运行的机制(包括线程使用的细节、调度等)分离开来的方法。<br>通常使用 Executor 而不是显式地创建线程。</p><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>ExecutorService继承自Executor接口，ExecutorService提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。<br>可以关闭 ExecutorService，这将导致其停止接受新任务。关闭后，执行程序将最后终止，这时没有任务在执行，也没有任务在等待执行，并且无法提交新任务。</p><h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p>ScheduledExecutorService继承自ExecutorService接口，可安排在给定的延迟后运行或定期执行的命令。</p><h3 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h3><p>AbstractExecutorService继承自ExecutorService接口，其提供 ExecutorService 执行方法的默认实现。<br>此类使用 newTaskFor 返回的 RunnableFuture 实现 submit、invokeAny 和 invokeAll 方法，默认情况下，RunnableFuture 是此包中提供的 FutureTask 类。</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。<br>如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。<br>FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。<br>除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。<br>FutureTask 的线程安全由CAS来保证。</p><h3 id="核心-ThreadPoolExecutor"><a href="#核心-ThreadPoolExecutor" class="headerlink" title="核心: ThreadPoolExecutor"></a>核心: ThreadPoolExecutor</h3><p>ThreadPoolExecutor实现了AbstractExecutorService接口，也是一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。<br>线程池可以解决两个不同问题: 由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源(包括执行任务集时使用的线程)的方法。<br>每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</p><h3 id="核心-ScheduledThreadExecutor"><a href="#核心-ScheduledThreadExecutor" class="headerlink" title="核心: ScheduledThreadExecutor"></a>核心: ScheduledThreadExecutor</h3><p>ScheduledThreadPoolExecutor实现ScheduledExecutorService接口，可安排在给定的延迟后运行命令，或者定期执行命令。<br>需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。</p><h3 id="核心-Fork-Join框架"><a href="#核心-Fork-Join框架" class="headerlink" title="核心: Fork/Join框架"></a>核心: Fork/Join框架</h3><p>ForkJoinPool 是JDK 7加入的一个线程池类。Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。</p><h3 id="工具类-Executors"><a href="#工具类-Executors" class="headerlink" title="工具类: Executors"></a>工具类: Executors</h3><p>Executors是一个工具类，用其可以创建ExecutorService、ScheduledExecutorService、ThreadFactory、Callable等对象。它的使用融入到了ThreadPoolExecutor, ScheduledThreadExecutor和ForkJoinPool中。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构-SpringCloud</title>
      <link href="/posts/42622.html"/>
      <url>/posts/42622.html</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud的目标是微服务架构的一站式解决方案。<br>Spring Cloud 可以说是 Spring 社区为微服务架构提供的一个“全家桶”套餐。<br>由于“套餐”中的组件通过一个社区进行包装与整合，使得“套餐”中各个组件之间的配合变得更加和谐，这可以有效减少我们在组件的选型和整合上花费的精力，所以它可以帮助我们快速构建起基础的微服务架构系统。</p><p><a href="https://spring.io/projects/spring-boot">springboot官网</a><br><a href="https://spring.io/projects/spring-cloud">springcloud官网</a></p><table><thead><tr><th align="left"></th><th align="left">第一代 Spring Cloud（Netflix，SCN）</th><th align="left">第二代 Spring Cloud（Spring Cloud Alibaba，SCA）</th></tr></thead><tbody><tr><td align="left"><strong>注册中心</strong></td><td align="left">Netflix Eureka（2.0孵化失败）</td><td align="left">阿里巴巴 Nacos</td></tr><tr><td align="left"><strong>客户端负载均衡</strong></td><td align="left">Netflix Ribbon</td><td align="left">阿里巴巴 Dubbo LB、Spring Cloud Loadbalancer</td></tr><tr><td align="left"><strong>熔断器</strong></td><td align="left">Netflix Hystrix</td><td align="left">阿里巴巴 Sentinel</td></tr><tr><td align="left"><strong>网关</strong></td><td align="left">Netflix Zuul</td><td align="left">官方 Spring Cloud Gateway</td></tr><tr><td align="left"><strong>配置中心</strong></td><td align="left">官方 Spring Cloud Config</td><td align="left">阿里巴巴 Nacos、携程 Apollo</td></tr><tr><td align="left">服务调用</td><td align="left">Netflix Feign</td><td align="left">阿里巴巴 Dubbo RPC</td></tr><tr><td align="left">消息驱动</td><td align="left">官方 Spring Cloud Stream</td><td align="left"></td></tr><tr><td align="left">链路追踪</td><td align="left">官方 Spring Cloud Sleuth/Zipkin</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">阿里巴巴 seata 分布式事务方案</td></tr></tbody></table><h2 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h2><p><strong>Spring Cloud Netflix的五大组件(神兽)</strong></p><ul><li>Eureka：服务注册和发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便的查看所有注册的服务的界面。 所有的服务使用Eureka的服务发现客户端来将自己注册到Eureka的服务器上。</li><li>Zuul：网关，所有的客户端请求通过这个网关访问后台的服务。他可以使用一定的路由配置来判断某一个URL由哪个服务来处理。并从Eureka获取注册的服务来转发请求。</li><li>Ribbon：即负载均衡，Zuul网关将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过Ribbon来通过一定的负载均衡策略来发送给某一个服务实例。</li><li>Feign：服务客户端，服务之间如果需要相互访问，可以使用RestTemplate，也可以使用Feign客户端访问。它默认会使用Ribbon来实现负载均衡。</li><li>Hystrix：监控和断路器。我们只需要在服务接口上添加Hystrix标签，就可以实现对这个接口的监控和断路器功能。</li></ul><h2 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h2><h2 id="停更的组件"><a href="#停更的组件" class="headerlink" title="停更的组件"></a>停更的组件</h2><p><img src="/posts/42622/springcloud-stop.png"></p><p><strong>服务注册中心</strong></p><ul><li>Eureka：官方停止更新，并且已经有更好的替代产品了，可以使用，但是官方已经不建议使用了（重度患者）。</li><li>Zookeeper：某些老系统，以前是用的Zookeeper + Dubbo，后来做技术升级，结果发现SpringCloud的Eureka停更了，然后就用了最少的技术切换，那么就用了Zookeeper做注册中心。</li><li>Consul：go语言开发的，也是一个优秀的服务注册框架，但是使用量较少，风头都被Nacos抢了。</li><li>Nacos：来自于SpringCloudAlibaba，在企业中经过了百万级注册考验的，不但可以完美替换Eureka，还能做其他组件的替换，所以强烈建议使用，是学习的重点。</li></ul><p><strong>服务调用</strong></p><ul><li>Ribbon：也进入了维护状态，停止更新了，但是Spring官方还在使用（轻度患者）。</li><li>LoadBalancer：Spring官方推出的一个新的组件，打算逐渐取代掉Ribbon。</li></ul><p><strong>服务调用2</strong></p><ul><li>Feign：Netflix 公司产品，也停止更新了。</li><li>OpenFeign：Spring社区等不了Netflix更新了，然后就自己做了一个组件，不用Feign了。</li></ul><p><strong>服务降级</strong></p><ul><li>Hystrix：官网不推荐使用，但是中国企业中还在大规模使用。</li><li>Resilience4J：官网推荐使用，但是国内很少用这个。</li><li>Sentienl：来自于SpringCloudAlibaba，在中国企业替换Hystrix的组件，国内强烈建议使用。</li></ul><p><strong>服务网关</strong></p><ul><li>Zuul：Netflix 公司产品，公司内部产生分歧，有的人想自己出一个Zuul2。</li><li>Zuul2：也是Netflix 公司准备出的产品，但是由于内部分歧，所以Zuul2已经胎死腹中了。</li><li>gateway：Spring社区自己出的网关组件，官方隆重介绍和极度推荐的网关服务组件。</li></ul><p><strong>服务配置</strong></p><ul><li>Config：目前也在使用，风头被Nacos抢了。</li><li>Nacos：来自于SpringCloudAlibaba，后来居上，把Config给替换了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-spring</title>
      <link href="/posts/22426.html"/>
      <url>/posts/22426.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis-Spring 帮助将 MyBatis 代码无缝地整合到 Spring 中。</p><p><img src="/posts/22426/mybatis-spring-%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%9D%97.png"></p><h2 id="Mybatis与Spring集成时都做了什么？"><a href="#Mybatis与Spring集成时都做了什么？" class="headerlink" title="Mybatis与Spring集成时都做了什么？"></a>Mybatis与Spring集成时都做了什么？</h2><p>MyBatis集成Spring后，Spring侵入了Mybatis的初始化和mapper绑定，具体就是：</p><ol><li>Cofiguration的实例化是读取Spring的配置文件（注解、配置文件），而不是mybatis-config.xml</li><li>mapper对象是方法级别的，Spring通过FactoryBean巧妙地解决了这个问题</li><li>事务交由Spring管理</li></ol><h3 id="初始化相关"><a href="#初始化相关" class="headerlink" title="初始化相关"></a>初始化相关</h3><p>在基础的MyBatis中，通过SqlSessionFactoryBuilder创建SqlSessionFactory。<br>集成Spring后由SqlSessionFactoryBean来创建。　　</p><p>Cofiguration的实例化是读取Spring的配置文件（注解、配置文件），而不是mybatis-config.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBean</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">SqlSessionFactory</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//配置加载完毕后，创建SqlSessionFactory</span></span><br><span class="line">        afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回sqlSessionFactory</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        notNull(dataSource, <span class="string">&quot;Property &#x27;dataSource&#x27; is required&quot;</span>);</span><br><span class="line">        notNull(sqlSessionFactoryBuilder, <span class="string">&quot;Property &#x27;sqlSessionFactoryBuilder&#x27; is required&quot;</span>);</span><br><span class="line">        state((configuration == <span class="keyword">null</span> &amp;&amp; configLocation == <span class="keyword">null</span>) || !(configuration != <span class="keyword">null</span> &amp;&amp; configLocation != <span class="keyword">null</span>),</span><br><span class="line">            <span class="string">&quot;Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactory = buildSqlSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SqlSessionFactory <span class="title">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Configuration targetConfiguration;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>MyBatis-Spring 允许 MyBatis 参与到 Spring 的事务管理中。<br>借助 Spring 的 DataSourceTransactionManager 实现事务管理。</p><p>SqlSeeion与事务的关系：</p><ol><li>同一事务中不管调用多少次 mapper里的方法，最终都是用得同一个sqlSession，即一个事务中使用的是同一个sqlSession。</li><li>如果没有开启事务，调用一次mapper里的方法将会新建一个 sqlSession 来执行方法。</li></ol><h3 id="SqlSeeion"><a href="#SqlSeeion" class="headerlink" title="SqlSeeion"></a>SqlSeeion</h3><p>在MyBatis 中，使用 SqlSessionFactory 来创建 SqlSession。通过它执行映射的sql语句，提交或回滚连接，当不再需要它的时候，可以关闭 session。<br>使用 MyBatis-Spring 之后，我们不再需要直接使用 SqlSessionFactory 了，因为我们的bean 可以被注入一个线程安全的 SqlSession，它能基于 Spring 的事务配置来自动提交、回滚、关闭 session。</p><p>spring整合mybatis之后，通过动态代理的方式，使用SqlSessionTemplate持有的sqlSessionProxy属性来代理执行sql操作。方法执行完操作后，会执行finally里面的代码对sqlSeesion进行关闭。<br>因此，spring整合mybatis之后，由spring管理的sqlSeesion在sql方法(增删改查等操作)执行完毕后就自行关闭了sqlSession，不需要我们对其进行手动关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> externalSqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionDaoSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.externalSqlSession) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sqlSession = <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionTemplate</span><span class="params">(SqlSessionTemplate sqlSessionTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSessionTemplate;</span><br><span class="line">        <span class="keyword">this</span>.externalSqlSession = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.sqlSession, <span class="string">&quot;Property &#x27;sqlSessionFactory&#x27; or &#x27;sqlSessionTemplate&#x27; are required&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title">SqlSession</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="params"><span class="function">        PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        notNull(sqlSessionFactory, <span class="string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);</span><br><span class="line">        notNull(executorType, <span class="string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">        <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">        <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; SqlSession.class &#125;, <span class="keyword">new</span> SqlSessionInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SqlSession sqlSession = getSqlSession(SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory,</span><br><span class="line">            SqlSessionTemplate.<span class="keyword">this</span>.executorType, SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = method.invoke(sqlSession, args);</span><br><span class="line">            <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">            <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">            <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">            sqlSession.commit(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Throwable unwrapped = unwrapThrowable(t);</span><br><span class="line">            <span class="keyword">if</span> (SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator != <span class="keyword">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">            <span class="comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span></span><br><span class="line">            closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">            sqlSession = <span class="keyword">null</span>;</span><br><span class="line">            Throwable translated = SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator</span><br><span class="line">                .translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">            <span class="keyword">if</span> (translated != <span class="keyword">null</span>) &#123;</span><br><span class="line">                unwrapped = translated;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> unwrapped;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// closeSqlSession</span></span><br><span class="line">                closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射器-Mapper"><a href="#映射器-Mapper" class="headerlink" title="映射器 Mapper"></a>映射器 Mapper</h3><h4 id="Mapper的注册"><a href="#Mapper的注册" class="headerlink" title="Mapper的注册"></a>Mapper的注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  <span class="doctag">@MapperScan</span>注解方式  */</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.feng.blog.mybatis.*.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HaierDocumentCenterApplication</span> </span>&#123;&#125; </span><br></pre></td></tr></table></figure><p>最终mapper接口都将被注册为MapperFactoryBean。</p><h4 id="MapperFactoryBean分析"><a href="#MapperFactoryBean分析" class="headerlink" title="MapperFactoryBean分析"></a>MapperFactoryBean分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. MapperFactoryBean.getObject()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. SqlSessionTemplate.getMapper()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title">SqlSession</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getConfiguration().getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. Configuration.getMapper()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. MapperRegistry.getMapper()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">        <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. MapperProxyFactory.newInstance()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">        <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终看到动态代理生成了一个新的代理实例返回了，也就是说，我们使用@Autowired注解进来一个Mapper接口，每次使用时都会由代理生成一个新的实例。</p><p><strong>为什么在Mybatis中SqlSession是方法级的，Mapper是方法级的，在集成Spring后却可以注入到类中使用？</strong><br>因为在Mybatis-Spring中所有Mapper被注册为FactoryBean，每次调用都会执行getObject()，返回新实例。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch-数据同步方案</title>
      <link href="/posts/35373.html"/>
      <url>/posts/35373.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据同步类型"><a href="#数据同步类型" class="headerlink" title="数据同步类型"></a>数据同步类型</h2><ol><li>增量同步<br> ES服务接入后，MySQL数据库数据实时增量同步至ES中。</li><li>全量同步<br> ES服务接入时，将MySQL中的历史数据优雅切完整的置入ES中。</li></ol><h2 id="数据同步方案"><a href="#数据同步方案" class="headerlink" title="数据同步方案"></a>数据同步方案</h2><h3 id="1-同步双写"><a href="#1-同步双写" class="headerlink" title="1. 同步双写"></a>1. 同步双写</h3><p><img src="/posts/35373/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-%E5%90%8C%E6%AD%A5%E5%8F%8C%E5%86%99.png"></p><ul><li>优点<br>  实现最简单，新增、更新、删除时，写入数据库同时写入ES。</li><li>缺点<ul><li>业务逻辑耦合度高，耦合大量数据同步代码；</li><li>写入两个存储，接口的响应时间变长；</li><li>不便于扩展，搜索可能会有一些个性化需求，需要对数据进行聚合。</li></ul></li></ul><h3 id="2-ES服务订阅消息队列，异步写入"><a href="#2-ES服务订阅消息队列，异步写入" class="headerlink" title="2. ES服务订阅消息队列，异步写入"></a>2. ES服务订阅消息队列，异步写入</h3><p><img src="/posts/35373/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BC%82%E6%AD%A5.png"><br>业务数据有变动的时候，将数据丢进MQ。为了解耦合，一般会拆分一个搜索服务，由搜索服务去订阅数据变动的消息，来完成同步。<br>一般数据需要聚合处理成类似宽表的结构，搜索服务需要查库或者远程调用接口，<strong>回查</strong>来完成数据的聚合。</p><ul><li>优点<ul><li>解耦合，业务服务不需要关注数据同步</li><li>实时性较好，适用MQ，正常情况下，同步完成在秒级</li></ul></li><li>缺点<br>  引入了新的组件和服务，复杂度提升</li></ul><h3 id="3-定时任务"><a href="#3-定时任务" class="headerlink" title="3. 定时任务"></a>3. 定时任务</h3><p>如果数据量不大，需要快速搞搞实现的话，可以选择定时任务的方式。</p><ul><li>优点：不改变原来的代码，侵入性低，没有业务强耦合。</li><li>缺点：时效性差，定时任务的执行周期不好设定；需要频繁的查询数据库，给数据库增加一定的压力。</li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ol><li>近实时update任务<br> 定时任务按较短的时间周期，读取<strong>UpdateTime大于上一次读取时间的所有数据</strong>，即该段时间内的增量，将这些数据写入到es，然后更新定时任务中的<strong>UpdateTime标识</strong>，重复执行。</li><li>全量修复任务<br> 每小时全量对比修复一次数据。</li></ol><h3 id="4-数据订阅，基于-MySQL-binlog"><a href="#4-数据订阅，基于-MySQL-binlog" class="headerlink" title="4. 数据订阅，基于 MySQL binlog"></a>4. 数据订阅，基于 MySQL binlog</h3><p>MySQL 通过 binlog 订阅实现主从同步，各路数据订阅框架比如 canal 就依据这个原理，将 client 组件伪装成从库，来实现数据订阅。</p><p><img src="/posts/35373/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-canal.png"><br>借助canal，实现canal-client，监听和聚合数据，写入ES。</p><p><a href="https://blog.csdn.net/weixin_43846997/article/details/95940565?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-9-95940565-blog-104222544.235%5Ev32%5Epc_relevant_default_base3&spm=1001.2101.3001.4242.6&utm_relevant_index=12">基于 MySQL Binlog 的 Elasticsearch 数据同步实践</a><br><a href="https://blog.csdn.net/bianlifengtech/article/details/120327575?spm=1001.2101.3001.6650.10&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-10-120327575-blog-95940565.235%5Ev32%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-10-120327575-blog-95940565.235%5Ev32%5Epc_relevant_default_base3&utm_relevant_index=16">基于MySQL binlog日志，实现Elasticsearch近实时同步实践</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://blog.csdn.net/weixin_43114485/article/details/104222544?spm=1001.2101.3001.6650.10&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-10-104222544-blog-126031022.235%5Ev32%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-10-104222544-blog-126031022.235%5Ev32%5Epc_relevant_default_base3&utm_relevant_index=11">ElasticSearch数据的同步方案,遇到的坑</a></p><h3 id="实时性要求高的场景，ES如何使用"><a href="#实时性要求高的场景，ES如何使用" class="headerlink" title="实时性要求高的场景，ES如何使用"></a>实时性要求高的场景，ES如何使用</h3><p>ES索引数据写入过程：<strong>write -&gt; refresh -&gt; flush -&gt; merge</strong>。<br>新增数据时，会先写入到ES用户进程的内存缓冲区，然后定时（默认是每隔1秒）写入到操作系统（内核态）的缓存，然后由操作系统决定刷盘时机，数据落入磁盘。<br>当数据写入到操作系统的缓存，数据就可以被搜索到。所以ES是近实时搜索，而非实时。文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。<br>如果业务系统的ES对于refresh是配置为默认1秒或者大于1秒，对于实时性要求高的业务，数据的准确性会有问题。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-线上问题</title>
      <link href="/posts/18111.html"/>
      <url>/posts/18111.html</url>
      
        <content type="html"><![CDATA[<h2 id="2023-06-30-查询优化"><a href="#2023-06-30-查询优化" class="headerlink" title="2023-06-30 查询优化"></a>2023-06-30 查询优化</h2><p>线上查询时，接口相应在5s左右，一开始以为是当前用户项目数量太多，in列表过长导致的，结果最后发现有一张新增的关联关系表没有加索引导致的。</p><ul><li>加索引前<br>  <img src="/posts/18111/230630-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E5%8A%A0%E7%B4%A2%E5%BC%95%E5%89%8D.png"></li><li>加索引后  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `doc_document_type_rel` </span><br><span class="line"><span class="keyword">ADD</span> INDEX `idx_file_type_code`(`file_type_code`, `document_id`) <span class="keyword">USING</span> BTREE;</span><br></pre></td></tr></table></figure>  <img src="/posts/18111/230630-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E5%8A%A0%E7%B4%A2%E5%BC%95%E5%90%8E.png"></li></ul><h2 id="2023-05-08-数据意外更新"><a href="#2023-05-08-数据意外更新" class="headerlink" title="2023-05-08 数据意外更新"></a>2023-05-08 数据意外更新</h2><p>表数据都被更新成同样的数据。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot源码分析-自动装配</title>
      <link href="/posts/32497.html"/>
      <url>/posts/32497.html</url>
      
        <content type="html"><![CDATA[<h2 id="自定义starter包的知识盲区"><a href="#自定义starter包的知识盲区" class="headerlink" title="自定义starter包的知识盲区"></a>自定义starter包的知识盲区</h2><h3 id="Configuration配置类解析"><a href="#Configuration配置类解析" class="headerlink" title="@Configuration配置类解析"></a>@Configuration配置类解析</h3><p>ConfigurationClassPostProcessor</p><h3 id="Spring的SPI机制"><a href="#Spring的SPI机制" class="headerlink" title="Spring的SPI机制"></a>Spring的SPI机制</h3><p>SPI全称为Service Provider Interface 服务提供接口。</p><p>在SpringBoot的自动装配过程中，最终会加载<strong>META-INF/spring.factories</strong>文件，而加载的过程是由<strong>SpringFactoriesLoader</strong>加载的。<br>从CLASSPATH下的每个Jar包中搜寻所有<strong>META-INF/spring.factories</strong>配置文件，然后将解析properties文件，找到指定名称的配置后返回。<br>需要注意的是，其实这里不仅仅是会去Classpath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的Jar包中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"><span class="comment">// spring.factories文件的格式为：key=value1,value2,value3</span></span><br><span class="line"><span class="comment">// 从所有的jar包中找到META-INF/spring.factories文件</span></span><br><span class="line"><span class="comment">// 然后从文件中解析出key=factoryClass类名称的所有value值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="comment">// 取得资源文件的URL</span></span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有的URL</span></span><br><span class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">        URL url = urls.nextElement();</span><br><span class="line">        <span class="comment">// 根据资源文件URL解析properties文件，得到对应的一组@Configuration类</span></span><br><span class="line">        Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span><br><span class="line">        String factoryClassNames = properties.getProperty(factoryClassName);</span><br><span class="line">        <span class="comment">// 组装数据，并返回</span></span><br><span class="line">        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot的自动装配机制"><a href="#SpringBoot的自动装配机制" class="headerlink" title="SpringBoot的自动装配机制"></a>SpringBoot的自动装配机制</h3><h3 id="如何自定义SpringBoot的starter"><a href="#如何自定义SpringBoot的starter" class="headerlink" title="如何自定义SpringBoot的starter"></a>如何自定义SpringBoot的starter</h3><h2 id="什么是SpringBoot自动装配"><a href="#什么是SpringBoot自动装配" class="headerlink" title="什么是SpringBoot自动装配"></a>什么是SpringBoot自动装配</h2><p>何谓SpringBoot的自动装配，简要概括就是：引入<strong>第三方组件的starter包</strong>后能够<strong>自动</strong>将<strong>第三方组件的bean</strong>加载到<strong>IOC容器</strong>中供应用程序使用。</p><p>自动装配的机制是SpringBoot提供的，因此第三方组件的starter包在编写的时候，就需要根据SpringBoot的自动装配的规则来编写starter包。<br>规则概括如下：</p><ol><li><strong>starter包</strong>需要在<strong>META-INF</strong>目录下提供<strong>spring.factories</strong>文件；</li><li><strong>spring.factories</strong>文件中以<strong>Key-Values</strong>的形式来提供需要Springboot去加载的类的全限定名。<ul><li>Key就是Springboot中各种扩展点的全限定名。<br>  比如org.springframework.boot.autoconfigure.EnableAutoConfiguration。</li><li>Values就是starter包中提供的扩展点的所有类的全限定名，以逗号隔开。</li></ul></li></ol><h3 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="/META-INF/spring.factories"></a>/META-INF/spring.factories</h3><p><strong>spring-boot-autoconfigure-2.3.4.RELEASE.jar</strong>的spring.factories</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># Failure analyzers</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisUrlSyntaxFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayMigrationScriptMissingFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer</span><br><span class="line"></span><br><span class="line"># Template availability providers</span><br><span class="line">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure><h2 id="SpringBoot自动配置原理-相关注解"><a href="#SpringBoot自动配置原理-相关注解" class="headerlink" title="SpringBoot自动配置原理 - 相关注解"></a>SpringBoot自动配置原理 - 相关注解</h2><ul><li>SpringBoot 是依靠入口注解 <strong>@SpringBootApplication</strong> 来启动整个自动配置体系的<br>  其中 <strong>@EnableAutoConfiguration</strong> 注解启动AutoConfigure功能</li><li>SpringBoot 是通过读取 <code>META-INF/spring.factories</code> 文件中配置的自动配置类来完成自动配置的<br>  自动配置类大多以 AutoConfiguration 结尾，AutoConfiguration类主要是通过springboot自定义的条件注解来完成自动配置的</li></ul><h3 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@java</span>.lang.annotation.Target(&#123;java.lang.annotation.ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Documented</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Inherited</span><br><span class="line"><span class="meta">@org</span>.springframework.boot.SpringBootConfiguration</span><br><span class="line"><span class="meta">@org</span>.springframework.boot.autoconfigure.EnableAutoConfiguration</span><br><span class="line"><span class="meta">@org</span>.springframework.context.annotation.ComponentScan</span><br></pre></td></tr></table></figure><p><strong>@SpringBootApplication</strong>是由3个注解组成的复合注解。</p><ul><li><strong>@SpringBootConfiguration</strong><br>  该注解表明Springboot启动类是一个配置类。</li><li><strong>@ComponentScan</strong><br>  该注解会将指定路径下的被特定注解修饰的类加载为Spring中的bean。<br>  这些特定注解为@Component、@Controller、@Service、@Repository和@Configuration注解。</li><li><strong>@EnableAutoConfiguration</strong><br>  该注解用于开启Springboot的自动装配。</li></ul><h3 id="SpringBootConfiguration注解"><a href="#SpringBootConfiguration注解" class="headerlink" title="@SpringBootConfiguration注解"></a>@SpringBootConfiguration注解</h3><h3 id="ComponentScan注解"><a href="#ComponentScan注解" class="headerlink" title="@ComponentScan注解"></a>@ComponentScan注解</h3><h3 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="@EnableAutoConfiguration注解"></a>@EnableAutoConfiguration注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@java</span>.lang.annotation.Target(&#123;java.lang.annotation.ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Documented</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Inherited</span><br><span class="line"><span class="meta">@org</span>.springframework.boot.autoconfigure.AutoConfigurationPackage</span><br><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Import(&#123;org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    java.lang.String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    java.lang.Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    java.lang.String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@EnableAutoConfiguration</strong>注解也是一个复合注解，主要功能由 <strong>@AutoConfigurationPackage</strong>注解和 <strong>@Import</strong>注解实现，那么肯定的，自动装配，就是这两个注解实现的。</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>@AutoConfigurationPackage注解作用在Springboot启动类上，会向Spring容器注册一个类型为AutoConfigurationPackages.BasePackages的bean，这个bean中保存了Springboot启动类的包路径，后续Springboot就会扫描这个包路径下由@Component、@Controller、@Service、@Repository和@Configuration注解修饰的类。</p><h4 id="Import-AutoConfigurationImportSelector-class-重要！！！"><a href="#Import-AutoConfigurationImportSelector-class-重要！！！" class="headerlink" title="@Import(AutoConfigurationImportSelector.class) 重要！！！"></a>@Import(AutoConfigurationImportSelector.class) 重要！！！</h4><ul><li><strong>@Import(AutoConfigurationImportSelector.class)<strong>会通过</strong>AutoConfigurationImportSelector</strong>延迟且分组的向Spring容器导入需要自动装配的组件的配置类，从而在解析这些配置类的时候能够将自动装配的组件的bean注册到容器中<ul><li>所谓的延迟，是因为AutoConfigurationImportSelector实现了DeferredImportSelector接口，其逻辑会在Springboot启动类被解析完毕后才会执行；</li><li>所谓的分组，是因为处理DeferredImportSelector是一组一组的进行的，只要DeferredImportSelector的实现类实现的getImportGroup()方法返回的Class对象一样，那么这样的DeferredImportSelector的实现类就属于同一组；</li></ul></li><li><strong>AutoConfigurationImportSelector</strong>获取到需要自动装配的组件的配置类的全限定名，是通过<strong>SpringFactoriesLoader</strong>完成的，而SpringFactoriesLoader就是<strong>Spring中的SPI机制</strong>的实现。</li></ul><p><a href="https://www.bilibili.com/read/cv17225413/">https://www.bilibili.com/read/cv17225413/</a></p><h2 id="SpringBoot自动配置原理-自动装配过程"><a href="#SpringBoot自动配置原理-自动装配过程" class="headerlink" title="SpringBoot自动配置原理 - 自动装配过程"></a>SpringBoot自动配置原理 - 自动装配过程</h2><h3 id="SpringBootApplication启动对象的注入"><a href="#SpringBootApplication启动对象的注入" class="headerlink" title="SpringBootApplication启动对象的注入"></a>SpringBootApplication启动对象的注入</h3><p><strong>SpringApplication#run#prepareContext#load</strong><br>prepareContext过程中，当前sources列表中只有一个main启动方法所在的Application.class对象，在此处加载springboot启动类。</p><h3 id="自动装配过程的方法调用链"><a href="#自动装配过程的方法调用链" class="headerlink" title="自动装配过程的方法调用链"></a>自动装配过程的方法调用链</h3><ol><li>SpringApplication#run</li><li><strong>SpringApplication#refreshContext</strong></li><li><strong>AbstractApplicationContext#refresh()</strong></li><li><strong>AbstractApplicationContext#invokeBeanFactoryPostProcessors(beanFactory)</strong><br> 此处是自动装配的入口！！！</li><li>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())</li><li>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(registry)</li><li>ConfigurationClassParser#parse(candidates)#processConfigurationClass#doProcessConfigurationClass#processImports</li><li><strong>AutoConfigurationImportSelector#selectImports#getAutoConfigurationEntry#getCandidateConfigurations</strong></li><li> <strong>SpringFactoriesLoader#loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader())#loadSpringFactories</strong></li></ol><h4 id="AbstractApplicationContext-postProcessBeanFactory-beanFactory"><a href="#AbstractApplicationContext-postProcessBeanFactory-beanFactory" class="headerlink" title="AbstractApplicationContext#postProcessBeanFactory(beanFactory)"></a>AbstractApplicationContext#postProcessBeanFactory(beanFactory)</h4><p>beanFactory的后置处理器 postProcessBeanFactory(beanFactory)</p><p>当前applicationContext是AnnotationConfigServletWebServerApplicationContext的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigServletWebServerApplicationContext#postProcessBeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigServletWebServerApplicationContext</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ServletWebServerApplicationContext</span> <span class="keyword">implements</span> <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理beanFactory</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显式调用父类ServletWebServerApplicationContext#postProcessBeanFactory</span></span><br><span class="line">        <span class="keyword">super</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">//basePackages默认为null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.basePackages != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.basePackages.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//不为空的话,进行扫描</span></span><br><span class="line">            <span class="keyword">this</span>.scanner.scan(<span class="keyword">this</span>.basePackages);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//annotatedClasses默认为空</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.annotatedClasses.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//不为空的话注册类</span></span><br><span class="line">            <span class="keyword">this</span>.reader.register(ClassUtils.toClassArray(<span class="keyword">this</span>.annotatedClasses));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServletWebServerApplicationContext#postProcessBeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericWebApplicationContext</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConfigurableWebServerApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在ServletContext和ServletConfig初始化之前</span></span><br><span class="line">        <span class="comment">//进行bean处理</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(</span><br><span class="line">                <span class="keyword">new</span> WebApplicationContextServletContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">        <span class="comment">//忽略ServletContextAware自动配置</span></span><br><span class="line">        beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">        <span class="comment">//beanFactory注册web应用scopes</span></span><br><span class="line">        <span class="comment">//request和session</span></span><br><span class="line">        registerWebApplicationScopes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WebApplicationContextUtils#registerWebApplicationScopes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebApplicationContextUtils</span># </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWebApplicationScopes</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传入ServletContext为null</span></span><br><span class="line">        registerWebApplicationScopes(beanFactory, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWebApplicationScopes</span><span class="params">(ConfigurableListableBeanFactory beanFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@Nullable</span> ServletContext sc)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册Scope</span></span><br><span class="line">        <span class="comment">//request</span></span><br><span class="line">        beanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, <span class="keyword">new</span> RequestScope());</span><br><span class="line">        <span class="comment">//session</span></span><br><span class="line">        beanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, <span class="keyword">new</span> SessionScope());</span><br><span class="line">        <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//传入sc为null</span></span><br><span class="line">            <span class="comment">//注册application scope</span></span><br><span class="line">            ServletContextScope appScope = <span class="keyword">new</span> ServletContextScope(sc);</span><br><span class="line">            beanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);</span><br><span class="line">            <span class="comment">// 设置ServletContext属性</span></span><br><span class="line">            sc.setAttribute(ServletContextScope.class.getName(), appScope);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册几个Autowired自动装配</span></span><br><span class="line">        <span class="comment">//ServletRequest.class</span></span><br><span class="line">        beanFactory.registerResolvableDependency(ServletRequest.class, <span class="keyword">new</span> RequestObjectFactory());</span><br><span class="line">        <span class="comment">//ServletResponse.class</span></span><br><span class="line">        beanFactory.registerResolvableDependency(ServletResponse.class, <span class="keyword">new</span> ResponseObjectFactory());</span><br><span class="line">        <span class="comment">//HttpSession.class</span></span><br><span class="line">        beanFactory.registerResolvableDependency(HttpSession.class, <span class="keyword">new</span> SessionObjectFactory());</span><br><span class="line">        <span class="comment">//WebRequest.class</span></span><br><span class="line">        beanFactory.registerResolvableDependency(WebRequest.class, <span class="keyword">new</span> WebRequestObjectFactory());</span><br><span class="line">        <span class="keyword">if</span> (jsfPresent) &#123;</span><br><span class="line">            <span class="comment">//jsfPresent默认为false</span></span><br><span class="line">            FacesDependencyRegistrar.registerFacesDependencies(beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractApplicationContext-invokeBeanFactoryPostProcessors-beanFactory"><a href="#AbstractApplicationContext-invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="AbstractApplicationContext#invokeBeanFactoryPostProcessors(beanFactory)"></a>AbstractApplicationContext#invokeBeanFactoryPostProcessors(beanFactory)</h4><p>BeanFactoryPostProcessor是一个接口, 处理beanFactory中所有的bean, 在所有的beanDefinition加载完成之后, BeanFactoryPostProcessor可以对beanDefinition进行属性的修改, 之后再进行bean实例化。</p><p>BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子接口, 定义了postProcessBeanDefinitionRegistry方法, 会在postProcessBeanFactory方法执行之前, 获取bean定义, 并注册到spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext#invokeBeanFactoryPostProcessors(beanFactory)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理器代理类</span></span><br><span class="line">    <span class="comment">//处理this.beanFactoryPostProcessors中维护的bean处理器</span></span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TempClassLoader为空</span></span><br><span class="line">    <span class="comment">//包含了LoadTimeWeaver(加载到JVM时, 进行切面织入)</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors"><a href="#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors" class="headerlink" title="PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors"></a>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors</h4><p>如果beanFactory是BeanDefinitionRegistry的子类, 按优先级，先处理BeanDefinitionRegistryPostProcessor类型的后置处理器, 最后处理传入的其他类型后置处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PostProcessorRegistrationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactoryPostProcessors有三个:</span></span><br><span class="line"><span class="comment">     *      CachingMetadataReaderFactoryPostProcessor</span></span><br><span class="line"><span class="comment">     *      ConfigurationWarningsPostProcessor</span></span><br><span class="line"><span class="comment">     *      PropertySourceOrderingPostProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//processedBeans记录处理过的bean名称</span></span><br><span class="line">        Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">            <span class="comment">//优先处理传入的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">            BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">            <span class="comment">//非BeanDefinitionRegistryPostProcessor类型, 常规BeanFactory后置处理器</span></span><br><span class="line">            List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//BeanDefinitionRegistryPostProcessor类型的bean定义注册器后置处理器</span></span><br><span class="line">            List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//regularPostProcessors有1个:PropertySourceOrderingPostProcessor</span></span><br><span class="line">            <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                    <span class="comment">//bean定义注册器后置处理器,有如下两个:</span></span><br><span class="line">                    <span class="comment">//CachingMetadataReaderFactoryPostProcessor</span></span><br><span class="line">                    <span class="comment">//ConfigurationWarningsPostProcessor</span></span><br><span class="line">                    BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                            (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                            <span class="comment">//执行其postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">                    registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                    <span class="comment">//然后加入到registryProcessors中</span></span><br><span class="line">                    registryProcessors.add(registryProcessor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不是BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">                    <span class="comment">//那么放入regularPostProcessors(常规后置处理器)中</span></span><br><span class="line">                    regularPostProcessors.add(postProcessor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理beanFactory中注册的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当前正在处理的PostProcessor, 处理完成之后会清空</span></span><br><span class="line">            List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将其名称放入postProcessorNames数组中</span></span><br><span class="line">            <span class="comment">//当前只能获取到一个bean:        </span></span><br><span class="line">            <span class="comment">//名称为org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line">            <span class="comment">//类型为ConfigurationClassPostProcessor</span></span><br><span class="line">            String[] postProcessorNames =</span><br><span class="line">                    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                    <span class="comment">//优先处理PriorityOrdered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    <span class="comment">//处理完成之后, 放到processedBeans列表</span></span><br><span class="line">                    processedBeans列表中.add(ppName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            <span class="comment">//添加到registryProcessors</span></span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            <span class="comment">//遍历currentRegistryProcessors,调用其postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">            <span class="comment">//执行ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry, 扫描并注册模块中@Configuration注解的bean</span></span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            <span class="comment">//清空currentRegistryProcessors</span></span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实现Order注解的bean</span></span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后,调用其他的BeanDefinitionRegistryPostProcessor的方法</span></span><br><span class="line">            <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">                reiterate = <span class="keyword">false</span>;</span><br><span class="line">                postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                        processedBeans.add(ppName);</span><br><span class="line">                        reiterate = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">                registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">                <span class="comment">//调用其他BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">                invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">                currentRegistryProcessors.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用BeanDefinitionRegistryPostProcessor的postProcessBeanFactory</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">            <span class="comment">//方法传入普通BeanFactoryPostProcessor, 实现其postProcessBeanFactory方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果beanFactory不是BeanDefinitionRegistry</span></span><br><span class="line">            <span class="comment">//方法传入普通BeanFactoryPostProcessor, 实现其postProcessBeanFactory方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理beanFactory中注册的普通BeanFactoryPostProcessor</span></span><br><span class="line">        <span class="comment">//非BeanDefinitionRegistryPostProcessor类型后置处理器</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">                <span class="comment">//说明已经处理过了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                <span class="comment">//优先处理实现了PriorityOrdered接口的子类</span></span><br><span class="line">                priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                <span class="comment">//再处理实现了Ordered接口的子类</span></span><br><span class="line">                orderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//最后处理其他BeanFactoryPostProcessor</span></span><br><span class="line">                nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现了PriorityOrdered接口的BeanFactoryPostProcessor, 优先处理</span></span><br><span class="line">        sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现了Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">            orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后再实现不排序BeanFactoryPostProcessor</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">            nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除缓存</span></span><br><span class="line">        beanFactory.clearMetadataCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConfigurationClassPostProcessor-postProcessBeanDefinitionRegistry-registry"><a href="#ConfigurationClassPostProcessor-postProcessBeanDefinitionRegistry-registry" class="headerlink" title="ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(registry)"></a>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(registry)</h4><p>ConfigurationClassPostProcessor扫描和注册BeanDefinition</p><ol><li>首先处理手动注册的BeanDefinition</li><li>实例化<strong>ConfigurationClassParser</strong>, 递归扫描@Configuration, @ComponentScan, @Import等注解</li><li>实例化ConfigurationClassBeanDefinitionReader,递归读取并注册BeanDefinition</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>,</span></span><br><span class="line"><span class="class">        <span class="title">PriorityOrdered</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean定义扫描和注册</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">            <span class="comment">//this.registriesPostProcessed包含了registryId</span></span><br><span class="line">            <span class="comment">//说明postProcessBeanDefinitionRegistry方法已经执行</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">            <span class="comment">//this.factoriesPostProcessed已经包含了registryId</span></span><br><span class="line">            <span class="comment">//说明postProcessBeanFactory方法已经执行</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加到this.registriesPostProcessed中</span></span><br><span class="line">        <span class="comment">//标记已经被执行</span></span><br><span class="line">        <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理bean定义</span></span><br><span class="line">        processConfigBeanDefinitions(registry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理bean定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首先处理手动注册的BeanDefinition</span></span><br><span class="line">        <span class="comment">//获取手工注册的bean定义名称列表</span></span><br><span class="line">        String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">                    ConfigurationClassUtils.isLiteConfigurationClass(bean)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//beanDefinition是lite或者是full</span></span><br><span class="line">                <span class="comment">//full指的是使用了Configuration注解</span></span><br><span class="line">                <span class="comment">//lite指的是使用了Component, ComponentScan, Import, ImportResource注解</span></span><br><span class="line">                <span class="comment">//或者方法包含了Bean注解</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                <span class="comment">//当前beanDefinition是一个配置类</span></span><br><span class="line">                <span class="comment">//添加到configCandidates中</span></span><br><span class="line">                configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//如果配置类为空,那么立即返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//@Order注解排序</span></span><br><span class="line">        configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">            <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置bean名称生成策略</span></span><br><span class="line">        SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">            sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">                BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">                <span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                    <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ConfigurationClassParser只负责解析被注解的类</span></span><br><span class="line">        <span class="comment">//并不进行BeanDefinition的注册</span></span><br><span class="line">        ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">                <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">                <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Configuration类名</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">        <span class="comment">//已经解析过的ConfigurationClass</span></span><br><span class="line">        Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//解析, 维护到parser.configurationClasses中</span></span><br><span class="line">            parser.parse(candidates);</span><br><span class="line">            <span class="comment">//验证</span></span><br><span class="line">            <span class="comment">//类不可以为final类型, 必须可重写,  static方法不处理</span></span><br><span class="line">            parser.validate();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//configClasses维护待处理的ConfigurationClasse</span></span><br><span class="line">            Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">            configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// this.reader初始化为ConfigurationClassBeanDefinitionReader</span></span><br><span class="line">            <span class="comment">//进行BeanDefinition的加载</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                        registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                        <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加载BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">            <span class="comment">//alreadyParsed维护已经解析完的class</span></span><br><span class="line">            alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">            candidates.clear();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">                <span class="comment">//说明在加载Configuration注解类的过程中,</span></span><br><span class="line">                <span class="comment">//扫描到了Import注解, 引入了新的BeanDefinition</span></span><br><span class="line">                String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">                Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">                Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                    alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                        <span class="comment">//上次没有处理过的类</span></span><br><span class="line">                        BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                        <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                                !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                            <span class="comment">//@Configuration注解的类</span></span><br><span class="line">                            <span class="comment">//没有被处理过</span></span><br><span class="line">                            candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                candidateNames = newCandidateNames;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//candidates不为空, 说明处理@Configuration注解的类</span></span><br><span class="line">        <span class="comment">//扫描到了@Import注解, 引入了新的@Configuration注解类</span></span><br><span class="line">        <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将@Import引入的类列表注册为单例Bean</span></span><br><span class="line">        <span class="comment">//这样可以支持Configuration注解的ImportAware的实现类</span></span><br><span class="line">        <span class="comment">//在实例化Bean的时候, 可以将Import导入的类, 传递给Bean实例</span></span><br><span class="line">        <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">            <span class="comment">//清空缓存</span></span><br><span class="line">            ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConfigurationClassParser-parse"><a href="#ConfigurationClassParser-parse" class="headerlink" title="ConfigurationClassParser#parse"></a>ConfigurationClassParser#parse</h4><p>ConfigurationClassParser#parse方法, 共执行了下面8步：</p><ol><li>处理内部类ConfigurationClassParser#processMemberClasses</li><li>处理@PropertySource注解</li><li>ComponentScanAnnotationParser处理@ComponentScan注解</li><li>处理@Import注解</li><li>处理@ImportResource注解</li><li>处理方法上的@Bean注解</li><li>处理接口的中的default方法</li><li>处理@Import导入的DeferredImportSelector类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析</span></span><br><span class="line">    <span class="comment">//最终都会执行processConfigurationClass方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">            BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    <span class="comment">//AnnotatedBeanDefinition类型</span></span><br><span class="line">                    <span class="comment">//解析metadata</span></span><br><span class="line">                    parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                    <span class="comment">//AbstractBeanDefinition类型</span></span><br><span class="line">                    <span class="comment">//解析beanClass</span></span><br><span class="line">                    parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//MetadataReader类型</span></span><br><span class="line">                    <span class="comment">//解析beanClassName</span></span><br><span class="line">                    parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                        <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理@Import导入的DeferredImportSelectorHolder类</span></span><br><span class="line">        <span class="keyword">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理@Configuration注解的class</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否已经被处理过</span></span><br><span class="line">        ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">        <span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//已经被处理过了</span></span><br><span class="line">            <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">                <span class="comment">//configClass是被Import导入的</span></span><br><span class="line">                <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                    <span class="comment">//将configClass的importedBy合并到existingClass的existingClass中</span></span><br><span class="line">                    existingClass.mergeImportedBy(configClass);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果configClass不是被Import导入</span></span><br><span class="line">                <span class="comment">//那么说明是一个显式的bean定义, 我们旧的移除掉 </span></span><br><span class="line">                <span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">                <span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//递归扫描并处理父类, 以及其注解</span></span><br><span class="line">            sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//维护已经处理的类</span></span><br><span class="line">        <span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实际解析配置类的方法</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//configClass使用了@Component注解</span></span><br><span class="line">        <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">            <span class="comment">//递归处理内部类</span></span><br><span class="line">            processMemberClasses(configClass, sourceClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理@PropertySources注解</span></span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">                sourceClass.getMetadata(), <span class="meta">@PropertySources</span>.class,</span><br><span class="line">                org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">                <span class="comment">//this.environment是ConfigurableEnvironment实例, 才进行@PropertySources属性替换</span></span><br><span class="line">                processPropertySource(propertySource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                        <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理configClass类的@ComponentScans,ComponentScan注解</span></span><br><span class="line">        Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">                sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">        <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">                !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">                <span class="comment">// 交付给ComponentScanAnnotationParser进行扫描</span></span><br><span class="line">                Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                        <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">                        </span><br><span class="line">                <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                    <span class="comment">//获取来源Beanthis.reader.loadBeanDefinitions(configClasses)Definition</span></span><br><span class="line">                    <span class="comment">//OriginatingBeanDefinition由代理设置</span></span><br><span class="line">                    BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                    <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        bdCand = holder.getBeanDefinition();</span><br><span class="line">                    &#125;</span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                        <span class="comment">//BeanDefinition中的类由@Configuration注解</span></span><br><span class="line">                        <span class="comment">//调用parse方法, 递归处理@Configuration注解的类</span></span><br><span class="line">                        parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理configClass类的@Import注解</span></span><br><span class="line">        processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理configClass类的@ImportResource注解</span></span><br><span class="line">        AnnotationAttributes importResource =</span><br><span class="line">                AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">        <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取ImportResource的属性</span></span><br><span class="line">            String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">            Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">                <span class="comment">//处理导入的resource</span></span><br><span class="line">                String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">                configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理sourceClass中@Bean注解的方法</span></span><br><span class="line">        Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">        <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">            <span class="comment">//添加到configClass中</span></span><br><span class="line">            configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理接口中的default方法</span></span><br><span class="line">        processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有父类的话, 处理父类</span></span><br><span class="line">        <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">            String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">            <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">                    !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//返回父类</span></span><br><span class="line">                <span class="comment">//递归处理父类</span></span><br><span class="line">                <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有父类, 处理结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AutoConfigurationImportSelector-selectImports"><a href="#AutoConfigurationImportSelector-selectImports" class="headerlink" title="AutoConfigurationImportSelector#selectImports"></a>AutoConfigurationImportSelector#selectImports</h4><h4 id="SpringFactoriesLoader-loadFactoryNames-loadSpringFactories"><a href="#SpringFactoriesLoader-loadFactoryNames-loadSpringFactories" class="headerlink" title="SpringFactoriesLoader#loadFactoryNames#loadSpringFactories"></a>SpringFactoriesLoader#loadFactoryNames#loadSpringFactories</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot源码分析-启动过程</title>
      <link href="/posts/57966.html"/>
      <url>/posts/57966.html</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot源码分析-启动过程"><a href="#SpringBoot源码分析-启动过程" class="headerlink" title="SpringBoot源码分析 - 启动过程"></a>SpringBoot源码分析 - 启动过程</h2><p>基于SpringBoot 2.3.4</p><h3 id="main-SpringApplication-run"><a href="#main-SpringApplication-run" class="headerlink" title="main#SpringApplication.run()"></a>main#SpringApplication.run()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringBoot Web服务入口</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SpringApplication#run</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 先构造SpringApplication实例，再调用run方法</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先构造SpringApplication实例，再调用run方法。</p><h3 id="SpringApplication-构造方法"><a href="#SpringApplication-构造方法" class="headerlink" title="SpringApplication#构造方法"></a>SpringApplication#构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line"><span class="comment">// 设置SpringApplication#primarySources，注意这里primarySources参数就是run方法的第一个参数</span></span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); <span class="comment">//#1</span></span><br><span class="line"><span class="comment">// 判断当前应用是JAVA应用，SERVLET应用或REACTIVE应用。</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath(); <span class="comment">//#2</span></span><br><span class="line"><span class="comment">// 加载spring.factories中配置的ApplicationContextInitializer实现类，将结果存放到SpringApplication#initializers</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); <span class="comment">//#3</span></span><br><span class="line"><span class="comment">// 加载spring.factories中配置的ApplicationListener实现类，将结果存放到SpringApplication#listeners</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); <span class="comment">//#4</span></span><br><span class="line"><span class="comment">// 获取main方法所在Class</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass(); <span class="comment">//#5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deduceFromClasspath-webApplicationType"><a href="#deduceFromClasspath-webApplicationType" class="headerlink" title="deduceFromClasspath - webApplicationType"></a>deduceFromClasspath - webApplicationType</h4><p>Springboot 项目的程序类型有三种：</p><ol><li>WebApplicationType.NONE<br>   非 web 应用程序（不内嵌服务器）</li><li>WebApplicationType.SERVLET<br>   内嵌基于 servlet 的 web 服务器（如：Tomcat，Jetty，Undertow 等，其实现在大多Java网站应用都是采用的基于 Tomcat 的 servlet 类型服务器）</li><li>WebApplicationType.REACTIVE<br>   内嵌基于反应式的 web 服务器（如： Netty）</li></ol><h4 id="deduceMainApplicationClass-mainApplicationClass"><a href="#deduceMainApplicationClass-mainApplicationClass" class="headerlink" title="deduceMainApplicationClass - mainApplicationClass"></a>deduceMainApplicationClass - mainApplicationClass</h4><p>获取main方法所在Class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用异常堆栈来判断 当前主类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">      StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">      <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="string">&quot;main&quot;</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      <span class="comment">// Swallow and continue</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring-boot的启动主类，一切都是由spring自己推导的，所以我们不要所以然的认为主类是我们传给spring容器的。</p><h4 id="SpringApplication-getSpringFactoriesInstances"><a href="#SpringApplication-getSpringFactoriesInstances" class="headerlink" title="SpringApplication#getSpringFactoriesInstances"></a>SpringApplication#getSpringFactoriesInstances</h4><p><strong>spring-boot</strong>:SpringApplication#getSpringFactoriesInstances<br><strong>spring-core</strong>:SpringFactoriesLoader#loadSpringFactories</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringApplication#getSpringFactoriesInstances</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line"><span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line"><span class="comment">// SpringFactoriesLoader.loadFactoryNames(type, classLoader)</span></span><br><span class="line">Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SpringFactoriesLoader#loadFactoryNames</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SpringFactoriesLoader#loadSpringFactories</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// FACTORIES_RESOURCE_LOCATION就是字符串&quot;META-INF/spring.factories&quot;，这里读取jar中META-INF/spring.factories文件内容</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line"><span class="comment">// 加载spring.factories文件（格式为Properties）</span></span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line"><span class="comment">// 读取Properties内容，缓存结果</span></span><br><span class="line">result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.haier.updaterecord.mybatis.plus.spring.boot.autoconfigure.UpdateRecordAutoConfiguration,\</span><br><span class="line">com.haier.updaterecord.core.factory.UpdateRecordServiceFactory</span><br></pre></td></tr></table></figure><p>key为spring扩展接口（或声明功能的注解），value为对应的功能实现类的列表</p><h3 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication#run"></a>SpringApplication#run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   <span class="comment">// 监视器启动，计算初始化需要花费多少时间</span></span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList();</span><br><span class="line">   <span class="comment">// 配置java.awt.headless</span></span><br><span class="line">   <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">   <span class="comment">// 从 META-INF/spring.factories 中获取 SpringApplicationRunListener 实现类，并调用starting（）</span></span><br><span class="line">   SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">   listeners.starting();</span><br><span class="line"></span><br><span class="line">   Collection exceptionReporters;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 命令行参数处理</span></span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">      <span class="comment">// 构建Environment，准备环境变量配置</span></span><br><span class="line">      ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">      <span class="comment">// 通过 spring.beaninfo.ignore 配置是否忽略bean信息 暂不明觉厉</span></span><br><span class="line">      <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">      <span class="comment">// 打印SpringBoot控制台启动图案</span></span><br><span class="line">      Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">      <span class="comment">// 创建应用上下文ApplicationContext</span></span><br><span class="line">      context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">      <span class="comment">// 从 META-INF/spring.factories 中获取异常报告处理器，用作处理启动异常</span></span><br><span class="line">      exceptionReporters = <span class="keyword">this</span>.getSpringFactoriesInstances(SpringBootExceptionReporter.class, <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 准备应用上下文</span></span><br><span class="line"><span class="comment">         * 1 设置上下文环境配置</span></span><br><span class="line"><span class="comment">         * 2 注册 beanNameGenerator 等</span></span><br><span class="line"><span class="comment">         * 3 执行 ApplicationContextInitializer#initialize()初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 刷新上下文 重要！！！</span></span><br><span class="line">      <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 容器初始化之后 开始执行 ApplicationRunner 和 CommandLineRunner 自定义初始化执行器</span></span><br><span class="line">      <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      listeners.started(context);</span><br><span class="line">      <span class="keyword">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      listeners.running(context);</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run-prepareEnvironment"><a href="#run-prepareEnvironment" class="headerlink" title="run#prepareEnvironment"></a>run#prepareEnvironment</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Create and configure the environment</span></span><br><span class="line">     <span class="comment">// 创建一个Environment</span></span><br><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">     <span class="comment">// 将SpringApplication#run中的可变参数列表传递给Environment</span></span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">     <span class="comment">// 发送ApplicationEnvironmentPreparedEvent事件</span></span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"><span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关于SpringApplication-run中的args参数"><a href="#关于SpringApplication-run中的args参数" class="headerlink" title="关于SpringApplication#run中的args参数"></a>关于SpringApplication#run中的args参数</h5><p>我们在启动SpringBoot时，可以添加命令行参数，如<strong>java -jar app.jar –spring.profiles.active=dev</strong>。<br>命令行参数<code>--spring.profiles.active=dev</code>会传递给main方法，main方法中需要将其传递给<strong>SpringApplication#run</strong>方法，<br>这里将命令行参数添加Environment中，作为一个PropertySource。</p><h4 id="run-createApplicationContext"><a href="#run-createApplicationContext" class="headerlink" title="run#createApplicationContext"></a>run#createApplicationContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line"><span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line"><span class="comment">// SERVLET应用，选择AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line"><span class="comment">// REACTIVE应用，选择AnnotationConfigReactiveWebServerApplicationContext</span></span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// JAVA应用，选择AnnotationConfigApplicationContext</span></span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造对应的Spring Context</span></span><br><span class="line"><span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般我们的<strong>SringBoot Web应用</strong>的<strong>webApplicationType</strong>为<strong>SERVLET</strong>，所以会创建<strong>AnnotationConfigServletWebServerApplicationContext</strong>。<br><strong>其父类ServletWebServerApplicationContext，通过ServletWebServerFactory创建并初始化WebServer。</strong><br>WebServer兼容不同的servlet容器（tomcat，jetty，netty），提供统一的start，stop操作。</p><h4 id="run-prepareContext"><a href="#run-prepareContext" class="headerlink" title="run#prepareContext"></a>run#prepareContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="params"><span class="function">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置context上下文环境</span></span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line"><span class="comment">// ApplicationContext的后置处理</span></span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line"><span class="comment">// 调用ApplicationContextInitializer#initialize，执行initialize</span></span><br><span class="line">applyInitializers(context);</span><br><span class="line"><span class="comment">// 调用SpringApplicationRunListener#contextPrepared方法，发布contextPrepared事件</span></span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="comment">// 打印项目启动日志</span></span><br><span class="line">logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 打印profile</span></span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add boot specific singleton beans</span></span><br><span class="line"><span class="comment">// 获取到DefaultListableBeanFactory实例</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line"><span class="comment">// 注册名为springApplicationArguments,值为applicationArguments的命令行参数单例bean</span></span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line"><span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果banner不为空,那么注册名为springBootBanner,值为printedBanner的单例bean</span></span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line"><span class="comment">// allowBeanDefinitionOverriding默认为false</span></span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Load the sources</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line"><span class="comment">// 当前sources列表中只有一个main启动方法所在的Application.class对象，在此处加载springboot启动类</span></span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SpringApplication#load</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化BeanDefinitionLoader</span></span><br><span class="line">BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setBeanNameGenerator(<span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setEnvironment(<span class="keyword">this</span>.environment);</span><br><span class="line">&#125;</span><br><span class="line">loader.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run-refreshContext"><a href="#run-refreshContext" class="headerlink" title="run#refreshContext"></a>run#refreshContext</h4><p>参照Spring源码解析的refreshContext部分。</p><p>AbstractApplicationContext#refresh()#invokeBeanFactoryPostProcessors(beanFactory)，<strong>自动装配在此完成</strong>。<br>当前applicationContext是AnnotationConfigServletWebServerApplicationContext。</p><h2 id="SpringBoot源码分析-启动过程-Tomcat启动"><a href="#SpringBoot源码分析-启动过程-Tomcat启动" class="headerlink" title="SpringBoot源码分析 - 启动过程 - Tomcat启动"></a>SpringBoot源码分析 - 启动过程 - Tomcat启动</h2><h3 id="Tomcat和Spring、Spring-MVC的关系"><a href="#Tomcat和Spring、Spring-MVC的关系" class="headerlink" title="Tomcat和Spring、Spring MVC的关系"></a>Tomcat和Spring、Spring MVC的关系</h3><h3 id="为什么默认是Tomcat"><a href="#为什么默认是Tomcat" class="headerlink" title="为什么默认是Tomcat"></a>为什么默认是Tomcat</h3><p>spring-boot-starter-web最原始依赖的是tomcat。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入springboot父依赖--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--引入启动器依赖 里面就有默认的tomcat --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--引入启动器依赖 里面就有默认的tomcat --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--排除tomcat--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--引入Jetty--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入Netty--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--引入Undertow--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="createApplicationContext-gt-AnnotationConfigServletWebServerApplicationContext"><a href="#createApplicationContext-gt-AnnotationConfigServletWebServerApplicationContext" class="headerlink" title="createApplicationContext -&gt; AnnotationConfigServletWebServerApplicationContext"></a>createApplicationContext -&gt; AnnotationConfigServletWebServerApplicationContext</h3><p>因为我们的应用是 Web Servlet 类型，<br>所以实例化的是AnnotationConfigServletWebServerApplicationContext。</p><p><img src="/posts/57966/AnnotationConfigServletWebServerApplicationContext.png"></p><h3 id="refreshContext-gt-tomcat启动"><a href="#refreshContext-gt-tomcat启动" class="headerlink" title="refreshContext -&gt; tomcat启动"></a>refreshContext -&gt; tomcat启动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">    refresh(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">            <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">    ((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">        <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">            <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">/** 主要关系 onRefresh() 方法 ------------- **/</span></span><br><span class="line">            <span class="keyword">this</span>.onRefresh();</span><br><span class="line">            <span class="keyword">this</span>.registerListeners();</span><br><span class="line">            <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.warn(<span class="string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">            <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">            <span class="keyword">throw</span> var9;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.createWebServer();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;Unable to start web server&quot;</span>, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">    ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">    <span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/** 得到Servlet WebServer工厂 **/</span></span><br><span class="line">        ServletWebServerFactory factory = <span class="keyword">this</span>.getWebServerFactory();</span><br><span class="line">        <span class="keyword">this</span>.webServer = factory.getWebServer(<span class="keyword">new</span> ServletContextInitializer[]&#123;<span class="keyword">this</span>.getSelfInitializer()&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.getSelfInitializer().onStartup(servletContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.initPropertySources();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SpringBoot源码分析-启动过程-Spring-MVC自动配置"><a href="#SpringBoot源码分析-启动过程-Spring-MVC自动配置" class="headerlink" title="SpringBoot源码分析 - 启动过程 - Spring MVC自动配置"></a>SpringBoot源码分析 - 启动过程 - Spring MVC自动配置</h2><p>即Spring MVC的核心组件DispatcherServlet的注册过程。<br>DispatcherServlet 如何通过自动配置注册到ServletWebServer中。</p><h3 id="1-自动配置DispatcherServlet和DispatcherServletRegistry"><a href="#1-自动配置DispatcherServlet和DispatcherServletRegistry" class="headerlink" title="1. 自动配置DispatcherServlet和DispatcherServletRegistry"></a>1. 自动配置DispatcherServlet和DispatcherServletRegistry</h3><ol><li><p>DispatcherServletAutoConfiguration自动配置类<br> SpringBoot的自动配置基于SPI机制，实现自动配置的核心要点就是添加一个自动配置的类，SpringBoot MVC的自动配置自然也是相同原理。<br> 先找到对应的自动配置类：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">// @Configuration表明这是一个配置类，将会被spring给解析。</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span> <span class="comment">//意味着当是一个web项目，且是Servlet项目的时候才会被解析</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span> <span class="comment">// 指明DispatcherServlet这个核心类必须存在才解析该类</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)</span> <span class="comment">// 指明在ServletWebServerFactoryAutoConfiguration这个类之后再解析，设定了一个顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The bean name for a DispatcherServlet that will be mapped to the root URL &quot;/&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = <span class="string">&quot;dispatcherServlet&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The bean name for a ServletRegistrationBean for the DispatcherServlet &quot;/&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = <span class="string">&quot;dispatcherServletRegistration&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="meta">@Conditional(DefaultDispatcherServletCondition.class)</span></span><br><span class="line">        <span class="meta">@ConditionalOnClass(ServletRegistration.class)</span></span><br><span class="line">        <span class="meta">@EnableConfigurationProperties(WebMvcProperties.class)</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> DispatcherServlet <span class="title">dispatcherServlet</span><span class="params">(WebMvcProperties webMvcProperties)</span> </span>&#123;</span><br><span class="line">                DispatcherServlet dispatcherServlet = <span class="keyword">new</span> DispatcherServlet();</span><br><span class="line">                dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());</span><br><span class="line">                dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());</span><br><span class="line">                dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());</span><br><span class="line">                dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());</span><br><span class="line">                dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());</span><br><span class="line">                <span class="keyword">return</span> dispatcherServlet;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Bean</span></span><br><span class="line">            <span class="meta">@ConditionalOnBean(MultipartResolver.class)</span></span><br><span class="line">            <span class="meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line">                <span class="keyword">return</span> resolver;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="meta">@Conditional(DispatcherServletRegistrationCondition.class)</span></span><br><span class="line">        <span class="meta">@ConditionalOnClass(ServletRegistration.class)</span></span><br><span class="line">        <span class="meta">@EnableConfigurationProperties(WebMvcProperties.class)</span></span><br><span class="line">        <span class="meta">@Import(DispatcherServletConfiguration.class)</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletRegistrationConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span></span><br><span class="line">            <span class="meta">@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">(DispatcherServlet dispatcherServlet,</span></span></span><br><span class="line"><span class="params"><span class="function">                    WebMvcProperties webMvcProperties, ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig)</span> </span>&#123;</span><br><span class="line">                DispatcherServletRegistrationBean registration = <span class="keyword">new</span> DispatcherServletRegistrationBean(dispatcherServlet,</span><br><span class="line">                        webMvcProperties.getServlet().getPath());</span><br><span class="line">                registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">                registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">                multipartConfig.ifAvailable(registration::setMultipartConfig);</span><br><span class="line">                <span class="keyword">return</span> registration;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... 省略后续代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> DispatcherServletAutoConfiguration类主要包含了两个内部类，分别是：</p><ul><li>DispatcherServletConfiguration<br>  配置DispatcherServlet。</li><li>DispatcherServlet<strong>Registration</strong>Configuration<br>  配置DispatcherServlet的<strong>注册类</strong>。<br>  DispatcherServletRegistrationConfiguration将生成一个<strong>DispatcherServletRegistrationBean</strong>，<strong>负责将DispatcherServlet给注册到ServletContext中</strong>。</li></ul></li><li><p>配置DispatcherServletConfiguration</p></li><li><p>配置DispatcherServletRegistrationConfiguration</p></li></ol><h3 id="2-注册DispatcherServlet到ServletContext"><a href="#2-注册DispatcherServlet到ServletContext" class="headerlink" title="2. 注册DispatcherServlet到ServletContext"></a>2. 注册DispatcherServlet到ServletContext</h3><p>DispatcherServletRegistrationBean负责将DispatcherServlet注册到ServletContext当中。<br><img src="/posts/57966/springmvc-DispatcherServletRegistrationBean-%E7%B1%BB%E5%9B%BE.png"></p><p>总的来说，其实就是触发了初始化ServletContext时候的回调接口onStartup方法，而后直接将DispatcherServlet作为一个Servlet给add到ServletContext当中。</p><h3 id="3-初始化mvc的组件"><a href="#3-初始化mvc的组件" class="headerlink" title="3. 初始化mvc的组件"></a>3. 初始化mvc的组件</h3><p><img src="/posts/57966/springmvc-DispatcherServlet-%E7%B1%BB%E5%9B%BE.png"><br>根据类图可以看到两部分的设计：<br>第一部分是Servlet到HttpServlet，也就是Servlet容器相关的内部设计。<br>第二部分是Spring在HttpServlet的基础上扩展了框架相关的内容，而最终DispatcherServlet将扩展springMVC的内容。</p><p>DispatcherServlet作为一个Servlet的实现，在Servlet被调用init方法以后最终将会调用DispatcherServlet的initStrategies方法，该方法将会初始化各个组件。<br>初始化组件基本就是把各个Bean对象从BeanFactory中拿出来组合到DispatcherServlet中，供后续使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 九大组件</span></span><br><span class="line">        <span class="comment">// 文件上传的解析器</span></span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">        <span class="comment">// 国际化解析器</span></span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">        <span class="comment">// 主题解析器</span></span><br><span class="line">initThemeResolver(context);</span><br><span class="line">        <span class="comment">// HandlerMapping 根据请求对象找到Hander处理器对象</span></span><br><span class="line">initHandlerMappings(context);</span><br><span class="line">        <span class="comment">// HandlerAdapter 处理器的适配器</span></span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line">        <span class="comment">// 异常解析器</span></span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">        <span class="comment">// 视图名称解析器</span></span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line">        <span class="comment">// 视图解析器</span></span><br><span class="line">initViewResolvers(context);</span><br><span class="line">        <span class="comment">// 通过redirect携参的请求</span></span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO - BIO</title>
      <link href="/posts/13032.html"/>
      <url>/posts/13032.html</url>
      
        <content type="html"><![CDATA[<p>BIO，blocking IO，同步阻塞IO。最容易理解、最容易实现的IO工作方式。<br>应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送到应用程序；最后应用程序收到数据，并解除等待状态。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="阻塞IO-amp-非阻塞IO"><a href="#阻塞IO-amp-非阻塞IO" class="headerlink" title="阻塞IO &amp; 非阻塞IO"></a>阻塞IO &amp; 非阻塞IO</h3><p>这两个概念是<strong>应用程序级别</strong>的。<br>主要描述的是应用程序请求操作系统IO操作后，如果IO资源没有准备好，那么应用程序该如何处理的问题。</p><ul><li>阻塞IO：应用程序等待</li><li>非阻塞IO：应用程序继续执行（并且使用线程一直轮询，直到有IO资源准备好了）</li></ul><h3 id="同步IO-amp-异步IO"><a href="#同步IO-amp-异步IO" class="headerlink" title="同步IO &amp; 异步IO"></a>同步IO &amp; 异步IO</h3><p>这两个概念是<strong>操作系统级别</strong>的。<br>主要描述的是操作系统在收到应用程序请求IO操作后，如果IO资源没有准备好，该如何响应应用程序的问题。</p><ul><li>同步IO：不响应，直到IO资源准备好以后</li><li>异步IO：返回一个标记（好让应用程序和自己知道之后准备好的数据往哪里通知），当IO资源准备好以后，再用事件机制返回给应用程序。</li></ul><h2 id="传统的BIO通信方式简介"><a href="#传统的BIO通信方式简介" class="headerlink" title="传统的BIO通信方式简介"></a>传统的BIO通信方式简介</h2><p>以前大多数网络通信方式都是阻塞模式的，即：</p><ul><li>客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。</li><li>服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。</li></ul><p><a href="java-io-bio.png"></a></p><h3 id="BIO的问题"><a href="#BIO的问题" class="headerlink" title="BIO的问题"></a>BIO的问题</h3><ol><li>同一时间，服务器只能接受来自于客户端A的请求信息；虽然客户端A和客户端B的请求是同时进行的，但客户端B发送的请求信息只能等到服务器接受完A的请求数据后，才能被接受。</li><li>由于服务器一次只能处理一个客户端请求，当处理完成并返回后(或者异常时)，才能进行第二次请求的处理。很显然，这样的处理方式在高并发的情况下，是不能采用的。</li></ol><h3 id="多线程方式-伪异步"><a href="#多线程方式-伪异步" class="headerlink" title="多线程方式 - 伪异步"></a>多线程方式 - 伪异步</h3><p>上面说的情况是服务器只有一个线程的情况，那么是否可以使用多线程技术来解决这个问题:</p><ul><li>当服务器收到客户端X的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端Y的请求。</li><li>客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式/观察模式(等其他设计模式)通知主线程。</li></ul><p><a href="java-io-bio-%E5%A4%9A%E7%BA%BF%E7%A8%8B"></a><br>使用线程来解决这个问题实际上是有局限性的。</p><ol><li>虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知accept()的方式还是单个的。也就是，实际上是服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来</li><li>在linux系统中，可以创建的线程是有限的。我们可以通过cat /proc/sys/kernel/threads-max 命令查看可以创建的最大线程数。当然这个值是可以更改的，但是线程越多，CPU切换所需的时间也就越长，用来处理真正业务的需求也就越少。</li><li>创建一个线程是有较大的资源消耗的。JVM创建一个线程的时候，即使这个线程不做任何的工作，JVM都会分配一个堆栈空间。这个空间的大小默认为128K，您可以通过-Xss参数进行调整。当然还可以使用ThreadPoolExecutor线程池来缓解线程的创建问题，但是又会造成BlockingQueue积压任务的持续增加，同样消耗了大量资源。</li><li>另外，如果应用程序大量使用长连接的话，线程是不会关闭的。这样系统资源的消耗更容易失控。 </li></ol><p>那么，如果真想单纯使用线程解决阻塞的问题，那么都可以算出来一个服务器节点可以一次接受多大的并发了。<br>看来，单纯使用线程解决这个问题不是最好的办法。</p><h2 id="BIO通信方式深入分析"><a href="#BIO通信方式深入分析" class="headerlink" title="BIO通信方式深入分析"></a>BIO通信方式深入分析</h2><p>BIO的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于accept()、read()的操作点都是被阻塞。</p><p>要测试这个问题，也很简单。<br>我们模拟了20个客户端(用20根线程模拟)，利用JAVA的同步计数器CountDownLatch，保证这20个客户都初始化完成后然后同时向服务器发送请求，然后我们来观察一下Server这边接受信息的情况。</p><h3 id="模拟20个客户端并发请求，服务器端使用单线程"><a href="#模拟20个客户端并发请求，服务器端使用单线程" class="headerlink" title="模拟20个客户端并发请求，服务器端使用单线程"></a>模拟20个客户端并发请求，服务器端使用单线程</h3><h3 id="多线程来优化服务器端"><a href="#多线程来优化服务器端" class="headerlink" title="多线程来优化服务器端"></a>多线程来优化服务器端</h3><h3 id="看看服务器端的执行效果"><a href="#看看服务器端的执行效果" class="headerlink" title="看看服务器端的执行效果"></a>看看服务器端的执行效果</h3><h3 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line"><span class="keyword">int</span> realLen = in.read(contextBytes, <span class="number">0</span>, maxLen);</span><br></pre></td></tr></table></figure><p>重点的问题并不是“是否使用了多线程”，而是为什么accept()、read()方法会被阻塞。</p><p><strong>serverSocket.accept()会被阻塞?</strong><br><strong>它内部的实现是使用的操作系统级别的同步IO。</strong></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO - NIO</title>
      <link href="/posts/12584.html"/>
      <url>/posts/12584.html</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h2><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p><h3 id="Java-IO与NIO的区别"><a href="#Java-IO与NIO的区别" class="headerlink" title="Java IO与NIO的区别"></a>Java IO与NIO的区别</h3><p>标准IO是对字节流的读写，在进行IO之前，首先创建一个流对象，流对象进行读写操作都是按字节 ，一个字节一个字节的来读或写。<br>而NIO把IO抽象成块，类似磁盘的读写，每次IO操作的单位都是一个块，块被读入内存之后就是一个byte[]，NIO一次可以读或写多个字节。</p><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p><p>Java NIO 由以下几个核心部分组成： </p><ol><li>缓冲区 Buffer</li><li>通道 Channel </li><li>选择器 Selector</li></ol><p>传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。<br>NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。</p><p>NIO的主要用途是网络IO，在NIO之前java要使用网络编程就只有用Socket。而Socket是阻塞的，显然对于高并发的场景是不适用的。所以NIO的出现就是解决了这个痛点。</p><p>主要思想是把Channel通道注册到Selector中，通过Selector去监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动。没有监听的事件，服务器可以做自己的事情。</p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>Buffer是一个内存块。<br>在NIO中，所有的数据都是用Buffer处理，有读写两种模式。在读模式下，应用程序只能从Buffer中读取数据，不能进行写操作。但是在写模式下，应用程序是可以进行读操作的，这就表示可能会出现脏读的情况。所以一旦决定要从Buffer中读取数据，一定要将Buffer的状态改为读模式。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。<br>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p><p>常用的四种channel</p><ul><li>FileChannel，读写文件中的数据。</li><li>SocketChannel，TCP Socket套接字的监听通道，一个<strong>Socket套接字</strong>对应了一个<strong>客户端IP: 端口 到 服务器IP: 端口</strong>的通信连接。</li><li>ServerSockectChannel，应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持<strong>多路复用IO</strong>的端口监听。同时支持UDP协议和TCP协议。</li><li>DatagramChannel，UDP 数据报文的监听通道。</li></ul><p>Channel本身并不存储数据，只是负责数据的运输。必须要和Buffer一起使用。</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector，选择器/多路复用器/轮询代理器/事件订阅器/channel容器管理机。<br>只有网络IO才会使用选择器，文件IO是不需要使用的。<br>选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现单线程管理多个Channel的目的。</p><ul><li>事件订阅和Channel管理<br>  应用程序将向Selector对象注册需要它关注的Channel，以及具体的某一个Channel会对哪些IO事件感兴趣。Selector中也会维护一个“已经注册的Channel”的容器。</li><li>轮询代理<br>  应用程序不再通过阻塞模式或者非阻塞模式直接询问操作系统“事件有没有发生”，而是由Selector代其询问。</li><li>实现不同操作系统的支持<br>  多路复用IO技术是需要操作系统进行支持的，其特点就是操作系统可以同时扫描同一个端口上不同网络连接的事件。<br>  所以作为上层的JVM，必须要为不同操作系统的多路复用IO实现编写不同的代码。</li></ul><p><strong>NIO 实现了 IO 多路复用中的 Reactor 模型</strong>，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p><p>监听配置为<strong>非阻塞的通道 Channel</strong>，那么当该 Channel 上的 IO 事件还未到达时，Selector 就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。<br>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。<br>应该注意的是，<strong>只有 SocketChannel 才能配置为非阻塞</strong>，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p><p><img src="/posts/12584/javanio-selector.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、将通道注册到选择器上</span></span><br><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 通道配置为非阻塞</span></span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 注册的具体事件</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_CONNECT</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_ACCEPT</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_READ</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_WRITE</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、监听事件 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</span></span><br><span class="line"><span class="keyword">int</span> num = selector.select();</span><br><span class="line"><span class="comment">// 4、获取到达的事件</span></span><br><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5、事件循环</span></span><br><span class="line"><span class="comment">// 因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零拷贝在Java中的实现"><a href="#零拷贝在Java中的实现" class="headerlink" title="零拷贝在Java中的实现"></a>零拷贝在Java中的实现</h3><p>如果涉及到文件传输，transferTo是首选，但是如果涉及到对内存数据的修改选用MappedByteBuffer。</p><h4 id="mmap-MappedByteBuffer"><a href="#mmap-MappedByteBuffer" class="headerlink" title="mmap - MappedByteBuffer"></a>mmap - MappedByteBuffer</h4><p>MappedByteBuffer 是 Java 中的 mmap 操作类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. MappedByteBuffer 可让文件直接在内存(堆外内存)修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应的通道</span></span><br><span class="line">        FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1: FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">         * 参数2： 0 ： 可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">         * 参数3:  5: 是映射到内存的大小(不是索引位置) ,即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">         * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;Y&#x27;</span>);<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sendfile-FileChannel-transferTo"><a href="#sendfile-FileChannel-transferTo" class="headerlink" title="sendfile - FileChannel.transferTo()"></a>sendfile - FileChannel.transferTo()</h4><p>FileChannel的transferTo()/transferFrom()，底层就是sendfile() 系统调用函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        <span class="comment">//得到一个文件channel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.zip&quot;</span>).getChannel();</span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//在linux下一个transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在windows 下 一次调用 transferTo 只能发送8m , 就需要分段传输文件, 而且要主要</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总的字节数 =&quot;</span> + transferCount + <span class="string">&quot; 耗时:&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java对IO多路复用的支持"><a href="#Java对IO多路复用的支持" class="headerlink" title="Java对IO多路复用的支持"></a>Java对IO多路复用的支持</h3><p><img src="/posts/12584/java%E5%AF%B9IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81.png"></p><p>多路复用IO技术是操作系统的内核实现。<br>在不同的操作系统，甚至同一系列操作系统的版本中所实现的多路复用IO技术都是不一样的。<br>那么作为跨平台的JAVA JVM来说如何适应多种多样的多路复用IO技术实现呢? </p><p>JAVA NIO中对各种多路复用IO的支持，主要的基础是java.nio.channels.spi.SelectorProvider抽象类。<br>其中的几个主要抽象方法包括:</p><ul><li>public abstract DatagramChannel openDatagramChannel(): 创建和这个操作系统匹配的UDP 通道实现。</li><li>public abstract AbstractSelector openSelector(): 创建和这个操作系统匹配的NIO选择器，就像上文所述，不同的操作系统，不同的版本所默认支持的NIO模型是不一样的。</li><li>public abstract ServerSocketChannel openServerSocketChannel(): 创建和这个NIO模型匹配的服务器端通道。</li><li>public abstract SocketChannel openSocketChannel(): 创建和这个NIO模型匹配的TCP Socket套接字通道(用来反映客户端的TCP连接)</li></ul><p><img src="/posts/12584/java-nio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png"></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>什么是IO多路复用，简单讲，就是一个进程可以同时处理多个网络连接的IO请求。</p><p>IO多路复用技术最适用的是<strong>高并发</strong>场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下IO多路复用技术发挥不出来它的优势。</p><p>select、poll、epoll（mac的kqueue、windows的IOCP）是操作系统层面的IO多路复用的实现方法。<br>Reactor模型、Proactor模型是应用程序层面处理并发I/O的模型。</p><h3 id="Linux中典型的IO多路复用实现"><a href="#Linux中典型的IO多路复用实现" class="headerlink" title="Linux中典型的IO多路复用实现"></a>Linux中典型的IO多路复用实现</h3><p>select/poll/epoll 就是操作系统内核提供给用户态的多路复用系统调用函数，线程可以通过一个系统调用函数从内核中获取多个事件。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><ol><li><strong>用户态</strong>将<strong>已连接的 Socket （先 accept 好的）</strong>都放到一个<strong>文件描述符集合</strong>；</li><li>然后<strong>调用 select 函数将文件描述符集合拷贝到内核里</strong>，让<strong>内核来检查是否有网络事件产生</strong>，检查的方式很粗暴，就是通过<strong>遍历文件描述符集合</strong>的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写；</li><li>接着再把整个文件描述符集合<strong>拷贝回用户态</strong>里，用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</li></ol><p>对于 <strong>select</strong> 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里；<br>而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p><strong>select</strong> 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的<strong>FD_SETSIZE</strong>限制，<strong>默认最大值为1024，只能监听 0~1023 的文件描述符</strong>。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，<strong>突破了 select 的文件描述符个数限制</strong>，当然还会受到系统文件描述符限制。</p><p>但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是在Linux2.6版本推出的一种IO多路实现手段。<br>mac平台是kqueue、windows平台是IOCP。</p><p><img src="/posts/12584/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-epoll.png"></p><ul><li>epoll_create 负责创建一个池子，一个监控和管理句柄 fd 的池子；</li><li>epoll_ctl 负责管理这个池子里的 fd 增、删、改；</li><li>epoll_wait 就是负责打盹的，让出 CPU 调度，但是只要有“事”，立马会从这里唤醒；</li></ul><p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p><ol><li>epoll 在<strong>内核里</strong>使用<strong>红黑树</strong>来<strong>跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过<strong>epoll_ctl()函数</strong>加入内核中的红黑树里。<br> 红黑树是个高效的数据结构，增、删、改一般时间复杂度是 O(logn)。</li><li>epoll 使用<strong>事件驱动</strong>的机制，<strong>内核里维护了一个链表来记录就绪事件</strong>。<br> 当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中；<br> 当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符。<br> 不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li></ol><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><p>Reactor模型是对事件处理流程的一种模式抽象，是对IO多路复用模式的一种封装。<br>Reactor模式特别适合应用于处理多个客户端并发向服务器端发送请求的场景。</p><p>在Reactor模型中，主要有3个角色：</p><ul><li>Reactor<br>  派发器，负责监听和分配事件，并将事件分派给对应的 Handler。<br>  新的事件包含连接建立就绪、读就绪、写就绪等。</li><li>Acceptor<br>  请求连接器，处理客户端新连接。<br>  Reactor 接收到 client 端的连接事件后，会将其转发给 Acceptor，由 Acceptor 接收 Client 的连接，创建对应的 Handler，并向 Reactor 注册此 Handler。</li><li>Handler<br>  请求处理器，负责事件的处理，将自身与事件绑定，执行非阻塞读/写任务，完成 channel 的读入，完成处理业务逻辑后，负责将结果写出 channel。<br>  可用资源池/线程池来管理。</li></ul><h4 id="Reactor模型-单reactor单线程"><a href="#Reactor模型-单reactor单线程" class="headerlink" title="Reactor模型 - 单reactor单线程"></a>Reactor模型 - 单reactor单线程</h4><p><img src="/posts/12584/%E5%8D%95reactor%E5%8D%95%E7%BA%BF%E7%A8%8B.png" alt="单reactor单线程"></p><ol><li>Reactor 线程通过 select 监听事件，收到事件后通过 Dispatch 进行分发</li><li>如果是连接建立事件，则将事件分发给 Acceptor，Acceptor 会通过 accept() 方法获取连接，并创建一个Handler 对象来处理后续的响应事件</li><li>如果是IO读写事件，则 Reactor 会将该事件交由当前连接的 Handler 来处理</li><li>Handler 会完成 read -&gt; 业务处理 -&gt; send 的完整业务流程</li></ol><p>改进后的Reactor模型相对于传统的IO模型主要有如下优点：</p><ul><li>从模型上来讲，如果仅仅还是只使用一个线程池来处理客户端连接的网络读写，以及业务计算，那么Reactor模型与传统IO模型在效率上并没有什么提升。但是Reactor模型是以事件进行驱动的，其能够将接收客户端连接，网络读和网络写，以及业务计算进行拆分，从而极大的提升处理效率；</li><li>Reactor模型是同步非阻塞模型，工作线程在没有网络事件时可以处理其他的任务，而不用像传统IO那样必须阻塞等待。</li></ul><h4 id="Reactor模型-单Reactor多线程-业务处理与IO分离"><a href="#Reactor模型-单Reactor多线程-业务处理与IO分离" class="headerlink" title="Reactor模型 - 单Reactor多线程 - 业务处理与IO分离"></a>Reactor模型 - 单Reactor多线程 - 业务处理与IO分离</h4><p>在上面的Reactor模型中，由于网络读写和业务操作都在同一个线程中，在高并发情况下，这里的系统瓶颈主要在两方面：</p><ul><li>高频率的网络读写事件处理</li><li>大量的业务操作处理</li></ul><p>基于上述两个问题，这里在单线程Reactor模型的基础上提出了使用线程池的方式处理业务操作的模型。<br>如下是该模型的示意图：<br><img src="/posts/12584/%E5%8D%95reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="单reactor多线程"></p><ol><li>Reactor 线程通过 select 监听事件，收到事件后通过 Dispatch 进行分发</li><li>如果是连接建立事件，则将事件分发给 Acceptor，Acceptor 会通过 accept() 方法获取连接，并创建一个Handler 对象来处理后续的响应事件</li><li>如果是IO读写事件，则 Reactor 会将该事件交由当前连接对应的 Handler 来处理</li><li>与单Reactor单线程不同的是，Handler 不再做具体业务处理，只负责接收和响应事件，通过 read 接收数据后，将数据发送给后面的 Worker 线程池进行业务处理。</li><li>Worker 线程池再分配线程进行业务处理，完成后将响应结果发给 Handler 进行处理。</li><li>Handler 收到响应结果后通过 send 将响应结果返回给 Client。</li></ol><p>这种模式相较于单reactor单线程模式性能有了很大的提升，主要在于在进行网络读写的同时，也进行了业务计算，从而大大提升了系统的吞吐量。<br>但是这种模式也有其不足，主要在于：</p><ul><li>网络读写是一个比较消耗CPU的操作，在高并发的情况下，将会有大量的客户端数据需要进行网络读写，此时一个线程将不足以处理这么多请求。</li><li>Handler 使用多线程模式，自然带来了多线程竞争资源的开销，同时涉及共享数据的互斥和保护机制，实现比较复杂</li></ul><h4 id="Reactor模型-主从Reactor多线程-并发读写"><a href="#Reactor模型-主从Reactor多线程-并发读写" class="headerlink" title="Reactor模型 - 主从Reactor多线程 - 并发读写"></a>Reactor模型 - 主从Reactor多线程 - 并发读写</h4><p>主从 Reactor 多线程模型将 Reactor 分成两部分：</p><ol><li>MainReactor<br> 只负责处理连接建立事件，通过 select 监听 server socket，将建立的 socketChannel 指定注册给 subReactor，通常一个线程就可以了。</li><li>SubReactor<br> 负责读写事件，维护自己的 selector，基于 MainReactor 注册的 SocketChannel 进行多路分离 IO 读写事件，读写网络数据，并将业务处理交由 worker 线程池来完成。<br> SubReactor 的个数一般和 CPU 个数相同。</li></ol><p><img src="/posts/12584/%E4%B8%BB%E4%BB%8Ereactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="主从reactor多线程"></p><h3 id="Proactor模型"><a href="#Proactor模型" class="headerlink" title="Proactor模型"></a>Proactor模型</h3><p>Proactor基于异步IO模式。<br>所有的 I/O 操作都交由系统提供的异步 I/O 接口去执行。工作线程仅仅负责业务逻辑。</p><p>在 Proactor 中，用户函数启动一个异步的文件操作。同时将这个操作注册到多路复用器上。多路复用器并不关心文件是否可读或可写而是关心这个异步读操作是否完成。异步操作是操作系统完成，用户程序不需要关心。多路复用器等待直到有完成通知到来。当操作系统完成了读文件操作——将读到的数据复制到了用户先前提供的缓冲区之后，通知多路复用器相关操作已完成。多路复用器再调用相应的处理程序，处理数据。</p><h2 id="Java-NIO的bug"><a href="#Java-NIO的bug" class="headerlink" title="Java NIO的bug"></a>Java NIO的bug</h2><h3 id="epoll空轮询"><a href="#epoll空轮询" class="headerlink" title="epoll空轮询"></a>epoll空轮询</h3><p>epoll机制是Linux下一种高效的IO复用方式，相较于select和poll机制来说，其高效的原因是将基于事件的fd放到内核中来完成，在内核中基于红黑树+链表数据结构来实现，链表存放有事件发生的fd集合，然后在调用epoll_wait时返回给应用程序，由应用程序来处理这些fd事件。</p><p>使用IO复用，Linux下一般默认就是epoll，Java NIO在Linux下默认也是epoll机制。<br>但是JDK中epoll的实现却是有漏洞的，其中最有名的<strong>java nio epoll bug</strong>就是即使是关注的select轮询事件返回数量为0，NIO照样不断的从select本应该阻塞的**Selector.select()/Selector.select(timeout)**中wake up出来，导致CPU 100%问题。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO - 基础</title>
      <link href="/posts/23102.html"/>
      <url>/posts/23102.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java-IO分类"><a href="#Java-IO分类" class="headerlink" title="Java IO分类"></a>Java IO分类</h2><p>从<strong>传输方式</strong>和<strong>数据操作</strong>两个方面分析Java IO的分类。</p><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>字节是给计算机看的，字符才是给人看的。</p><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>InputStream<br>OutputStream</p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>Reader<br>Writer</p><h4 id="字节和字符的区别和理解"><a href="#字节和字符的区别和理解" class="headerlink" title="字节和字符的区别和理解"></a>字节和字符的区别和理解</h4><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><ul><li>文件(file)<br>FileInputStream、FileOutputStream、FileReader、FileWriter</li><li>数组([])<br>字节数组(byte[]): ByteArrayInputStream、ByteArrayOutputStream<br>字符数组(char[]): CharArrayReader、CharArrayWriter</li><li>管道操作<br>PipedInputStream、PipedOutputStream、PipedReader、PipedWrite</li><li>基本数据类型<br>DataInputStream、DataOutputStream</li><li>缓冲操作<br>BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</li><li>打印<br>PrintStream、PrintWriter</li><li>对象序列化反序列化<br>ObjectInputStream、ObjectOutputStream</li><li>转换<br>InputStreamReader、OutputStreamWriter</li></ul><h2 id="Java-IO的设计模式-装饰者模式"><a href="#Java-IO的设计模式-装饰者模式" class="headerlink" title="Java IO的设计模式 - 装饰者模式"></a>Java IO的设计模式 - 装饰者模式</h2><h2 id="Java-IO源码-InputStream"><a href="#Java-IO源码-InputStream" class="headerlink" title="Java IO源码 - InputStream"></a>Java IO源码 - InputStream</h2><h2 id="Java-IO源码-OutputStream"><a href="#Java-IO源码-OutputStream" class="headerlink" title="Java IO源码 - OutputStream"></a>Java IO源码 - OutputStream</h2><h2 id="IO模型-Unix-IO模型"><a href="#IO模型-Unix-IO模型" class="headerlink" title="IO模型 - Unix IO模型"></a>IO模型 - Unix IO模型</h2><h3 id="Unix的5种IO模型"><a href="#Unix的5种IO模型" class="headerlink" title="Unix的5种IO模型"></a>Unix的5种IO模型</h3><h4 id="阻塞I-O-blocking-IO"><a href="#阻塞I-O-blocking-IO" class="headerlink" title="阻塞I/O     blocking IO"></a>阻塞I/O     blocking IO</h4><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。<br>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p><p>下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。<br><img src="/posts/23102/io%E6%A8%A1%E5%9E%8B-%E9%98%BB%E5%A1%9Eio.png"></p><h4 id="非阻塞I-O-nonblocking-I-O"><a href="#非阻塞I-O-nonblocking-I-O" class="headerlink" title="非阻塞I/O   nonblocking I/O"></a>非阻塞I/O   nonblocking I/O</h4><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。<br>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。<br><img src="/posts/23102/io%E6%A8%A1%E5%9E%8B-%E9%9D%9E%E9%98%BB%E5%A1%9Eio.png"></p><h4 id="I-O复用-I-O-multiplexing"><a href="#I-O复用-I-O-multiplexing" class="headerlink" title="I/O复用     I/O multiplexing"></a>I/O复用     I/O multiplexing</h4><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。<br>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。<br>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。<br><img src="/posts/23102/io%E6%A8%A1%E5%9E%8B-io%E5%A4%8D%E7%94%A8.png"></p><h4 id="信号驱动I-O-signal-driven-I-O-SIGIO"><a href="#信号驱动I-O-signal-driven-I-O-SIGIO" class="headerlink" title="信号驱动I/O  signal driven I/O (SIGIO)"></a>信号驱动I/O  signal driven I/O (SIGIO)</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。<br>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。<br><img src="/posts/23102/io%E6%A8%A1%E5%9E%8B-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io.png"></p><h4 id="异步I-O-asynchronous-I-O"><a href="#异步I-O-asynchronous-I-O" class="headerlink" title="异步I/O     asynchronous I/O"></a>异步I/O     asynchronous I/O</h4><p>进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。<br>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。<br><img src="/posts/23102/io%E6%A8%A1%E5%9E%8B-%E5%BC%82%E6%AD%A5io.png"></p><h3 id="I-O模型比较"><a href="#I-O模型比较" class="headerlink" title="I/O模型比较"></a>I/O模型比较</h3><p><img src="/posts/23102/io%E6%A8%A1%E5%9E%8B-%E6%AF%94%E8%BE%83.png"><br>前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p><p>同步 I/O: 应用进程在调用 recvfrom 操作时会阻塞。<br>异步 I/O: 不会阻塞。<br>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</p><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><blockquote><p>IO多路复用最为重要，后面的文章<strong>Java IO - NIO</strong>将对IO多路复用，Ractor模型以及Java NIO对其的支持作详解。</p></blockquote><h4 id="IO多路复用工作模式"><a href="#IO多路复用工作模式" class="headerlink" title="IO多路复用工作模式"></a>IO多路复用工作模式</h4><p>epoll 的描述符事件有两种触发模式: LT(level trigger)和 ET(edge trigger)。</p><p><strong>LT模式</strong><br>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。<br>是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。<br><strong>ET模式</strong><br>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。<br>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。<br>只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id="应用场景-select-amp-poll-amp-epoll"><a href="#应用场景-select-amp-poll-amp-epoll" class="headerlink" title="应用场景 select&amp;poll&amp;epoll"></a>应用场景 select&amp;poll&amp;epoll</h4><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。<br><strong>selent</strong><br><strong>poll</strong><br><strong>epoll</strong></p><h2 id="IO基础知识与概念"><a href="#IO基础知识与概念" class="headerlink" title="IO基础知识与概念"></a>IO基础知识与概念</h2><h3 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h3><p>在计算机操作系统中，所谓的I/O就是<strong>输入 input</strong>和<strong>输出 output</strong>，也可以理解为<strong>读 read</strong>和<strong>写 write</strong>。<br>针对不同的对象，I/O模式可以划分为<strong>磁盘IO</strong>和<strong>网络IO</strong>。</p><p>I/O操作会涉及到<strong>用户空间</strong>和<strong>内核空间</strong>的转换，理解以下规则：</p><ul><li>内存空间分为用户空间和内核空间，也称为用户缓冲区和内核缓冲区；</li><li>用户的应用程序不能直接操作内核空间，需要将数据从内核空间拷贝到用户空间才能使用；</li><li>无论是read操作，还是write操作，都只能在内核空间里执行；</li><li>磁盘IO和网络IO请求加载到内存的数据都是先放在内核空间的。</li></ul><p>在IO中（磁盘IO或者是网络IO），都是由用户去调用<strong>Read</strong>读取内核态中的数据，读取数据到用户态；而<strong>write</strong>则是将数据从用户态写到内核态中，由内核去写入文件或者是通过网络IO（网卡）发送数据。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符(fd, File Descriptor)，用于描述指向文件的引用的抽象化概念。</p><p>当应用程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。<br>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。<br>在Linxu系统中，一切皆文件，因此socket也是一个文件，也有文件句柄（或文件描述符）。</p><h3 id="操作系统的内核态和用户态"><a href="#操作系统的内核态和用户态" class="headerlink" title="操作系统的内核态和用户态"></a>操作系统的内核态和用户态</h3><p>Linux系统中分为<strong>内核态 Kernel Model</strong>和<strong>用户态 User Model</strong>，CPU会在两个Model之间切换。</p><p>通俗点讲，<strong>内核空间</strong>是操作系统内核代码运行的地方，<strong>用户空间</strong>是用户程序代码运行的地方。<br>当应用进程在运行用户代码时就处于<strong>用户态</strong>。<br>当应用进程执行系统调用，从而内核代码执行时就处于<strong>内核态</strong>。</p><p>内核空间可以执行任意的命令，而用户空间只能执行简单的运算，不能直接调用系统资源和数据。必须通过操作系统提供接口，向系统内核发送指令。<br>一旦调用系统接口，应用进程就从用户态切换到内核态了，因为开始运行内核代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;i am qige&quot;</span> <span class="comment">// 用户空间，赋值运算</span></span><br><span class="line">x = x + <span class="number">2</span>         <span class="comment">// 用户空间，赋值运算</span></span><br><span class="line">file.write(str)   <span class="comment">// 切换到内核空间。因为用户不能直接写文件，必须通过内核安排。</span></span><br><span class="line">y = x + <span class="number">4</span>         <span class="comment">// 切换回用户空间</span></span><br></pre></td></tr></table></figure><h4 id="用户态切换到内核态的3种方式"><a href="#用户态切换到内核态的3种方式" class="headerlink" title="用户态切换到内核态的3种方式"></a>用户态切换到内核态的3种方式</h4><ol><li>系统调用<br> 也称为 System Call，是说用户态进程<strong>主动</strong>要求切换到内核态的一种方式，用户态进程使用操作系统提供的服务程序完成工作。</li><li>异常<br> 当CPU在用户空间执行程序代码时发生了不可预期的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，切换到内核态，比如缺页异常。</li><li>外围设备的中断<br> 当外围设备完成用户请求的某些操作后，会向CPU发送相应的中断信号，这时CPU会暂停执行下一条即将执行的指令转而去执行与中断信号对应的处理程序，如果当前正在运行用户态下的程序指令，自然就发生由用户态到内核态的切换。<br> 比如硬盘数据读写完成，系统会切换到中断处理程序中执行后续操作等。</li></ol><h3 id="磁盘IO-amp-网络IO"><a href="#磁盘IO-amp-网络IO" class="headerlink" title="磁盘IO &amp; 网络IO"></a>磁盘IO &amp; 网络IO</h3><h4 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h4><p><img src="/posts/23102/IO%E5%9F%BA%E7%A1%80-%E7%A3%81%E7%9B%98IO.png"></p><p><strong>读操作</strong><br>当应用程序调用read()方法时，操作系统检查内核高速缓冲区中是否存在需要的数据。<br>如果存在，那么就直接把内核空间的数据copy到用户空间，供用户的应用程序使用。<br>如果内核缓冲区没有需要的数据，那么通过DMA方式从磁盘中读取数据到内核缓冲区，然后由CPU控制，把内核空间的数据copy到用户空间。</p><p>这个过程会涉及到两次缓冲区copy，第一次是从磁盘到内核缓冲区，第二次是从内核缓冲区到用户缓冲区，第一次是DMA的copy，第二次是CPU的copy。</p><p><strong>写操作</strong><br>当应用程序调用write()方法时，应用程序将数据从用户空间copy到内核空间的缓冲区中（如果用户空间没有相应的数据，则需要从磁盘—&gt;内核缓冲区—&gt;用户缓冲区），这时对用户程序来说写操作就已经完成。<br>至于什么时候把数据再写到磁盘（从内核缓冲区到磁盘的写操作也由DMA控制，不需要cpu参与），由操作系统决定。<br>除非应用程序显示地调用了sync命令，立即把数据写入磁盘。</p><p>如果应用程序没准备好写的数据，则必须先从磁盘读取数据才能执行写操作。<br>这时会涉及到<strong>四次</strong>缓冲区的copy，第一次是从磁盘的缓冲区到内核缓冲区，第二次是从内核缓冲区到用户缓冲区，第三次是从用户缓冲区到内核缓冲区，第四次是从内核缓冲区写回到磁盘。前两次是为了读，后两次是为了写。这其中有两次 CPU 拷贝，两次DMA拷贝。</p><p><strong>磁盘IO的延时</strong><br>为了读或写，磁头必须能移动到所指定的磁道上，并等待所指定的扇区的开始位置旋转到磁头下，然后再开始读或写数据。<br>磁盘IO的延时分成以下三部分：</p><ul><li>寻道时间：把磁头移动到指定磁道上所经历的时间；</li><li>旋转延迟时间 ：指定扇区移动到磁头下面所经历的时间；</li><li>传输时间 ：数据的传输时间（数据读出或写入的时间）。</li></ul><h4 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h4><p><img src="/posts/23102/IO%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9CIO.png"></p><p><strong>读操作</strong><br>网络 IO 既可以从物理磁盘中读数据，也可以从Socket中读数据（从网卡中获取）。<br>当从物理磁盘中读数据的时候，其流程和磁盘IO的读操作一样。<br>当从Socket中读数据，应用程序需要等待客户端发送数据，如果客户端还没有发送数据，对应的应用程序将会被阻塞，直到客户端发送了数据，该应用程序才会被唤醒，从Socket协议栈（网卡）中读取客户端发送的数据到内核空间的Socket Buffer（这个过程也由DMA控制），然后把内核空间的数据 copy 到用户空间，供应用程序使用。</p><p><strong>写操作</strong><br>假设网络IO的数据从磁盘中获取，读写操作的流程如下：</p><ul><li>当应用程序调用 read() 方法时，通过DMA方式将数据从磁盘拷贝到内核缓冲区；</li><li>由cpu控制，将内核缓冲区的数据拷贝到用户空间的缓冲区中，供应用程序使用；</li><li>当应用程序调用 write() 方法时，CPU 会把用户缓冲区中的数据 copy 到内核缓冲区的 Socket Buffer 中；</li><li>最后通过DMA方式将内核空间中的Socket Buffer拷贝到Socket协议栈（即网卡设备）中传输。</li></ul><p>网络IO 的写操作也有<strong>四次</strong>缓冲区的copy，第一次是从磁盘缓冲区到内核缓冲区（由DMA控制），第二次是内核缓冲区到用户缓冲区（CPU控制），第三次是用户缓冲区到内核缓冲区的 Socket Buffer（由CPU控制），第四次是从内核缓冲区的 Socket Buffer 到网卡设备（由DMA控制）。四次缓冲区的copy工作两次由CPU控制，两次由DMA控制。</p><p><strong>网络IO的延时</strong><br>网络IO主要延时是由：<strong>服务器响应延时+带宽限制+网络延时+跳转路由延时+本地接收延时</strong>决定。一般为几十到几千毫秒，受环境影响较大。<br>所以，一般来说，网络IO延时要大于磁盘IO延时(不过同数据中心的交互除外，会比磁盘 IO 更快)。</p><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>mmap的核心思想是：应用程序这边由于在用户态无法直接操作寄存器的物理地址，于是通过mmap方法进行内存映射，将物理地址映射到用户态的虚拟地址上，然后应用程序通过读写自己手边的虚拟地址，就可以实现对物理地址的读取/写入。</p><h4 id="sendFile"><a href="#sendFile" class="headerlink" title="sendFile"></a>sendFile</h4><p>sendfile系统调用函数，可以直接把内核缓冲区的数据直接拷贝到socket缓冲区中，不再拷贝到用户态。</p><p><strong>sendfile</strong>要求输入的fd必须是文件句柄，不能是socket，输出的fd必须是socket，也就是说，数据的来源必须是从本地的磁盘，而不能是从网络中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span></span><br></pre></td></tr></table></figure><p>in_fd 必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。<br>由此可见，sendfile 几乎是专门为在网络上传输文件而设计的。</p><h3 id="数据传输方式-PIO-amp-DMA"><a href="#数据传输方式-PIO-amp-DMA" class="headerlink" title="数据传输方式 PIO &amp; DMA"></a>数据传输方式 PIO &amp; DMA</h3><p>DMA（直接存储器访问）和 PIO（程控输入/输出）。<br>DMA和PIO分别是在电子设备中传输信息的两种方式；在计算机和其他类似设备中更为著名。<br>PIO是一种较老的方法，由于某些优点，在大多数应用中已被DMA取代。</p><h3 id="缓冲IO-amp-直接IO"><a href="#缓冲IO-amp-直接IO" class="headerlink" title="缓冲IO &amp; 直接IO"></a>缓冲IO &amp; 直接IO</h3><h4 id="缓冲IO"><a href="#缓冲IO" class="headerlink" title="缓冲IO"></a>缓冲IO</h4><p>机械硬盘的读写原理与特点是：一个机械硬盘中装有多个盘片，每个盘片上有多个同心圆（磁道），每个同心圆又由多个弧（扇区）组成，每个弧上都记录了等量的数据（比方说512byte）。<br>如果发起一个随机读写请求，磁头需要先找到对应的磁道，然后等待对应的扇区旋转到磁头正下方才能开始读取数据（民用机械硬盘的转速一般在5400或者7200RPM，工业界倒是经常使用10000RPM的机械硬盘。但是它们的寻道时间大概都在几ms到十几ms左右）。<br>机械硬盘的顺序读写很快（一般在100-200MB/s），但是随机读写很慢（寻道时间在十几ms，导致随机读写的iops只有几十）。</p><p>假定我们不做任何额外的优化处理，在用户发起读数据请求的时候，直接调用硬盘驱动读取磁盘数据并返回。<br>设想一个场景：循环调用read方法读取文件，但是每次只读取较少的数据（比方说每次只读一个byte）。那么每次read请求都对应于一次对磁盘的随机读写（两次读请求之前需要重新寻道），也就是说read操作的tps只有几十。<br>也就是说此时磁盘占用率为100%，但是只能提供不到100byte/s的数据读取率，这显然是不可接受的。</p><p>Linux对此有个很简单的优化，就是在内核中维护一块缓冲区（buffer cache），在用户第一次调用read读取数据的时候，无论用户想要读取的数据有多小，都会一次性从磁盘中加载一段数据放到缓冲区中，根据局部性原理，这样用户下一次调用read方法的时候可以直接从缓冲区中返回数据，不用再次访问磁盘了。<br>write方法也是同理，用户写入的数据不是直接落盘，而是先写到kernel中的缓冲区里，按照一定的策略批量刷盘。当然也可以调用flush方法强制将缓存区的数据落盘。<br>这个优化极大的提高了顺序读写的效率。由于直接读写的是kernel中的缓冲区而不是磁盘，这种IO被称为缓冲IO。</p><h4 id="直接IO"><a href="#直接IO" class="headerlink" title="直接IO"></a>直接IO</h4><p>一般来说，缓冲IO已经足够应付日常需求了。但是像数据库这种极度依赖IO的应用程序，为了追求极致的性能，往往更加愿意自己直接操作磁盘。<br>直接IO可以直接将数据从磁盘复制到用户空间，或者将数据从用户空间写到磁盘，减少了kernel中的缓冲区这一环节，这是直接IO可以提高性能的原理。<br>但是如果用得不好就悲剧了，所以直接IO只在少数场景下使用。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——Kafka</title>
      <link href="/posts/31046.html"/>
      <url>/posts/31046.html</url>
      
        <content type="html"><![CDATA[<p>首次接触到Kafka的背景，<code>实时同步mysql数据到doris，Mysql binlog + kafka + flink + doris</code></p><p><img src="/posts/31046/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="消息队列发展史"><br><img src="/posts/31046/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.jpeg" alt="主流消息队列对比"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kafka 是一种分布式的，基于发布 / 订阅的消息系统。<br>主要设计目标如下：</p><ul><li>以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。</li><li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒 100K 条以上消息的传输。</li><li>支持 Kafka Server 间的消息分区，及分布式消费，同时保证每个 Partition 内的消息顺序传输。</li><li>同时支持离线数据处理和实时数据处理。</li><li>Scale out：支持在线水平扩展。</li></ul><h3 id="创建背景"><a href="#创建背景" class="headerlink" title="创建背景"></a>创建背景</h3><p>Kafka 是一个消息系统，原本开发自 LinkedIn，用作 LinkedIn 的活动流（Activity Stream）和运营数据处理管道（Pipeline）的基础。</p><h2 id="Kafka基础概念"><a href="#Kafka基础概念" class="headerlink" title="Kafka基础概念"></a>Kafka基础概念</h2><p><img src="/posts/31046/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.png"></p><h3 id="Kafka的特性"><a href="#Kafka的特性" class="headerlink" title="Kafka的特性"></a>Kafka的特性</h3><ul><li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒。</li><li>可扩展性：kafka集群支持热扩展。</li><li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失。</li><li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）。</li><li>高并发：支持数千个客户端同时读写。</li></ul><h4 id="Kafka为什么吞吐量大、速度快【重要】"><a href="#Kafka为什么吞吐量大、速度快【重要】" class="headerlink" title="Kafka为什么吞吐量大、速度快【重要】"></a>Kafka为什么吞吐量大、速度快【重要】</h4><ol><li><p><strong>Partition并行 分区分段+索引</strong><br> Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。<br> 每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。<br> 这也非常符合分布式系统分区分桶的设计思想。</p><p> 通过这种分区分段的设计，Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。<br> 为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的<code>.index</code>文件。<br> 这种<strong>分区分段+索引</strong>的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p></li><li><p><strong>顺序读写磁盘</strong><br> Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入，这使得Kafka写入吞吐量得到了显著提升 。</p><blockquote><p>影响磁盘的关键因素是磁盘服务时间，即磁盘完成一个 I/O 请求所花费的时间，它由寻道时间、旋转延迟和数据传输时间三部分构成。<br>机械硬盘的<strong>连续读写</strong>性能很好，但<strong>随机读写</strong>性能很差，这主要是因为磁头移动到正确的磁道上需要时间，随机读写时，磁头需要不停的移动，时间都浪费在了磁头寻址上，所以性能不高。衡量磁盘的重要主要指标是 IOPS 和吞吐量。<br>在许多的开源框架如 Kafka、HBase 中，都<strong>通过追加写的方式来尽可能的将随机 I/O 转换为顺序 I/O，以此来降低寻址时间和旋转延时</strong>，从而最大限度的提高 IOPS。</p></blockquote><p> Kafka的每一个Partition其实都是一个文件，收到消息后Kafka会把数据插入到文件末尾。</p><p> 这种方法有一个缺陷：<strong>没有办法删除数据</strong>。所以Kafka是不会删除数据的，它会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个offset用来表示读取到了第几条数据。<br> 如果不删除硬盘肯定会被撑满，所以Kakfa提供了两种策略来删除数据。一是基于时间，二是基于partition文件大小。具体配置可以参看它的配置文档。</p></li><li><p><strong>Page Cache</strong></p><blockquote><p>操作系统层面引入 Cache 层的目的是为了提高 Linux 操作系统对磁盘访问的性能。Cache 层在内存中缓存了磁盘上的部分数据。当数据的请求到达时，如果在 Cache 中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。<br>在 Linux 的实现中，文件 Cache 分为两个层面，一是 Page Cache，另一个 Buffer Cache，每一个 Page Cache 包含若干 Buffer Cache。<br>Page Cache 主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有 read/write 操作的时候。<br>Buffer Cache 则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。</p></blockquote><p>通过操作系统的Page Cache，Kafka的读写操作基本上是基于内存的，读写速度得到了极大的提升。</p><p>在写磁盘文件的时候，就可以先直接写入 os cache 中，也就是仅仅写入内存中，接下来由操作系统自己决定什么时候把 os cache 里的数据真的刷入到磁盘中, 这样大大提高写入效率和性能。</p></li><li><p><strong>零拷贝</strong><br> Kafka 中存在大量的<strong>网络数据持久化到磁盘（Producer 到 Broker）</strong>和<strong>磁盘文件通过网络发送（Broker 到 Consumer）</strong>的过程。这一过程的性能直接影响 Kafka 的整体吞吐量。</p><blockquote><p><img src="/posts/31046/%E9%9B%B6%E6%8B%B7%E8%B4%9D-%E5%85%A8%E9%83%A8%E6%8B%B7%E8%B4%9D%E8%BF%87%E7%A8%8B.jpg"><br>在实际应用中，把磁盘中的某个文件内容发送到远程服务器上，必须要经过几个拷贝的过程：</p><ol><li>从磁盘中读取目标文件内容拷贝到内核缓冲区（OS Cache）；</li><li>CPU控制器再把内核缓冲区的数据赋值到用户空间的缓冲区中；</li><li>接着在应用程序中，调用write()方法，把用户空间缓冲区中的数据拷贝到内核下的Socket Buffer中；</li><li>最后，把在内核模式下的SocketBuffer中的数据赋值到网卡缓冲区（NIC Buffer），网卡缓冲区再把数据传输到目标服务器上。</li></ol></blockquote><blockquote><p>在这个过程中我们可以发现，数据从磁盘到最终发送出去，要经历4次拷贝，而在这四次拷贝过程中，有两次拷贝是浪费的，分别是：</p><ol><li>从内核空间赋值到用户空间</li><li>从用户空间再次复制到内核空间</li></ol></blockquote><blockquote><p>零拷贝，就是把这两次多余的拷贝省略掉，应用程序可以直接把磁盘中的数据从内核中直接传输给Socket，而不需要再经过应用程序所在的用户空间。<br><img src="/posts/31046/%E9%9B%B6%E6%8B%B7%E8%B4%9D-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E8%BF%87%E7%A8%8B.jpg"><br>零拷贝通过DMA（Direct Memory Access，直接存储器访问）技术把文件内容复制到内核空间中的Read Buffer，接着把包含数据位置和长度信息的文件描述符加载到Socket Buffer中，DMA引擎直接可以把数据从内核空间中传递给网卡设备。<br>在这个流程中，数据只经历了两次拷贝就发送到了网卡中，并且减少了2次cpu的上下文切换，对于效率有非常大的提高。<br>所以，所谓零拷贝，并不是完全没有数据赋值，只是相对于用户空间来说，不再需要进行数据拷贝。对于前面说的整个流程来说，零拷贝只是避免了在内核空间和用户空间之间的拷贝。</p></blockquote><ul><li><code>Producer 生产的数据持久化到 broker</code>，采用 mmap 文件映射，实现磁盘的快速写入。<br>   mmap 文件映射（Memory Mapped Files）：将磁盘文件映射到内存, 用户通过修改内存就能修改磁盘文件</li><li><code>Customer 从 broker 读取数据</code>，采用 sendfile，将磁盘文件读到 OS 内核缓冲区后，转到 NIO buffer 进行网络发送，减少 CPU 消耗。</li></ul></li><li><p><strong>批处理 批量读写</strong><br> Kafka数据读写也是批量的而不是单条的。</p><p> 除了利用底层的技术外，Kafka还在应用程序层面提供了一些手段来提升性能。最明显的就是使用批次。<br> 在向Kafka写入数据时，可以启用批次写入，这样可以避免在网络上频繁传输单个消息带来的延迟和带宽开销。<br> 假设网络带宽为10MB/S，一次性传输10MB的消息比传输1KB的消息10000万次显然要快得多。</p></li><li><p><strong>数据压缩</strong><br> 在很多情况下，系统的瓶颈不是 CPU 或磁盘，而是网络 IO。<br> Producer 可将数据压缩后发送给 broker，从而减少网络传输代价，目前支持的压缩算法有：Snappy、Gzip、LZ4。数据压缩一般都是和批处理配套使用来作为优化手段的。</p></li><li><p><strong>超高并发网络架构</strong></p></li></ol><h3 id="概念1-生产者与消费者"><a href="#概念1-生产者与消费者" class="headerlink" title="概念1 生产者与消费者"></a>概念1 生产者与消费者</h3><p>对于 Kafka 来说，客户端有两种基本类型：生产者（Producer）和消费者（Consumer）。<br>除此之外，还有用来做数据集成的 Kafka Connect API 和流式处理的 Kafka Streams 等高阶客户端，但这些高阶客户端底层仍然是生产者和消费者API，它们只不过是在上层做了封装。</p><ul><li><strong>Producer</strong><br>  消息生产者，就是向 kafka broker 发消息的客户端。</li><li><strong>Consumer</strong><br>  消息消费者，向 kafka broker 取消息的客户端。</li><li><strong>Consumer Group</strong><br>  消费者组，由多个 consumer 组成，消费者组是逻辑上的一个订阅者。<ul><li><strong>重平衡：Rebalance</strong><br>  消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。<br>  Rebalance 是 Kafka 消费者端实现高可用的重要手段。</li></ul></li></ul><h3 id="概念2-主题-Topic-与分区-Partition"><a href="#概念2-主题-Topic-与分区-Partition" class="headerlink" title="概念2 主题(Topic)与分区(Partition)"></a>概念2 主题(Topic)与分区(Partition)</h3><ul><li><p><strong>Topic</strong><br>  Topic是一个逻辑上的消息队列，同一类型的消息可以放到一个Topic（消息队列）中。<br>  主要作用是用来屏蔽底层分区和副本的复杂逻辑。</p></li><li><p><strong>Partition</strong><br>  Partition（分区），是Kafka下数据存储的基本单元，这个是物理上的概念。</p><p>  一个 topic 可以分为多个 partition，每个 partition 都是一个有序的队列。<br>  主题可以被分为若干个分区（partition），同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性，单一主题中的分区有序，但是无法保证主题中所有的分区有序。</p><p>  同一个分区（partition）可以被不同的消费者组同时消费；<br>  但是在同一个消费者组内，一个分区只能被一个消费者消费。</p></li></ul><h4 id="当broker里面的topic数量过多时，kafka的性能不如rocketMq？"><a href="#当broker里面的topic数量过多时，kafka的性能不如rocketMq？" class="headerlink" title="当broker里面的topic数量过多时，kafka的性能不如rocketMq？"></a>当broker里面的topic数量过多时，kafka的性能不如rocketMq？</h4><blockquote><p>Kafka与RocketMQ在topic处理上的不同</p><ol><li>kafka中partition增多会存在随机写的可能性，partition之间刷盘的冲撞率会高，但是RocketMQ是把消息都写到一个CommitLog文件中，所以相当于一个文件的顺序写。</li><li>RockertMQ的consumerQueue消息格式大小固定（20字节），写入pagecache之后被触发刷盘频率相对较低。</li></ol></blockquote><ul><li><p><strong>Replica</strong><br>  Replica（副本），就是Partition的一个备份，副本的数量是可以配置的。<br>  Kafka 定义了两类副本：领导者副本（Leader Replica） 和 追随者副本（Follower Replica），前者对外提供服务，后者只是被动跟随。<br>  一个分区（Partition）只能有一个leader，但是可以设置多个副本（follower），同一分区的副本不能在同一台机器上。</p><p>  <strong>leader partition</strong>：<br>  1、写数据、读数据操作都是从leader partition去操作的。<br>  2、会维护一个ISR（in-sync-replica）列表，但是会根据一定的规则删除ISR列表里面的值。生产者发送来一个消息，消息首先要写入到leader partition中，写完了以后，还要把消息写入到ISR列表里面的其它分区，写完后才算这个消息提交。<br>  <strong>follower partition</strong>：从leader partition同步数据。<br>  当 leader 发生故障时，某个 follower 会成为新的 leader，以此来保证kafka的可用性。</p><p>  自 Kafka 2.4 之后，Kafka 提供了有限度的读写分离，也就是说，Follower 副本能够对外提供读服务。</p></li></ul><h3 id="概念3-Broker和集群-Cluster"><a href="#概念3-Broker和集群-Cluster" class="headerlink" title="概念3 Broker和集群(Cluster)"></a>概念3 Broker和集群(Cluster)</h3><p>一台 kafka 服务器就是一个 broker。<br>一个kafka集群由多个 broker 组成，然后通过Zookeeper来进行集群的管理。</p><ul><li><p><strong>Zookeeper</strong><br>  2.8.0版本之前，Kafka 将 Broker、Topic 和 Partition 的元数据信息存储在 Zookeeper 上。</p><p>  <img src="/posts/31046/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-kafka-zookeeper.png"></p><p>  通过在 Zookeeper 上建立相应的数据节点，并监听节点的变化。</p></li><li><p><strong>Controller</strong><br>  Controller 是从 Broker 中选举出来的，负责整个集群中所有分区、副本的管理。<br>  当分区中Leader副本出现问题时及时选举新的Leader副本。</p></li></ul><h3 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h3><p><img src="/posts/31046/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E6%A0%B8%E5%BF%83api.jpeg"></p><ul><li>Producer API<br>允许应用程序向一个或多个 topics 上发送消息记录。</li><li>Consumer API<br>允许应用程序订阅一个或多个 topics 并对发布给他们的流式数据进行处理。</li><li>Streams API<br>它允许应用程序作为流处理器，消费一个或者多个topic产生的输入流，然后生产一个输出流到一个或多个topic中去，在输入输出流中进行有效的转换。</li><li>Connector API<br>它允许构建并运行可重用的生产者或者消费者，将Kafka topics连接到已存在的应用程序或者数据系统。<br>比如，连接到一个关系型数据库，捕捉表（table）的所有变更内容。</li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;mid=2247488849&amp;idx=1&amp;sn=febda095589f02553d9191528f271c07&amp;chksm=cefb3c60f98cb576fd9c58d760b9a5e4ae32a0c001e2049b591297d904a0401646448999c78a&amp;scene=178&amp;cur_album_id=2147575846151290880#rd">https://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;mid=2247488849&amp;idx=1&amp;sn=febda095589f02553d9191528f271c07&amp;chksm=cefb3c60f98cb576fd9c58d760b9a5e4ae32a0c001e2049b591297d904a0401646448999c78a&amp;scene=178&amp;cur_album_id=2147575846151290880#rd</a></p><h2 id="Kafka-Producer"><a href="#Kafka-Producer" class="headerlink" title="Kafka Producer"></a>Kafka Producer</h2><p>在 Kafka 中, 我们把产生消息的一方称为 Producer 即 生产者, 它是 Kafka 的核心组件之一, 也是消息的来源所在。<br>它的主要功能是将客户端的请求打包封装发送到 kafka 集群的某个 Topic 的某个分区上。</p><p>那么这些生产者产生的消息是怎么传到 Kafka 服务端的呢？<br>初始化和发送过程是怎么样的呢？</p><h3 id="Producer初始化"><a href="#Producer初始化" class="headerlink" title="Producer初始化"></a>Producer初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1)、设置分区器(partitioner), 分区器是支持自定义的</span><br><span class="line">2)、设置重试时间(retryBackoffMs)默认100ms</span><br><span class="line">3)、设置序列化器(Serializer)</span><br><span class="line">4)、设置拦截器(interceptors)</span><br><span class="line">5)、初始化集群元数据(metadata),刚开始空的</span><br><span class="line">6)、设置最大的消息为多大(maxRequestSize), 默认最大1M, 生产环境可以提高到10M</span><br><span class="line">7)、设置缓存大小(totalMemorySize) 默认是32M</span><br><span class="line">8)、设置压缩格式(compressionType)</span><br><span class="line">9)、初始化RecordAccumulator也就是缓冲区指定为32M</span><br><span class="line">10)、定时更新(metadata.update)</span><br><span class="line">11)、创建NetworkClient</span><br><span class="line">12)、创建Sender线程</span><br><span class="line">13)、KafkaThread将Sender设置为守护线程并启动</span><br></pre></td></tr></table></figure><h3 id="Producer发送过程"><a href="#Producer发送过程" class="headerlink" title="Producer发送过程"></a>Producer发送过程</h3><h4 id="KafkaProducer-send-ProducerRecord-Callback"><a href="#KafkaProducer-send-ProducerRecord-Callback" class="headerlink" title="KafkaProducer.send(ProducerRecord, Callback)"></a>KafkaProducer.send(ProducerRecord, Callback)</h4><ol><li>序列化+计算目标分区</li><li>追加写入消息缓冲区(accumulator)</li><li>Sender线程预处理及消息发送</li><li>Sender线程处理response</li></ol><h4 id="Producer内存池设计"><a href="#Producer内存池设计" class="headerlink" title="Producer内存池设计"></a>Producer内存池设计</h4><h4 id="Ack应答确认机制"><a href="#Ack应答确认机制" class="headerlink" title="Ack应答确认机制"></a>Ack应答确认机制</h4><p>ack作用是确认收到消息，一是producer发送消息到leader收到消息之后发送ack，二是leader和follower之间同步完成数据会发送ack</p><p><strong>acks参数</strong>指定了必须要有多少个分区副本收到消息，生产者才认为该消息是写入成功的，这个参数对于消息是否丢失起着重要作用。<br>该参数的配置具体如下：</p><ul><li>acks=0<br>  producer不等待broker的ack，这一种操作提供了最低的延迟，broker一接受到还没有写入到磁盘就已经返回了，当broker故障的时候 丢失数据（相当于异步发送）</li><li>acks=1<br>  producer等待broker的ack，partition的leader落盘成功后返回ack。<br>  如果follower同步数据之前leader故障，此时会丢失数据。<br>  此时follower需要同步leader中的数据，但是leader宕机了，挂了之后kafka集群会重新选举leader，选举出leader之后，并没有同步到原有的数据，就会造成数据的丢失。</li><li>acks=-1<br>  producer等待broker的ackpartition的leader和follower全部落盘成功后，才会返回ack。<br>  但是如果follower同步完成之后，在broker发送ack之前，leader发生故障，生产者收不到ack确认，会重新发送消息，那么会出现数据的重复，但不会造成数据丢失。</li></ul><h3 id="Producer网络架构"><a href="#Producer网络架构" class="headerlink" title="Producer网络架构"></a>Producer网络架构</h3><h2 id="Kafka-Consumer"><a href="#Kafka-Consumer" class="headerlink" title="Kafka Consumer"></a>Kafka Consumer</h2><h3 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h3><p>Kafka Consumer 采用从 Broker 中主动拉取数据。</p><p>不采用 push（推）模式是因为：由 broker 决定消息发送速率，很难适应所有消费者的消费速率。</p><p>pull 模式不足之处是，如果 Kafka 没有数据，消费者可能会陷入循环中，一直返回空数据。</p><h3 id="Consumer初始化"><a href="#Consumer初始化" class="headerlink" title="Consumer初始化"></a>Consumer初始化</h3><h3 id="消费组概念"><a href="#消费组概念" class="headerlink" title="消费组概念"></a>消费组概念</h3><p>为什么 Kafka 要设计 Consumer Group, 只有 Consumer 不可以吗？<br>我们知道 Kafka 是一款高吞吐量，低延迟，高并发,  高可扩展性的消息队列产品，那么如果某个 Topic 拥有数百万到数千万的数据量，仅仅依靠 Consumer 进程消费，消费速度可想而知，所以需要一个扩展性较好的机制来保障消费进度，这个时候 Consumer Group 应运而生。<br>Consumer Group 是 Kafka 提供的可扩展且具有容错性的消费者机制。</p><p>特点：</p><ul><li>每个 Consumer Group 有一个或者多个 Consumer；</li><li>每个 Consumer Group 拥有一个公共且唯一的 Group ID；</li><li>Consumer Group 在消费 Topic 的时候，Topic 的每个 Partition 只能分配给组内的某个 Consumer，只要被任何 Consumer 消费一次, 那么这条数据就可以认为被当前 Consumer Group 消费成功。</li></ul><h4 id="Group-Coordinator"><a href="#Group-Coordinator" class="headerlink" title="Group Coordinator"></a>Group Coordinator</h4><p>所谓协调者，它专门为Consumer Group服务，负责为Group执行Rebalance以及提供位移管理和组成员管理等。<br>每个Consumer Group都会选择一个broker作为自己的Coordinator。</p><p>具体来讲，Consumer端应用程序在提交位移时，其实是向Coordinator所在的Broker提交位移，同样地，当Consumer应用启动时，也是向Coordinator所在的Broker发送各种请求，然后由Coordinator负责执行消费者组的注册、成员管理记录等元数据管理操作。</p><p>所有Broker在启动时，都会创建和开启相应的Coordinator组件。也就是说，「所有Broker都有各自的Coordinator组件」。</p><p><strong>Consumer Group</strong>如何确定为它服务的Coordinator在哪台Broker上？<br>通过Kafka内部主题<code>__consumer_offsets</code></p><p>Kafka为某个Consumer Group确定Coordinator所在的Broker的算法有2个步骤：</p><ol><li>确定由__consumer_offsets主题的哪个分区来保存该Group数据.<br> <code>partitionId = Math.abs(groupId.hashCode() % offsetsTopicPartitionCount)</code></li><li>找出该分区Leader副本所在的Broker，该Broker即为对应的Coordinator。</li></ol><h4 id="Rebalance消费者组重分配机制"><a href="#Rebalance消费者组重分配机制" class="headerlink" title="Rebalance消费者组重分配机制"></a>Rebalance消费者组重分配机制</h4><p>消费者组内所有消费者自动重新分配订阅主题分区的过程。<br>Rebalance是Kafka消费者端实现高可用的重要手段。<br>Consumer group靠Coordinator实现了Rebalance。</p><p><strong>Rebalance 的触发条件</strong></p><ol><li>当 Consumer Group 组成员数量发生变化(主动加入或者主动离组，故障下线等)</li><li>当订阅主题数量发生变化</li><li>当订阅主题的分区数发生变化</li></ol><p><strong>Rebalance 如何通知其他 consumer 进程？</strong><br>Rebalance 的通知机制是靠 Consumer 端的心跳线程，它会定期发送心跳请求到 Broker 端的 Coordinator，当协调者决定开启 Rebalance 后，它会将“REBALANCE_IN_PROGRESS”封装进心跳请求的响应中发送给 Consumer,当 Consumer 发现心跳响应中包含了“REBALANCE_IN_PROGRESS”，就知道 Rebalance开始了。</p><p><strong>Partition分区分配策略</strong></p><ul><li>rage<br>  RangeAssignor 是 Kafka 默认的分区分配算法。<br>  它是按照 Topic 的维度进行分配的，对于每个 Topic，首先对 Partition 按照分区ID进行排序，然后对订阅这个 Topic 的 Consumer Group 的 Consumer 再进行排序，之后尽量均衡的按照范围区段将分区分配给 Consumer。此时可能会造成先分配分区的 Consumer 进程的任务过重（分区数无法被消费者数量整除）。</li><li>round-robin<br>  RoundRobinAssignor 的分区分配策略是将 Consumer Group 内订阅的所有 Topic 的 Partition 及所有 Consumer 进行排序后按照顺序尽量均衡的一个一个进行分配。<br>  如果 Consumer Group 内，每个 Consumer 订阅都订阅了相同的Topic，那么分配结果是均衡的。<br>  如果订阅 Topic 是不同的，那么分配结果是不保证“尽量均衡”的，因为某些 Consumer 可能不参与一些 Topic 的分配。</li><li>sticky<br>  StickyAssignor 分区分配算法是 Kafka Java 客户端提供的分配策略中最复杂的一种，可以通过 partition.assignment.strategy 参数去设置，从 0.11 版本开始引入，目的就是在执行新分配时，尽量在上一次分配结果上少做调整。<br>  其主要实现了以下2个目标：<ol><li>Topic Partition 的分配要尽量均衡。</li><li>当 Rebalance(重分配，后面会详细分析) 发生时，尽量与上一次分配结果保持一致。<br>注意：当两个目标发生冲突的时候，优先保证第一个目标，这样可以使分配更加均匀，其中第一个目标是3种分配策略都尽量去尝试完成的，而第二个目标才是该算法的精髓所在。</li></ol></li></ul><h3 id="偏移量管理-位移提交机制"><a href="#偏移量管理-位移提交机制" class="headerlink" title="偏移量管理 位移提交机制"></a>偏移量管理 位移提交机制</h3><p>对于Kafka Partition而言，每条消息都有一个offset，用来表示消息的位置。存储层面。<br>对于消费者而言，也有一个offset，用来表示消费到分区中某个消息所在的位置，称为消费位移。消费层面。</p><p>在消费者每次调用pull方法的时候，拉取到的是还没有消费过的消费集，要做到这一点，就需要记录上一次消费时候的消费位移，并且这个位移必须做持久化的保存，而不是单单保存在消费者内存中，否则消费者重启后就无法获取之前的消费位移，以及如果新增一个消费者，分区再均衡的时候，新的消费者无法获取消费位移。</p><p>在 Kafka 0.9 版本之前，Consumer 默认将 Offset 保存在 ZooKeeper 中。<br>由于Zookeeper并不适合大批量的频繁写入操作，从 0.9 版本开始，消费者去掉了对ZK的依赖，当启动一个消费者时不再向ZK进行注册，而是由消费者协调器（Group Coordinator）统一管理，消费者已消费消息的偏移量提交会保存在名为**__consumer_offsets**的Kafka内部主题中，以支持高并发的读写。</p><p>将<strong>消费位移做持久化操作的动作</strong>称为<strong>提交</strong>，消费者在消费完消息之后需要执行消费位移的提交。</p><h4 id="consumer-offsets"><a href="#consumer-offsets" class="headerlink" title="__consumer_offsets"></a>__consumer_offsets</h4><p><code>__consumer_offsets</code> 是 kafka 自行创建的，和普通的 topic 相同。它存在的目的之一就是保存 consumer 提交的位移。</p><p>__consumer_offsets 的每条消息格式大致如图所示：<br><img src="/posts/31046/Consumer-%E5%81%8F%E7%A7%BB%E9%87%8F-consumer-offset.png"><br><code>&lt;K, V&gt; = &lt;group.id + topic + 分区号, offset&gt;</code></p><p>考虑到一个 kafka 生成环境中可能有很多 consumer 和 consumer group，如果这些 consumer 同时提交位移，则必将加重 __consumer_offsets 的写入负载，因此 kafka 默认为该 topic 创建了<strong>50个分区</strong>，并且对每个 group.id 做哈希求模运算<strong>Math.abs(groupID.hashCode()) % numPartitions</strong>，从而将负载分散到不同的 __consumer_offsets 分区上。</p><p>一般情况下，当集群中第一次有消费者消费消息时会自动创建 __consumer_offsets。<br>它的<strong>副本因子</strong>受 offsets.topic.replication.factor 参数的约束，默认值为3（注意：该参数的使用限制在0.11.0.0版本发生变化）；<br><strong>分区数</strong>可以通过 offsets.topic.num.partitions 参数设置，默认值为50。</p><h4 id="Kafka位移提交方式"><a href="#Kafka位移提交方式" class="headerlink" title="Kafka位移提交方式"></a>Kafka位移提交方式</h4><ul><li>自动提交<br>  kafka消费者中默认的消费位移提交方式是自动提交，由<code>enable.autto.commit</code>配置，默认每5s提交一次。</li><li>手动提交<ul><li>同步提交</li><li>异步提交</li></ul></li></ul><blockquote><p><strong>位移提交当中涉及到了很多消息重复消费和消息丢失的问题！！！</strong></p></blockquote><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg3MTcxMDgxNA==&amp;action=getalbum&amp;album_id=2147575846151290880&amp;scene=173&amp;from_msgid=2247488847&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect">https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg3MTcxMDgxNA==&amp;action=getalbum&amp;album_id=2147575846151290880&amp;scene=173&amp;from_msgid=2247488847&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect</a></p><h2 id="Kafka-Broker"><a href="#Kafka-Broker" class="headerlink" title="Kafka Broker"></a>Kafka Broker</h2><h3 id="Controller-控制器机制"><a href="#Controller-控制器机制" class="headerlink" title="Controller 控制器机制"></a>Controller 控制器机制</h3><p>每个正常运转的 Kafka 集群，在任意时刻都有且只有一个控制器。<br>Controller 在 Zookeeper 的帮助下管理和协调整个 Kafka 集群。</p><h4 id="Controller-选举"><a href="#Controller-选举" class="headerlink" title="Controller 选举"></a>Controller 选举</h4><p>Kafka 2.8.0 以前用ZooKeeper管理元数据，Controller的选择是在Zookeeper上完成的。</p><p>Kafka 当前选举控制器的规则是：Kafka 集群中第一个启动的 broker 通过在 ZooKeeper 里创建一个临时节点 /controller 让自己成为 controller 控制器。其他 broker 在启动时也会尝试创建这个节点，但是由于这个节点已存在，所以后面想要创建 /controller 节点时就会收到一个节点已存在的异常。然后其他 broker 会在这个控制器上注册一个 ZooKeeper 的 watch 对象，/controller节点发生变化时，其他 broker 就会收到节点变更通知。这种方式可以确保只有一个控制器存在。那么只有单独的节点一定是有个问题的，那就是单点问题。</p><p><strong>Controller Failover</strong><br>如果控制器关闭或者与 ZooKeeper 断开链接，ZooKeeper 上的临时节点就会消失。集群中的其他节点收到 watch 对象发送控制器下线的消息后，其他 broker 节点都会尝试让自己去成为新的控制器。其他节点的创建规则和第一个节点的创建原则一致，都是第一个在 ZooKeeper 里成功创建控制器节点的 broker 会成为新的控制器，那么其他节点就会收到节点已存在的异常，然后在新的控制器节点上再次创建 watch 对象进行监听。</p><h4 id="Controller-作用"><a href="#Controller-作用" class="headerlink" title="Controller 作用"></a>Controller 作用</h4><ol><li>Topic管理<br> 控制器帮助完成对Kafka主题的创建、删除以及分区增加的操作</li><li>分区重分配</li><li>Partition Leader选举</li><li>集群Broker管理<br> 新增Broker、Broker主动关闭、Broker故障</li></ol><h3 id="日志存储-分区分段保存"><a href="#日志存储-分区分段保存" class="headerlink" title="日志存储 分区分段保存"></a>日志存储 分区分段保存</h3><p>Kafka中的消息是以主题为基本单位进行归类的，每个主题在逻辑上相互独立。<br>每个主题又可以分为一个或多个分区，在不考虑副本的情况下，一个分区会对应一个日志。<br>但设计者考虑到随着时间推移，日志文件会不断扩大，因此为了防止Log过大，设计者引入了日志分段（LogSegment）的概念，将Log切分为多个LogSegment，便于后续的消息维护和清理工作。<br><img src="/posts/31046/broker-%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8.png" alt="主题、分区、Log、LogSegment"></p><h4 id="LogSegment"><a href="#LogSegment" class="headerlink" title="LogSegment"></a>LogSegment</h4><p>在Kafka中，每个Log对象又可以划分为多个LogSegment文件，每个LogSegment文件包括一个日志数据文件和两个索引文件（偏移量索引文件和消息时间戳索引文件）。</p><p>其中，每个LogSegment中的日志数据文件大小均相等（该日志数据文件的大小可以通过在Kafka Broker的<code>config/server.properties</code>配置文件的中的<code>「log.segment.bytes」</code>进行设置，默认为<strong>1G</strong>大小（1073741824字节），在顺序写入消息时如果超出该设定的阈值，将会创建一组新的日志数据和索引文件）。</p><p>index, log, snapshot, timeindex 文件以当前 Segment 的第一条消息的 Offset 命名。<br>“.index” 文件存储大量的索引信息。<br>“.log” 文件存储大量的数据，索引文件中的元数据指向对应数据文件中 Message 的物理偏移量。</p><p><img src="/posts/31046/broker-%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8-logsegment.png"></p><h3 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h3><ul><li><strong>AR（Assigned Replicas）</strong>：分区中的所有副本统称为AR。<br>  所有消息会先发送到leader副本，然后follower副本才能从leader中拉取消息进行同步。<br>  但是在同步期间，follower对于leader而言会有一定程度的滞后，这个时候follower和leader并非完全同步状态</li><li><strong>OSR（Out Sync Replicas）</strong>：follower副本与leader副本没有完全同步或滞后的副本集合</li><li><strong>ISR（In Sync Replicas）</strong>：AR中的一个子集，ISR中的副本都是与leader保持完全同步的副本<br>  如果某个在ISR中的follower副本落后于leader副本太多，则会被从ISR中移除，否则如果完全同步，会从OSR中移至ISR集合。<br>  在默认情况下，当leader副本发生故障时，只有在ISR集合中的follower副本才有资格被选举为新leader，而OSR中的副本没有机会（可以通过unclean.leader.election.enable进行配置）。</li><li><strong>HW（High Watermark）</strong>：高水位<br>  它标识了一个特定的消息偏移量（offset），消费者只能拉取到这个水位 offset 之前的消息</li><li><strong>LEO（Log End Offset）</strong>：标识当前日志文件中下一条待写入的消息的offset<br>  HW 之前的消息数据对消费者是可见的, 属于 commited 状态；<br>  HW 之后的消息数据对消费者是不可见的，属于 uncommited 状态。</li></ul><h4 id="HW和LEO更新机制"><a href="#HW和LEO更新机制" class="headerlink" title="HW和LEO更新机制"></a>HW和LEO更新机制</h4><p><img src="/posts/31046/broker-replica-hw&leo.png"><br>每个 kafka 副本对象都有两个重要的属性：LEO 和 HW。注意是所有的副本（leader + Follower）。<br>但实际上，在 Leader 副本所在的 Broker 上，还保存了其他 Follower 副本的 LEO 值。<br>Kafka之所以要在Leader副本上保存这些所有 Follower LEO, 就是为了帮助 Leader 副本确定其高水位，也就是分区高水位。</p><p><strong>1. follower副本何时更新LEO？</strong><br><strong>2. follower副本何时更新HW？</strong><br><strong>3. leader副本何时更新LEO？</strong><br>leader写log时就会自动地更新它自己的LEO值。<br><strong>4. leader副本何时更新HW？</strong></p><ol><li>producer向leader副本写入消息时：因为写入消息会更新leader的LEO，故有必要再查看下HW值是否也需要修改</li><li>leader处理follower FETCH请求时：当leader处理follower的FETCH请求时首先会从底层的log读取数据，之后会尝试更新分区HW值</li></ol><p>当尝试确定分区HW时，它会选出所有满足条件的副本，比较它们的LEO(当然也包括leader自己的LEO)，并选择最小的LEO值作为HW值。<br>这里的满足条件主要是指副本只需满足以下两个条件之一即可：</p><ol><li>处于ISR中</li><li>副本LEO落后于leader LEO的时长不大于 replica.lag.time.max.ms 参数值(默认是10s)</li></ol><h4 id="LeaderEpoch机制"><a href="#LeaderEpoch机制" class="headerlink" title="LeaderEpoch机制"></a>LeaderEpoch机制</h4><p>Kafka 0.11 引入了leader epoch来取代HW值。</p><blockquote><p>很多原因都可能造成 Leader 和 Follower 保存的消息序列不一致，比如程序 Bug、网络问题等。这是很严重的错误，必须要完全规避。<br>之前确保一致性的主要手段是高水位机制 High watermark，但高水位值无法保证 Leader 连续变更场景下的数据一致性。<br>因此，社区在 0.11 版本引入了 Leader Epoch 机制，来规避因 HW 更新错配导致的各种不一致问题。</p></blockquote><p>Leader端多开辟一段内存区域专门保存leader的epoch信息。<br>所谓leader epoch实际上是一对值：<code>&lt;epoch, offset&gt;</code></p><ul><li>epoch表示leader的版本号，从0开始，当leader变更过1次时epoch就会+1。</li><li>offset则对应于该epoch版本的leader写入第一条消息的offset。</li></ul><p>Kafka Broker 会在内存中为每个分区都缓存 Leader Epoch 数据，同时它还会定期地将这些信息持久化到一个 checkpoint 文件中。<br>当 Leader Partition 写入消息到磁盘时，Broker 会尝试更新这部分缓存。<br>如果该 Leader 是首次写入消息，那么 Broker 会向缓存中增加一个 Leader Epoch 条目，否则就不做更新。<br>这样，每次有 Leader 变更时，新的 Leader 副本会查询这部分缓存，取出对应的 Leader Epoch 的起始位移，以避免数据丢失和不一致的情况。</p><p><strong>规避数据丢失</strong><br><img src="/posts/31046/broker-leaderEpoch-%E8%A7%84%E9%81%BF%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1.png"><br><strong>规避数据不一致</strong><br><img src="/posts/31046/broker-leaderEpoch-%E8%A7%84%E9%81%BF%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4.png"></p><h2 id="Kafka-网络通信设计"><a href="#Kafka-网络通信设计" class="headerlink" title="Kafka 网络通信设计"></a>Kafka 网络通信设计</h2><p>KAFKA 并没有使用现有的网络框架比如 Netty 去作为自己通信的底座，而是基于 NIO 自行研发了一套适合 KAFKA 自身的网络框架模型。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;mid=2247497246&amp;idx=2&amp;sn=4d700a976a3c531bd77aab58f00bcb83&amp;chksm=cef8df2ff98f563949117c8055e7ff271346b84d12b698f7690181dca16ea9e679a9939a3f46&amp;scene=178&amp;cur_album_id=2147575846151290880#rd">https://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;mid=2247497246&amp;idx=2&amp;sn=4d700a976a3c531bd77aab58f00bcb83&amp;chksm=cef8df2ff98f563949117c8055e7ff271346b84d12b698f7690181dca16ea9e679a9939a3f46&amp;scene=178&amp;cur_album_id=2147575846151290880#rd</a></p><p><img src="/posts/31046/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84-%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p><h2 id="版本演进"><a href="#版本演进" class="headerlink" title="版本演进"></a>版本演进</h2><h3 id="0-7-x"><a href="#0-7-x" class="headerlink" title="0.7.x"></a>0.7.x</h3><p>只提供最基础的消息队列功能。</p><h3 id="0-8-x"><a href="#0-8-x" class="headerlink" title="0.8.x"></a>0.8.x</h3><ul><li>Kafka 0.8.0增加了副本机制<br>  至此 Kafka 成为了一个真正意义上完备的分布式高可用消息队列解决方案。</li><li>Kafka 0.8.2.0引入了新版本Producer API</li></ul><h3 id="0-9-x"><a href="#0-9-x" class="headerlink" title="0.9.x"></a>0.9.x</h3><p>Kafka 0.9 是一个重大的版本迭代，增加了非常多的新特性，主要体现在三个方面：</p><ul><li>安全方面<br>  在0.9.0之前，Kafka安全方面的考虑几乎为0。<br>  Kafka 0.9.0 在安全认证、授权管理、数据加密等方面都得到了支持，包括支持Kerberos等。</li><li>新版本Consumer APi<br>  Kafka 0.9.0 重写并提供了新版消费端API，使用方式也是从连接Zookeeper切到了连接Broker，但是此时新版Consumer API也不太稳定、存在不少Bug，生产使用可能会比较痛苦；<br>  而0.9.0版本的Producer API已经比较稳定了，生产使用问题不大。</li><li>Kafka Connect<br>  Kafka 0.9.0 引入了新的组件 Kafka Connect ，用于实现Kafka与其他外部系统之间的数据抽取。</li></ul><h3 id="0-10-x"><a href="#0-10-x" class="headerlink" title="0.10.x"></a>0.10.x</h3><p>Kafka 0.10 是一个重要的大版本，因为Kafka 0.10.0.0 引入了 Kafka Streams，使得Kafka不再仅是一个消息引擎，而是往一个分布式流处理平台方向发展。<br>0.10 大版本包含两个小版本：0.10.1 和 0.10.2，它们的主要功能变更都是在 Kafka Streams 组件上。</p><p>值得一提的是，自 0.10.2.2 版本起，新版本 Consumer API 已经比较稳定了，而且 Producer API 的性能也得到了提升，因此对于使用 0.10.x 大版本的用户，建议使用或升级到 Kafka 0.10.2.2 版本。</p><h3 id="0-11-x"><a href="#0-11-x" class="headerlink" title="0.11.x"></a>0.11.x</h3><p>Kafka 0.11 是一个里程碑式的大版本，主要有两个大的变更。</p><ol><li>Kafka从这个版本开始支持Exactly-Once 语义即精准一次语义<br> 主要是实现了Producer端的消息幂等性，以及事务特性，这对于Kafka流式处理具有非常大的意义。</li><li>Kafka消息格式的重构<br> Kafka 0.11主要为了实现Producer幂等性与事务特性，重构了投递消息的数据结构。<br> 这一点非常值得关注，因为Kafka 0.11之后的消息格式发生了变化，所以我们要特别注意Kafka不同版本间消息格式不兼容的问题。</li></ol><h3 id="1-x"><a href="#1-x" class="headerlink" title="1.x"></a>1.x</h3><p>Kafka 1.x 更多的是Kafka Streams方面的改进，以及Kafka Connect的改进与功能完善等。<br>但仍有两个重要特性：</p><ol><li>Kafka 1.0.0实现了磁盘的故障转移<br> 当Broker的某一块磁盘损坏时数据会自动转移到其他正常的磁盘上，Broker还会正常工作，这在之前版本中则会直接导致Broker宕机，因此Kafka的可用性与可靠性得到了提升</li><li>Kafka 1.1.0开始支持副本跨路径迁移<br> 分区副本可以在同一Broker不同磁盘目录间进行移动，这对于磁盘的负载均衡非常有意义。</li></ol><h3 id="2-x"><a href="#2-x" class="headerlink" title="2.x"></a>2.x</h3><p>Kafka 2.x 更多的也是Kafka Streams、Connect方面的性能提升与功能完善，以及安全方面的增强等。</p><ul><li>Kafka 2.1.0开始支持ZStandard的压缩方式，提升了消息的压缩比，显著减少了磁盘空间与网络io消耗。</li><li>Kafka 2.8.0 用自管理的Quorum代替ZooKeeper管理元数据</li></ul><h4 id="为什么Kafka在2-8版本中会“抛弃”Zookeeper"><a href="#为什么Kafka在2-8版本中会“抛弃”Zookeeper" class="headerlink" title="为什么Kafka在2.8版本中会“抛弃”Zookeeper"></a>为什么Kafka在2.8版本中会“抛弃”Zookeeper</h4><h3 id="3-x"><a href="#3-x" class="headerlink" title="3.x"></a>3.x</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列—区别/对比/选型</title>
      <link href="/posts/34057.html"/>
      <url>/posts/34057.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/34057/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="消息队列发展史"><br><img src="/posts/34057/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.jpeg" alt="主流消息队列对比"></p><ul><li>什么是消息队列</li><li>消息队列的应用场景</li><li>消息队列技术选型，Kafka还是RocketMQ，还是RabbitMQ</li><li>消息中间件如何做到高可用？</li><li>消息队列如何解决<strong>消息丢失</strong>问题</li><li>消息队列有可能发生<strong>重复消费</strong>吗？如何幂等处理？</li><li>如何处理消息队列的<strong>消息积压</strong>问题</li><li>消息队列如何保证消息的顺序性。</li><li>如何保证数据一致性，事务消息如何实现</li><li>如果让你写一个消息队列，该如何进行架构设计？</li></ul><h2 id="消息队列应用场景"><a href="#消息队列应用场景" class="headerlink" title="消息队列应用场景"></a>消息队列应用场景</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><h3 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h3><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><h3 id="引入消息队列的劣势分析"><a href="#引入消息队列的劣势分析" class="headerlink" title="引入消息队列的劣势分析"></a>引入消息队列的劣势分析</h3><p>引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。<br>一个使用了MQ的项目，如果连MQ的缺点都没有考虑过，就把MQ引进去了，那就会给自己的项目带来风险。</p><ul><li>系统可用性降低<br>  系统的可用性会受消息队列的可用性影响。</li><li>系统复杂度提高<br>  引入消息队列后，要多考虑很多方面的问题。<br>  消息丢失、消息重复消息、消息可靠传输、消息积压、数据一致性等等。<br>  需要考虑的东西多了，系统复杂性随之增加。</li><li>一致性问题</li></ul><h2 id="消息中间件基本架构"><a href="#消息中间件基本架构" class="headerlink" title="消息中间件基本架构"></a>消息中间件基本架构</h2><h3 id="架构组成"><a href="#架构组成" class="headerlink" title="架构组成"></a>架构组成</h3><ul><li>Producer 生产者，消息的产生方，生产者会将消息发送到消息队列。</li><li>queue 消息队列，接受并存储生产者的消息。</li><li>Consumer 消费者，消费消息队列中的消息。</li></ul><h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><h4 id="点对点模式（一对一）"><a href="#点对点模式（一对一）" class="headerlink" title="点对点模式（一对一）"></a>点对点模式（一对一）</h4><p><img src="/posts/34057/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%A8%A1%E5%9E%8B-%E7%82%B9%E5%AF%B9%E7%82%B9.png"></p><p>早期的消息队列，就是按照 “队列” 的数据结构来设计的，生产者发消息是入队操作，消费者收消息就是出队动作，服务单存放消息的容器就是 “队列”。</p><p>消费者之间是竞争关系，如果想要将一份消息分发给多个消费者，要求每个消费者都能收到全量的消息，单个队列就无法满足，一个比较笨的解决方法就是为每一个消费者创建一个消息队列，让生产者发送多份。<br>但是这样缺点比较明显：一是一份数据复制多份，浪费资源，二是生产者必须知道有多少个消费者，违背了 “解耦” 的设计初衷。</p><h4 id="发布-订阅模式（一对多）"><a href="#发布-订阅模式（一对多）" class="headerlink" title="发布-订阅模式（一对多）"></a>发布-订阅模式（一对多）</h4><p><img src="/posts/34057/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%A8%A1%E5%9E%8B-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.png"></p><p>在发布-订阅模型中，消息的发送者称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。</p><p><code>发布-订阅模型</code>与<code>队列模型</code>之间最大的区别就是 <strong>一份消息数据能不能被消费多次的问题</strong> 。<br>消费者消费完消息后，消息不会被删除，消息会存储一段时间，这种模式下的消息会被所有订阅该主题的消费者消费。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li>RabbitMQ<br>  如果消息队列不是将要构建系统的重点，对消息队列功能和性能没有很高的要求，只需要一个快速上手易于维护的消息队列，建议使用 RabbitMQ。</li><li>RocketMQ<br>  如果系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，需要低延迟和高稳定性，建议使用 RocketMQ。</li><li>Kafka<ul><li>优点：兼容性极好、设计上大量使用了批量和异步的思想，有超高的性能</li><li>缺点：由于 “先攒一波再一起处理” 的设计，时延较高，不太适合在线业务场景</li><li>如果需要处理海量的消息，像收集日志、监控信息或是埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那 Kafka 是最适合的消息队列。</li></ul></li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="1-高可用"><a href="#1-高可用" class="headerlink" title="1. 高可用"></a>1. 高可用</h3><p>Kafka基于<strong>Partition分区</strong>和<strong>Replica副本</strong>来保证高可用。</p><p>Kafka 集群由若干个 Broker 组成，Topic 由若干个 Partition 组成，每个 Partition 可存在不同的 Broker 上。可以这样说，一个 Topic 的数据，分散在多个机器上，即每个机器上都存放一部分数据。</p><ul><li>Kafka 0.8以前<br>  Kafka 0.8 以前是没有高可用机制的。<br>  假设一个 Topic，由 3 个 Partiton 组成。3 个 Partition 在不同机器上，如果其中某一台机器宕掉了，则 Topic 的部分数据就丢失了。</li><li>Kafka 0.8以后<br>  Kafka 0.8 以后，通过副本机制来实现高可用。</li></ul><h3 id="2-消息丢失"><a href="#2-消息丢失" class="headerlink" title="2. 消息丢失"></a>2. 消息丢失</h3><p>经过参数优化配置，能够做到零丢失。</p><h4 id="生产阶段：Producer丢失数据"><a href="#生产阶段：Producer丢失数据" class="headerlink" title="生产阶段：Producer丢失数据"></a>生产阶段：Producer丢失数据</h4><p>如果 Producer 端设置了 acks=all，则不会丢失数据。Leader 在所有的 Follower 都同步到了消息之后，才认为本次写成功。如果没满足这个条件，生产者会进行无限次重试。</p><p>在生产阶段，需要捕获消息发送的错误，并重发消息。</p><h4 id="存储阶段：Broker丢失数据"><a href="#存储阶段：Broker丢失数据" class="headerlink" title="存储阶段：Broker丢失数据"></a>存储阶段：Broker丢失数据</h4><p>比较常见的一个场景：Kafka 某个 Broker 宕机，然后重新选举新的 Leader ，但此时其他的 Follower 部分数据尚未同步，结果此时 Leader 挂了(宕机的Broker就是该分区的leader)，然后选举某个 Follower 成 Leader，丢失一部分数据。</p><p>一般设置如下 4 个参数：</p><ul><li>Topic 设置<code>replication.factor</code>参数<br>  参数值必须大于 1，要求每个 Partition 必须有至少 2 个副本。</li><li>Kafka 服务端设置 <code>min.insync.replicas</code> 参数<br>  参数值必须大于 1，要求每个 Partition 必须有至少 2 个副本。</li><li>Producer 设置 <code>acks=all</code><br>  要求每条数据，必须是写入所有副本，才认为写成功。</li><li>Producer 端设置 <code>retries=MAX</code><br>  MAX 即是一个超级大的数字，表示无限次重试。<code>retries=MAX</code>要求一旦写入数据失败，就无限重试。</li></ul><h4 id="消费阶段：Consumer丢失数据"><a href="#消费阶段：Consumer丢失数据" class="headerlink" title="消费阶段：Consumer丢失数据"></a>消费阶段：Consumer丢失数据</h4><p>默认情况下，Kafka 会自动提交 Offset，Kafka 认为 Consumer 已经处理消息了，但是 Consumer 可能在处理消息的过程中挂掉了。重启系统后，Consumer 会根据提交的 Offset 进行消费，也就丢失了一部分数据。</p><p>解决：关闭自动提交 Offset，在处理完之后自己手动提交 Offset，就可以保证数据不会丢失。但可能会存在消息重复消费问题。 </p><h3 id="3-重复消费"><a href="#3-重复消费" class="headerlink" title="3. 重复消费"></a>3. 重复消费</h3><h4 id="消费者相关参数"><a href="#消费者相关参数" class="headerlink" title="消费者相关参数"></a>消费者相关参数</h4><ul><li><code>enable.auto.commit</code>：表示消费者会周期性自动提交消费的offset。默认值true。</li><li><code>auto.commit.interval.ms</code>：在<code>enable.auto.commit为</code>true的情况下，自动提交的间隔。默认值5秒。</li><li><code>max.poll.records</code>：单次消费者拉取的最大数据条数，默认值500。</li><li><code>max.poll.interval.ms</code>：表示若在阈值时间之内消费者没有消费完上一次poll的消息，consumer client会主动向 coordinator 发起LeaveGroup请求，触发Rebalance；然后consumer重新发送JoinGroup请求。</li><li><code>session.timeout.ms</code>：group Coordinator 检测consumer发生崩溃所需的时间。在这个时间内如果Coordinator未收到Consumer的任何消息，那Coordinator就认为Consumer挂了。默认值10秒。</li><li><code>heartbeat.interval.ms</code>：标识Consumer给Coordinator发一个心跳包的时间间隔。heartbeat.interval.ms越小，发的心跳包越多。默认值3秒。</li><li>Group Coordinator<br>  对于每一个Consumer Group，Kafka集群为其从Broker集群中选择一个Broker作为其Coordinator。Coordinator主要做两件事：<ol><li>维持Group成员的组成。这包括加入新的成员，检测成员的存活性，清除不再存活的成员。</li><li>协调Group成员的行为。</li></ol></li></ul><h4 id="重复消费的原因"><a href="#重复消费的原因" class="headerlink" title="重复消费的原因"></a>重复消费的原因</h4><ul><li>原因1：消费者宕机、重启或者被强行kill进程，导致消费者消费的offset没有提交。</li><li>原因2：设置<code>enable.auto.commit</code>为true，如果在关闭消费者进程之前，取消了消费者的订阅，则有可能部分offset没提交，下次重启会重复消费。</li><li>原因3：消费后的数据，当offset还没有提交时，Partition就断开连接。比如，通常会遇到消费的数据，处理很耗时，导致超过了Kafka的<code>session timeout.ms</code>时间，那么就会触发reblance重平衡，此时可能存在消费者offset没提交，会导致重平衡后重复消费。</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>保证消费消息的幂等性</strong>。</p><blockquote><p>什么是幂等性，它本来是一个数学上的概念，如果函数f(x) 满足 **f(f(x)) = f(x)**，则函数满足幂等性。<br>这个概念被拓展到计算机领域，被用来描述一个操作、方法或者服务，一个幂等操作的特点是 其任意多次执行所产生的影响均与一次执行的影响相同。<br>一个幂等的方法，使用同样的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的。</p></blockquote><p><strong>如何实现接口的幂等性？</strong></p><h3 id="4-消息积压"><a href="#4-消息积压" class="headerlink" title="4. 消息积压"></a>4. 消息积压</h3><p>使用消息队列的时候，大部分的性能问题都出现在消费端，如果消费的速度跟不上发送端生产消息的速度，就会造成消息积压。<br>如果这种性能倒挂是暂时的，问题不大，如果消费速度一直比生产速度慢，时间长了，整个系统就会出现问题，要么消息队列的存储被填满无法提供服务，要么消息丢失，这对于整个系统来说都是严重故障。</p><p>一定要<strong>保证消费端的消费性能要高于生产端的发送性能</strong>，这样的系统才能健康的持续运行。<br>消费端的性能优化除了<strong>优化消费业务逻辑</strong>以外，也可以通过<strong>水平扩容，增加消费端的并发数</strong>来提升总体的消费性能。<br>特别需要注意的是，<strong>在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（队列）数量，确保 Consumer 的实例数和分区数量是相等的</strong>。</p><h3 id="5-顺序消费"><a href="#5-顺序消费" class="headerlink" title="5. 顺序消费"></a>5. 顺序消费</h3><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构</title>
      <link href="/posts/49043.html"/>
      <url>/posts/49043.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/49043/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"><br>Redis的每种对象其实都由对象结构(redisObject)与对应编码的数据结构组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。</p><p>从一下两个角度来研究底层：</p><ul><li>对象设计机制: 对象结构(redisObject)</li><li>编码类型和底层数据结构: 对应编码的数据结构</li></ul><h2 id="对象机制"><a href="#对象机制" class="headerlink" title="对象机制"></a>对象机制</h2><h3 id="为什么Redis会设计redisObject对象"><a href="#为什么Redis会设计redisObject对象" class="headerlink" title="为什么Redis会设计redisObject对象"></a>为什么Redis会设计redisObject对象</h3><ol><li>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式。</li><li>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理.</li></ol><p>为了解决以上问题, Redis 构建了自己的类型系统, 这个系统的主要功能包括:</p><ul><li>redisObject 对象.</li><li>基于 redisObject 对象的类型检查.</li><li>基于 redisObject 对象的显式多态函数.</li><li>对 redisObject 进行分配、共享和销毁的机制.</li></ul><h3 id="redisObject数据结构"><a href="#redisObject数据结构" class="headerlink" title="redisObject数据结构"></a>redisObject数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">// LRU_BITS: 24</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向底层数据结构实例</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li>type记录了对象所保存的值的类型  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0 <span class="comment">// 字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1 <span class="comment">// 列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2 <span class="comment">// 集合</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3 <span class="comment">// 有序集</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4 <span class="comment">// 哈希表</span></span></span><br></pre></td></tr></table></figure></li><li>encoding记录了对象所保存的值的编码  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对象编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* 注意：版本2.6后不再使用. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* 注意：不再使用了，旧版本2.x中String的底层之一. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure></li><li>ptr是一个指针，指向实际保存值的数据结构。<br>  这个数据结构由type和encoding属性决定。<br>  举个例子，如果一个redisObject 的type 属性为<code>OBJ_LIST</code> ，encoding 属性为<code>OBJ_ENCODING_QUICKLIST</code>，那么这个对象就是一个Redis 列表（List），它的值保存在一个QuickList的数据结构内，而ptr 指针就指向quicklist的对象</li><li>lru属性: 记录了对象最后一次被命令程序访问的时间</li></ul><h3 id="命令的类型检查和多态"><a href="#命令的类型检查和多态" class="headerlink" title="命令的类型检查和多态"></a>命令的类型检查和多态</h3><blockquote><p>那么Redis是如何处理一条命令的呢？</p></blockquote><p>当执行一个处理数据类型命令的时候，redis执行以下步骤</p><ul><li>根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；</li><li>检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；</li><li>根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；</li><li>返回数据结构的操作结果作为命令的返回值。</li></ul><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><ul><li>简单动态字符串 - sds</li><li>压缩列表 - ZipList</li><li>快表 - QuickList</li><li>字典/哈希表 - Dict</li><li>整数集 - IntSet</li><li>跳表 - ZSkipList</li></ul><h3 id="简单动态字符串-sds"><a href="#简单动态字符串-sds" class="headerlink" title="简单动态字符串 - sds"></a>简单动态字符串 - sds</h3><blockquote><p>Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为<code>简单动态字符串（simple dynamic string,SDS）</code>的抽象类型，并将 SDS 作为 Redis的默认字符串表示。<br>这是一种用于存储二进制数据的一种结构, 具有动态扩容的特点. 其实现位于src/sds.h与src/sds.c中。</p></blockquote><h4 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h4><p><img src="/posts/49043/redis-sds.png"><br>其中sdshdr是头部, buf是真实存储用户数据的地方。<br>另外注意, 从命名上能看出来, 这个数据结构除了能存储二进制数据, 显然是用于设计作为字符串使用的, 所以在buf中, 用户数据后总跟着一个\0. 即图中 “数据” + “\0” 是为所谓的buf。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sds.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的头部, 分别如下:<br><img src="/posts/49043/redis-sds-header.png"></p><ul><li>len 保存了SDS保存字符串的长度</li><li>buf[] 数组用来保存字符串的每个元素</li><li>alloc 分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数</li><li>flags 始终为一字节, 以低三位标示着头部的类型, 高5位未使用</li></ul><h4 id="为什么使用SDS"><a href="#为什么使用SDS" class="headerlink" title="为什么使用SDS"></a>为什么使用SDS</h4><p>为什么不使用C语言字符串实现，而是使用 SDS呢？这样实现有什么好处？</p><ul><li><p>常数复杂度获取字符串长度<br>  由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。<br>  而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。<br>  通过 strlen key 命令可以获取 key 的字符串长度。</p></li><li><p>杜绝缓冲区溢出<br>  我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。<br>  而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p></li><li><p>减少修改字符串的内存重新分配次数<br>  C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。<br>  而对于SDS，由于len属性和alloc属性的存在，对于修改字符串SDS实现了<code>空间预分配</code>和<code>惰性空间释放</code>两种策略：</p><ol><li><p>空间预分配<br> 对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p><p> 当执行追加操作时，比如现在给<strong>key=‘Hello World’</strong>的字符串后追加 ‘ again!’ 则这时的len=18，free由0变成了18，此时的**buf=’Hello World again!\0………………..’(.表示空格)**，也就是buf的内存空间是18+18+1=37个字节，其中‘\0’占1个字节。redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，就无须在进行空间分配了。<br> 在Redis 6.0版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p></li><li><p>惰性空间释放<br> 对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 alloc 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p></li></ol></li><li><p>二进制安全<br>  因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；<br>  而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p></li><li><p>兼容部分 C 字符串函数<br>  虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。</p></li></ul><h3 id="压缩列表-ZipList"><a href="#压缩列表-ZipList" class="headerlink" title="压缩列表 - ZipList"></a>压缩列表 - ZipList</h3><blockquote><p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。<br>它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。<br>它能在O(1)的时间复杂度下完成list两端的push和pop操作。<br>但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p></blockquote><h4 id="ziplist结构"><a href="#ziplist结构" class="headerlink" title="ziplist结构"></a>ziplist结构</h4><p><img src="/posts/49043/redis-ziplist-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><p>整个ziplist在内存中的存储格式如下：<br><img src="/posts/49043/redis-ziplist-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png"></p><ul><li><strong>zlbytes</strong>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数。</li><li><strong>zltail</strong>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量。<br>  用于快速定位最后一个entry, 以快速完成pop等操作。</li><li><strong>zllen</strong>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量。<br>  这个值只占2bytes（16位）。<br>  如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值。<br>  若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到。</li><li><strong>zlend</strong>是一个终止字节, 其值为全F, 即0xff。<br>   ziplist保证任何情况下, 一个entry的首字节都不会是255。</li></ul><h4 id="ziplist-entry结构"><a href="#ziplist-entry结构" class="headerlink" title="ziplist-entry结构"></a>ziplist-entry结构</h4><p><img src="/posts/49043/redis-ziplist-entry%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><ul><li>第一种情况：一般结构<code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code><ul><li><strong>prevlen</strong>：前一个entry的大小；</li><li><strong>encoding</strong>：不同的情况下值不同，用于表示当前entry的类型和长度；</li><li><strong>entry-data</strong>：真是用于存储entry表示的数据；</li></ul></li><li>第二种情况：<code>&lt;prevlen&gt; &lt;encoding&gt;</code><br>  在entry中存储的是int类型时，encoding和entry-data会合并在encoding中表示，此时没有entry-data字段。<br>  redis中，在存储数据时，会先尝试将string转换成int存储，节省空间。</li></ul><p><strong>为什么ZipList特别省内存</strong></p><blockquote><p>只有理解上面的Entry结构，我们才会真正理解ZipList为什么是特别节省内存的数据结构。</p></blockquote><p>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，所以增加encoding字段，针对不同的encoding来细化存储大小。<br>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，所以增加了prelen字段。</p><h3 id="快表-QuickList"><a href="#快表-QuickList" class="headerlink" title="快表 - QuickList"></a>快表 - QuickList</h3><blockquote><p>quicklist这个结构是Redis在3.2版本后新加的, 之前的版本是list(即linkedlist)， 用于String数据类型中。<br>它是一种以ziplist为结点的双端链表结构。<br>宏观上, quicklist是一个链表；微观上, 链表中的每个结点都是一个ziplist。</p></blockquote><p><a href="redis-quicklist-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></a></p><h3 id="字典-哈希表-Dict"><a href="#字典-哈希表-Dict" class="headerlink" title="字典/哈希表 - Dict"></a>字典/哈希表 - Dict</h3><blockquote><p>本质上就是哈希表</p></blockquote><p>哈希表结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于 size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"> </span><br><span class="line">&#125;dictht</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，</span></span><br><span class="line"><span class="comment">// dictEntry 结构定义如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">     <span class="comment">//键</span></span><br><span class="line">     <span class="keyword">void</span> *key;</span><br><span class="line">     <span class="comment">//值</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">          <span class="keyword">void</span> *val;</span><br><span class="line">          uint64_tu64;</span><br><span class="line">          int64_ts64;</span><br><span class="line">     &#125;v;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry</span><br></pre></td></tr></table></figure><p><a href="redis-dictht%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"></a></p><h3 id="整数集-IntSet"><a href="#整数集-IntSet" class="headerlink" title="整数集 - IntSet"></a>整数集 - IntSet</h3><blockquote><p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p></blockquote><h3 id="跳表-ZSkipList"><a href="#跳表-ZSkipList" class="headerlink" title="跳表 - ZSkipList"></a>跳表 - ZSkipList</h3><blockquote><p>跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。<br>跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。<br>跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p></blockquote><p>思考：<strong>为什么用跳跃表实现，而不是平衡树或者哈希表？</strong></p><h4 id="什么是跳跃表"><a href="#什么是跳跃表" class="headerlink" title="什么是跳跃表"></a>什么是跳跃表</h4><p>跳表其实就是一种可以进行二分查找的有序链表。<br>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找，将查找的时间复杂度从O(N)降到O(logN)。</p><h4 id="Redis-zskiplist的设计"><a href="#Redis-zskiplist的设计" class="headerlink" title="Redis zskiplist的设计"></a>Redis zskiplist的设计</h4><p>redis跳跃表并没有在单独的类（比如skplist.c）中定义，而是其定义在server.h中, 如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><a href="redis-zskiplist-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></a><br>zskiplist的核心设计要点</p><ul><li>头节点不持有任何数据, 且其level[]的长度为32</li><li>每个结点<ul><li><strong>ele</strong>字段，持有数据，是sds类型。</li><li><strong>score</strong>字段，其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列。</li><li><strong>backward</strong>指针，这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点。</li><li><strong>level</strong>字段, 用以记录所有结点(除过头节点外)；每个结点中最多持有32个zskiplistLevel结构，实际数量在结点创建时，按幂次定律随机生成(不超过32)。<br>每个zskiplistLevel中有两个字段：<ul><li><strong>forward</strong>字段指向比自己得分高的某个结点(不一定是紧邻的)，并且，若当前zskiplistLevel实例在level[]中的索引为X，则其forward字段指向的结点, 其level[]字段的容量至少是X+1。这也是上图中, 为什么forward指针总是画的水平的原因。</li><li><strong>span</strong>字段代表forward字段指向的结点，距离当前结点的距离。紧邻的两个结点之间的距离定义为1。</li></ul></li></ul></li></ul><h2 id="Redis对象和底层结构对应关系"><a href="#Redis对象和底层结构对应关系" class="headerlink" title="Redis对象和底层结构对应关系"></a>Redis对象和底层结构对应关系</h2><h3 id="字符串对象-string"><a href="#字符串对象-string" class="headerlink" title="字符串对象 string"></a>字符串对象 string</h3><blockquote><p>字符串是Redis最基本的数据类型，不仅所有key都是字符串类型，其它几种数据类型构成的元素也是字符串。<br>注意字符串的长度不能超过512M。</p></blockquote><p><strong>编码</strong><br>字符串对象的编码可以是<code>int，raw或者embstr</code>。</p><ul><li>int 编码：保存的是可以用 long 类型表示的整数值。</li><li>embstr 编码：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li><li>raw 编码：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li></ul><p><strong>内存布局</strong><br>字符串对象支持三种编码方式: RAW, INT, EMBSTR, 三种方式的内存布局分别如下:<br><img src="/posts/49043/redis%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB-string-encode.png"><br><strong>raw 和 embstr 的区别</strong></p><p><strong>编码的转换</strong><br>当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。</p><p>对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</p><h3 id="列表对象-list"><a href="#列表对象-list" class="headerlink" title="列表对象 list"></a>列表对象 list</h3><blockquote><p>list 列表，它是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际上是个链表结构。</p></blockquote><p><strong>编码</strong><br>列表对象的编码是<code>quicklist</code>。 (之前版本中有linked和ziplist这两种编码。进一步的, 目前Redis定义的10个对象编码方式宏名中, 有两个被完全闲置了, 分别是: OBJ_ENCODING_ZIPMAP与OBJ_ENCODING_LINKEDLIST。 从Redis的演进历史上来看, 前者是后续可能会得到支持的编码值（代码还在）, 后者则应该是被彻底淘汰了)<br><strong>内存布局</strong><br><img src="/posts/49043/redis%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB-list-quicklist.png"></p><h3 id="哈希对象-hash"><a href="#哈希对象-hash" class="headerlink" title="哈希对象 hash"></a>哈希对象 hash</h3><p>哈希对象的键是一个字符串类型，值是一个键值对集合。<br><strong>编码</strong><br>哈希对象的编码可以是 ziplist 或者 hashtable；对应的底层实现有两种，一种是ziplist，一种是dict。<br><strong>编码的转换</strong><br>当同时满足下面两个条件时，使用ziplist（压缩列表）编码：</p><ol><li>列表保存元素个数小于512个</li><li>每个元素长度小于64字节</li></ol><p>不能满足这两个条件的时候使用 hashtable 编码。</p><h3 id="集合对象-set"><a href="#集合对象-set" class="headerlink" title="集合对象 set"></a>集合对象 set</h3><p>集合对象 set 是 string 类型（整数也会转换成string类型进行存储）的无序集合。<br>注意集合和列表的区别：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。<br><strong>编码</strong><br>集合对象的编码可以是 intset 或者 hashtable; 底层实现有两种, 分别是intset和dict。 </p><p>显然当使用intset作为底层实现的数据结构时, 集合中存储的只能是数值数据, 且必须是整数;<br>而当使用dict作为集合对象的底层实现时, 是将数据全部存储于dict的键中, 值字段闲置不用.<br><strong>编码的转换</strong><br>当集合同时满足以下两个条件时，使用 intset 编码：</p><ol><li>集合对象中所有元素都是整数</li><li>集合对象所有元素数量不超过512</li></ol><p>不能满足这两个条件的就使用 hashtable 编码。<br>第二个条件可以通过配置文件的 <code>set-max-intset-entries</code> 进行配置。</p><h3 id="有序集合对象-zset"><a href="#有序集合对象-zset" class="headerlink" title="有序集合对象 zset"></a>有序集合对象 zset</h3><p>和集合对象相比，有序集合对象是有序的。<br>与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。<br><strong>编码</strong><br>有序集合的底层实现有两种：<br>一种是使用ziplist作为底层实现, 对应的编码值宏为<code>ZIPLIST</code>；<br>另外一种比较特殊, 底层使用了两种数据结构: dict与skiplist, 对应的编码值宏为<code>SKIPLIST</code>。</p><p>使用ziplist来实现有序集合很容易理解, 只需要在ziplist这个数据结构的基础上做好排序与去重就可以了。<br>使用zskiplist来实现有序集合也很容易理解, Redis中实现的这个跳跃表似乎天然就是为了实现有序集合对象而实现的, 那么为什么还要辅助一个dict实例呢?<br>我们先看来有序集合对象在这两种编码方式下的内存布局, 然后再做解释。</p><ul><li>ZIPLIST<br>  <img src="/posts/49043/redis%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB-zset-ziplist.png"></li><li>SKIPLIST<br>  <img src="/posts/49043/redis%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB-zset-skiplist.png"></li></ul><p><strong>编码的转换</strong><br>当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：</p><ol><li>保存的元素数量小于128；</li><li>保存的所有元素长度都小于64字节。</li></ol><p>不能满足上面两个条件的使用 skiplist 编码。<br>以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-主从复制和分库分表</title>
      <link href="/posts/61222.html"/>
      <url>/posts/61222.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库主备搭建"><a href="#数据库主备搭建" class="headerlink" title="数据库主备搭建"></a>数据库主备搭建</h2><h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><p><img src="/posts/61222/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.png"></p><ul><li>主库对外提供读写的操作</li><li>从库对外提供读的操作</li></ul><p>主从架构的优势</p><ul><li>读写分离，减少主库压力，提升服务性能</li><li>备份数据</li><li>高可用，实时灾备</li></ul><p>主从架构需要考虑的问题</p><ul><li>主从一致性</li><li>主从延迟</li></ul><h4 id="主主、主从、主备"><a href="#主主、主从、主备" class="headerlink" title="主主、主从、主备"></a>主主、主从、主备</h4><ul><li>主主<br>  两台都是主数据库，同时对外提供读写操作。<br>  客户端访问任意一台。<br>  数据存在双向同步。</li><li>主从<br>  一台是主数据库，对外提供读写操作。<br>  一台是从数据库，对外提供读操作。<br>  数据从主库同步到从库。</li><li>主备<br>  一台是主数据库，对外提供读写操作。<br>  一台是备库，只作为备份作用，不对外提供读写，主机挂了就取而代之。<br>  数据从主库同步到备库。</li></ul><h3 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h3><ul><li>主数据库有个<code>bin log</code>二进制文件，纪录了所有增删改SQL语句。（binlog线程）</li><li>从数据库把主数据库的bin log文件的SQL 语句复制到自己的<code>中继日志 relay log</code>（io线程）</li><li>从数据库的relay log重做日志文件，再执行一次这些sql语句。（Sql执行线程）</li></ul><p>详细的主从同步过程如下：<br><img src="/posts/61222/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86.png"></p><ul><li>主库的更新SQL(update、insert、delete)被写到binlog</li><li>从库发起连接，连接到主库</li><li>此时主库创建一个<strong>binlog dump thread</strong>，把bin log的内容发送到从库</li><li>从库启动之后，创建一个<strong>I/O线程-io_thread</strong>，读取主库传过来的bin log内容并写入到relay log</li><li>从库还会创建一个<strong>SQL线程-sql_thread</strong>，从relay log里面读取内容，从ExecMasterLog_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db</li></ul><h3 id="主从一致性"><a href="#主从一致性" class="headerlink" title="主从一致性"></a>主从一致性</h3><h3 id="主从延迟"><a href="#主从延迟" class="headerlink" title="主从延迟"></a>主从延迟</h3><p>与主从数据同步相关的时间点有三个：</p><ul><li>主库执行完一个事务，写入binlog，我们把这个时刻记为T1；</li><li>主库同步数据给从库，从库接收完这个binlog的时刻，记录为T2；</li><li>从库执行完这个事务，这个时刻记录为T3。</li></ul><p>主从延迟，指一个事务，在从库执行完的时间和在主库执行完的时间差值，即T3-T1。</p><h4 id="导致主从延迟的情况"><a href="#导致主从延迟的情况" class="headerlink" title="导致主从延迟的情况"></a>导致主从延迟的情况</h4><ul><li>从库机器比主库机器性能差</li><li>从库的查询压力大，消耗大量CPU，影响同步速度</li><li>大事务，大表的DDL语句</li><li>网络延迟</li><li>从数据库太多</li><li>低版本的MySQL只支持单线程复制，如果主库并发高，来不及送到从库会导致延迟。<code>MySQL从5.6开始支持多线程复制</code>。</li></ul><h4 id="主从同步延迟如何处理"><a href="#主从同步延迟如何处理" class="headerlink" title="主从同步延迟如何处理"></a>主从同步延迟如何处理</h4><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><h3 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h3><h4 id="Sharding-存在的问题及解决方案"><a href="#Sharding-存在的问题及解决方案" class="headerlink" title="Sharding 存在的问题及解决方案"></a>Sharding 存在的问题及解决方案</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-数据库锁及InnoDB的锁</title>
      <link href="/posts/10347.html"/>
      <url>/posts/10347.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="加锁的目的"><a href="#加锁的目的" class="headerlink" title="加锁的目的"></a>加锁的目的</h4><p>数据库的锁是为了解决事务的隔离性问题，为了让事务之间相互不影响，每个事务进行操作的时候都会对数据加上一把特有的锁，防止其他事务同时操作数据。</p><h4 id="锁是基于什么实现的"><a href="#锁是基于什么实现的" class="headerlink" title="锁是基于什么实现的"></a>锁是基于什么实现的</h4><p>在Innodb中，锁是作用在索引上面的，当我们的SQL命中索引时，那么锁住的就是命中条件内的索引节点(行锁)，如果没有命中索引的话，那我们锁的就是整个索引树（表锁）</p><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><ul><li>基于锁的属性分类：共享锁、排他锁。</li><li>基于锁的粒度分类：行级锁(innodb)、表级锁(innodb、myisam)、页级锁(innodb引擎)、记录锁、间隙锁、临键锁、自增锁。</li><li>基于锁的状态分类：意向共享锁、意向排它锁。</li><li>基于加锁的态度分类：悲观锁、乐观锁。</li></ul><h2 id="InnoDB的锁"><a href="#InnoDB的锁" class="headerlink" title="InnoDB的锁"></a>InnoDB的锁</h2><h3 id="隐式锁定和显式锁定"><a href="#隐式锁定和显式锁定" class="headerlink" title="隐式锁定和显式锁定"></a>隐式锁定和显式锁定</h3><ul><li>隐式锁定<br>  InnoDB在事务执行过程中，使用两阶段锁协议（不主动进行显示锁定的情况）<ul><li>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</li><li>锁只有在事务执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</li></ul></li><li>显式锁定<br>  InnoDB也支持通过特定的语句进行显示锁定（存储引擎层）  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode <span class="operator">/</span><span class="operator">/</span>共享锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> update <span class="operator">/</span><span class="operator">/</span>排他锁</span><br></pre></td></tr></table></figure></li></ul><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><h4 id="1-基本锁"><a href="#1-基本锁" class="headerlink" title="1. 基本锁"></a>1. 基本锁</h4><p>在一个高并发系统中，会出现多会话同时访问同一资源的情况，此时即产生了竞争。<br>为了保证数据的一致性，必须要用锁机制来控制资源的并发访问。</p><p>InnoDB采用的行锁的设计（MyISAM只支持表锁），行锁带来更高的并发性，但管理复杂度也要比表锁更高。<br>InnoDB共实现了2种标准的行级锁：</p><ul><li>共享锁（S Lock），允许持有锁的事务读取数据。</li><li>排它锁（X Lock），允许持有锁的事务修改和删除数据。</li></ul><h4 id="2-意向锁-Intention-locks"><a href="#2-意向锁-Intention-locks" class="headerlink" title="2. 意向锁 Intention locks"></a>2. 意向锁 Intention locks</h4><p>InnoDB存储引擎支持多粒度的锁定，即允许行级锁和表级锁同时存在。</p><ul><li>意向共享锁（IS lock），表示事务想要获得表中某几行的共享锁。</li><li>意向排它锁（IX lock），表示事务想要获得表中某几行的排它锁。</li></ul><p>意向锁是一种表级锁，表示事务稍后希望在更细的粒度上（行级别）加锁。</p><ul><li>select … lock in share mode; 会对表施加IS锁</li><li>select … for update; 会对表施加IX锁</li></ul><table><thead><tr><th align="center"></th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">冲突</td></tr><tr><td align="center">IX</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">冲突</td><td align="center">兼容</td></tr><tr><td align="center">S</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center">IS</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><p>例如，如果请求在记录r上加X锁，则需要先在表级别上加意向排他锁（IX），如果此时表上存在其他锁，则意向锁需要等待表级别锁的释放，待表级意向锁(IX)获得成功后，才可以对行级别加X锁。</p><p>意向锁只会阻塞表级别的请求（如全表扫描、lock tables … write），除此之外不会阻塞任何操作。</p><h4 id="3-行锁-记录锁-Record-locks"><a href="#3-行锁-记录锁-Record-locks" class="headerlink" title="3. 行锁/记录锁 Record locks"></a>3. 行锁/记录锁 Record locks</h4><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，而不是给表的行记录加锁实现的，这就意味着只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。</p><p>由于InnoDB的行锁实现是针对索引字段添加的锁，不是针对行记录加的锁，因此虽然访问的是InnoDB引擎下表的不同行，但如果使用相同的索引字段作为过滤条件，依然会发生锁冲突，只能串行进行，不能并发进行。</p><p>即使SQL中使用了索引，但是经过MySQL的优化器后，如果认为全表扫描比使用索引效率高，此时会放弃使用索引，因此也不会使用行锁，而是使用表锁。</p><p>例如：<code>select col from t where col=1 for update;</code> 即对col为1的记录添加记录锁，阻止其他事务对此记录的操作。</p><h4 id="4-间隙锁-Gap-locks"><a href="#4-间隙锁-Gap-locks" class="headerlink" title="4. 间隙锁 Gap locks"></a>4. 间隙锁 Gap locks</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</p><p>例如：<code>select col from t where col between 1 and 10 for update;</code>会锁住1~10之间的间隙，而不管这段间隙内是否存在记录，因此间隙锁可能只锁住了一段空气。此时如果想插入为col为5的记录会被阻塞，即使5的记录不存在。</p><p>间隙锁的唯一目的即是阻止其他的事务往间隙中插入记录，因此不同的事务可以对同样的间隙重复加锁，没有共享和排他类型之分。</p><h5 id="InnoDB自动使用间隙锁的条件"><a href="#InnoDB自动使用间隙锁的条件" class="headerlink" title="InnoDB自动使用间隙锁的条件"></a>InnoDB自动使用间隙锁的条件</h5><ol><li><code>可重复读 Repeatable Read</code>级别下才会有间隙锁。必须在RR级别下。</li><li>检索条件必须有索引。（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 打开间隙锁设置</span><br><span class="line">innodb_locks_unsafe_for_binlog: OFF #默认值为OFF，即启用间隙锁</span><br></pre></td></tr></table></figure><h4 id="5-临键锁-Next-Key-locks"><a href="#5-临键锁-Next-Key-locks" class="headerlink" title="5. 临键锁 Next-Key locks"></a>5. 临键锁 Next-Key locks</h4><p>行锁与间隙锁组合起来用就叫做Next-Key Lock。<br>InnoDB默认加锁方式是<code>next-key</code>锁。</p><p><code>next-key lock</code>会对记录本身和记录之前的区间加锁。</p><blockquote><p>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.</p></blockquote><p>如果一个会话占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。</p><blockquote><p>If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order.</p></blockquote><p>例如：假设表中存在索引记录1,10。则next-key lock可能锁住的范围是：(-∞,1]、(1,10]、(10,+∞），对于最后一个区间，next-key lock也会锁住最大记录之后的间隙。</p><blockquote><p><code>Next-key lock</code>只在<code>MySQL InnoDB</code>的<code>*repeatable read</code>隔离级别下使用，主要是用来解决<code>幻读(phantom read)</code>的问题。</p></blockquote><p>当对唯一键值进行锁定时，查询的索引含有唯一属性，next-key lock将会降级为record lock，即仅锁住唯一记录。<br>而如果唯一键由多个列组成，而查询仅使用其中一列，则其实是range查询，InnoDB会依然使用next-key lock进行锁定。</p><h4 id="6-插入意向锁-Insert-intention-locks"><a href="#6-插入意向锁-Insert-intention-locks" class="headerlink" title="6. 插入意向锁 Insert intention locks"></a>6. 插入意向锁 Insert intention locks</h4><p>插入意向锁是间隙锁的一种，其由insert语句在插入记录前获取，代表将在间隙中插入记录的意向。</p><p>多个事务可以对同一个间隙重复加insert intention lock，只要插入的记录值不同，事务就不会冲突。</p><p>例如表中已存在记录1和10,两个事务分别想插入5和6。两个事务都会对1和10记录之间的间隙(2,9)加insert intention lock，但由于插入的记录值不同，因此后续对要插入的记录获取X锁的时候并不会冲突。</p><h4 id="7-自增锁-auto-inc-locks"><a href="#7-自增锁-auto-inc-locks" class="headerlink" title="7. 自增锁 auto-inc locks"></a>7. 自增锁 auto-inc locks</h4><p>自增锁是一种特殊类型的表锁，只要在事务对auto_increment类型的列插入数据时，才会施加auto-inc lock，此时其他想插入的事务都需要等待该锁的释放，而持有该锁的事务可以获得连续的primary key值。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC锁-锁核心AQS</title>
      <link href="/posts/63925.html"/>
      <url>/posts/63925.html</url>
      
        <content type="html"><![CDATA[<p>AbstractQueuedSynchronizer抽象类是核心，需要重点掌握。它提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。</p><p>AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)</p><h2 id="带着BAT大厂的面试问题去理解"><a href="#带着BAT大厂的面试问题去理解" class="headerlink" title="带着BAT大厂的面试问题去理解"></a>带着BAT大厂的面试问题去理解</h2><ul><li>什么是AQS? 为什么它是核心?</li><li>AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等</li><li>AQS有哪些核心的方法?</li><li>AQS定义什么样的资源获取方式?<br>  AQS定义了两种资源获取方式：<ul><li><strong>独占</strong>(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock) </li><li><strong>共享</strong>(多个线程可同时访问执行，如Semaphore、CountDownLatch、 CyclicBarrier )。</li><li>ReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读。</li></ul></li><li>AQS底层使用了什么样的设计模式? <strong>模板模式</strong></li><li>AQS的应用示例?</li></ul><h2 id="AbstractQueuedSynchronizer简介"><a href="#AbstractQueuedSynchronizer简介" class="headerlink" title="AbstractQueuedSynchronizer简介"></a>AbstractQueuedSynchronizer简介</h2><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock、Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。<br>当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p><p><img src="/posts/63925/AQS-%E5%AD%90%E7%B1%BB.png"></p><h3 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h3><p>AQS核心思想是：<br><strong>如果被请求的共享资源空闲</strong>，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态；<br><strong>如果被请求的共享资源被占用</strong>，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用<strong>CLH队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。</p><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。<br>状态信息通过procted类型的getState，setState，compareAndSetState进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h3><ul><li>独占 Exclusive<br>  只有一个线程能执行，如ReentrantLock，又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li>共享 Share<br>  多个线程可同时执行，如Semaphore、CountDownLatch、CyclicBarrier、ReadWriteLock<br>  ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</li></ul><h3 id="AQS的设计模式-模板模式"><a href="#AQS的设计模式-模板模式" class="headerlink" title="AQS的设计模式 - 模板模式"></a>AQS的设计模式 - 模板模式</h3><p>同步器的设计是基于模板方法模式的。</p><p>使用者继承AbstractQueuedSynchronizer并重写指定的方法。(这些重写方法很简单，无非是对于共享资源state的获取和释放)<br>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p><p>自定义同步器时需要重写下面几个AQS提供的模板方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()   <span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)       <span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)       <span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>) <span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>) <span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure><h2 id="AbstractQueuedSynchronizer数据结构"><a href="#AbstractQueuedSynchronizer数据结构" class="headerlink" title="AbstractQueuedSynchronizer数据结构"></a>AbstractQueuedSynchronizer数据结构</h2><p><img src="/posts/63925/AQS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97&%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png"></p><p>AQS有两个队列，双向的同步队列 sync queue 和单向的条件队列 condition queue。</p><p>AbstractQueuedSynchronizer类底层的数据结构是使用<code>CLH(Craig,Landin,and Hagersten)队列</code>的变体。</p><p>AQS是将每个请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。<br>其中，Sync queue，即同步队列，是虚拟的双向链表，包括head结点和tail结点，head结点主要用作后续的调度。<br>而Condition queue不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue。</p><h3 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h3><h3 id="同步队列-Sync-queue"><a href="#同步队列-Sync-queue" class="headerlink" title="同步队列 - Sync queue"></a>同步队列 - Sync queue</h3><h4 id="为什么同步队列是双向的？"><a href="#为什么同步队列是双向的？" class="headerlink" title="为什么同步队列是双向的？"></a>为什么同步队列是双向的？</h4><p>方便以O(1)的时间复杂度获取到prev前驱结点。<br>按照同步队列的设计，头结点head是空的，表示已经获取到锁的线程，<strong>只有头结点的后继结点next有必要尝试获取锁</strong>，否则会造成羊群效应，其它后面的大量结点在阻塞之前尝试去竞争锁会带来比较大的性能开销。<br>所以<code>acquireQueued</code>时，会判断前驱结点是不是头结点，如果不是头结点就没有必要去<code>tryAcquire</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 只有前驱结点是头结点才去tryAcquire</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class="comment">// 否则返回中断标识</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件队列-Condition-queue"><a href="#条件队列-Condition-queue" class="headerlink" title="条件队列 - Condition queue"></a>条件队列 - Condition queue</h3><p><img src="/posts/63925/AQS-%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png"></p><p>AQS中的条件队列，是一个单向链表，<strong>通过Node节点的nextWaiter来连接</strong>。</p><ul><li>Condition#<strong>await</strong><br>  调用<code>Condition#await</code>方法时必须持有锁，所以当前线程位于同步队列(sync queue)的头节点。<br>  此时会将当前线程移动到条件队列(condition queue)的尾节点——<code>addConditionWaiter()</code>，释放线程当前持有的锁，阻塞当前线程。</li><li>Condition#<strong>signal</strong><br>  调用<code>Condition#signal</code>方法会将条件队列(condition queue)的首节点移动到同步队列(sync queue)尾部，然后唤醒因调用<code>Condition#await</code>方法而阻塞的线程(唤醒之后这个线程就可以去竞争锁了)。<br>  所以调用<code>Condition#signal</code>方法的时候必须持有锁，持有锁的线程唤醒被因调用<code>Condition#await</code>方法而阻塞的线程。</li></ul><h2 id="AbstractQueuedSynchronizer源码分析"><a href="#AbstractQueuedSynchronizer源码分析" class="headerlink" title="AbstractQueuedSynchronizer源码分析"></a>AbstractQueuedSynchronizer源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3737899427754241961L</span>;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractOwnableSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 独占模式下的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置独占线程 </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取独占线程 </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer继承自AbstractOwnableSynchronizer抽象类，并且实现了Serializable接口，可以进行序列化。</p><p>AbstractOwnableSynchronizer抽象类中，可以设置独占资源线程和获取独占资源线程。分别为setExclusiveOwnerThread与getExclusiveOwnerThread方法，这两个方法会被子类调用</p><h3 id="内部类-Node类"><a href="#内部类-Node类" class="headerlink" title="内部类 - Node类"></a>内部类 - Node类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模式，分为共享与独占</span></span><br><span class="line">    <span class="comment">// 共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;        </span><br><span class="line">    <span class="comment">// 结点状态</span></span><br><span class="line">    <span class="comment">// CANCELLED，值为1，表示当前的线程被取消</span></span><br><span class="line">    <span class="comment">// SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark</span></span><br><span class="line">    <span class="comment">// CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中</span></span><br><span class="line">    <span class="comment">// PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行</span></span><br><span class="line">    <span class="comment">// 值为0，表示当前节点在sync队列中，等待着获取锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;        </span><br><span class="line">    <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;    </span><br><span class="line">    <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;        </span><br><span class="line">    <span class="comment">// 结点所对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;        </span><br><span class="line">    <span class="comment">// 下一个等待者</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结点是否在共享模式下等待</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取前驱结点，若前驱结点为空，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        <span class="comment">// 保存前驱结点</span></span><br><span class="line">        Node p = prev; </span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="comment">// 前驱结点为空，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 前驱结点不为空，返回</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;    <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个被阻塞的线程都会被封装成一个Node结点，放入队列。<br>每个节点包含了一个Thread类型的引用，并且每个节点都存在一个状态，具体状态如下：</p><ul><li><code>CANCELLED</code>，值为1，表示当前的线程被取消。</li><li><code>SIGNAL</code>，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。</li><li><code>CONDITION</code>，值为-2，表示当前节点在等待condition，也就是在condition queue中。</li><li><code>PROPAGATE</code>，值为-3，表示当前场景下后续的acquireShared能够得以执行。</li><li>值为0，表示当前节点在sync queue中，等待着获取锁。</li></ul><h3 id="内部类-ConditionObject类"><a href="#内部类-ConditionObject类" class="headerlink" title="内部类 - ConditionObject类"></a>内部类 - ConditionObject类</h3><p>ConditionObject类实现了Condition接口，Condition接口定义了条件操作规范，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号或被中断之前一直处于等待状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号之前一直处于等待状态，不响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 </span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) &gt; 0</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><p>属性中包含了头节点head、尾结点tail、状态state、自旋时间spinForTimeoutThreshold，还有AbstractQueuedSynchronizer抽象的属性在内存中的偏移地址，通过该偏移地址，可以获取和设置该属性的值，同时还包括一个静态初始化块，用于加载内存偏移地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984972572414691L</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;    </span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;    </span><br><span class="line">    <span class="comment">// 自旋时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Unsafe类实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// state内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">    <span class="comment">// head内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">    <span class="comment">// state内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line">    <span class="comment">// tail内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitStatusOffset;</span><br><span class="line">    <span class="comment">// next内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">            headOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">            tailOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">            waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">            nextOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h3><p>此类构造方法为从抽象构造方法，供子类调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueuedSynchronizer</span><span class="params">()</span> </span>&#123; &#125;    </span><br></pre></td></tr></table></figure><h3 id="核心方法-acquire方法"><a href="#核心方法-acquire方法" class="headerlink" title="核心方法 - acquire方法"></a>核心方法 - acquire方法</h3><p>该方法以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述源码可以知道，当一个线程调用acquire时，调用方法流程如下：<br><img src="/posts/63925/AQS-acquire-%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><ol><li>首先调用<strong>tryAcquire</strong>方法。<br> 在AbstractQueuedSynchronizer源码中默认会抛出一个异常，即需要子类去重写此方法完成自己的逻辑。</li><li>若tryAcquire失败，则调用<strong>addWaiter</strong>方法，<strong>addWaiter方法完成的功能是将调用此方法的线程封装成为一个结点并放入同步队列Sync queue</strong>。</li><li>调用<strong>acquireQueued</strong>方法，此方法完成的功能是<strong>Sync queue中的结点不断尝试获取资源</strong>，若成功，则返回true，否则，返回false。</li></ol><h4 id="addWaiter-Node-mode"><a href="#addWaiter-Node-mode" class="headerlink" title="addWaiter(Node mode)"></a>addWaiter(Node mode)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加等待者</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新生成一个结点，默认为独占模式</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 保存尾结点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 尾结点不为空，即已经被初始化</span></span><br><span class="line">        <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">        node.prev = pred; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 比较pred是否为尾结点，是则将尾结点设置为node </span></span><br><span class="line">            <span class="comment">// 设置尾结点的next域为node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">// 返回新生成的结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// 尾结点为空(即还没有被初始化过)，或者是compareAndSetTail操作失败，则入队列</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，确保结点能够成功入队列</span></span><br><span class="line">        <span class="comment">// 保存尾结点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 尾结点为空，即还没被初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 头节点为空，并设置头节点为新生成的结点</span></span><br><span class="line">                tail = head; <span class="comment">// 头节点与尾结点都指向同一个新生结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 尾结点不为空，即已经被初始化过</span></span><br><span class="line">            <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">            node.prev = t; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 比较结点t是否为尾结点，若是则将尾结点设置为node</span></span><br><span class="line">                <span class="comment">// 设置尾结点的next域为node</span></span><br><span class="line">                t.next = node; </span><br><span class="line">                <span class="keyword">return</span> t; <span class="comment">// 返回尾结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addWaiter方法使用快速添加的方式往sync queue尾部添加结点，如果sync queue队列还没有初始化，则会使用enq插入队列中。<br>enq方法会使用无限循环来确保节点的成功插入。</p><h4 id="acquireQueued-final-Node-node-int-arg"><a href="#acquireQueued-final-Node-node-int-arg" class="headerlink" title="acquireQueued(final Node node, int arg)"></a>acquireQueued(final Node node, int arg)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync队列中的结点在独占且忽略中断的模式下获取(资源)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标志</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 中断标志</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取node节点的前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); </span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 前驱为头节点并且成功获得锁</span></span><br><span class="line">                setHead(node); <span class="comment">// 设置头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 设置标志</span></span><br><span class="line">                <span class="keyword">return</span> interrupted; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当获取(资源)失败后，检查并且更新结点状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取前驱结点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 状态为SIGNAL，为-1</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">            * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">// 可以进行park操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// 表示状态为CANCELLED，为1</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">            * indicate retry.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>); <span class="comment">// 找到pred结点前面最近的一个状态不为CANCELLED的结点</span></span><br><span class="line">        <span class="comment">// 赋值pred结点的next域</span></span><br><span class="line">        pred.next = node; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">            * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">            * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">// 比较并设置前驱结点的状态为SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能进行park操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行park操作并且返回该线程是否被中断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在许可可用之前禁用当前线程，并且设置了blocker</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 当前线程是否已被中断，并清除中断标记位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法-release方法"><a href="#核心方法-release方法" class="headerlink" title="核心方法 - release方法"></a>核心方法 - release方法</h3><p>以独占模式释放对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 释放成功</span></span><br><span class="line">        <span class="comment">// 保存头节点</span></span><br><span class="line">        Node h = head; </span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 头节点不为空并且头节点状态不为0</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">//释放头节点的后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于AbstractQueuedSynchronizer的分析，最核心的就是sync queue的分析。</p><ul><li>每一个结点都是由前一个结点唤醒</li><li>当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行。</li><li>condition queue中的结点向sync queue中转移是通过signal操作完成的。</li><li>当结点的状态为SIGNAL时，表示后面的结点需要运行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC锁-ReentrantLock</title>
      <link href="/posts/2000.html"/>
      <url>/posts/2000.html</url>
      
        <content type="html"><![CDATA[<p>可重入锁ReentrantLock的底层是通过AbstractQueuedSynchronizer实现。</p><h2 id="带着BAT大厂的面试问题去理解"><a href="#带着BAT大厂的面试问题去理解" class="headerlink" title="带着BAT大厂的面试问题去理解"></a>带着BAT大厂的面试问题去理解</h2><ul><li>什么是可重入，什么是可重入锁? 它用来解决什么问题?</li><li>ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗? 说说其类内部结构关系。</li><li>ReentrantLock是如何实现公平锁的?</li><li>ReentrantLock是如何实现非公平锁的?</li><li>ReentrantLock默认实现的是公平还是非公平锁?</li><li>使用ReentrantLock实现公平和非公平锁的示例?</li><li>ReentrantLock和Synchronized的对比?</li></ul><h2 id="ReentrantLock源码分析"><a href="#ReentrantLock源码分析" class="headerlink" title="ReentrantLock源码分析"></a>ReentrantLock源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><p>ReentrantLock实现了Lock接口，Lock接口中定义了lock与unlock相关操作，并且还存在newCondition方法，表示生成一个条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>ReentrantLock总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。<br><img src="/posts/2000/reentrantlock-%E5%86%85%E9%83%A8%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><p>ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。</p><h4 id="Sync类"><a href="#Sync类" class="headerlink" title="Sync类"></a>Sync类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取锁，交给具体子类去实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非公平方式获取</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 表示没有线程正在竞争该锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 比较并设置状态成功，状态0表示锁没有被占用</span></span><br><span class="line">                <span class="comment">// 设置当前线程独占</span></span><br><span class="line">                setExclusiveOwnerThread(current); </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 当前线程拥有该锁</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires; <span class="comment">// 增加重入次数</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置状态</span></span><br><span class="line">            setState(nextc); </span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 当前线程不为独占线程</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(); <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="comment">// 释放标识</span></span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 已经释放，清空独占</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置标识</span></span><br><span class="line">        setState(c); </span><br><span class="line">        <span class="keyword">return</span> free; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断资源是否被当前线程占有</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新生一个条件</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods relayed from outer class</span></span><br><span class="line">    <span class="comment">// 返回资源的占用线程</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 资源是否被占用</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 自定义反序列化逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;　　</span><br></pre></td></tr></table></figure><h4 id="NonfairSync类"><a href="#NonfairSync类" class="headerlink" title="NonfairSync类"></a>NonfairSync类</h4><p>NonfairSync类继承了Sync类，表示采用非公平策略获取锁，其实现了Sync类中抽象的lock方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 比较并设置状态成功，状态0表示锁没有被占用</span></span><br><span class="line">            <span class="comment">// 把当前线程设置独占了锁</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 锁已经被占用，或者set失败</span></span><br><span class="line">            <span class="comment">// 以独占模式获取对象，忽略中断</span></span><br><span class="line">            acquire(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<strong>NonfairSync#lock方法</strong>的源码可知，lock时先<code>compareAndSetState(0, 1)</code>尝试获取锁，而并不会按照公平等待的原则进行等待，让sync queue中的第一个线程获得锁。</p><h4 id="FairSyn类"><a href="#FairSyn类" class="headerlink" title="FairSyn类"></a>FairSyn类</h4><p>FairSync类也继承了Sync类，表示采用公平策略获取锁，其实现了Sync类中的抽象lock方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以独占模式获取对象，忽略中断</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">        * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 尝试公平获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 状态为0</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// sync queue中不存在线程并且compareAndSetState设置状态成功</span></span><br><span class="line">                <span class="comment">// 设置当前线程独占</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 状态不为0，即资源已经被线程占据，看是否是当前线程占用，是则重入</span></span><br><span class="line">            <span class="comment">// 下一个状态 增加重入次数</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// 超过了int的表示范围</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置状态</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要资源被其他线程占用，<strong>FairSyn</strong>会将该线程添加到sync queue中的尾部，而不会先尝试获取资源。<br>这也是和<strong>Nonfair</strong>最大的区别，<strong>Nonfair每一次都会尝试去compareAndSetState获取资源（有两次机会），如果此时该资源恰好被释放，则会被当前线程获取，这就造成了不公平的现象</strong>，当获取不成功，再加入队列尾部。</p><p><strong>公平锁下，同步队列Sync queue的头节点线程一定可以拿到资源吗？</strong><br>理论上，同步队列的头节点线程应该是第一个获取到锁的线程。但是并非头节点线程一定可以获取到锁。<br>公平锁只是尽最大努力保证同步队列的线程可以按顺序获得锁，但终究还是受限于系统调度和锁的实际使用状态。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984872572414699L</span>;    </span><br><span class="line">    <span class="comment">// 同步队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock类的sync非常重要，对ReentrantLock类的操作大部分都直接转化为对Sync和AbstractQueuedSynchronizer类的操作。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>ReentrantLock()  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平策略</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ReentrantLock(boolean fair)<br>  可以传递参数确定采用公平策略或者是非公平策略，参数为true表示公平策略，否则，采用非公平策略。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>通过分析ReentrantLock的源码，可知对其操作都转化为对Sync对象的操作，由于Sync继承了AQS，所以基本上都可以转化为对AQS的操作。<br>如将ReentrantLock的lock函数转化为对Sync的lock函数的调用，而具体会根据采用的策略(如公平策略或者非公平策略)的不同而调用到Sync的不同子类。<br>所以可知，在ReentrantLock的背后，是AQS对其服务提供了支持。</p><h2 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h2><h3 id="可重入的例子"><a href="#可重入的例子" class="headerlink" title="可重入的例子"></a>可重入的例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 方法体...</span></span><br><span class="line">            method2();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 方法体...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockExample example = <span class="keyword">new</span> ReentrantLockExample();</span><br><span class="line">        example.method1();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC锁-LockSupport</title>
      <link href="/posts/1156.html"/>
      <url>/posts/1156.html</url>
      
        <content type="html"><![CDATA[<p>LockSupport是锁中的基础，是一个提供锁机制的工具类。</p><h2 id="带着BAT大厂的面试问题去理解"><a href="#带着BAT大厂的面试问题去理解" class="headerlink" title="带着BAT大厂的面试问题去理解"></a>带着BAT大厂的面试问题去理解</h2><ul><li>为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)</li><li>写出分别通过wait/notify和LockSupport的park/unpark实现同步?</li><li>LockSupport.park()会释放锁资源吗? 那么Condition.await()呢?</li><li>Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点</li><li>如果在wait()之前执行了notify()会怎样?</li><li>如果在park()之前执行了unpark()会怎样?</li></ul><h2 id="LockSupport简介"><a href="#LockSupport简介" class="headerlink" title="LockSupport简介"></a>LockSupport简介</h2><p>LockSupport用来创建锁和其他同步类的基本线程阻塞原语。内部是通过虚拟机的Unsafe（可以直接操作内存）实现的。</p><p>LockSupport类的核心方法其实就两个：**park()和unpark()**，其中<code>park()</code>方法用来阻塞当前调用线程，<code>unpark()</code>方法用于唤醒指定线程。<br>这其实和Object类的wait()和signal()方法有些类似，但是LockSupport的这两种方法从语意上讲比Object类的方法更清晰，而且可以针对指定线程进行阻塞和唤醒。</p><p>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。<br>初始时，permit为0，当调用unpark()方法时，线程的permit加1；当调用park()方法时，如果permit为0，则调用线程进入阻塞状态。</p><h2 id="LockSupport源码分析"><a href="#LockSupport源码分析" class="headerlink" title="LockSupport源码分析"></a>LockSupport源码分析</h2><p>基于JDK 8</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hotspot implementation via intrinsics API</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// 表示内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> parkBlockerOffset;</span><br><span class="line">    <span class="comment">// 表示内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line">    <span class="comment">// 表示内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="comment">// 表示内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取Unsafe实例</span></span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            <span class="comment">// 线程类类型</span></span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">            <span class="comment">// 获取Thread的parkBlocker字段的内存偏移地址</span></span><br><span class="line">            parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;parkBlocker&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取Thread的threadLocalRandomSeed字段的内存偏移地址</span></span><br><span class="line">            SEED = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomSeed&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取Thread的threadLocalRandomProbe字段的内存偏移地址</span></span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomProbe&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取Thread的threadLocalRandomSecondarySeed字段的内存偏移地址</span></span><br><span class="line">            SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomSecondarySeed&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UNSAFE字段表示sun.misc.Unsafe类，查看其源码，点击在这里，一般程序中不允许直接调用；<br>而long型的表示实例对象相应字段在内存中的偏移地址，可以通过该偏移地址获取或者设置该字段的值。</p><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私有构造函数，无法被实例化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LockSupport</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>LockSupport只有一个私有构造函数，无法被实例化。</p><h3 id="核心方法分析"><a href="#核心方法分析" class="headerlink" title="核心方法分析"></a>核心方法分析</h3><h4 id="sun-misc-Unsafe"><a href="#sun-misc-Unsafe" class="headerlink" title="sun.misc.Unsafe"></a>sun.misc.Unsafe</h4><p>在分析LockSupport函数之前，先引入sun.misc.Unsafe类中的park和unpark函数，因为<strong>LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数</strong>。</p><p>下面给出两个函数的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Unsafe#park<br>  阻塞线程，并且该线程在下列情况发生之前都会被阻塞：<ul><li>① 调用unpark函数，释放该线程的许可。</li><li>② 该线程被中断。</li><li>③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。</li></ul></li><li>Unsafe#unpark<br>  释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。</li></ul><h4 id="park方法"><a href="#park方法" class="headerlink" title="park方法"></a>park方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LockSupport</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 设置Blocker</span></span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="comment">// 重新可运行后再此设置Blocker</span></span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Even though volatile, hotspot doesn&#x27;t need a write barrier here.</span></span><br><span class="line">        <span class="comment">// 设置线程t的parkBlocker字段的值为arg</span></span><br><span class="line">        UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取许可，设置时间为无限长，直到可以获取许可</span></span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>park函数有两个重载版本，两个函数的区别在于park()函数没有没有blocker，即没有设置线程的parkBlocker字段。</p><ul><li>park(Object blocker)<br>  调用<strong>LockSupport#park</strong>函数时，首先获取当前线程，然后设置当前线程的parkBlocker字段，即调用setBlocker函数，之后调用Unsafe类的park函数，之后再调用setBlocker函数。<br>  为什么要在<strong>LockSupport#park</strong>函数中要调用两次setBlocker函数呢？<br>  原因其实很简单，调用<strong>LockSupport#park</strong>函数时，当前线程首先设置好parkBlocker字段，然后再调用<strong>Unsafe类的park函数</strong>，这时当前线程就已经阻塞了，等待该线程的<strong>LockSupport#unpark(currentThread)<strong>被调用，所以第二个<code>setBlocker(t, null)</code>暂时无法运行；unpark函数被调用，该线程获得许可后，就可以继续运行了，此时运行<code>setBlocker(t, null)</code>，这样就完成了整个</strong>LockSupport#park</strong>的逻辑。<br>  如果没有<code>setBlocker(t, null)</code>，那么之后没有调用**LockSupport#park(object)<strong>，而直接调用getBlock函数，得到的是前一个</strong>LockSupport#park(object)<strong>设置的blocker，显然是不合理的。<br>  <code>setBlocker(t, null)</code>，是保证在</strong>LockSupport#park(object)**整个函数执行完后，该线程的parkBlocker字段又恢复为null。</li><li>park()<br>  调用了park()函数后，会禁用当前线程，除非许可可用。<br>  在以下三种情况之一发生之前，当前线程都将处于休眠状态，即下列情况发生时，当前线程会获取许可，可以继续运行。<ul><li>其他某个线程<strong>将当前线程作为目标</strong>调用 unpark(currentThread)。</li><li>其他某个线程中断当前线程。</li><li>该调用不合逻辑地(即毫无理由地)返回。</li></ul></li><li>parkNanos(Object blocker, long nanos)<br>  nanos参数表示相对时间，表示等待多长时间</li><li>parkUntil(Object blocker, long deadline)<br>  deadline参数表示绝对时间，表示指定的时间</li></ul><h4 id="unpark方法"><a href="#unpark方法" class="headerlink" title="unpark方法"></a>unpark方法</h4><p>此函数表示如果给定线程的许可尚不可用，则使其可用。如果线程在 park 上受阻塞，则它将解除其阻塞状态。否则，保证下一次调用 park 不会受阻塞。如果给定线程尚未启动，则无法保证此操作有任何效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>) <span class="comment">// 线程为不空</span></span><br><span class="line">        UNSAFE.unpark(thread); <span class="comment">// 释放该线程许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Thread-parkBlocker属性"><a href="#Thread-parkBlocker属性" class="headerlink" title="Thread - parkBlocker属性"></a>Thread - parkBlocker属性</h4><p>线程对象 Thread 里面有一个重要的属性 parkBlocker，它保存当前线程因为什么而 park。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">volatile</span> Object parkBlocker;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程被 unpark 唤醒后，这个属性会被置为 null。<br>Unsafe.park 和 unpark 并不会帮我们设置 parkBlocker 属性，负责管理这个属性的工具类是 LockSupport，它对 Unsafe 这两个方法进行了简单的包装。</p><p>Java 的AQS锁数据结构正是通过调用 LockSupport 来实现休眠与唤醒的。<br>线程对象里面的 parkBlocker 字段的值就是「排队管理器」- AbstractQueuedSynchronizer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LockSupport示例"><a href="#LockSupport示例" class="headerlink" title="LockSupport示例"></a>LockSupport示例</h2><h3 id="使用wait-notify实现线程同步"><a href="#使用wait-notify实现线程同步" class="headerlink" title="使用wait/notify实现线程同步"></a>使用wait/notify实现线程同步</h3><h3 id="使用park-unpark实现线程同步"><a href="#使用park-unpark实现线程同步" class="headerlink" title="使用park/unpark实现线程同步"></a>使用park/unpark实现线程同步</h3><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><h2 id="更深入的理解"><a href="#更深入的理解" class="headerlink" title="更深入的理解"></a>更深入的理解</h2><h3 id="Thread-sleep-和Object-wait-的区别"><a href="#Thread-sleep-和Object-wait-的区别" class="headerlink" title="Thread.sleep()和Object.wait()的区别"></a>Thread.sleep()和Object.wait()的区别</h3><p>最大的区别是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。</p><h3 id="Object-wait-和Condition-await-的区别"><a href="#Object-wait-和Condition-await-的区别" class="headerlink" title="Object.wait()和Condition.await()的区别"></a>Object.wait()和Condition.await()的区别</h3><h3 id="Thread-sleep-和LockSupport-park-的区别"><a href="#Thread-sleep-和LockSupport-park-的区别" class="headerlink" title="Thread.sleep()和LockSupport.park()的区别"></a>Thread.sleep()和LockSupport.park()的区别</h3><h3 id="Object-wait-和LockSupport-park-的区别"><a href="#Object-wait-和LockSupport-park-的区别" class="headerlink" title="Object.wait()和LockSupport.park()的区别"></a>Object.wait()和LockSupport.park()的区别</h3><ul><li><p>Object.wait()</p><ul><li>Object.wait()方法需要在synchronized块中执行；</li><li>Object.wait()方法抛出了中断异常，调用者需要捕获或者再抛出；</li><li>Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；</li></ul></li><li><p>LockSupport.park()</p><ul><li>LockSupport.park()可以在任意地方执行；</li><li>LockSupport.park()不需要捕获中断异常；</li><li>LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；</li></ul></li><li><p>如果在wait()之前执行了notify()会怎样?<br>  如果当前线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时，会抛出IllegalMonitorStateException异常。<br>  如果当前线程是此对象锁的所有者，在wait()之前执行了notify()，wait()后将一直阻塞，因为后续将没有其他线程notify()来唤醒它。</p></li><li><p>如果在park()之前执行了unpark()会怎样?<br>  线程不会被阻塞，直接跳过park()，继续执行后续内容。<br>  原因是unpark()先释放了一个凭证，所以park()的时候，凭证已经存在则不阻塞继续执行。</p></li></ul><p>park()/unpark()底层的原理是“二元信号量”，可以把它想象成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。</p><h3 id="LockSupport-park-会释放锁资源吗"><a href="#LockSupport-park-会释放锁资源吗" class="headerlink" title="LockSupport.park()会释放锁资源吗?"></a>LockSupport.park()会释放锁资源吗?</h3><p>不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC工具类-CyclicBarrier</title>
      <link href="/posts/31020.html"/>
      <url>/posts/31020.html</url>
      
        <content type="html"><![CDATA[<h2 id="带着BAT大厂的面试问题去理解"><a href="#带着BAT大厂的面试问题去理解" class="headerlink" title="带着BAT大厂的面试问题去理解"></a>带着BAT大厂的面试问题去理解</h2><ul><li>什么是CyclicBarrier?</li><li>CyclicBarrier底层实现原理?</li><li>CountDownLatch和CyclicBarrier对比?</li><li>CyclicBarrier的核心函数有哪些?</li><li>CyclicBarrier适用于什么场景?</li></ul><h2 id="CyclicBarrier简介"><a href="#CyclicBarrier简介" class="headerlink" title="CyclicBarrier简介"></a>CyclicBarrier简介</h2><p>对于CountDownLatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。</p><p>对于CyclicBarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。</p><p>和CountDownLatch对比</p><ul><li>CountDownLatch减计数，CyclicBarrier加计数。</li><li>CountDownLatch是一次性的，CyclicBarrier可以重用。</li><li>CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思<ul><li>CountDownLatch的下一步的动作实施者是<strong>主线程</strong>，具有不可重复性；</li><li>CyclicBarrier的下一步动作实施者是<strong>最后一个进入屏障的线程</strong>，具有往复多次实施动作的特点。</li></ul></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><p>CyclicBarrier没有显示继承哪个父类或者实现哪个父接口，它的AQS和重入锁不是通过继承实现的，而是通过组合实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类的内部类</span></span><br><span class="line"><span class="comment">     * CyclicBarrier类存在一个内部类Generation，每一次使用的CycBarrier可以当成Generation的实例，其源代码如下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性broken，用来表示当前屏障是否被损坏。</span></span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 条件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">// 参与的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">// 由最后一个进入 barrier 的线程执行的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">// 当前代</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    <span class="comment">// 正在等待进入屏障的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性有一个为ReentrantLock对象，有一个为Condition对象，而Condition对象又是基于AQS的，所以，归根到底，底层还是由AQS提供支持。<br>CyclicBarrier组合ReentrantLock和Condition来实现。</p><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><ul><li><p>CyclicBarrier(int parties, Runnable barrierAction)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 参与的线程数量小于等于0，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="comment">// 设置parties</span></span><br><span class="line"><span class="keyword">this</span>.parties = parties;</span><br><span class="line"><span class="comment">// 设置count</span></span><br><span class="line"><span class="keyword">this</span>.count = parties;</span><br><span class="line"><span class="comment">// 设置barrierCommand</span></span><br><span class="line"><span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  该构造函数可以指定关联该CyclicBarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。</p></li><li><p>CyclicBarrier(int parties)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用含有两个参数的构造函数</span></span><br><span class="line"><span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  该构造函数仅仅执行了关联该CyclicBarrier的线程数量，没有设置执行动作。</p></li></ul><h3 id="核心函数-dowait"><a href="#核心函数-dowait" class="headerlink" title="核心函数 dowait"></a>核心函数 dowait</h3><p>此函数为CyclicBarrier类的核心函数，CyclicBarrier类对外提供的await函数在底层都是调用该了doawait函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CyclicBarrier#await</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">            BrokenBarrierException,</span></span><br><span class="line"><span class="function">            TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CyclicBarrier#dowait</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">            TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">// 保存当前锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 锁定</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存当前代</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (g.broken) <span class="comment">// 屏障被破坏，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">// 线程被中断</span></span><br><span class="line">            <span class="comment">// 损坏当前屏障，并且唤醒所有的线程，只有拥有锁的时候才会调用</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减少正在等待进入屏障的线程数量</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 正在等待进入屏障的线程数量为0，所有线程都已经进入</span></span><br><span class="line">            <span class="comment">// 运行的动作标识</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 保存运行动作</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>) <span class="comment">// 动作不为空</span></span><br><span class="line">                    <span class="comment">// 运行</span></span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 设置ranAction状态</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 进入下一代</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction) <span class="comment">// 没有运行的动作</span></span><br><span class="line">                    <span class="comment">// 损坏当前屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed) <span class="comment">// 没有设置等待时间</span></span><br><span class="line">                    <span class="comment">// 等待</span></span><br><span class="line">                    trip.await(); </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>) <span class="comment">// 设置了等待时间，并且等待时间大于0</span></span><br><span class="line">                    <span class="comment">// 等待指定时长</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; </span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123; <span class="comment">// 等于当前代并且屏障没有被损坏</span></span><br><span class="line">                    <span class="comment">// 损坏当前屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="comment">// 抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不等于当前带后者是屏障被损坏</span></span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    <span class="comment">// 中断当前线程</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken) <span class="comment">// 屏障被损坏，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation) <span class="comment">// 不等于当前代</span></span><br><span class="line">                <span class="comment">// 返回索引</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123; <span class="comment">// 设置了等待时间，并且等待时间小于0</span></span><br><span class="line">                <span class="comment">// 损坏屏障</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="comment">// 抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心函数-nextGeneration"><a href="#核心函数-nextGeneration" class="headerlink" title="核心函数 nextGeneration"></a>核心函数 nextGeneration</h3><p>此函数在所有线程进入屏障后会被调用，即生成下一个版本，所有线程又可以重新进入到屏障中。<br>其源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    <span class="comment">// 恢复正在等待进入屏障的线程数量</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 新生一代</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此函数中会调用AQS的signalAll方法，即唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。</p><p>在此函数中会调用AQS的signalAll方法，即唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。<br>其源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">                <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">                <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  此函数判断头节点是否为空，即条件队列是否为空，不为空会调用doSignalAll函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 不被当前线程独占，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="comment">// 保存condition队列头节点</span></span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 头节点不为空</span></span><br><span class="line">                <span class="comment">// 唤醒所有等待线程</span></span><br><span class="line">                doSignalAll(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此函数会依次将条件队列中的节点转移到同步队列中，会调用到transferForSignal函数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Node next = first.nextWaiter;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                transferForSignal(first);</span><br><span class="line">                first = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此函数的作用就是将处于条件队列中的节点转移到同步队列中，并设置结点的状态信息，其中会调用到enq函数</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">                * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">                * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">                * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            Node p = enq(node);</span><br><span class="line">            <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">                LockSupport.unpark(node.thread);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此函数完成了结点插入同步队列的过程</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，确保结点能够成功入队列</span></span><br><span class="line">                <span class="comment">// 保存尾结点</span></span><br><span class="line">                Node t = tail;</span><br><span class="line">                <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 尾结点为空，即还没被初始化</span></span><br><span class="line">                    <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 头节点为空，并设置头节点为新生成的结点</span></span><br><span class="line">                        tail = head; <span class="comment">// 头节点与尾结点都指向同一个新生结点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 尾结点不为空，即已经被初始化过</span></span><br><span class="line">                    <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">                    node.prev = t; </span><br><span class="line">                    <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 比较结点t是否为尾结点，若是则将尾结点设置为node</span></span><br><span class="line">                        <span class="comment">// 设置尾结点的next域为node</span></span><br><span class="line">                        t.next = node; </span><br><span class="line">                        <span class="keyword">return</span> t; <span class="comment">// 返回尾结点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="breakBarrier函数"><a href="#breakBarrier函数" class="headerlink" title="breakBarrier函数"></a>breakBarrier函数</h3><p>此函数的作用是损坏当前屏障，会唤醒所有在屏障中的线程。<br>源代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 恢复正在等待进入屏障的线程数量</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此函数也调用了AQS的signalAll函数，由signal函数提供支持。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-数据库事务及InnoDB的事务、MVCC</title>
      <link href="/posts/9614.html"/>
      <url>/posts/9614.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><p>原子性（atomicity，或称不可分割性）<br>一致性（consistency）<br>隔离性（isolation，又称独立性）<br>持久性（durability）</p><h3 id="标准事务的隔离级别"><a href="#标准事务的隔离级别" class="headerlink" title="标准事务的隔离级别"></a>标准事务的隔离级别</h3><ul><li><p>读未提交 read-uncommitted<br>  允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p>  事务对当前被读取的数据不加锁；<br>  事务在更新某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放。</p></li><li><p>读已提交 read-committed<br>  允许读取并发事务已经提交过的数据，可以防止脏读，但是幻读或不可重复读仍有可能发生。</p><p>  事务对当前被读取的数据加行级共享锁（当读到时才加锁），一旦读完该行，立即释放；<br>  事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放。</p><p>  Oracle/SQLserver的默认隔离级别是read committed，是允许幻读和不可重复读存在的。<br>  MySQL InnoDB在RC级别通过快照读解决了不可重复读问题。</p></li><li><p>可重复读 repeatable-read<br>  对同一数据记录的多次读取结果都是一致的，除非是被本身事务自己所修改，可以防止脏读和不可重复读，但幻读仍有可能发生。</p><p>  事务在读取某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放；<br>  事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放。</p><p>  MySQL InnoDB默认隔离级别是RR，在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。</p></li><li><p>串行化 serializable<br>  最高的隔离级别，完全服从ACID的隔离级别。<br>  所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。</p><p>  事务在读取数据是，必须先对其加表级共享锁，直到事务结束才释放；<br>  事务在更新数据时，必须先对其加表级排他锁，知道事务结束才释放。</p></li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h3><ul><li><p>脏读 dirty read<br>  当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”。</p></li><li><p>不可重复读 unrepeatable read<br>  一个事务对同一数据的读取结果前后不一致。<br>  与脏读的区别在于，脏读的是另一事务未提交的数据，不可重复读的是另一事务已经提交的数据，只不过数据被其他事务修改过。</p><p>  事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p></li><li><p>幻读 phantom read<br>  事务读取某个范围的数据时，因为其他事务的insert操作导致前后两次读取的结果不一致。<br>  幻读和不可重复读的区别在于，不可重复读是针对确定的某一行数据而言，而幻读是针对不确定的多行数据，因此幻读通常出现在带有查询条件的范围查询中。<br>  一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询不存在的行。</p><p>  系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p></li><li><p>更新丢失(Lost Update)或脏写<br>  当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。</p></li></ul><h3 id="事务并发场景"><a href="#事务并发场景" class="headerlink" title="事务并发场景"></a>事务并发场景</h3><ul><li>读读情况<br>  并发事务相继读取相同记录，允许发生。</li><li>读-写或写-读情况<br>  读-写或写-读，即一个事务进行读取操作，另一个进行改动操作。<br>  这种情况下可能发生脏读、不可重复读、幻读的问题。</li><li>写写情况<br>  这种情况会出现脏写的问题，任何一种隔离级别都不允许这种问题的发生，是通过加锁来实现的。</li></ul><h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>怎么解决脏读、不可重复读、幻读的问题，有两种解决方案。</p><ul><li>方案一：读操作利用多版本并发控制(MVCC)，写操作进行加锁</li><li>方案二：读写操作都采用加锁的方法</li></ul><p>MySQL的InnoDB存储引擎默认事务隔离级别是<code>RR(可重复读)</code>，是通过 <code>next-key锁 + MVCC</code>一起实现的，正常读的时候不加锁，写的时候加锁。</p><h2 id="MySQL-InnoDB事务原理"><a href="#MySQL-InnoDB事务原理" class="headerlink" title="MySQL InnoDB事务原理"></a>MySQL InnoDB事务原理</h2><h3 id="MySQL-InnoDB事务特性实现"><a href="#MySQL-InnoDB事务特性实现" class="headerlink" title="MySQL InnoDB事务特性实现"></a>MySQL InnoDB事务特性实现</h3><ul><li>A-原子性；原子性通过undo log实现；</li><li>C-一致性；通过原子性、隔离性、持久性实现的；</li><li>I-隔离性；隔离级别，通过MVCC + 锁实现；</li><li>D-持久性；持久性通过redo log实现；</li></ul><h3 id="MySQL-InnoDB的事务隔离级别的实现原理"><a href="#MySQL-InnoDB的事务隔离级别的实现原理" class="headerlink" title="MySQL InnoDB的事务隔离级别的实现原理"></a>MySQL InnoDB的事务隔离级别的实现原理</h3><p>标准SQL事务隔离级别的实现是依赖锁的。<br>InnoDB使用不同的锁策略(Locking Strategy)以及MVCC机制来实现不同的隔离级别。</p><h4 id="读未提交-Read-UnCommitted"><a href="#读未提交-Read-UnCommitted" class="headerlink" title="读未提交 Read UnCommitted"></a>读未提交 Read UnCommitted</h4><p>事务对当前被读取的数据不加锁，都是<code>当前读</code>。<br>事务在更新某数据的瞬间，对其加行级共享锁，直到事务结束才释放。</p><h4 id="读已提交-Read-Committed"><a href="#读已提交-Read-Committed" class="headerlink" title="读已提交 Read Committed"></a>读已提交 Read Committed</h4><p>事务对当前被读取的数据不加锁，且是<code>快照读</code>。<br>事务在更新某数据的瞬间，对其加行级排他锁（Record Lock），直到事务结束才释放。</p><p>通过快照读，MySQL InnoDB在RC级别就解决了不可重复读的问题。</p><h4 id="可重复读-Repeatable-Read"><a href="#可重复读-Repeatable-Read" class="headerlink" title="可重复读 Repeatable Read"></a>可重复读 Repeatable Read</h4><p>事务对当前被读取的数据不加锁，且是<code>快照读</code>。<br>事务在更新某数据的瞬间，对其加行级排他锁（Record + gap = next-key lock），直到事务结束才释放。</p><p>通过临键锁，MySQL InnoDB在RR级别解决了幻读。</p><h4 id="序列化读"><a href="#序列化读" class="headerlink" title="序列化读"></a>序列化读</h4><p>事务在读取数据时，必须先对其加表级共享锁，直到事务结束才释放，都是<code>当前读</code>。<br>事务在更新数据时，必须先对其加表级排他锁，直到事务结束才释放。</p><h2 id="MySQL-InnoDB的MVCC实现机制"><a href="#MySQL-InnoDB的MVCC实现机制" class="headerlink" title="MySQL InnoDB的MVCC实现机制"></a>MySQL InnoDB的MVCC实现机制</h2><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。<br>MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用不加锁的方式去处理读-写冲突，<code>实现读-写冲突不加锁</code>。</p><h3 id="什么是MySQL-InnoDB下的当前读和快照读"><a href="#什么是MySQL-InnoDB下的当前读和快照读" class="headerlink" title="什么是MySQL InnoDB下的当前读和快照读"></a>什么是MySQL InnoDB下的当前读和快照读</h3><p>快照读和当前读都是针对于某一行数据记录来说的。</p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是最新版本。<br>像<code>UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE</code>、<code>SELECT ... FOR UPDATE</code>这些操作都是一种当前读。</p><p>为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>读取的是快照版本，也就是历史版本。<br>像不加锁的SELECT操作就是快照读，即不加锁的非阻塞读。</p><p>快照读的前提是隔离级别不是未提交读和序列化读级别。<br>因为未提交读总是读取最新的数据行，而不是符合当前事务版本的数据行；而序列化读则会对表加锁，退化成当前读。</p><h4 id="当前读，快照读和MVCC的关系"><a href="#当前读，快照读和MVCC的关系" class="headerlink" title="当前读，快照读和MVCC的关系"></a>当前读，快照读和MVCC的关系</h4><h3 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h3><blockquote><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 4个隐式字段，undo日志 ，Read View 来实现的。</p></blockquote><h4 id="4个隐式字段"><a href="#4个隐式字段" class="headerlink" title="4个隐式字段"></a>4个隐式字段</h4><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p><ul><li>DB_ROW_ID 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li><li>DB_TRX_ID 6byte, 最近修改(修改/插入)事务ID，记录创建这条记录/最后一次修改该记录的事务ID</li><li>DB_ROLL_PTR 7byte, 回滚指针，用于配合undo日志，指向这条记录的上一个版本（存储于rollback segment里）</li><li>DELETED_BIT 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了</li></ul><h4 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h4><p>InnoDB把这些为了回滚而记录的这些东西称之为undo log。<br>这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。</p><p>undo log主要分为3种：</p><ul><li>Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li><li>Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li><li>Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 <ul><li>删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。</li><li>为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。<br>  为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）。<br>  如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li></ul></li></ul><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><h3 id="MVCC相关问题"><a href="#MVCC相关问题" class="headerlink" title="MVCC相关问题"></a>MVCC相关问题</h3><h4 id="RC、RR级别下的InnoDB快照读有什么不同"><a href="#RC、RR级别下的InnoDB快照读有什么不同" class="headerlink" title="RC、RR级别下的InnoDB快照读有什么不同"></a>RC、RR级别下的InnoDB快照读有什么不同</h4><p>正是Read View生成时机的不同，从而造成RC、RR级别下快照读的结果的不同</p><ul><li>RR快照读<br>  在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见。<br>  即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见。</li><li>RC快照读<br>  在RC级别下的事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。</li></ul><p>总之，<br>在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；<br>而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC工具类-Semaphore</title>
      <link href="/posts/16860.html"/>
      <url>/posts/16860.html</url>
      
        <content type="html"><![CDATA[<p>Semaphore底层是基于AbstractQueuedSynchronizer来实现的。<br>Semaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源。</p><h2 id="带着BAT大厂的面试问题去理解"><a href="#带着BAT大厂的面试问题去理解" class="headerlink" title="带着BAT大厂的面试问题去理解"></a>带着BAT大厂的面试问题去理解</h2><ul><li>什么是Semaphore?</li><li>Semaphore内部原理?</li><li>Semaphore常用方法有哪些? 如何实现线程同步和互斥的?</li><li>Semaphore适合用在什么场景?</li><li>单独使用Semaphore是不会使用到AQS的条件队列?</li><li>Semaphore中申请令牌(acquire)、释放令牌(release)的实现?</li><li>Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?</li><li>Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?</li><li>Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?</li><li>Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semaphore实现了Serializable接口，即可以进行序列化。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>Semaphore与ReentrantLock的内部类的结构相同，类内部总共存在Sync、NonfairSync、FairSync三个类。<br>NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。</p><h4 id="Sync类"><a href="#Sync类" class="headerlink" title="Sync类"></a>Sync类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类，继承自AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="comment">// 设置状态数</span></span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享模式下非公平策略获取</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可数</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="comment">// 剩余的许可</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining)) <span class="comment">// 许可小于0或者比较并且设置状态成功</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共享模式下进行释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的缩减量减小可用许可的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Permit count underflow&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并返回立即可用的所有许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>)) <span class="comment">// 许可为0或者比较并设置成功</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NonfairSync类"><a href="#NonfairSync类" class="headerlink" title="NonfairSync类"></a>NonfairSync类</h4><p>NonfairSync类继承了Sync类，表示采用非公平策略获取资源，其只有一个tryAcquireShared方法，重写了AQS的该方法，其源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享模式下获取</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从tryAcquireShared方法的源码可知，其会调用父类Sync的nonfairTryAcquireShared方法，表示按照非公平策略进行资源的获取。</p><h4 id="FairSync类"><a href="#FairSync类" class="headerlink" title="FairSync类"></a>FairSync类</h4><p>FairSync类继承了Sync类，表示采用公平策略获取资源，其只有一个tryAcquireShared方法，重写了AQS的该方法，其源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从tryAcquireShared方法的源码可知，它使用公平策略来获取资源，它会判断同步队列中是否存在其他的等待节点。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semaphore自身只有两个属性，最重要的是sync属性，基于Semaphore对象的操作绝大多数都转移到了对sync的操作。</p><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><ul><li><p>Semaphore(int permits)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  该构造函数会创建具有给定的许可数和非公平设置的Semaphore。</p></li><li><p>Semaphore(int permits, boolean fair)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  该构造函数会创建具有给定的许可数和给定的公平设置的Semaphore。</p></li></ul><h3 id="核心函数-acquire函数"><a href="#核心函数-acquire函数" class="headerlink" title="核心函数 acquire函数"></a>核心函数 acquire函数</h3><p>方法从信号量获取一个(多个)许可，在提供一个许可前一直将线程阻塞，或者线程被中断，其源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireShared(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquireShared(permits) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中将会调用Sync对象的**acquireSharedInterruptibly(从AQS继承而来的方法)**方法。</p><p>假设使用非公平策略，acquire方法大致的调用链如下：<br><img src="/posts/16860/semaphore-acquire%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%93%BE.png"></p><h3 id="核心函数-release函数"><a href="#核心函数-release函数" class="headerlink" title="核心函数 release函数"></a>核心函数 release函数</h3><p>此方法释放一个(多个)许可，将其返回给信号量，源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中将会调用Sync对象的releaseShared(从AQS继承而来的方法)方法</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="单独使用Semaphore是不会使用到AQS的条件队列的"><a href="#单独使用Semaphore是不会使用到AQS的条件队列的" class="headerlink" title="单独使用Semaphore是不会使用到AQS的条件队列的"></a>单独使用Semaphore是不会使用到AQS的条件队列的</h3><p>不同于CyclicBarrier和ReentrantLock，单独使用Semaphore是不会使用到AQS的条件队列的。<br>其实，只有进行<code>Condition.await</code>操作才会进入条件队列；其他的都是在同步队列中，只是当前线程会被park。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-存储引擎及InnoDB详解</title>
      <link href="/posts/922.html"/>
      <url>/posts/922.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>一个库中可以有多个不同存储引擎的表。</p><p>InnoDB和MyISAM数据库的表的结构定义信息都存储在frm文件中。<br>InnoDB的数据和索引存储在ibd文件中（聚集），MyISAM索引存在MYI文件中，数据存储在MYD文件中（非聚集）。  </p><h3 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h3><p>若一个主键被定义，该主键则作为密集索引；<br>若没有主键被定义，该表的第一个唯一非空索引则作为密集索引；<br>若不满足以上条件，innoDB内部会生成一个隐藏主键(rowid，密集索引，该主键是一个六字节的列，该列的值随着记录的插入而自增)。</p><p>即innoDB必须得有一个主键作为密集索引存在，innodb引擎里的主键一般都是聚集索引；<br>非主键索引都是非聚集索引，非主键索引存储相关键位和其对应的主键值，要进行两次查找(先通过非主键索引去查找主键索引，再通过主键索引去查找数据的物理地址)。</p><p>InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如updatetable set num=1 where name like “a%”，就是说在不确定的范围时，InnoDB还是会锁表的。<br>InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM索引结构: MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。<br>B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。<br>主键索引和其他索引没有任何区别, 都是稀疏索引, 表数据存储在独立的地方MYD, 表数据MYD和索引MYI的分开的, 索引用地址指向表数据。</p><p><strong>两者的对比：</strong></p><ol><li>是否支持行级锁；</li><li>是否支持事务和崩溃后的安全恢复<br> MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。<br> InnoDB提供事务支持、外部键等高级数据库功能。</li><li>是否支持外键；</li><li>是否支持MVCC<br> 仅InnoDB支持。<br> 应对高并发事务，MVCC比单纯的加锁更高效；<br> MVCC只在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>两个隔离级别下工作；<br> MVCC可以使用乐观锁和悲观锁来实现；<br> 各数据库中MVCC实现并不统一。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</span><br></pre></td></tr></table></figure><h2 id="MySQL-InnoDB存储引擎体系结构"><a href="#MySQL-InnoDB存储引擎体系结构" class="headerlink" title="MySQL InnoDB存储引擎体系结构"></a>MySQL InnoDB存储引擎体系结构</h2><p><img src="/posts/922/mysql-innodb-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-1.png"><br><img src="/posts/922/mysql-innodb-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-2.png"><br><img src="/posts/922/mysql-innodb-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-3.png"></p><h2 id="InnoDB后台线程"><a href="#InnoDB后台线程" class="headerlink" title="InnoDB后台线程"></a>InnoDB后台线程</h2><p>InnoDB存储引擎是多线程的模型，有多个后台线程去负责处理不同的任务。</p><p>后台线程的主要作用是<strong>负责刷新内存池中的数据，保证缓冲池中缓存的是最近的数据</strong>。此外<strong>将已修改的数据文件刷新到磁盘文件</strong>，同时<strong>保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态</strong>。</p><ol><li>Master Thread<br>该线程是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘中，保证数据的一致性。包括脏页的刷新、合并插入缓冲、UNDO页回收等。<ul><li>脏页<br>由于InnoDB在进行表数据修改的时候，并不是直接修改磁盘上的数据文件，而是将磁盘上的页缓存到缓冲池中进行修改，之后再根据一定的机制和频率刷新回磁盘，这种还没有刷新回磁盘但是已经被修改的页称为脏页。</li><li>合并插入缓冲<br>当要插入非聚集索引的时候，将其放在缓冲内存中保存，根据一定的机制和频率将要插入的非聚集索引一起刷新到索引页中。</li></ul></li><li>IO Thread<br>在InnoDB存储引擎中使用了大量的AIO（Async IO）来处理写IO请求，这样可以极大的提高数据库的性能，而IO Thread的工作主要是负责这些IO请求的回调处理。</li><li>Purge Thread<br>Purge Thread主要的作用是回收已经使用并分配的undo页。<br>事务被提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。</li><li>Page Cleaner Thread<br>作用就是刷新脏页，这个线程是1.2.x版本中引入的，将刷新脏页的操作放入单独的线程中完成，减轻原Master Thread的工作量，提高存储引擎的性能。</li></ol><h2 id="InnoDB内存结构"><a href="#InnoDB内存结构" class="headerlink" title="InnoDB内存结构"></a>InnoDB内存结构</h2><p><img src="/posts/922/mysql-innodb-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1.png"></p><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>InnoDB可以有多个缓冲池实例（<code>innodb_buffer_pool_instances</code>默认为1，最大为64），每个页根据哈希值平均分配到不同缓冲池实例中。</p><ol><li>数据页</li><li>索引页</li><li>插入缓冲</li><li>自适应哈希索引</li><li>锁信息</li><li>数据字典信息</li></ol><h3 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h3><p>InnoDB先将重做日志信息放到这个缓冲区，然后按一定频率刷新到重做日志文件。<br>一般每秒都会将缓冲刷新到日志，所以重做日志缓冲不需要很大。</p><h3 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h3><p>每个缓冲池中的帧缓冲（frame buffer）以及对应的缓冲控制对象，它们的内存需要从额外内存池中获取。</p><h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><h4 id="插入缓冲-Insert-Buffer"><a href="#插入缓冲-Insert-Buffer" class="headerlink" title="插入缓冲 Insert Buffer"></a>插入缓冲 Insert Buffer</h4><h4 id="两次写-Double-Write"><a href="#两次写-Double-Write" class="headerlink" title="两次写 Double Write"></a>两次写 Double Write</h4><h4 id="自适应哈希索引-Adaptive-Hash-Index"><a href="#自适应哈希索引-Adaptive-Hash-Index" class="headerlink" title="自适应哈希索引 Adaptive Hash Index"></a>自适应哈希索引 Adaptive Hash Index</h4><h4 id="异步IO-AIO"><a href="#异步IO-AIO" class="headerlink" title="异步IO AIO"></a>异步IO AIO</h4><h4 id="刷新邻接页-Flush-Neighbor-Page"><a href="#刷新邻接页-Flush-Neighbor-Page" class="headerlink" title="刷新邻接页 Flush Neighbor Page"></a>刷新邻接页 Flush Neighbor Page</h4><h2 id="InnoDB磁盘结构"><a href="#InnoDB磁盘结构" class="headerlink" title="InnoDB磁盘结构"></a>InnoDB磁盘结构</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC工具类-CountDownLatch</title>
      <link href="/posts/22626.html"/>
      <url>/posts/22626.html</url>
      
        <content type="html"><![CDATA[<h2 id="带着BAT大厂的面试问题去理解"><a href="#带着BAT大厂的面试问题去理解" class="headerlink" title="带着BAT大厂的面试问题去理解"></a>带着BAT大厂的面试问题去理解</h2><ul><li>什么是CountDownLatch?</li><li>CountDownLatch底层实现原理?</li><li>CountDownLatch一次可以唤醒几个任务? 多个</li><li>CountDownLatch有哪些主要方法? await(),countDown()</li><li>CountDownLatch适用于什么场景?</li><li>写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束? 使用CountDownLatch 代替wait notify 好处。</li></ul><h2 id="CountDownLatch介绍"><a href="#CountDownLatch介绍" class="headerlink" title="CountDownLatch介绍"></a>CountDownLatch介绍</h2><p>从源码可知，其底层是由AQS提供支持，所以其数据结构可以参考AQS的数据结构，而AQS的数据结构核心就是两个虚拟队列: 同步队列sync queue 和条件队列condition queue，不同的条件会有不同的条件队列。</p><p>CountDownLatch典型的用法是将一个程序分为n个互相独立的可解决任务，并创建值为n的CountDownLatch。<br>等待问题被解决的任务调用这个锁存器的<code>await()</code>，将自己拦住，直至锁存器计数结束。<br>当每一个任务完成时，都会在这个锁存器上调用<code>countDown()</code>。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><p>CountDownLatch没有显示继承哪个父类或者实现哪个父接口, 它底层是AQS提供支持，是通过内部类Sync来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>CountDownLatch类存在一个内部类Sync，继承自AbstractQueuedSynchronizer。<br>对CountDownLatch方法的调用会转发到对Sync或AQS的方法的调用，所以，AQS对CountDownLatch提供支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图在共享模式下获取对象状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图设置状态来反映共享模式下的一个释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 没有被线程占有</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 下一个状态</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 比较并且设置成功</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的属性和构造函数"><a href="#类的属性和构造函数" class="headerlink" title="类的属性和构造函数"></a>类的属性和构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化状态数</span></span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到CountDownLatch类的内部只有一个Sync类型的属性。</li><li>该构造函数可以构造一个给定计数初始化的CountDownLatch，并且构造函数内完成了sync的初始化，并设置了状态数。</li></ul><h3 id="核心函数-await"><a href="#核心函数-await" class="headerlink" title="核心函数 await()"></a>核心函数 await()</h3><p>此函数将会使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 转发到sync对象上</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对CountDownLatch对象的await的调用会转发为对Sync的acquireSharedInterruptibly(从AQS继承的方法)方法的调用。</p><p>CountDownLatch的await调用链：<br><img src="/posts/22626/countdownlatch-await.png"></p><ul><li><p>AQS#acquireSharedInterruptibly</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  acquireSharedInterruptibly又调用了<strong>CountDownLatch的内部类Sync的tryAcquireShared</strong>和<strong>AQS的doAcquireSharedInterruptibly函数</strong>。</p></li><li><p>CountDownLatch#Sync#tryAcquireShared</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  该函数只是简单的判断AQS的state是否为0，为0则返回1，不为0则返回-1。</p></li><li><p>AQS#doAcquireSharedInterruptibly</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 添加节点至等待队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取node的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 前驱节点为头节点</span></span><br><span class="line">                <span class="comment">// 试图在共享模式下获取对象状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 获取成功</span></span><br><span class="line">                    <span class="comment">// 设置头节点并进行繁殖</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    <span class="comment">// 设置节点next域</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 在获取失败后是否需要禁止线程并且进行中断检查</span></span><br><span class="line">                <span class="comment">// 抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在AQS的doAcquireSharedInterruptibly中可能会再次调用CountDownLatch的内部类Sync的tryAcquireShared方法和AQS的setHeadAndPropagate方法。</p></li></ul><h3 id="核心函数-countDown"><a href="#核心函数-countDown" class="headerlink" title="核心函数 countDown()"></a>核心函数 countDown()</h3><p>此函数将递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对countDown的调用转换为对Sync对象的releaseShared(从AQS继承而来)方法的调用。</p><p>CountDownLatch的countDown调用链：<br><img src="/posts/22626/countdownlatch-countdown.png"></p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><blockquote><p>实现一个容器，提供两个方法，add，size<br>写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束.</p></blockquote><h3 id="使用wait和notify实现"><a href="#使用wait和notify实现" class="headerlink" title="使用wait和notify实现"></a>使用wait和notify实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  必须先让t2先进行启动 使用wait 和 notify 进行相互通讯，wait会释放锁，notify不会释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        T2 t2 = <span class="keyword">new</span> T2();</span><br><span class="line"></span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 启动&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(t2.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">/**会释放锁*/</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;t2 结束&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t1 启动&quot;</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">                   t2.add(i);</span><br><span class="line">                   System.out.println(<span class="string">&quot;add&quot;</span>+i);</span><br><span class="line">                   <span class="keyword">if</span>(t2.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                       <span class="comment">/**不会释放锁*/</span></span><br><span class="line">                       lock.notify();</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           lock.wait();</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch实现"><a href="#CountDownLatch实现" class="headerlink" title="CountDownLatch实现"></a>CountDownLatch实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用CountDownLatch 代替wait notify 好处是通讯方式简单，不涉及锁定。  Count 值为0时当前线程继续执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T3 t = <span class="keyword">new</span> T3();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 start&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(t.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   countDownLatch.await();</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2 end&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 start&quot;</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">               t.add(i);</span><br><span class="line">               System.out.println(<span class="string">&quot;add&quot;</span>+ i);</span><br><span class="line">               <span class="keyword">if</span>(t.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;countdown is open&quot;</span>);</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 end&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC原子类</title>
      <link href="/posts/1288.html"/>
      <url>/posts/1288.html</url>
      
        <content type="html"><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS的全称为Compare-And-Swap，直译就是对比交换。<br>是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值。<br>经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。  </p><p>简单解释：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。<br>CAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。</p><h3 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>因为CAS需要在操作值的时候，检查值有没有发生变化，没有发生变化则更新。但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。<br>在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么 A-&gt;B-&gt;A 就会变成 1A-&gt;2B-&gt;3A。</p><p>从Java 1.5开始，JDK的Atomic包里提供了一个类<code>AtomicStampedReference</code>来解决ABA问题。<br>这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><p>如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。<br>pause指令有两个作用：</p><ul><li>第一，它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；</li><li>第二，它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率。</li></ul><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p><p>还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i = 2，j = a，合并一下ij = 2a，然后用CAS来操作ij。</p><p>从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p><img src="/posts/1288/JUC-unsafe-api.png"></p><h3 id="Unsafe与CAS"><a href="#Unsafe与CAS" class="headerlink" title="Unsafe与CAS"></a>Unsafe与CAS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object newValue)</span> </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getObjectVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2, Object paramObject3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt1, <span class="keyword">int</span> paramInt2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2, <span class="keyword">long</span> paramLong3)</span></span>;</span><br></pre></td></tr></table></figure><p>Unsafe内部使用自旋的方式进行CAS更新(while循环进行CAS更新，如果更新失败，则循环再次重试)。</p><p>Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong。都是native方法。</p><h4 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h4><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用于获取value字段相对当前对象的“起始地址”的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递增加detla</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递增加1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> AtomicInteger 底层用的是volatile的变量和CAS来进行更改数据的。</p><ul><li>volatile保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值</li><li>CAS 保证数据更新的原子性。</li></ul><h3 id="12个原子类"><a href="#12个原子类" class="headerlink" title="12个原子类"></a>12个原子类</h3><h4 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h4><ul><li>AtomicBoolean: 原子更新布尔类型。</li><li>AtomicInteger: 原子更新整型。</li><li>AtomicLong: 原子更新长整型。<h4 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h4></li><li>AtomicIntegerArray: 原子更新整型数组里的元素。</li><li>AtomicLongArray: 原子更新长整型数组里的元素。</li><li>AtomicReferenceArray: 原子更新引用类型数组里的元素。</li></ul><p>这三个类的最常用的方法是如下两个方法：</p><ul><li>get(int index)：获取索引为index的元素值。</li><li>compareAndSet(int i,E expect,E update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值。<h4 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h4></li><li>AtomicReference: 原子更新引用类型。</li><li>AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。</li><li>AtomicMarkableReferce: 原子更新带有标记位的引用类型。</li></ul><h4 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h4><ul><li>AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater: 原子更新长整型字段的更新器。</li><li>AtomicReferenceFieldUpdater: 原子更新饮用类型字段的更新器。</li></ul><h3 id="AtomicStampedReference解决CAS的ABA问题"><a href="#AtomicStampedReference解决CAS的ABA问题" class="headerlink" title="AtomicStampedReference解决CAS的ABA问题"></a>AtomicStampedReference解决CAS的ABA问题</h3><p>AtomicStampedReference主要维护包含一个对象引用以及一个可以自动更新的整数<code>stamp</code>的<code>pair对象</code>来解决ABA问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;  <span class="comment">//维护对象引用</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;  <span class="comment">//用于标志版本</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * expectedReference ：更新之前的原始值</span></span><br><span class="line"><span class="comment">      * newReference : 将要更新的新值</span></span><br><span class="line"><span class="comment">      * expectedStamp : 期待更新的标志版本</span></span><br><span class="line"><span class="comment">      * newStamp : 将要更新的标志版本</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                             V   newReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前的(元素值，版本号)对</span></span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            <span class="comment">// 引用没变</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            <span class="comment">// 版本号没变</span></span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            <span class="comment">// 新引用等于旧引用</span></span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">            <span class="comment">// 新版本号等于旧版本号</span></span><br><span class="line">            newStamp == current.stamp) ||</span><br><span class="line">            <span class="comment">// 构造新的Pair对象并CAS更新</span></span><br><span class="line">            casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用Unsafe的compareAndSwapObject()方法CAS更新pair的引用为新引用</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——RocketMQ</title>
      <link href="/posts/12377.html"/>
      <url>/posts/12377.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/48816137">https://zhuanlan.zhihu.com/p/48816137</a></p><p><a href="https://www.zhihu.com/question/449611434/answer/1824707689">https://www.zhihu.com/question/449611434/answer/1824707689</a></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty</title>
      <link href="/posts/15056.html"/>
      <url>/posts/15056.html</url>
      
        <content type="html"><![CDATA[<p>Netty是一个高性能、异步事件驱动的NIO框架，提供了对TCP、UDP和文件传输的支持。<br>作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p><p><img src="/posts/15056/netty-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84.png"></p><p><a href="http://www.52im.net/thread-2043-1-1.html">新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析</a></p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul><li><p><strong>Bootstrap、ServerBootstrap</strong><br>  Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件。<br>  Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p></li><li><p><strong>Future、ChannelFuture</strong><br>  在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。<br>  但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures 可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p></li><li><p><strong>Channel</strong><br>  Netty 网络通信的组件，能够用于执行网络 I/O 操作。<br>  Channel 为用户提供：</p><ol><li>当前网络连接的通道的状态（例如是否打开？是否已连接？）</li><li>网络连接的配置参数 （例如接收缓冲区大小）</li><li>提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。</li><li>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方。</li><li>支持关联 I/O 操作与对应的处理程序。</li></ol><p>  不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。<br>  下面是一些常用的 Channel 类型：</p><ul><li>NioSocketChannel，异步的客户端 TCP Socket 连接。</li><li>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</li><li>NioDatagramChannel，异步的 UDP 连接。</li><li>NioSctpChannel，异步的客户端 Sctp 连接。</li><li>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</li></ul></li><li><p><strong>Selector</strong><br>  Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。<br>  当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读、可写、网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p></li><li><p><strong>NioEventLoop</strong><br>  NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务：</p><ul><li><strong>I/O任务</strong>，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等，由 processSelectedKeys 方法触发。</li><li><strong>非IO任务</strong>，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</li></ul></li><li><p><strong>NioEventLoopGroup</strong><br>  NioEventLoopGroup，主要管理 eventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个 Channel 上的事件，而一个 Channel 只对应于一个线程。</p></li><li><p><strong>ChannelHandler</strong><br>  ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。<br>  ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p><ul><li>ChannelInboundHandler 用于处理入站 I/O 事件。</li><li>ChannelOutboundHandler 用于处理出站 I/O 操作。</li></ul><p>  或者使用以下适配器类：</p><ul><li>ChannelInboundHandlerAdapter 用于处理入站 I/O 事件。</li><li>ChannelOutboundHandlerAdapter 用于处理出站 I/O 操作。</li><li>ChannelDuplexHandler 用于处理入站和出站事件。</li></ul></li><li><p><strong>ChannelHandlerContext</strong><br>  保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。</p></li><li><p><strong>ChannelPipline</strong><br>  保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作。<br>  ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-IOC-实现原理详解-初探</title>
      <link href="/posts/3526.html"/>
      <url>/posts/3526.html</url>
      
        <content type="html"><![CDATA[<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="Bean是如何注册到IOC容器中的"><a href="#Bean是如何注册到IOC容器中的" class="headerlink" title="Bean是如何注册到IOC容器中的"></a>Bean是如何注册到IOC容器中的</h3><h4 id="xml配置文件方式下Bean的注册"><a href="#xml配置文件方式下Bean的注册" class="headerlink" title="xml配置文件方式下Bean的注册"></a>xml配置文件方式下Bean的注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="comment">//将传入的xml配置位置信息设置到configLocations</span></span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">    <span class="comment">//核心方法</span></span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注册xml配置文件到configLocations</li><li>调用refresh()进行整个Context的刷新，实际上就是整个Context的启动</li><li>Bean的加载会读到配置文件，解析成DOM对象，将DOM对象转换成<code>beanDeifnition</code><ul><li>obtainFreshBeanFactory()</li><li>refreshBeanFactory()</li><li>loadBeanDefinitions(beanFactory)</li></ul></li><li>将 beanDeifnition 存到 beanDeifnitionMap，完成这个Bean的注册<ul><li>DefaultListableBeanFactory#registerBeanDefinition</li></ul></li></ul><h4 id="注解方式下Bean的注册"><a href="#注解方式下Bean的注册" class="headerlink" title="注解方式下Bean的注册"></a>注解方式下Bean的注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigApplicationContext构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line"><span class="comment">//主要是scan方法完成bean的注册</span></span><br><span class="line">scan(basePackages);</span><br><span class="line"><span class="comment">//核心方法</span></span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationConfigApplicationContext#scan</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line"><span class="comment">//扫描包，进行Bean注册</span></span><br><span class="line">doScan(basePackages);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容器启动核心-AbstractApplicationContext-refresh"><a href="#容器启动核心-AbstractApplicationContext-refresh" class="headerlink" title="容器启动核心 AbstractApplicationContext#refresh()"></a>容器启动核心 AbstractApplicationContext#refresh()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext#refresh()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">// 准备初始化容器工作，设置启动标志、记录启动时间等</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 beanFactory, 并加载bean定义等</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">// beanFactory注入一些标准组件，例如ApplicationContextAwareProcessor，ClassLoader等</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">// 给实现类留的一个钩子，例如注入BeanPostProcessors，这里是个空方法 </span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">// 调用在上下文中注册为bean的工厂处理器。</span></span><br><span class="line"><span class="comment">// 执行 BeanFactoryPostProcessor 实现类的 postProcessBeanFactory()方法</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">// 注册 BeanPostProcessor 实现类</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line"><span class="comment">// 国际化资源处理</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">// bean工厂注册一个key为applicationEventMulticaster的广播器 用于事件广播</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">// 给实现类留的一钩子，可以执行其他refresh的工作，比如启动tomcat server</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">// 注册事件监听器</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">// 完成单例bean的初始化</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">// 完成容器启动，发布容器启动事件</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line"><span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doGetBean-Bean是如何从IOC容器中被获取到的"><a href="#doGetBean-Bean是如何从IOC容器中被获取到的" class="headerlink" title="doGetBean - Bean是如何从IOC容器中被获取到的"></a>doGetBean - Bean是如何从IOC容器中被获取到的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo#applicationContext.getBean</span></span><br><span class="line">ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">User user = (User) applicationContext.getBean(<span class="string">&quot;userBean&quot;</span>);</span><br><span class="line">System.out.println(user.getUserName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractApplicationContext#getBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanFactory#getBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanFactory#doGetBean</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理别名BeanName、处理带&amp;符的工厂BeanName</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从单例缓存中获取对象</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果 sharedInstance 是普通的 Bean 实例，则下面的方法会直接返回</span></span><br><span class="line"><span class="comment">// 2. 如果 sharedInstance 是 FactoryBean 类型，则需要获取 getObject 方法，可以参考关于 FactoryBean 的实现类 </span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 循环依赖有三种，setter注入、多实例和构造函数，Spring 只能解决 setter 注入，所以这里是 Prototype 则会抛出异常</span></span><br><span class="line"><span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 父 bean 工厂存在</span></span><br><span class="line"><span class="comment">// 2. 当前 bean 不存在于当前bean工厂，则到父工厂查找 bean 实例</span></span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line"><span class="comment">// 获取 name 对应的 beanName，如果 name 是以 &amp; 开头，则返回 &amp; + beanName</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. typeCheckOnly，用于判断调用 getBean 方法时，是否仅是做类型检查</span></span><br><span class="line"><span class="comment">// 2. 如果不是只做类型检查，就会调用 markBeanAsCreated 进行记录</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里通过beanName获取相关信息来组装RootBeanDefinition</span></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// 检查当前创建的 bean 定义是否为抽象 bean 定义</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前Bean的依赖项</span></span><br><span class="line"><span class="comment">// 在实例化自己之前，需要先实例化自己依赖的bean</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="comment">// 监测是否存在 depends-on 循环依赖，若存在则会抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册依赖记录</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加载 depends-on 依赖（dep 是 depends-on 缩写）</span></span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处开始创建实例对象</span></span><br><span class="line"><span class="comment">// 单例的对象创建</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 把 beanName 和 new ObjectFactory 匿名内部类传入回调</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建 bean</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line"><span class="comment">// 创建失败则销毁</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prototype 原型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line"><span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"><span class="comment">// 如果需要类型转换，这里会进行操作</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line"><span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> convertedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doGetBean()方法基本上概括了整个Bean的获取过程</p><ul><li>首先通过BeanName从容器中获取Bean相关的信息，并组装成RootBeanDefinition</li><li>通过RootBeanDefinition来创建实例对象，这里需要根据单例、多例来分别进行创建</li><li>将创建或者获取到的对象返回<br>  单例对象是容器启动的时候就已经实例化好了，可以直接拿来用，当然也可以设置延迟加载</li></ul><h3 id="doCreateBean-Bean的创建"><a href="#doCreateBean-Bean的创建" class="headerlink" title="doCreateBean - Bean的创建"></a>doCreateBean - Bean的创建</h3><p><img src="/posts/3526/getbean-createbean.png"></p><p>在判断 mbd.isSingleton() 单例以后，开始使用基于 ObjectFactory 包装的方式创建 createBean，进入后核心逻辑是开始执行 doCreateBean 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#doCreateBean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanWrapper封装了具体的Bean实例，然后可以很方便地通过调用getPropertyValue和setPropertyValue等方法反射读写Bean的具体属性</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 先尝试从缓存中取</span></span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 调用构造方法创建一个空实例对象，并用BeanWrapper进行包装</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的后置处理器，如果后置处理器实现了MergedBeanDefinitionPostProcessor接口，则一次调用其postProcessMergedBeanDefinition方法</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果满足循环依赖缓存条件，先缓存具体对象</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环依赖处理逻辑：将已完成实例化，但是未完成属性赋值和相关的初始化的一个不完整的 bean 添加到三级缓存 singletonFactories 中</span></span><br><span class="line"><span class="comment">// 具体内部会遍历后置处理器，判断是否有SmartInstantiationAwareBeanPostProcessor的实现类，然后调用里面getEarlyBeanReference覆盖当前Bean</span></span><br><span class="line"><span class="comment">// 默认不做任何操作返回当前Bean，作为拓展，这里比如可以供AOP来创建代理类</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始对Bean实例进行初始化</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 对bean进行属性填充，在这里面完成依赖注入的相关内容</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 完成属性依赖注入后，进一步初始化Bean</span></span><br><span class="line"><span class="comment">// 具体进行了以下操作：</span></span><br><span class="line"><span class="comment">// 1.若实现了BeanNameAware， BeanClassLoaderAware，BeanFactoryAwareAware等接口，则注入相关对象</span></span><br><span class="line"><span class="comment">// 2.遍历后置处理器，调用实现的postProcessBeforeInitialization方法，</span></span><br><span class="line"><span class="comment">// 3.如果实现了initialzingBean，调用实现的 afterPropertiesSet()</span></span><br><span class="line"><span class="comment">// 4.如果配置了init-mothod，调用相应的init方法</span></span><br><span class="line"><span class="comment">// 5.遍历后置处理器，调用实现的postProcessAfterInitialization</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果实现了Disposable接口，会在这里进行注册，最后在销毁的时候调用相应的destroy方法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 bean 实例</span></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 doCreateBean 方法中包括的内容较多，但核心主要是创建实例、加入缓存以及最终进行属性填充，属性填充就是把一个 bean 的各个属性字段涉及到的类填充进去。</li><li>createBeanInstance，创建 bean 实例，并将 bean 实例包装到 BeanWrapper 对象中返回</li><li>addSingletonFactory，添加 bean 工厂对象到 singletonFactories 缓存中</li><li>getEarlyBeanReference，获取原始对象的早期引用，在 getEarlyBeanReference 方法中，会执行 AOP 相关逻辑。若 bean 未被 AOP 拦截，getEarlyBeanReference 原样返回 bean。</li><li>populateBean，填充属性，解析依赖关系。也就是从这开始去找寻 A 实例中属性 B，紧接着去创建 B 实例，最后在返回回来。</li><li>initializeBean(beanName, exposedObject, mbd)：完成 bean 的属性填充注入后，进一步初始化 bean，在此过程中产生代理对象。此时 bean 的创建工作正式完成，已经可以在项目中使用了</li></ul><h4 id="populateBean-bean属性填充"><a href="#populateBean-bean属性填充" class="headerlink" title="populateBean - bean属性填充"></a>populateBean - bean属性填充</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory#populateBean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line"><span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line"><span class="comment">// to support styles of field injection.</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="comment">// 根据bean的依赖注入方式：即是否标注有 @Autowired 注解或 autowire=“byType/byName” 的标签</span></span><br><span class="line"><span class="comment">// 会遍历bean中的属性，根据类型或名称来完成相应的注入</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line"><span class="comment">// 深拷贝当前已有的配置</span></span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据名称进行注入</span></span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据类型进行注入</span></span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合注入后的配置，覆盖当前配置</span></span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器是否注册了InstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="keyword">if</span> (hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否进行依赖检查</span></span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 将pvs上所有的属性填充到BeanWrapper对应的Bean实例中</span></span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean的存储及Spring-bean的三级缓存"><a href="#Bean的存储及Spring-bean的三级缓存" class="headerlink" title="Bean的存储及Spring bean的三级缓存"></a>Bean的存储及Spring bean的三级缓存</h3><h4 id="Bean的存储"><a href="#Bean的存储" class="headerlink" title="Bean的存储"></a>Bean的存储</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>存储 bean 的 map 在<code>DefaultListableBeanFactory</code>类中。<br>通常叫BeanDefinition接口为 : bean的定义对象。<br>可以认为BeanDefinition是一个中转站，这个中转站中，存放了所有的class对应的信息，如果是初始化，就根据BeanDefinition的属性信息去初始化。</p><h4 id="Bean的三级缓存"><a href="#Bean的三级缓存" class="headerlink" title="Bean的三级缓存"></a>Bean的三级缓存</h4><p>采用三级缓存模式来解决循环依赖问题。<br>Spring只是解决了单例模式下属性依赖的循环问题；Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第几级缓存 对应的map 说明</p><ul><li>第1级  Map&lt;String, Object&gt; singletonObjects<br>  用来存放已经完全创建好的单例 beanbeanName -&gt; bean 实例<br>  最基础的缓存，创建完并初始化（createBean）后的bean实例会放入，项目启动完成后获取bean实例时从此获取</li><li>第3级  Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories<br>  用来存放单例 bean 的 ObjectFactorybeanName -&gt; ObjectFactory 实例<br>  创建bean过程中用于处理循环依赖的临时缓存，由于只有在初始化时才知道有没有循环依赖，所以通过ObjectFactory临时<code>存储</code>刚创建完的bean，并延迟触发循环依赖时被引用的bean需要赋值当前bean时去获取当前bean的逻辑，且获取对象会作为当前bean的最终对象</li><li>第2级  Map&lt;String, Object&gt; earlySingletonObjects<br>  用来存放早期的 beanbeanName -&gt; bean 实例<br>  创建bean过程中用于处理循环依赖的临时缓存，搭配第三层缓存，用于其ObjectFactory返回对象的缓存，保证多个关联对象对当前bean的引用为同一个</li></ul><p>一个bean在创建过程中可能会产生两个对象：</p><ul><li>一个是循环依赖时需要设值给与此bean相互引用的其他bean的对象（getEarlyBeanReference）</li><li>一个是初始化后的对象（initializeBean）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="spring-beans"><a href="#spring-beans" class="headerlink" title="spring-beans"></a>spring-beans</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory，以Factory结尾，表示它是一个工厂(接口)， 它负责生产和管理bean的一个工厂。</p><p>在Spring中，BeanFactory是工厂的顶层接口，也是IOC容器的核心接口，因此BeanFactory中定义了管理Bean的通用方法，如 getBean 和 containsBean 等，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。BeanFactory只是个接口，并不是IOC容器的具体实现，所以Spring容器给出了很多种实现，如 DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等。</p><p>整套初始化方法及其标准顺序为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanNameAware#setBeanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanClassLoaderAware#setBeanClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanFactoryAware#setBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.EnvironmentAware#setEnvironment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.EmbeddedValueResolverAware#setEmbeddedValueResolver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ResourceLoaderAware#setResourceLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationEventPublisherAware#setApplicationEventPublisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.MessageSourceAware#setMessageSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationContextAware#setApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.ServletContextAware#setServletContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getInitMethodName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DisposableBean#destroy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span></span><br><span class="line"><span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例</span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到bean实例的Class类型</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span></span><br><span class="line">String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/3526/spring-beans-BeanFactory.png"></p><p>从BeanFactory接口的结构我们可以看出，通过getBean重载方法，为我们创建不同的Bean对象。<br>当然其也有很多工厂实现，例如我们用的最多的DefaultListableBeanFactory，还有SimpleJndiBeanFactory、StaticListableBeanFactory等等。</p><p>Spring工厂模式的应用还加入了反射及配置。通过对各种配置，例如xml、注解等等解析成BeanDefinition，然后根据不同工厂要求通过反射创建不同的Bean对象，这样开发过程中，我们可以将需要创建的对象通过配置等方式交给Bean工厂去完成，使用时直接获取便可。</p><p>Spring 中的 BeanFactory 就是<strong>简单工厂模式</strong>的体现。根据传入一个唯一的标识来获得 Bean 对象，但是在传入参数后创建还是传入参数前创建，要根据具体情况来定。</p><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>首先FactoryBean是一个Bean，但又不仅仅是一个Bean，这样听起来矛盾，但为啥又这样说呢？<br>其实在Spring中，所有的Bean都是由BeanFactory（也就是IOC容器）来进行管理的。<br>但对FactoryBean而言，这个FactoryBean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean，它的实现与设计模式中的<strong>工厂模式</strong>和修饰器模式类似。</p><p><img src="/posts/3526/spring-beans-FactoryBean.png"></p><p>FactoryBean表现的是一个工厂的职责。即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，通过常规的<code>ApplicationContext.getBean(beanId)</code>获取的不是FactoryBean这个直接对象，而是调用<code>FactoryBean.getObject()</code>生成的对象；<code>ApplicationContext.getBean(&amp;beanId)</code>，加上<code>&amp;</code>才能取得FactoryBean这个对象。</p><p><strong>FactoryBean使用场景</strong></p><ol><li>Spring 的 ProxyFactoryBean</li><li>Mybatis 中的 SqlSessionFactoryBean</li><li>dubbo 的 ReferenceBean</li></ol><p>FactoryBean的设计主要是为了进行扩展容器中Bean的创建方式，所以FactoryBean着重于自定义创建对象过程，同时FactoryBean都会放到容器中，FactoryBean所创建的Bean也会放入容器中。</p><h3 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个工厂，该工厂在调用时可以返回对象实例（可能是共享的或独立的）。</span></span><br><span class="line"><span class="comment"> * 此接口通常用于封装一个通用工厂，该工厂在每次调用时返回某个目标对象的新实例（原型）。</span></span><br><span class="line"><span class="comment"> * 这个接口类似于FactoryBean，但是后者的实现通常被定义为BeanFactory中的SPI实例，</span></span><br><span class="line"><span class="comment"> * 而这个类的实现通常是作为API提供给其他bean的（通过注入）。因此，getObject（）方法具有不同的异常处理行为。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the object type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Colin Sampaleanu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> FactoryBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此工厂管理的对象的实例（可能是共享的或独立的）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the resulting instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectFactory则只是一个普通的对象工厂接口。<br>在Spring中主要两处用了它：</p><ol><li>Object get(String name, ObjectFactory&lt;?&gt; objectFactory);<br> 这个方法的目的就是从对应的域中获取到指定名称的对象。<br> 为什么要传入一个objectFactory呢？主要是为了方便我们扩展自定义的域，而不是仅仅使用request，session等域。</li><li>void registerResolvableDependency(Class&lt;?&gt; dependencyType, @Nullable Object autowiredValue); <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> autowiredValue the corresponding autowired value. This may also be an* implementation of the &#123;<span class="doctag">@link</span> org.springframework.beans.factory.ObjectFactory&#125;* interface, which allows for lazy resolution of the actual target value.</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure> 从这段内容中我们能知道，autowiredValue这个参数可能就是一个ObjectFactory，主要是为了让注入点能够被延迟注入。<br> Spring通过这种方式注入了request、response等对象。<ul><li>beanFactory.registerResolvableDependency(ServletRequest.class, new RequestObjectFactory()); </li><li>beanFactory.registerResolvableDependency(ServletResponse.class, new ResponseObjectFactory()); </li><li>beanFactory.registerResolvableDependency(HttpSession.class, new SessionObjectFactory()); </li><li>beanFactory.registerResolvableDependency(WebRequest.class, new WebRequestObjectFactory());</li></ul></li></ol><h2 id="spring-context"><a href="#spring-context" class="headerlink" title="spring-context"></a>spring-context</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-ThreadLocal</title>
      <link href="/posts/15151.html"/>
      <url>/posts/15151.html</url>
      
        <content type="html"><![CDATA[<p>ThreadLocal是通过线程隔离的方式防止任务在共享资源上产生冲突, 线程本地存储是一种自动化机制，可以为使用相同变量的每个不同线程都创建不同的存储。</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ul><li><p>什么是ThreadLocal? 用来解决什么问题的? 说说你对ThreadLocal的理解</p></li><li><p>ThreadLocal是如何实现线程隔离的?<br>  主要是用到了<strong>Thread对象</strong>中的一个<strong>ThreadLocalMap类型的变量threadLocals</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment"> * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>为什么ThreadLocal会造成内存泄露? </p></li><li><p>如何解决还有哪些使用ThreadLocal的应用场景?</p></li></ul><h3 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h3><p><strong>内存泄漏（Memory Leak）</strong>是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><p>在java中就是存在已经没有任何引用的对象，但是GC又不能把对象所在的内存回收掉，所以就造成了内存泄漏。</p><h2 id="源码分析-ThreadLocal"><a href="#源码分析-ThreadLocal" class="headerlink" title="源码分析 ThreadLocal"></a>源码分析 ThreadLocal</h2><h3 id="散列算法-斐波那契散列法"><a href="#散列算法-斐波那契散列法" class="headerlink" title="散列算法 - 斐波那契散列法"></a>散列算法 - 斐波那契散列法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 神秘数字 0x61c88647</span></span><br><span class="line"><span class="comment">// 黄金分割点：(√5 - 1) / 2 = 0.6180339887</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算哈希</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下标</span></span><br><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="withInitial"><a href="#withInitial" class="headerlink" title="withInitial"></a>withInitial</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SuppliedThreadLocal"><a href="#SuppliedThreadLocal" class="headerlink" title="SuppliedThreadLocal"></a>SuppliedThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line"></span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析-ThreadLocalMap-重要！"><a href="#源码分析-ThreadLocalMap-重要！" class="headerlink" title="源码分析 ThreadLocalMap 重要！"></a>源码分析 ThreadLocalMap 重要！</h2><h3 id="Entry-WeakReference弱引用"><a href="#Entry-WeakReference弱引用" class="headerlink" title="Entry - WeakReference弱引用"></a>Entry - WeakReference弱引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key 是对 ThreadLocal 的一个弱引用。所以在没有外部强引用下，会发生GC，删除key。</p><h4 id="ThreadLocalMap类内部为什么用Entry数组，而不是Entry对象？"><a href="#ThreadLocalMap类内部为什么用Entry数组，而不是Entry对象？" class="headerlink" title="ThreadLocalMap类内部为什么用Entry数组，而不是Entry对象？"></a>ThreadLocalMap类内部为什么用Entry数组，而不是Entry对象？</h4><p>一个线程里，ThreadLocalMap是同一个，而不是多个，不管new几次ThreadLocal，ThreadLocalMap在一个线程里就一个。<br>ThreadLocalMap的引用是在Thread里的，所以它里面的Entry数组存放的是一个线程里new出来的多个ThreadLocal对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="设置元素-set"><a href="#设置元素-set" class="headerlink" title="设置元素 set"></a>设置元素 set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 清理过期key，判断是否扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>key.threadLocalHashCode &amp; (len-1);</code>，斐波那契散列，计算数组下标。</li><li><code>Entry</code>，是一个弱引用对象的实现类，所以在没有外部强引用下，会发生GC，删除key。</li><li>for循环判断元素是否存在，当前下标不存在元素时，直接设置元素 <code>tab[i] = new Entry(key, value);</code>。</li><li>如果元素存在，则会判断是否key值相等 <code>if (k == key)</code>，相等则更新值。</li><li>如果不相等，就到了 <code>replaceStaleEntry</code>，探测式清理过期元素。</li></ol><h3 id="元素清理-remove"><a href="#元素清理-remove" class="headerlink" title="元素清理 remove"></a>元素清理 remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="探测式清理-expungeStaleEntry"><a href="#探测式清理-expungeStaleEntry" class="headerlink" title="探测式清理 expungeStaleEntry"></a>探测式清理 expungeStaleEntry</h4><p>探测式清理，是以当前遇到的 GC 元素开始，向后不断的清理。直到遇到 null 为止，才停止 rehash 计算。</p><p><code>Rehash until we encounter null</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启发式清理-cleanSomeSlots"><a href="#启发式清理-cleanSomeSlots" class="headerlink" title="启发式清理 cleanSomeSlots"></a>启发式清理 cleanSomeSlots</h4><p>试探的扫描一些单元格，寻找过期元素，也就是被垃圾回收的元素。<br>当添加新元素或删除另一个过时元素时，将调用此函数。<br>它执行对数扫描次数，作为不扫描（快速但保留垃圾）和与元素数量成比例的扫描次数之间的平衡，这将找到所有垃圾，但会导致一些插入花费O（n）时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while 循环中不断的右移进行寻找需要被清理的过期元素，最终都会使用 <code>expungeStaleEntry</code> 进行处理，这里还包括元素的移位。</p><h2 id="源码分析-InheritableThreadLocal"><a href="#源码分析-InheritableThreadLocal" class="headerlink" title="源码分析 InheritableThreadLocal"></a>源码分析 InheritableThreadLocal</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes the child&#x27;s initial value for this inheritable thread-local</span></span><br><span class="line"><span class="comment">     * variable as a function of the parent&#x27;s value at the time the child</span></span><br><span class="line"><span class="comment">     * thread is created.  This method is called from within the parent</span></span><br><span class="line"><span class="comment">     * thread before the child is started.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method merely returns its input argument, and should be overridden</span></span><br><span class="line"><span class="comment">     * if a different behavior is desired.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentValue the parent thread&#x27;s value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the child thread&#x27;s initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the map associated with a ThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析-Thread"><a href="#源码分析-Thread" class="headerlink" title="源码分析 Thread"></a>源码分析 Thread</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes a Thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g                   线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target              run() 方法被调用的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name                新线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize           新线程所需的堆栈大小，或为零表示要忽略此参数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc                 要继承的 AccessControlContext，如果为 null，则为 AccessController.getContext()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritThreadLocals 如果 &#123;<span class="doctag">@code</span> true&#125;，从构造线程继承可继承线程局部变量的初始值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.addUnstarted();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一项inheritThreadLocals 是传进来的boolean值，重载时传的是true，</span></span><br><span class="line">    <span class="comment">// 第二项就是判断父线程中的inheritableThreadLocals属性是否为空，不为空的话</span></span><br><span class="line">    <span class="comment">// 两个条件同时满足，把父线程的inheritableThreadLocals复制给子线程</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 则新创建出来的子线程的inheritableThreadLocals 变量就和父线程的inheritableThreadLocals 的内容一样了。</span></span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">  </span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/posts/14457.html"/>
      <url>/posts/14457.html</url>
      
        <content type="html"><![CDATA[<p>ElasticSearch是一款非常强大的、基于Lucene的开源搜索及分析引擎，它是一个实时的分布式<strong>全文</strong>搜索分析引擎。<br>ES中的数据都是来自于MySQL，用ES的目的不是来持久化数据的，而是因为它的数据检索、复杂数据分析的效率极高，用它来完成检索、分析的功能。</p><p>它被用作<strong>全文检索、结构化搜索、分析</strong>以及这三个功能的组合：</p><ul><li>Wikipedia 使用 Elasticsearch 提供带有高亮片段的全文搜索，还有 search-as-you-type 和 did-you-mean 的建议。</li><li>卫报 使用 Elasticsearch 将网络社交数据结合到访客日志中，为它的编辑们提供公众对于新文章的实时反馈。</li><li>Stack Overflow 将地理位置查询融入全文检索中去，并且使用 more-like-this 接口去查找相关的问题和回答。</li><li>GitHub 使用 Elasticsearch 对1300亿行代码进行查询。</li></ul><p>除了搜索，结合<strong>Kibana、Logstash、Beats</strong>开源产品，<strong>Elastic Stack（简称ELK）</strong>还被广泛运用在大数据近实时分析领域，包括：日志分析、指标监控、信息安全等。它可以帮助你探索海量结构化、非结构化数据，按需创建可视化报表，对监控数据设置报警阈值，通过使用机器学习，自动识别异常状况。</p><p>ElasticSearch是基于Restful WebApi，使用Java语言开发的搜索引擎库类，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。其客户端在Java、C#、PHP、Python等许多语言中都是可用的。</p><h2 id="基础概念-全文搜索"><a href="#基础概念-全文搜索" class="headerlink" title="基础概念 - 全文搜索"></a>基础概念 - 全文搜索</h2><p>从全文数据中进行检索。</p><p>数据可分为：</p><ul><li>结构化数据<br>  指具有<strong>固定格式</strong>或<strong>有限长度</strong>的数据，如数据库、元数据等，可以用二维表结构来逻辑表达实现的数据</li><li>非结构化数据<br>  指不定长或无固定格式的数据，如邮件，word文档等。<br>  非结构化数据是数据结构不规则或不完整，没有预定义的数据模型，不方便用数据库二维逻辑表来表现的数据，包括所有格式的办公文档、文本、图片、各类报表、图像和音频/视频信息等等。</li><li>半结构化数据<br>  如XML、HTML等，当根据需要可按结构化数据来处理，也可抽取出纯文本按非结构化数据来处理。</li></ul><p>对于结构化数据，因为它们具有特定的结构，所以我们一般都是可以通过关系型数据库（MySQL、Oracle的）的二维表（Table）的方式存储和搜索，对表可以建立索引。</p><p><strong>对于非结构化数据，也即对全文数据的搜索主要有两种方法：</strong></p><ul><li><strong>顺序扫描</strong><br>  按照顺序扫描的方式查询特定的关键字。</li><li><strong>全文检索</strong><br>  将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。</li></ul><h2 id="基础概念-Lucene"><a href="#基础概念-Lucene" class="headerlink" title="基础概念 - Lucene"></a>基础概念 - Lucene</h2><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>Lucene能实现全文搜索主要是因为它实现了倒排索引的查询结构。<br>Elasticsearch是通过Lucene的倒排索引技术实现比关系型数据库更快的过滤。<br><strong>思考：其比关系型数据库的B+树索引快在哪里？为什么快？</strong></p><p>如何理解倒排索引呢？假如现有三份数据文档，文档的内容分别是：</p><ul><li>Java is the best programming language.</li><li>PHP is the best programming language.</li><li>Javascript is the best programming language.</li></ul><p>为了创建倒排索引，通过分词器将每个文档的内容域拆分成单独的词（称它为<strong>词条</strong>或<strong>Term</strong>），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。<br>结果如下所示：</p><table><thead><tr><th align="left">Term</th><th align="center">Doc_1</th><th align="center">Doc_2</th><th align="center">Doc_3</th></tr></thead><tbody><tr><td align="left">Java</td><td align="center">X</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">is</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">the</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">best</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">programming</td><td align="center">x</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">language</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">PHP</td><td align="center"></td><td align="center">X</td><td align="center"></td></tr><tr><td align="left">Javascript</td><td align="center"></td><td align="center"></td><td align="center">X</td></tr></tbody></table><p>这种结构由文档中所有不重复词的列表构成，对于其中每个词都有一个文档列表与之关联。<br>这种由属性值来确定记录的位置的结构就是<strong>倒排索引</strong>。<br><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%9F%BA%E7%A1%80-lucene%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png"></p><ul><li><strong>词条（Term）</strong><br>  索引里面最小的存储和查询单元，对于英文来说是一个单词，对于中文来说一般指分词后的一个词。</li><li><strong>词典（Term Dictionary）</strong><br>  或字典，是<strong>词条 Term 的集合</strong>。<br>  搜索引擎的通常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</li><li><strong>倒排表（Post list）</strong><br>  一个文档通常由多个词组成，倒排表记录的是某个词在哪些文档里出现过以及出现的位置。每条记录称为一个倒排项（Posting）。倒排表记录的不单是文档编号，还存储了词频等信息。</li><li><strong>倒排文件（Inverted FIle）</strong><br>  所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</li></ul><p>词典和倒排表是 Lucene 中很重要的两种数据结构，是实现快速检索的重要基石。词典和倒排文件是分两部分存储的，<strong>词典在内存中，而倒排文件存储在磁盘上。</strong></p><h3 id="Lucene索引结构"><a href="#Lucene索引结构" class="headerlink" title="Lucene索引结构"></a>Lucene索引结构</h3><p>Lucene的索引结构中有哪些文件？<br><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%9F%BA%E7%A1%80-lucene%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-%E6%96%87%E4%BB%B6.png"></p><p>文件的关系如下：<br><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%9F%BA%E7%A1%80-lucene%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-%E6%96%87%E4%BB%B6%E5%85%B3%E7%B3%BB.jpeg"></p><h3 id="Lucene段概念"><a href="#Lucene段概念" class="headerlink" title="Lucene段概念"></a>Lucene段概念</h3><h4 id="分段存储"><a href="#分段存储" class="headerlink" title="分段存储"></a>分段存储</h4><p>在早期的全文检索中为整个文档集合建立了一个很大的倒排索引，并将其写入磁盘中，如果索引有更新，就需要重新全量创建一个索引来替换原来的索引。这种方式在数据量很大时效率很低，并且由于创建一次索引的成本很高，所以对数据的更新不能过于频繁，也就不能保证时效性。<br>所以，在搜索中引入了<strong>段</strong>的概念，将一个Lucene Index索引文件拆分为多个子文件，每个子文件叫做段，每个段本身都是一个倒排索引，并且段具有不变性，一旦索引的数据被写入硬盘，就不可再修改。</p><p>段被写入到磁盘后会生成一个提交点，提交点是一个用来记录所有提交后段信息的文件。<br>一个段一旦拥有了提交点，就说明这个段只有读的权限，失去了写的权限。相反，当段在内存中时，就只有写的权限，而不具备读数据的权限，意味着不能被检索。</p><p>在分段的思想下，对数据写操作的过程如下：</p><ul><li>新增<br>  当有新的数据需要创建索引时，由于段的不变形，所以选择新建一个段来存储新增的数据。</li><li>删除<br>  当需要删除数据时，由于数据所在的段只可读，不可写，所以Lucene在索引文件下新增了一个<code>.del</code>的文件，用来专门存储被删除的数据id。<br>  当查询时，被删除的数据还是可以被查到的，只是在进行文档链表合并时，才把已经删除的数据过滤掉。<strong>被删除的数据在进行段合并时才会真正被移除</strong>。</li><li>更新<br>  更新的操作其实就是删除和新增的组合，先在<code>.del</code>文件中记录旧数据，再在新段中添加一条更新后的数据。</li></ul><p>段不变性的优点如下：</p><ul><li>不需要锁。因为数据不会更新，所以不用考虑多线程下的读写不一致情况。</li><li>可以常驻内存。段在被加载到内存后，由于具有不变性，所以只要内存的空间足够大，就可以长时间驻存，大部分查询请求会直接访问内存，而不需要访问磁盘，使得查询的性能有很大的提升。</li><li>缓存友好。在段的生命周期内始终有效，不需要在每次数据更新时被重建。</li><li>增量创建。分段可以做到增量创建索引，可以轻量级地对数据进行更新，由于每次创建的成本很低，所以可以频繁地更新数据，使系统接近实时更新。</li></ul><p>段不变性的缺点如下：</p><ul><li>当对数据进行删除时，旧数据不会被马上删除，而是在.del文件中被标记为删除。而旧数据只能等到段更新时才能真正被移除，这样会有大量的空间浪费。</li><li>更新。更新数据由删除和新增这两个动作组成。若有一条数据频繁更新，则会有大量的空间浪费。</li><li>由于索引具有不变性，所以每次新增数据时，都需要新增一个段来存储数据。当段的数量太多时，对服务器的资源（如文件句柄）的消耗会非常大，查询的性能也会受到影响。</li><li>在查询后需要对已经删除的旧数据进行过滤，这增加了查询的负担。</li></ul><h4 id="延迟写策略"><a href="#延迟写策略" class="headerlink" title="延迟写策略"></a>延迟写策略</h4><p>为了提升写的性能，ES 并没有每新增一条数据就增加一个段到磁盘上，而是采用延迟写的策略。</p><p>每当有新增的数据时，就将其先写入到内存中，在内存和磁盘之间是文件系统缓存。<br>当达到默认的时间（1 秒钟）或者内存的数据达到一定量时，会触发一次刷新（Refresh），将内存中的数据生成到一个新的段上并缓存到文件缓存系统 上，稍后再被刷新到磁盘中并生成提交点。<br>这里的内存使用的是 ES 的 JVM 内存，而文件缓存系统使用的是操作系统的内存。<br>新的数据会继续的被写入内存，但内存中的数据并不是以段的形式存储的，因此不能提供检索功能。<br>由内存刷新到文件缓存系统的时候会生成新的段，并将段打开以供搜索使用，而不需要等到被刷新到磁盘。<br>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 Refresh （即内存刷新到文件缓存系统）。<br>默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是近实时搜索，因为文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p><h4 id="段合并策略"><a href="#段合并策略" class="headerlink" title="段合并策略"></a>段合并策略</h4><p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。<br>每一个段都会消耗文件句柄、内存和 CPU 运行周期。更重要的是，每个搜索请求都必须轮流检查每个段然后合并查询结果，所以段越多，搜索也就越慢。<br>Elasticsearch 通过在后台定期进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p><p>根据段的大小先将段进行分组，再将属于同一组的段进行合并。但是由于对超级大的段的合并需要消耗更多的资源，所以Lucene会在段的大小达到一定规模，或者段里面的数据量达到一定条数时，不会再进行合并。<br>所以Lucene的段合并主要集中在对中小段的合并上，这样既可以避免对大段进行合并时消耗过多的服务器资源，也可以很好地控制索引中段的数量。</p><h2 id="基础概念-ElasticSearch"><a href="#基础概念-ElasticSearch" class="headerlink" title="基础概念 - ElasticSearch"></a>基础概念 - ElasticSearch</h2><ul><li><strong>cluster 集群</strong><br>  一个集群由一个唯一的名字标识，默认为“elasticsearch”。<br>  每个节点配置相同的 cluster.name 即可加入集群，集群名称可以在配置文件中指定。</li><li><strong>node 节点</strong></li><li><strong>Index 索引</strong><br>  一个索引是一个文档的集合。每个索引有唯一的名字，通过这个名字来操作它。一个集群中可以有任意多个索引。<br>  <img src="/posts/14457/es-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-index-shard-dev.png" alt="3个节点 2个index 各3个分片 零副本"><br>  <img src="/posts/14457/es-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-index-shard-prod.png" alt="3个节点 1个index 3个分片 2个副本"><ul><li><strong>shard 分片</strong><br>  ES支持PB级全文搜索，当某个索引上的数据量太大的时候，ES通过水平拆分的方式讲一个索引上的数据拆分出来分配到不同的数据块上，拆分出来的数据块称为一个分片。<br>  在创建索引的时候需要指定分片的数量，并且分片的数量一旦确定就不能修改，在一个多分片的索引中写入数据时，通过路由来确定具体写入哪一个分片中。<br>  <strong>ES中的每个shard分片本质上是Lucene中的一个索引文件</strong>，一个ES索引是分片的集合。<br>  当 Elasticsearch 在索引中搜索的时候，它发送查询到每一个属于索引的分片（Lucene 索引），然后合并每个分片的结果到一个全局的结果集。</li><li><strong>replica 副本</strong><br>  在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的， Elasticsearch 允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。</li></ul></li><li><strong>type 类型</strong><br>  指在一个索引中，可以索引不同类型的文档，如用户数据、博客数据。<br>  从6.0版本起已废弃。7.0版本及之后，<strong>一个index中只有一个默认的type，即_doc</strong>。</li><li><strong>document 文档</strong><br>  被索引的一条数据，索引的基本信息单元，以JSON格式来表示。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;:, 代表操作的哪个 index(库)</span><br><span class="line">    &quot;_type&quot;:, 代表操作的哪个 type(表)</span><br><span class="line">    &quot;_id&quot;:    , 每条记录 都有一个 唯一标识，当无法判断是更新，还是insert操作的时候，看展示的_id,有没有变化，</span><br><span class="line">                有就是insert了一条新记录，没有就是 更新操作</span><br><span class="line">                还有可能是 没有执行更新/insert操作</span><br><span class="line">    &quot;_version&quot;:    , 代表这条记录的版本号（根据版本号，可以得知此记录是否被修改过，修改一次，版本号就会变化一次）</span><br><span class="line">    &quot;_source&quot;:    , json记录本体信息</span><br><span class="line">    &quot;_seq_no&quot;:    , 并发控制字段，每次更新+1，用来做乐观锁</span><br><span class="line">            应用：在 更新请求后加上 ?if_seq_no = 此时记录的 seq_no &amp; if_primary_term = 此时记录的 primary_term</span><br><span class="line">            这时如果，更新操作的时候，如果记录的 _seq_no != if_seq_no 的值，那么无法更新</span><br><span class="line">            这样当两个请求，同时操作这条记录的时候，一个请求已经更新了记录，那么 _seq_no + 1，下一个请求就无法 完成更新操作了</span><br><span class="line">    &quot;_primary&quot;:    , 集群，主分片重新分配，如重启，就会变化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/posts/14457/es-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-rdbms%E5%AF%B9%E7%85%A7%E5%85%B3%E7%B3%BB-.png"></p><h3 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群 Cluster"></a>集群 Cluster</h3><p>ES 的集群搭建很简单，不需要依赖第三方协调管理组件，自身内部就实现了集群的管理功能。<br>ES 集群由一个或多个 Elasticsearch 节点组成，每个节点配置相同的 cluster.name 即可加入集群，默认值为 “elasticsearch”。<br>确保不同的环境中使用不同的集群名称，否则最终会导致节点加入错误的集群。<br>一个 Elasticsearch 服务启动实例就是一个节点（Node）。节点通过 node.name 来设置节点名称，如果不设置则在启动时给节点分配一个随机通用唯一标识符作为名称。</p><h4 id="发现机制"><a href="#发现机制" class="headerlink" title="发现机制"></a>发现机制</h4><p>ES 内部是如何通过一个相同的设置 cluster.name 就能将不同的节点连接到同一个集群的？<br>答案是 <strong>Zen Discovery</strong>。</p><p>Zen Discovery 是 Elasticsearch 的内置默认发现模块（发现模块的职责是<strong>发现集群中的节点</strong>以及<strong>选举 Master 节点</strong>）。<br>它提供单播和基于文件的发现，并且可以扩展为通过插件支持云环境和其他形式的发现。</p><p><strong>Todo: Elasticsearch服务发现以及选主的具体流程？</strong></p><p>由于它支持任意数目的集群（ 1- N ），所以不能像 Zookeeper 那样限制节点必须是奇数，也就无法用投票的机制来选主，而是通过一个规则。<br>只要所有的节点都遵循同样的规则，得到的信息都是对等的，选出来的主节点肯定是一致的。<br>但分布式系统的问题就出在信息不对等的情况，这时候很容易出现脑裂（Split-Brain）的问题。<br>大多数解决方案就是设置一个 Quorum 值，要求可用节点必须大于 Quorum（一般是超过半数节点），才能对外提供服务。<br>而 Elasticsearch 中，这个 Quorum 的配置就是 discovery.zen.minimum_master_nodes 。</p><h4 id="节点的角色"><a href="#节点的角色" class="headerlink" title="节点的角色"></a>节点的角色</h4><p>每个节点既可以是候选主节点也可以是数据节点，通过在配置文件<code>../config/elasticsearch.yml</code>中设置即可，默认都为 true。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span>  <span class="string">//是否候选主节点</span>  </span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span>    <span class="string">//是否数据节点</span> </span><br></pre></td></tr></table></figure><ul><li>数据节点<br>  数据节点负责数据的存储和相关的操作，例如对数据进行增、删、改、查和聚合等操作，所以数据节点（Data 节点）对机器配置要求比较高，对 CPU、内存和 I/O 的消耗很大。<br>  通常随着集群的扩大，需要增加更多的数据节点来提高性能和可用性。</li><li>候选主节点<br>  候选主节点可以被选举为主节点（Master 节点），集群中只有候选主节点才有选举权和被选举权，其他节点不参与选举的工作。</li><li>主节点<br>  主节点负责创建索引、删除索引、跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点、追踪集群中节点的状态等，稳定的主节点对集群的健康是非常重要的。</li></ul><p>一个节点既可以是候选主节点也可以是数据节点，但是由于数据节点对 CPU、内存核 I/O 消耗都很大。<br>所以如果某个节点既是数据节点又是主节点，那么可能会对主节点产生影响从而对整个集群的状态产生影响。<br>因此为了提高集群的健康性，我们应该对 Elasticsearch 集群中的节点做好角色上的划分和隔离。可以使用几个配置较低的机器群作为候选主节点群。</p><p>主节点和其他节点之间通过 Ping 的方式互检查，主节点负责 Ping 所有其他节点，判断是否有节点已经挂掉。其他节点也通过 Ping 的方式判断主节点是否处于可用状态。<br>虽然对节点做了角色区分，但是用户的请求可以发往任何一个节点，并由该节点负责分发请求、收集结果等操作，而不需要主节点转发。<br>这种节点可称之为<strong>协调节点</strong>，协调节点是不需要指定和配置的，集群中的任何节点都可以充当协调节点的角色。</p><h4 id="脑裂现象"><a href="#脑裂现象" class="headerlink" title="脑裂现象"></a>脑裂现象</h4><p>同时如果由于网络或其他原因导致集群中选举出多个 Master 节点，使得数据更新时出现不一致，这种现象称之为<strong>脑裂</strong>，即集群中不同的节点对于 Master 的选择出现了分歧，出现了多个 Master 竞争。</p><p>“脑裂”问题可能有以下几个原因造成：</p><ul><li>网络问题<br>  集群间的网络延迟导致一些节点访问不到 Master，认为 Master 挂掉了从而选举出新的 Master，并对 Master 上的分片和副本标红，分配新的主分片。</li><li>节点负载<br>  主节点的角色既为 Master 又为 Data，访问量较大时可能会导致 ES 停止响应（假死状态）造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。</li><li>内存回收<br>  主节点的角色既为 Master 又为 Data，当 Data 节点上的 ES 进程占用的内存较大，引发 JVM 的大规模内存回收，造成 ES 进程失去响应。</li></ul><p>为了避免脑裂现象的发生，我们可以从原因着手通过以下几个方面来做出优化措施：</p><ul><li>适当调大响应时间，减少误判。<br>  通过参数 <code>discovery.zen.ping_timeout</code> 设置节点状态的响应时间，默认为 3s，可以适当调大。<br>  如果 Master 在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如 6s，discovery.zen.ping_timeout:6），可适当减少误判。</li><li>选举触发。<br>  我们需要在候选集群中的节点的配置文件中设置参数 <code>discovery.zen.munimum_master_nodes</code> 的值。<br>  这个参数表示在选举主节点时需要参与选举的候选主节点的节点数，默认值是 1，官方建议取值<code>(master_eligibel_nodes / 2) + 1</code>，其中 <code>master_eligibel_nodes</code> 为候选主节点的个数。<br>  这样做既能防止脑裂现象的发生，也能最大限度地提升集群的高可用性，因为只要不少于 discovery.zen.munimum_master_nodes 个候选节点存活，选举工作就能正常进行。<br>  当小于这个值的时候，无法触发选举行为，集群无法使用，不会造成分片混乱的情况。</li><li>角色分离。<br>  即是上面我们提到的候选主节点和数据节点进行角色分离，这样可以减轻主节点的负担，防止主节点的假死状态发生，减少对主节点“已死”的误判。</li></ul><h3 id="分片-Shard"><a href="#分片-Shard" class="headerlink" title="分片 Shard"></a>分片 Shard</h3><p>ES 支持 PB 级全文搜索，当索引上的数据量太大的时候，ES 通过水平拆分的方式将一个索引上的数据拆分出来分配到不同的数据块上，拆分出来的数据库块称之为一个分片。<br>这类似于 MySQL 的分库分表，只不过 MySQL 分库分表需要借助第三方组件而 ES 内部自身实现了此功能。</p><p>在一个多分片的索引中写入数据时，通过路由来确定具体写入哪一个分片中，所以在创建索引的时候需要指定分片的数量，并且分片的数量一旦确定就不能修改。<br>分片的数量和下面介绍的副本数量都是可以通过创建索引时的 Settings 来配置，ES 默认为一个索引创建 5 个主分片, 并分别为每个分片创建一个副本。</p><p>ES 通过分片的功能使得索引在规模上和性能上都得到提升，<strong>每个分片都是 Lucene 中的一个索引文件，每个分片必须有一个主分片和零到多个副本。</strong></p><h3 id="副本-Replica"><a href="#副本-Replica" class="headerlink" title="副本 Replica"></a>副本 Replica</h3><p>副本就是对分片的 Copy，每个主分片都有一个或多个副本分片，当主分片异常时，副本可以提供数据的查询等操作。<br>主分片和对应的副本分片是不会在同一个节点上的，所以副本分片数的最大值是 N-1（其中 N 为节点数）。</p><p>对文档的新建、索引和删除请求都是写操作，必须在主分片上面完成之后才能被复制到相关的副本分片。<br>ES 为了提高写入的能力这个过程是并发写的，同时为了解决并发写的过程中数据冲突的问题，ES 通过乐观锁的方式控制，每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。<br>一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功。</p><p>将数据分片是为了提高可处理数据的容量和易于进行水平扩展，为分片做副本是为了提高集群的稳定性和提高并发量。<br>副本越多，集群的可用性就越高，但是由于每个分片都相当于一个 Lucene 的索引文件，会占用一定的文件句柄、内存及 CPU。并且分片间的数据同步也会占用一定的网络带宽，所以索引的分片数和副本数也不是越多越好。</p><h3 id="映射-Mapping"><a href="#映射-Mapping" class="headerlink" title="映射 Mapping"></a>映射 Mapping</h3><p>映射是用于定义 ES 对索引中字段的存储类型、分词方式和是否存储等信息，就像数据库中的 Schema ，描述了文档可能具有的字段或属性、每个字段的数据类型。</p><p>ES（v6.8）中字段数据类型主要有以下几类：</p><table><thead><tr><th align="left">类型</th><th align="left">数据类型</th></tr></thead><tbody><tr><td align="left">核心类型</td><td align="left">text、keywords、long、integer、short、double、data、boolean等</td></tr><tr><td align="left">复杂类型</td><td align="left">Object、Nested</td></tr><tr><td align="left">地理类型</td><td align="left">geo_point、get_shape</td></tr><tr><td align="left">特殊类型</td><td align="left">ip、completion、token_count、join等</td></tr></tbody></table><p>Text 用于索引全文值的字段，例如电子邮件正文或产品说明。这些字段是被分词的，它们通过分词器传递，以在被索引之前将字符串转换为单个术语的列表。<br>分析过程允许 Elasticsearch 搜索单个单词中每个完整的文本字段。文本字段不用于排序，很少用于聚合。</p><p>Keyword 用于索引结构化内容的字段，例如电子邮件地址，主机名，状态代码，邮政编码或标签。它们通常用于过滤，排序，和聚合。Keyword 字段只能按其确切值进行搜索。</p><h2 id="Elastic-Stack生态"><a href="#Elastic-Stack生态" class="headerlink" title="Elastic Stack生态"></a>Elastic Stack生态</h2><p>Beats + Logstash + ElasticSearch + Kibana</p><p><img src="/posts/14457/es-elk%E7%94%9F%E6%80%81.png"></p><p><strong>Beats</strong><br>Beats是一个面向轻量型采集器的平台，这些采集器可以从边缘机器向Logstash、ElasticSearch发送数据，它是由Go语言进行开发的，运行效率方面比较快。不同Beats的套件是针对不同的数据源。</p><p><strong>Logstash</strong><br>Logstash是动态数据收集管道，拥有可扩展的插件生态系统，支持从不同来源采集数据，转换数据，并将数据发送到不同的存储库中。其能够与ElasticSearch产生强大的协同作用，后被Elastic公司在2013年收购。</p><p><strong>ElasticSearch</strong><br>ElasticSearch对数据进行搜索、分析和存储，其是基于JSON的分布式搜索和分析引擎，专门为实现水平可扩展性、高可靠性和管理便捷性而设计的。<br>它的实现原理主要分为以下几个步骤：</p><ol><li>首先用户将数据提交到ElasticSearch数据库中；</li><li>再通过分词控制器将对应的语句分词；</li><li>将分词结果及其权重一并存入，以备用户在搜索数据时，根据权重将结果排名和打分，将返回结果呈现给用户。</li></ol><p><strong>Kibana</strong><br>Kibana实现数据可视化，其作用就是在ElasticSearch中进行民航。Kibana能够以图表的形式呈现数据，并且具有可扩展的用户界面，可以全方位的配置和管理ElasticSearch。</p><h3 id="从日志收集系统看ES-Stack的发展"><a href="#从日志收集系统看ES-Stack的发展" class="headerlink" title="从日志收集系统看ES Stack的发展"></a>从日志收集系统看ES Stack的发展</h3><p>一个典型的日志系统包括：<br>（1）收集：能够采集多种来源的日志数据<br>（2）传输：能够稳定的把日志数据解析过滤并传输到存储系统<br>（3）存储：存储日志数据<br>（4）分析：支持 UI 分析<br>（5）警告：能够提供错误报告，监控机制</p><p>beats+elasticsearch+kibana<br>beats+logstath+elasticsearch+kibana<br><img src="/posts/14457/es-elk%E7%94%9F%E6%80%81-%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F2.png"><br>beats+MQ+logstash+elasticsearch+kibana<br><img src="/posts/14457/es-elk%E7%94%9F%E6%80%81-%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F3.png"></p><h3 id="Elastic-Stack最佳实践"><a href="#Elastic-Stack最佳实践" class="headerlink" title="Elastic Stack最佳实践"></a>Elastic Stack最佳实践</h3><p><strong>日志收集系统</strong><br><strong>Metric收集和APM性能监控</strong><br><strong>多数据中心方案</strong></p><h2 id="ES原理-ElasticSearch-amp-Lucene"><a href="#ES原理-ElasticSearch-amp-Lucene" class="headerlink" title="ES原理 - ElasticSearch &amp; Lucene"></a>ES原理 - ElasticSearch &amp; Lucene</h2><p><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%9F%BA%E7%A1%80-%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png"></p><ul><li><strong>一个 ES Index</strong>在集群模式下，有多个 Node （节点）组成。每个节点就是 ES 的Instance (实例)。</li><li>每个节点上会有多个 shard（分片）， P0、P1是主分片, R0、R1是副本分片</li><li>每个分片上对应着就是一个 Lucene Index（底层索引文件）</li><li>Lucene Index 是一个统称 <ul><li>由多个 Segment （段文件，单个倒排索引文件称为Segment）组成。每个段文件存储着就是 Doc 文档。</li><li>commit point 记录了所有 segments 的信息。</li></ul></li></ul><h3 id="Lucene处理流程"><a href="#Lucene处理流程" class="headerlink" title="Lucene处理流程"></a>Lucene处理流程</h3><p><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%9F%BA%E7%A1%80-lucune%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpeg"></p><p><strong>创建索引的过程</strong></p><ul><li>准备待索引的原文档，数据来源可能是文件、数据库或网络</li><li>对文档的内容进行分词组件处理，形成一系列的Term</li><li>索引组件对文档和Term处理，形成字典和倒排表</li></ul><p><strong>搜索索引的过程</strong></p><ul><li>对查询语句进行分词处理，形成一系列Term</li><li>根据倒排索引表查找出包含Term的文档，并进行合并形成符合结果的文档集</li><li>比对查询语句与各个文档相关性得分，并按照得分高低返回</li></ul><h3 id="ElasticSearch分析器"><a href="#ElasticSearch分析器" class="headerlink" title="ElasticSearch分析器"></a>ElasticSearch分析器</h3><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>ES内部是如何运行的？</li><li>主分片和副本分片是如何同步的？</li><li>创建索引的流程是什么样的？</li><li>ES 如何将索引数据分配到不同的分片上的？以及这些索引数据是如何存储的？</li><li>为什么说 ES 是近实时搜索引擎而文档的 CRUD (创建-读取-更新-删除) 操作是实时的？</li><li>Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据？Translog（未持久化的数据）、段提交点（已持久化的段）</li><li>为什么删除文档不会立刻释放空间？</li></ul><blockquote><p>ElasticSearch中最重要原理是文档的索引和文档的读取</p></blockquote><h2 id="ES原理-索引文档流程详解（写）"><a href="#ES原理-索引文档流程详解（写）" class="headerlink" title="ES原理 - 索引文档流程详解（写）"></a>ES原理 - 索引文档流程详解（写）</h2><h3 id="文档索引步骤顺序"><a href="#文档索引步骤顺序" class="headerlink" title="文档索引步骤顺序"></a>文档索引步骤顺序</h3><h4 id="单个文档"><a href="#单个文档" class="headerlink" title="单个文档"></a>单个文档</h4><p>某索引下新建单个文档所需要的步骤顺序：<br><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%86%99-%E5%8D%95%E4%B8%AA%E6%96%87%E6%A1%A3.png" alt="3个节点 1个索引 2个分片 2个副本"></p><ol><li>客户端向 Node 1 发送新建、更新或者删除请求。</li><li>节点使用文档的 _id 确定文档属于分片 0。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。</li><li>Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。</li></ol><h4 id="多个文档"><a href="#多个文档" class="headerlink" title="多个文档"></a>多个文档</h4><p>使用 bulk 修改多个文档步骤顺序：<br><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%86%99-%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3.png" alt="3个节点 1个索引 2个分片 2个副本"></p><ol><li>客户端向 Node 1 发送 bulk 请求。</li><li>Node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。</li><li>主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</li></ol><h3 id="文档索引过程详解"><a href="#文档索引过程详解" class="headerlink" title="文档索引过程详解"></a>文档索引过程详解</h3><h4 id="整体的索引过程"><a href="#整体的索引过程" class="headerlink" title="整体的索引过程"></a>整体的索引过程</h4><p><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%86%99-%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B.jpeg"></p><ol><li>在一个写请求被发送到某个节点后，该节点即为前面说过的<strong>协调节点</strong>，协调节点会根据路由公式计算出需要写到哪个分片上，再将请求转发到该分片的主分片节点上。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。</span><br><span class="line">shard = hash(routing) % (num_of_primary_shards)</span><br></pre></td></tr></table></figure></li><li>当分片所在的节点接收到来自协调节点的请求后，会将请求<strong>写入到Memory Buffer（ES的JVM内存）</strong>；然后定时（默认是每隔1秒）写入到Filesystem Cache，这个<strong>从Momery Buffer到Filesystem Cache的过程</strong>就叫做<strong>refresh</strong>；</li><li>当然在某些情况下，存在Momery Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当<strong>Filesystem cache中的数据写入到磁盘中</strong>时，才会清除掉，这个过程叫做<strong>flush</strong>。</li><li>在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。 flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时。</li></ol><h4 id="分步骤看数据持久化过程：write-gt-refresh-gt-flush-gt-merge"><a href="#分步骤看数据持久化过程：write-gt-refresh-gt-flush-gt-merge" class="headerlink" title="分步骤看数据持久化过程：write -&gt; refresh -&gt; flush -&gt; merge"></a>分步骤看数据持久化过程：write -&gt; refresh -&gt; flush -&gt; merge</h4><p><strong>write过程</strong><br><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%86%99-write.png"></p><p>一个新文档过来，会存储在 in-memory buffer 内存缓存区（ES的JVM内存）中，顺便会记录 Translog（Elasticsearch 增加了一个 translog ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录）。<br>这时候数据还没到 segment ，是搜不到这个新文档的。数据只有被 refresh 后，才可以被搜索到。</p><p><strong>refresh过程</strong><br><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%86%99-refresh.png"></p><p>refresh 默认 1 秒钟，执行一次上图流程。ES 是支持修改这个值的，通过 index.refresh_interval 设置 refresh （冲刷）间隔时间。<br>refresh 流程大致如下：</p><ol><li>in-memory buffer 中的文档写入到新的 segment 中，但 segment 是存储在文件系统的缓存中。此时文档可以被搜索到。</li><li>最后清空 in-memory buffer。注意: Translog 没有被清空，为了将 segment 数据写到磁盘。</li></ol><p>文档经过 refresh 后， segment 暂时写到文件系统缓存，这样避免了性能 IO 操作，又可以使文档搜索到。<br>refresh 默认 1 秒执行一次，性能损耗太大。一般建议稍微延长这个 refresh 时间间隔，比如 5 s。因此，ES 其实就是准实时，达不到真正的实时。</p><p><strong>flush过程</strong><br>每隔一段时间（默认30分钟）或者 translog 变得越来越大（默认为512M），​索引被刷新（flush）：一个新的 translog 被创建，并且一个全量提交被执行。</p><p><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%86%99-flush.png"></p><p>文档从文件缓存写入磁盘的过程就是 flush。写入磁盘后，清空 translog。<br>具体过程如下：</p><ol><li>所有在内存缓冲区的文档都被写入一个新的段。</li><li>缓冲区被清空。</li><li>一个Commit Point被写入硬盘。</li><li>文件系统缓存通过 fsync 被刷新（flush）。</li><li>老的 translog 被删除。</li></ol><p><strong>merge过程</strong><br>由于<strong>自动刷新流程每秒会创建一个新的段</strong>，这样会导致短时间内的段数量暴增。<br>而段数目太多会带来较大的麻烦。每一个段都会消耗文件句柄、内存和cpu运行周期。<br>更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p><p>Elasticsearch通过在后台进行Merge Segment来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。<br>当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。</p><p><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%86%99-merge-1.png"><br><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E5%86%99-merge-2.png"></p><p>一旦合并结束，老的段被删除。新的段被刷新（flush）到了磁盘，写入一个包含新段且排除旧的和较小的段的新提交点。</p><p>合并大的段需要消耗大量的I/O和CPU资源，如果任其发展会影响搜索性能。Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然 有足够的资源很好地执行。</p><h3 id="深入ElasticSearch索引文档的实现机制"><a href="#深入ElasticSearch索引文档的实现机制" class="headerlink" title="深入ElasticSearch索引文档的实现机制"></a>深入ElasticSearch索引文档的实现机制</h3><h4 id="写操作的关键点"><a href="#写操作的关键点" class="headerlink" title="写操作的关键点"></a>写操作的关键点</h4><p>在考虑或分析一个分布式系统的写操作时，一般需要从下面几个方面考虑：</p><ul><li>可靠性：或者是持久性，数据写入系统成功后，数据不会被回滚或丢失。<br>  由于Lucene的设计中不考虑可靠性，在Elasticsearch中通过<strong>Replica</strong>和<strong>TransLog</strong>两套机制保证数据的可靠性。</li><li>一致性：数据写入成功后，再次查询时必须能保证读取到最新版本的数据，不能读取到旧数据。<br>  Lucene中的Flush锁只保证Update接口里面Delete和Add中间不会Flush，但是Add完成后仍然有可能立即发生Flush，导致Segment可读。这样就没法保证Primary和所有其他Replica可以同一时间Flush，就会出现查询不稳定的情况，这里只能实现最终一致性。</li><li>原子性：一个写入或者更新操作，要么完全成功，要么完全失败，不允许出现中间状态。<br>  Add和Delete都是直接调用Lucene的接口，是原子的。当部分更新时，使用Version和锁保证更新是原子的。</li><li>隔离性：多个写入操作相互不影响。<br>  仍然采用Version和局部锁来保证更新的是特定版本的数据。</li><li>实时性：写入后是否可以立即被查询到。<br>  使用定期Refresh Segment到内存，并且Reopen Segment方式保证搜索可以在较短时间（比如1秒）内被搜索到。通过将未刷新到磁盘数据记入TransLog，保证对未提交数据可以通过ID实时访问到。</li><li>性能：写入性能，吞吐量到底怎么样。</li></ul><h4 id="Lucene的写"><a href="#Lucene的写" class="headerlink" title="Lucene的写"></a>Lucene的写</h4><p>Elasticsearch内部使用了Lucene完成索引创建和搜索功能，Lucene中写操作主要是通过IndexWriter类实现，IndexWriter提供三个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">addDocument</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">updateDocuments</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">deleteDocuments</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>通过这三个接口可以完成单个文档的写入、更新和删除功能，包括了分词、倒排创建、正排创建等等所有搜索相关的流程。<br>只要Doc通过IndesWriter写入后，后面就可以通过IndexSearcher搜索了，看起来功能已经完善了，但是仍然有一些问题没有解：</p><ul><li>上述操作是单机的，而不是我们需要的分布式。</li><li>文档写入Lucene后并不是立即可查询的，需要生成完整的Segment后才可被搜索，如何保证实时性？</li><li>Lucene生成的Segment是在内存中，如果机器宕机或掉电后，内存中的Segment会丢失，如何保证数据可靠性？</li><li>Lucene不支持部分文档更新，但是这又是一个强需求，如何支持部分更新？</li></ul><p>上述问题，在Lucene中是没有解决的，那么就需要Elasticsearch中解决上述问题。</p><h4 id="ElasticSearch的写"><a href="#ElasticSearch的写" class="headerlink" title="ElasticSearch的写"></a>ElasticSearch的写</h4><h4 id="ElasticSearch写入请求类型"><a href="#ElasticSearch写入请求类型" class="headerlink" title="ElasticSearch写入请求类型"></a>ElasticSearch写入请求类型</h4><h2 id="ES原理-读取文档流程详解（读）"><a href="#ES原理-读取文档流程详解（读）" class="headerlink" title="ES原理 - 读取文档流程详解（读）"></a>ES原理 - 读取文档流程详解（读）</h2><h3 id="文档查询步骤顺序"><a href="#文档查询步骤顺序" class="headerlink" title="文档查询步骤顺序"></a>文档查询步骤顺序</h3><h4 id="单个文档-1"><a href="#单个文档-1" class="headerlink" title="单个文档"></a>单个文档</h4><p><a href="es-%E5%8E%9F%E7%90%86-%E8%AF%BB-%E5%8D%95%E4%B8%AA%E6%96%87%E6%A1%A3.png"></a></p><ol><li>客户端向 Node 1 发送获取请求。</li><li>节点使用文档的 _id 来确定文档属于分片 0。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node 2。</li><li>Node 2 将文档返回给 Node 1，然后将文档返回给客户端。</li></ol><p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。</p><p>在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p><h4 id="多个文档-1"><a href="#多个文档-1" class="headerlink" title="多个文档"></a>多个文档</h4><p><a href="es-%E5%8E%9F%E7%90%86-%E8%AF%BB-%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3.png"></a><br>以下是使用单个 mget 请求取回多个文档所需的步骤顺序：</p><ol><li>客户端向 Node 1 发送 mget 请求。</li><li>Node 1 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复， Node 1 构建响应并将其返回给客户端。</li></ol><h3 id="文档读取过程详解"><a href="#文档读取过程详解" class="headerlink" title="文档读取过程详解"></a>文档读取过程详解</h3><p>所有的搜索系统一般都是两阶段查询，第一阶段查询到匹配的DocID，第二阶段再查询DocID对应的完整文档，这种在Elasticsearch中称为query_then_fetch。<br><img src="/posts/14457/es-%E5%8E%9F%E7%90%86-%E8%AF%BB-%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B.jpeg"></p><ol><li>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在2. 搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。</li><li>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li><li>接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</li></ol><h3 id="深入ElasticSearch读取文档的实现机制"><a href="#深入ElasticSearch读取文档的实现机制" class="headerlink" title="深入ElasticSearch读取文档的实现机制"></a>深入ElasticSearch读取文档的实现机制</h3><h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><ul><li>一致性指的是写入成功后，下次读操作一定要能读取到最新的数据。对于搜索，这个要求会低一些，可以有一些延迟。但是对于NoSQL数据库，则一般要求最好是强一致性的。</li><li>结果匹配上，NoSQL作为数据库，查询过程中只有符合不符合两种情况，而搜索里面还有是否相关，类似于NoSQL的结果只能是0或1，而搜索里面可能会有0.1，0.5，0.9等部分匹配或者更相关的情况。</li><li>结果召回上，搜索一般只需要召回最满足条件的Top N结果即可，而NoSQL一般都需要返回满足条件的所有结果。</li><li>搜索系统一般都是两阶段查询，第一个阶段查询到对应的Doc ID，也就是PK；第二阶段再通过Doc ID去查询完整文档，而NoSQL数据库一般是一阶段就返回结果。在Elasticsearch中两种都支持。</li></ul><p>目前NoSQL的查询，聚合、分析和统计等功能上都是要比搜索弱的。</p><h4 id="Lucene的读"><a href="#Lucene的读" class="headerlink" title="Lucene的读"></a>Lucene的读</h4><p>Elasticsearch使用了Lucene作为搜索引擎库，通过Lucene完成特定字段的搜索等功能，在Lucene中这个功能是通过IndexSearcher的下列接口实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search接口实现搜索功能，返回最满足Query的N个结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TopDocs <span class="title">search</span><span class="params">(Query query, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// doc接口通过doc id查询Doc内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">doc</span><span class="params">(<span class="keyword">int</span> docID)</span></span>;</span><br><span class="line"><span class="comment">// count接口通过Query获取到命中数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(Query query)</span></span>;</span><br><span class="line">......(其他)</span><br></pre></td></tr></table></figure><p>这三个功能是搜索中的最基本的三个功能点，对于大部分Elasticsearch中的查询都是比较复杂的，直接用这个接口是无法满足需求的，比如分布式问题。<br>这些问题都留给了Elasticsearch解决。</p><h4 id="ElasticSearch的读"><a href="#ElasticSearch的读" class="headerlink" title="ElasticSearch的读"></a>ElasticSearch的读</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8、JDK11、JDK17</title>
      <link href="/posts/41624.html"/>
      <url>/posts/41624.html</url>
      
        <content type="html"><![CDATA[<p>之前项目开发一直使用<code>JDK8</code>，最近碰到IDEA插件在<code>IDEA 2022.2</code>以上版本报错的问题后，把自己的IDEA升级到2022.2，发现2022.2版本的IDEA默认JDK17。<br>把插件基础intellij环境升级到2022.2，必须要JDK17才能编译通过，同时Gradle要求7以上。</p><p>于是，想要对于JDK的不同版本进行一些了解。</p><p>LTS，是 Long Term Support，也就是官方保证会长期支持的版本。</p><p><a href="https://blog.csdn.net/java_wxid/article/details/131333918">https://blog.csdn.net/java_wxid/article/details/131333918</a></p><h2 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h2><h3 id="1、Lambda表达式"><a href="#1、Lambda表达式" class="headerlink" title="1、Lambda表达式"></a>1、Lambda表达式</h3><h3 id="2、接口增强"><a href="#2、接口增强" class="headerlink" title="2、接口增强"></a>2、接口增强</h3><ul><li>在1.8之前，接口中只能有：静态常量，抽象方法</li><li>在1.8之后，接口中可以有：静态常量，抽象方法，默认方法，静态方法</li></ul><p>默认方法可以被继承和重写。<br>静态方法只能通过<code>接口.方法名</code>调用，不能被继承和重写。</p><h3 id="3、函数式接口"><a href="#3、函数式接口" class="headerlink" title="3、函数式接口"></a>3、函数式接口</h3><ul><li>Supplier</li><li>Consumer</li><li>Function</li><li>Predicate</li></ul><h3 id="4、Stream-API"><a href="#4、Stream-API" class="headerlink" title="4、Stream API"></a>4、Stream API</h3><h3 id="5、Optional类"><a href="#5、Optional类" class="headerlink" title="5、Optional类"></a>5、Optional类</h3><p>Optional 类是一个可以为null的容器对象。<br>如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。</p><h4 id="Optional对象的创建方式"><a href="#Optional对象的创建方式" class="headerlink" title="Optional对象的创建方式"></a>Optional对象的创建方式</h4><ul><li>ofNullable：允许一个可能为空的对象</li><li>of：需要一个不为空的对象</li></ul><h4 id="Optional常用方法"><a href="#Optional常用方法" class="headerlink" title="Optional常用方法"></a>Optional常用方法</h4><ul><li>empty：可以创建一个空的Optional对象</li><li>get：直接获取Optional内部对象，但是不建议单独使用</li><li>isPresent：判断内部对象是否为空，返回一个布尔值</li><li>ifPresent：一样判断内部对象是否为空，如果不为空会执行lambda表达式</li><li>filter：通过一定条件过滤对象</li><li>flatMap：和map的区别为lambda入参的对象封装入了Optional</li><li>orElse：如果值为空，返回一个对象</li><li>orElseGet：如果值为空，执行一段lambda并返回一个对象</li><li>orElseThrow：如果值为空，抛出一个异常</li></ul><h3 id="6、新时间日期API"><a href="#6、新时间日期API" class="headerlink" title="6、新时间日期API"></a>6、新时间日期API</h3><p>JDK8中新增加了一套全新的日期时间API，这套API设计合理，并且是线程安全的。</p><p>API位于java.time包下：</p><ul><li>LocalDate：表示日期，包含年月日，格式为2020-01-11。</li><li>LocalTime：表示时间，包含时分秒，格式为11:07:03.580。</li><li>LocalDateTime：表示日期和时间组合，包含年月日，时分秒，格式为2020-01-11T11:07:03.580</li><li>DateTimeFormatter：日期时间格式化类</li><li>Instant：时间戳，表示一个特定的时间瞬间</li><li>Duration：用于计算两个时间（LocalTime，时分秒）的距离</li><li>Period：用于计算2个日期（LocalDate，年月日）的距离</li><li>ZoneDateTime：包含时区的时间</li></ul><h3 id="7、Base64-工具"><a href="#7、Base64-工具" class="headerlink" title="7、Base64 工具"></a>7、Base64 工具</h3><p>Java 8 内置了 Base64 编码的编码器和解码器</p><h3 id="8、JVM的PermGen方法区被移除，取代它的是Metaspace（JEP-122）元空间"><a href="#8、JVM的PermGen方法区被移除，取代它的是Metaspace（JEP-122）元空间" class="headerlink" title="8、JVM的PermGen方法区被移除，取代它的是Metaspace（JEP 122）元空间"></a>8、JVM的PermGen方法区被移除，取代它的是Metaspace（JEP 122）元空间</h3><h3 id="9、CompletableFuture"><a href="#9、CompletableFuture" class="headerlink" title="9、CompletableFuture"></a>9、CompletableFuture</h3><p>在 Java8 之前 Future 接口提供了异步执行任务的能力，但对于结果的获取只能通过阻塞或者轮询的方式。<br>为了增强异步编程的功能，Java8 添加了 CompletableFuture 类，CompletableFuture 类实现了 CompletionStage 和 Future 接口，默认使用 ForkJoinPool.commonPool() 线程池。</p><h2 id="JDK11"><a href="#JDK11" class="headerlink" title="JDK11"></a>JDK11</h2><h3 id="1、JVM-ZGC垃圾收集器"><a href="#1、JVM-ZGC垃圾收集器" class="headerlink" title="1、JVM ZGC垃圾收集器"></a>1、JVM ZGC垃圾收集器</h3><p>ZGC，ZGC可以看做是G1之上更细粒度的内存管理策略。由于内存的不断分配回收会产生大量的内存碎片空间，因此需要整理策略防止内存空间碎片化，在整理期间需要将对于内存引用的线程逻辑暂停，这个过程被称为”Stop the world”。只有当整理完成后，线程逻辑才可以继续运行。（并行回收）</p><h3 id="2、变量类型推断"><a href="#2、变量类型推断" class="headerlink" title="2、变量类型推断"></a>2、变量类型推断</h3><p>从 Java10 开始变量不需要写具体类型，变量类型直接使用 var 定义，编译器能根据右边的表达式自动推断类型。</p><h3 id="3、官方HTTP-Client"><a href="#3、官方HTTP-Client" class="headerlink" title="3、官方HTTP Client"></a>3、官方HTTP Client</h3><p>Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化。<br>Java 11 中的新 Http Client API，提供了对 HTTP/2 等业界前沿标准的支持，同时也向下兼容 HTTP/1.1，精简而又友好的 API 接口，与主流开源 API（如：Apache HttpClient、Jetty、OkHttp 等）类似甚至拥有更高的性能。</p><h3 id="4、接口允许有私有方法"><a href="#4、接口允许有私有方法" class="headerlink" title="4、接口允许有私有方法"></a>4、接口允许有私有方法</h3><h3 id="5、try语句"><a href="#5、try语句" class="headerlink" title="5、try语句"></a>5、try语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String path = <span class="string">&quot;/home/nathan/test.sh&quot;</span>;</span><br><span class="line">    <span class="comment">//Java7 引入的 try-with-resource 机制</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> InputStreamReader(System.in)) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java9 可以在 try 中使用已初始化的资源</span></span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">    <span class="keyword">var</span> writer = <span class="keyword">new</span> OutputStreamWriter(System.out);</span><br><span class="line">    <span class="keyword">try</span> (reader; writer) &#123;</span><br><span class="line">        <span class="comment">//reader是final的，不可再被赋值</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、I-O流新特性"><a href="#6、I-O流新特性" class="headerlink" title="6、I/O流新特性"></a>6、I/O流新特性</h3><p>类 <code>java.io.InputStream</code> 中增加了新的方法来读取和复制 InputStream 中包含的数据。</p><ul><li>readAllBytes：读取 InputStream 中的所有剩余字节。</li><li>readNBytes： 从 InputStream 中读取指定数量的字节到数组中。</li><li>transferTo：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中。</li></ul><h2 id="JDK17"><a href="#JDK17" class="headerlink" title="JDK17"></a>JDK17</h2><ul><li>SpringBoot 3.0最低版本要求的JDK 17</li><li>JetBrains：Intelij项目的源代码迁移到了Java 17</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus</title>
      <link href="/posts/37899.html"/>
      <url>/posts/37899.html</url>
      
        <content type="html"><![CDATA[<p>在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><h3 id="执行模式与执行器-Executor"><a href="#执行模式与执行器-Executor" class="headerlink" title="执行模式与执行器 Executor"></a>执行模式与执行器 Executor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExecutorType</span> </span>&#123;</span><br><span class="line">    SIMPLE,</span><br><span class="line">    REUSE,</span><br><span class="line">    BATCH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h4><h4 id="ReuseExecutor"><a href="#ReuseExecutor" class="headerlink" title="ReuseExecutor"></a>ReuseExecutor</h4><h4 id="BatchExecutor"><a href="#BatchExecutor" class="headerlink" title="BatchExecutor"></a>BatchExecutor</h4><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>批处理执行模式 <code>ExecutorType.BATCH</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认批处理长度 1000</span></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_BATCH_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.saveBatch(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.saveOrUpdateBatch(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.updateBatchById(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">        String sqlStatement = <span class="keyword">this</span>.getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            sqlSession.insert(sqlStatement, entity);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">        TableInfo tableInfo = TableInfoHelper.getTableInfo(<span class="keyword">this</span>.entityClass);</span><br><span class="line">        Assert.notNull(tableInfo, <span class="string">&quot;error: can not execute. because can not find cache of TableInfo for entity!&quot;</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        String keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">        Assert.notEmpty(keyProperty, <span class="string">&quot;error: can not execute. because can not find column for id from entity!&quot;</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.saveOrUpdateBatch(<span class="keyword">this</span>.entityClass, <span class="keyword">this</span>.mapperClass, <span class="keyword">this</span>.log, entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            Object idVal = ReflectionKit.getFieldValue(entity, keyProperty);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.checkValNull(idVal) || CollectionUtils.isEmpty(sqlSession.selectList(<span class="keyword">this</span>.getSqlStatement(SqlMethod.SELECT_BY_ID), entity));</span><br><span class="line">        &#125;, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            ParamMap&lt;T&gt; param = <span class="keyword">new</span> ParamMap();</span><br><span class="line">            param.put(<span class="string">&quot;et&quot;</span>, entity);</span><br><span class="line">            sqlSession.update(<span class="keyword">this</span>.getSqlStatement(SqlMethod.UPDATE_BY_ID), param);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">        String sqlStatement = <span class="keyword">this</span>.getSqlStatement(SqlMethod.UPDATE_BY_ID);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            ParamMap&lt;T&gt; param = <span class="keyword">new</span> ParamMap();</span><br><span class="line">            param.put(<span class="string">&quot;et&quot;</span>, entity);</span><br><span class="line">            sqlSession.update(sqlStatement, param);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Consumer&lt;SqlSession&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.executeBatch(<span class="keyword">this</span>.entityClass, <span class="keyword">this</span>.log, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Collection&lt;E&gt; list, <span class="keyword">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.executeBatch(<span class="keyword">this</span>.entityClass, <span class="keyword">this</span>.log, list, batchSize, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Collection&lt;E&gt; list, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.executeBatch(list, <span class="number">1000</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Consumer&lt;SqlSession&gt; consumer)</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactory(entityClass);</span><br><span class="line">        SqlSessionHolder sqlSessionHolder = (SqlSessionHolder)TransactionSynchronizationManager.getResource(sqlSessionFactory);</span><br><span class="line">        <span class="keyword">boolean</span> transaction = TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line">        SqlSession sqlSession;</span><br><span class="line">        <span class="keyword">if</span> (sqlSessionHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sqlSession = sqlSessionHolder.getSqlSession();</span><br><span class="line">            sqlSession.commit(!transaction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ExecutorType.BATCH</span></span><br><span class="line">        sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line">        <span class="keyword">if</span> (!transaction) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;SqlSession [&quot;</span> + sqlSession + <span class="string">&quot;] was not registered for synchronization because DataSource is not transactional&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> var7;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer.accept(sqlSession);</span><br><span class="line">            sqlSession.commit(!transaction);</span><br><span class="line">            var7 = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var13) &#123;</span><br><span class="line">            sqlSession.rollback();</span><br><span class="line">            Throwable unwrapped = ExceptionUtil.unwrapThrowable(var13);</span><br><span class="line">            <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                MyBatisExceptionTranslator myBatisExceptionTranslator = <span class="keyword">new</span> MyBatisExceptionTranslator(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> (DataAccessException)Objects.requireNonNull(myBatisExceptionTranslator.translateExceptionIfPossible((RuntimeException)unwrapped));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtils.mpe(unwrapped);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="keyword">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, (sqlSession) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Iterator var6 = list.iterator(); var6.hasNext(); ++i) &#123;</span><br><span class="line">                E element = var6.next();</span><br><span class="line">                consumer.accept(sqlSession, element);</span><br><span class="line">                <span class="keyword">if</span> (i % batchSize == <span class="number">0</span> || i == size) &#123;</span><br><span class="line">                    sqlSession.flushStatements();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/posts/61918.html"/>
      <url>/posts/61918.html</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ol><li>加载驱动 Class.forName(“com.mysql.jdbc.Driver”)</li><li>获取链接 Connection conn = (Connection) DriverManager.getConnection(url, username, password)</li><li>执行PreparedStatement</li><li>返回结果集 ResultSet</li></ol><h2 id="Mybatis总体框架设计"><a href="#Mybatis总体框架设计" class="headerlink" title="Mybatis总体框架设计"></a>Mybatis总体框架设计</h2><p><img src="/posts/61918/mybatis-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E6%A6%82%E8%A7%88%E5%9B%BE.png"></p><h3 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h3><h4 id="接口层-和数据库交互的方式"><a href="#接口层-和数据库交互的方式" class="headerlink" title="接口层 -和数据库交互的方式"></a>接口层 -和数据库交互的方式</h4><p>MyBatis和数据库的交互有两种方式：</p><ul><li>使用传统的MyBatis提供的API</li><li>使用Mapper接口</li></ul><h4 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h4><p>数据处理层可以说是MyBatis的核心，从大的方面上讲，它要完成两个功能：</p><ul><li>通过传入参数构建动态SQL语句</li><li>SQL语句的执行以及封装查询结果集成<code>List&lt;E&gt;</code></li></ul><p><strong>参数映射和动态SQL语句生成</strong><br>动态语句生成可以说是MyBatis框架非常优雅的一个设计，MyBatis通过传入的参数值，使用Ognl来动态地构造SQL语句，使得MyBatis有很强的灵活性和扩展性。</p><p>参数映射指的是对于java数据类型和jdbc数据类型之间的转换。<br>这里有包括两个过程：</p><ol><li>查询阶段，我们要将java类型的数据，转换成jdbc类型的数据，通过 preparedStatement.setXXX() 来设值；</li><li>对resultset查询结果集的jdbcType 数据转换成java 数据类型。</li></ol><p><strong>SQL语句的执行以及封装查询结果集成List</strong><br>动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List<E>列表。<br>MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。</E></p><h4 id="框架支撑层"><a href="#框架支撑层" class="headerlink" title="框架支撑层"></a>框架支撑层</h4><ul><li>事务管理机制<br>  事务管理机制对于ORM框架而言是不可缺少的一部分，事务管理机制的质量也是考量一个ORM框架是否优秀的一个标准。</li><li>连接池管理机制<br>  由于创建一个数据库连接所占用的资源比较大，对于数据吞吐量大和访问量非常大的应用而言，连接池的设计就显得非常重要。</li><li>缓存机制<br>  为了提高数据利用率和减小服务器和数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis 会直接将缓存结果返回给用户，而不用再到数据库中查找。</li><li>SQl语句的配置方式<br>  Mapper + XML</li></ul><h3 id="主要构件及其相互关系"><a href="#主要构件及其相互关系" class="headerlink" title="主要构件及其相互关系"></a>主要构件及其相互关系</h3><p><img src="/posts/61918/mybatis-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E4%B8%BB%E8%A6%81%E6%9E%84%E4%BB%B6.png"></p><ul><li>SqlSession，作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能；</li><li>Executor，MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护；</li><li>StatementHandler，封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合；</li><li>ParameterHandler，负责对用户传递的参数转换成JDBC Statement 所需要的参数；</li><li>ResultSetHandler，负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</li><li>TypeHandler 负责java数据类型和jdbc数据类型之间的映射和转换；</li><li>MappedStatement MappedStatement维护了一条<strong>select|update|delete|insert</strong>节点的封装；</li><li>SqlSource 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回；</li><li>BoundSql 表示动态生成的SQL语句以及相应的参数信息；</li><li>Configuration MyBatis所有的配置信息都维持在Configuration对象之中。</li></ul><h2 id="MyBatis执行流程"><a href="#MyBatis执行流程" class="headerlink" title="MyBatis执行流程"></a>MyBatis执行流程</h2><h3 id="Mybatis核心流程四大对象"><a href="#Mybatis核心流程四大对象" class="headerlink" title="Mybatis核心流程四大对象"></a>Mybatis核心流程四大对象</h3><p>MyBatis完成一次数据库操作需要经过的步骤，如下：</p><ol><li>加载配置文件，获取<strong>SqlSessionFactoryBuiler</strong>对象</li><li>通过SqlSessionFactoryBuiler和配置文件流来获取<strong>SqlSessionFactory</strong>对象</li><li>利用SqlSessionFactory对象来打开一个<strong>SqlSession</strong></li><li>通过SqlSession来获得对应的<strong>Mapper</strong>对象</li><li>通过Mapper对象调用对应接口来封装执行sql并解析返回数据</li></ol><table><thead><tr><th align="left">对象</th><th align="center">生命周期</th></tr></thead><tbody><tr><td align="left">SqlSessionFactoryBuiler</td><td align="center">方法局部（Method）使用完成即可被丢弃</td></tr><tr><td align="left">SqlSessionFactory</td><td align="center">应用级别（Application），全局存在，是一个单例对象</td></tr><tr><td align="left">SqlSession</td><td align="center">请求或方法（Request / Method）</td></tr><tr><td align="left">Mapper</td><td align="center">方法（Method）</td></tr></tbody></table><h3 id="SqlSession的创建过程"><a href="#SqlSession的创建过程" class="headerlink" title="SqlSession的创建过程"></a>SqlSession的创建过程</h3><p><img src="/posts/61918/mybatis-sqlsession-%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" alt="创建SqlSessiond的过程"></p><ol><li>首先，SqlSessionFactoryBuilder去读取mybatis的配置文件，然后build一个DefaultSqlSessionFactory。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一系列的构造方法最终都会调用本方法（配置文件为Reader时会调用本方法，还有一个InputStream方法与此对应）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> environment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过XMLConfigBuilder解析配置文件，解析的配置相关信息都会封装为一个Configuration对象</span></span><br><span class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">        <span class="comment">//这儿创建DefaultSessionFactory对象</span></span><br><span class="line">        <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>获取到SqlSessionFactory之后，就可以通过SqlSessionFactory去获取SqlSession对象。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通常一系列openSession方法最终都会调用本方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> execType </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> level</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> autoCommit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过Confuguration对象去获取Mybatis相关配置信息, Environment对象包含了数据源和事务的配置</span></span><br><span class="line">        <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">        <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        <span class="comment">//之前说了，从表面上来看，咱们是用sqlSession在执行sql语句， 实际呢，其实是通过excutor执行， excutor是对于Statement的封装</span></span><br><span class="line">        <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        <span class="comment">//关键看这儿，创建了一个DefaultSqlSession对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从配置中获取Environment；</li><li>从Environment中取得DataSource；从Environment中取得TransactionFactory；</li><li>从DataSource里获取数据库连接对象Connection；在取得的数据库连接上创建事务对象Transaction；</li><li>创建Executor对象（该对象非常重要，事实上sqlsession的所有操作都是通过它完成的）；</li><li>创建sqlsession对象。</li></ol></li></ol><h3 id="Mapper执行流程"><a href="#Mapper执行流程" class="headerlink" title="Mapper执行流程"></a>Mapper执行流程</h3><p>Mapper执行一次sql需要经过的步骤，如下：</p><ol><li>通过MybatisMapperRegistry获取JDK动态代理对象MybatisMapperProxy</li><li>通过MybatisMapperProxy执行代理方法</li><li>通过MappedStatement和入参创建Executor并实际执行数据库操作</li></ol><p><img src="/posts/61918/mybatis-mapper-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="MapperProxy的创建过程"></p><p>在mybatis中，通过MapperProxy动态代理咱们的dao或者mapper接口，也就是说，当咱们执行自己写的dao里面的方法的时候，其实是对应的mapperProxy在代理。<br>那么，看看怎么获取MapperProxy对象吧。</p><ol><li><strong>SqlSession</strong><br> SqlSession把包袱甩给了Configuration <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 什么都不做，直接去configuration中找， 哥就是这么任性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>Configuration</strong><br> Configuration不要这烫手的山芋，接着甩给了MapperRegistry <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 烫手的山芋，俺不要，你找mapperRegistry去要</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>MapperRegistry</strong><br> MapperRegistry交给MapperProxyFactory去做 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 烂活净让我来做了，没法了，下面没人了，我不做谁来做</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//能偷懒的就偷懒，俺把粗活交给MapperProxyFactory去做</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//关键在这儿</span></span><br><span class="line">        <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>MapperProxyFactory</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mapperProxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//动态代理我们写的dao接口</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Executor执行流程"><a href="#Executor执行流程" class="headerlink" title="Executor执行流程"></a>Executor执行流程</h3><p>Executor执行过程需要经过的步骤，如下：</p><ol><li>创建Executor，然后利用StatementHandler执行数据库操作</li><li>执行数据库操作前，利用ParameterHandler做参数处理</li><li>执行数据库操作后，利用ResultSetHandler处理数据库返回结果</li></ol><p>Executor与Sqlsession的关系就像市长与书记，Sqlsession只是个门面，真正干事的是Executor。<br>Sqlsession对数据库的操作都是通过Executor来完成的。<br>与Sqlsession一样，Executor也是动态创建的：<br><img src="/posts/61918/mybatis-excutor-%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="Excutor的创建过程"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configuration#newExecutor</span></span><br><span class="line"><span class="comment"> * Executor创建的源代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;  </span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;  </span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ?ExecutorType.SIMPLE : executorType;  </span><br><span class="line">    Executor executor;  </span><br><span class="line">    <span class="keyword">if</span>(ExecutorType.BATCH == executorType) &#123; <span class="comment">// BatchExecutor专门用于执行批量sql操作</span></span><br><span class="line">        executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>,transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ExecutorType.REUSE == executorType) &#123; <span class="comment">// ReuseExecutor会重用statement执行sql操作</span></span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>,transaction);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        executor = newSimpleExecutor(<span class="keyword">this</span>, transaction); <span class="comment">// SimpleExecutor只是简单执行sql没有什么特别的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        <span class="comment">// 开启cache的话（默认是开启的并且没有任何理由去关闭它），就会创建CachingExecutor，它以前面创建的Executor作为唯一参数</span></span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor);  </span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);  </span><br><span class="line">    <span class="keyword">return</span> executor;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configuration#newStatementHandler</span></span><br><span class="line"><span class="comment"> * newStatementHandler创建的源代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StatementHandler-sql执行、参数及结果映射流程"><a href="#StatementHandler-sql执行、参数及结果映射流程" class="headerlink" title="StatementHandler sql执行、参数及结果映射流程"></a>StatementHandler sql执行、参数及结果映射流程</h3><ol><li>将参数和执行sql解析封装成MetaObject</li><li>执行sql前后通过TypeHandler对java与数据库参数进行映射</li></ol><h2 id="MyBatis一级、二级缓存"><a href="#MyBatis一级、二级缓存" class="headerlink" title="MyBatis一级、二级缓存"></a>MyBatis一级、二级缓存</h2><p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">美团技术团队-聊聊MyBatis缓存机制</a></p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于<code>同一个SqlSession</code>而言。</p><h4 id="一级缓存的生命周期"><a href="#一级缓存的生命周期" class="headerlink" title="一级缓存的生命周期"></a>一级缓存的生命周期</h4><ol><li>MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。</li><li>如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。</li><li>如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。</li><li>SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用。</li></ol><p><strong>怎么判断某两次查询是完全相同的查询</strong><br>Mybatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询。</p><ol><li>传入的statementId。</li><li>查询时要求的结果集中的结果范围。</li><li>这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）。</li><li>传递给java.sql.Statement要设置的参数值。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>MyBatis一级缓存的生命周期和SqlSession一致。</li><li>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li><li>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。 <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">        <span class="attr">cache-enabled:</span> <span class="literal">false</span> <span class="comment">#禁用二级缓存</span></span><br><span class="line">        <span class="attr">local-cache-scope:</span> <span class="string">statement</span> <span class="comment">#一级缓存指定为statement级别。每次查询结束都会清掉一级缓存，实际效果就是禁用了一级缓存。</span></span><br><span class="line">        <span class="attr">local-cache-scope:</span> <span class="string">session</span>  <span class="comment">#一级缓存指定为session级别。对同样的查询将不再查询数据库，直接从缓存中获取。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>MyBatis的二级缓存是Application级别的缓存。<br>范围是按照每个namepace缓存来存贮和维护，同一个namespace放到一个缓存对象中。<br>当这个namaspace中执行了insert、update和delete语句的时候，整个namespace中的缓存全部清除掉。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">        <span class="string">//</span> <span class="string">默认不开启二级缓存</span></span><br><span class="line">        <span class="attr">cache-enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li><li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li><li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-主题maupassant目录优化解决方案</title>
      <link href="/posts/37061.html"/>
      <url>/posts/37061.html</url>
      
        <content type="html"><![CDATA[<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><ul><li>文章内容过多之后，查阅不方便</li><li><code>maupassant</code>主题默认的目录显示在正文</li></ul><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>以下方法来自于 <a href="https://wiki.hushhw.cn/posts/5dd904ed.html">https://wiki.hushhw.cn/posts/5dd904ed.html</a></p><h3 id="1、-config-yml"><a href="#1、-config-yml" class="headerlink" title="1、_config.yml"></a>1、_config.yml</h3><p>在主题配置文件_config.yml中添加侧栏toc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">widgets: </span><br><span class="line">  - toc</span><br><span class="line">  - info</span><br><span class="line">  - search</span><br><span class="line">  - category</span><br><span class="line">  - tag</span><br><span class="line">  - recent_posts</span><br><span class="line">  - recent_comments</span><br><span class="line">  - links</span><br></pre></td></tr></table></figure><h3 id="2、base-pug"><a href="#2、base-pug" class="headerlink" title="2、base.pug"></a>2、base.pug</h3><p><code>themes/maupassant/layout/base.pug</code><br>mac注意tab间隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#layout.pure-g</span><br><span class="line">  .pure-u-1.pure-u-md-3-4: .content_container</span><br><span class="line">    block content</span><br><span class="line">  if page.toc != true</span><br><span class="line">    .pure-u-1.pure-u-md-1-4: #sidebar</span><br><span class="line">      each item in theme.widgets</span><br><span class="line">        != partial(&#x27;_widget/&#x27; + item + &#x27;.pug&#x27;, null, &#123;cache: !config.relative_link&#125;)</span><br><span class="line">  else</span><br><span class="line">    //- if theme.toc_on_small_screens</span><br><span class="line">    if theme.widgets_on_small_screens</span><br><span class="line">      .pure-u-1.pure-u-md-1-4: #sidebar-toc</span><br><span class="line">        div(id=&quot;sidebar-stoc&quot; class=&quot;stoc-article&quot;)</span><br><span class="line">          strong(class=&quot;stoc-title&quot;)</span><br><span class="line">            i(class=&#x27;fa&#x27;)= &#x27; Contents &#x27;</span><br><span class="line">          div(id=&quot;stoc&quot; class=&#x27;toc-nav&#x27;)</span><br><span class="line">            != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br><span class="line">          script(type=&#x27;text/javascript&#x27;, src=url_for(theme.js) + &#x27;/toc.js&#x27; + &#x27;?v=&#x27; + theme.version)</span><br><span class="line">    else </span><br><span class="line">      .pure-u-1-4.hidden_mid_and_down: #sidebar-toc</span><br><span class="line">        div(id=&quot;sidebar-stoc&quot; class=&quot;stoc-article&quot;)</span><br><span class="line">          strong(class=&quot;stoc-title&quot;)</span><br><span class="line">            i(class=&#x27;fa&#x27;)= &#x27; Contents &#x27;</span><br><span class="line">          div(id=&quot;stoc&quot; class=&#x27;toc-nav&#x27;)</span><br><span class="line">            != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br><span class="line">          script(type=&#x27;text/javascript&#x27;, src=url_for(theme.js) + &#x27;/toc.js&#x27; + &#x27;?v=&#x27; + theme.version)</span><br><span class="line">  .pure-u-1.pure-u-md-3-4</span><br><span class="line">    != partial(&#x27;_partial/footer.pug&#x27;)</span><br></pre></td></tr></table></figure><h3 id="3、toc-js"><a href="#3、toc-js" class="headerlink" title="3、toc.js"></a>3、toc.js</h3><p><code>themes/maupassant/source/js/toc.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toc = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;sidebar-stoc&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> HEADER_OFFSET = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">var</span> toclink = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;toc-link&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> headerlink = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;headerlink&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (toc != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, scrollcatelogHandler);</span><br><span class="line"><span class="keyword">var</span> tocPosition = toc.offsetTop;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollcatelogHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event,</span><br><span class="line">     target = event.target || event.srcElement;</span><br><span class="line"> <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line"> <span class="keyword">if</span> (scrollTop &gt;  tocPosition -<span class="number">60</span>) &#123;</span><br><span class="line">     toc.classList.add(<span class="string">&quot;stoc-fixed&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     toc.classList.remove(<span class="string">&quot;stoc-fixed&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;toclink.length; i++)&#123;</span><br><span class="line"><span class="comment">//console.log(i);</span></span><br><span class="line"><span class="keyword">var</span> currentHeaderTop = headerlink[i].offsetTop - HEADER_OFFSET,</span><br><span class="line">nextHeaderTop = i+<span class="number">1</span> === toclink.length ? <span class="literal">Infinity</span> : headerlink[i+<span class="number">1</span>].offsetTop - HEADER_OFFSET;</span><br><span class="line"><span class="keyword">if</span>(currentHeaderTop &lt; scrollTop &amp;&amp; scrollTop &lt;= nextHeaderTop)&#123;</span><br><span class="line">toclink[i].classList.add(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">toclink[i].classList.remove(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、style-scss"><a href="#4、style-scss" class="headerlink" title="4、style.scss"></a>4、style.scss</h3><p><code>themes/maupassant/source/css/style.scss</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// toc start</span><br><span class="line"><span class="selector-id">#sidebar-toc</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-article</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">1em</span> <span class="number">0</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="built_in">rgba</span>(<span class="number">88</span>,<span class="number">88</span>,<span class="number">88</span>,<span class="number">0.1</span>) <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-title</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">150%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar-stoc</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: inherit;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.9em</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-fixed</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">81%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.toc-nav</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.7em</span> <span class="number">0.7em</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#stoc</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="selector-class">.active</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#0085a1</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#F5F5F5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.toc</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0.5em</span>;</span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">1.8em</span>;</span><br><span class="line">      <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">list-style-type</span>: none;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.toc-child</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// toc end</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-从ReentrantLock的实现看AQS的原理及应用</title>
      <link href="/posts/30988.html"/>
      <url>/posts/30988.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/30988/main.png"></p><p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。<br>AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。</p><h2 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1 ReentrantLock"></a>1 ReentrantLock</h2><h3 id="1-1-ReentrantLock特性概览"><a href="#1-1-ReentrantLock特性概览" class="headerlink" title="1.1 ReentrantLock特性概览"></a>1.1 ReentrantLock特性概览</h3><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。<br><img src="/posts/30988/%E5%AF%B9%E6%AF%94.png" alt="ReentrantLock VS Synchronized"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **************************Synchronized的使用方式**************************</span></span><br><span class="line"><span class="comment">// 1.用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 2.用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="comment">// 3.用于方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 4.可重入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **************************ReentrantLock的使用方式**************************</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> throw Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1.初始化选择公平锁、非公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 2.可用于代码块</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span></span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.手动释放锁</span></span><br><span class="line">lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-ReentrantLock与AQS的关联"><a href="#1-2-ReentrantLock与AQS的关联" class="headerlink" title="1.2 ReentrantLock与AQS的关联"></a>1.2 ReentrantLock与AQS的关联</h3><p>ReentrantLock支持公平锁和非公平锁，并且ReentrantLock的底层就是由AQS来实现的。<br>那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 从这两者的加锁过程来理解一下它们与AQS之间的关系。</p><h4 id="非公平锁加锁"><a href="#非公平锁加锁" class="headerlink" title="非公平锁加锁"></a>非公平锁加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#NonfairSync</span></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码的含义为：</p><ol><li>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</li><li>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</li></ol><p>第二步获取锁失败后，后续的处理策略是怎么样的？</p><ul><li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：<ol><li>将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</li><li>存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</li></ol></li><li>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</li><li>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</li><li>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</li></ul><h4 id="公平锁加锁"><a href="#公平锁加锁" class="headerlink" title="公平锁加锁"></a>公平锁加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#FairSync</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  ...  </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p><p>对于上边提到的问题，其实在ReentrantLock源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。<br>下面对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。</p><h2 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2 AQS"></a>2 AQS</h2><p><img src="/posts/30988/AQS.png"></p><ul><li>上图中有颜色的为Method，无颜色的为Attribution。</li><li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li><li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li></ul><p>下面从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：<br><img src="/posts/30988/AQS%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B.png"></p><h3 id="2-1-原理概览"><a href="#2-1-原理概览" class="headerlink" title="2.1 原理概览"></a>2.1 原理概览</h3><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</p><p>这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。<br>主要原理图如下：<br><img src="/posts/30988/AQS-CLH%E9%98%9F%E5%88%97.png"></p><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><h4 id="2-1-1-AQS数据结构"><a href="#2-1-1-AQS数据结构" class="headerlink" title="2.1.1 AQS数据结构"></a>2.1.1 AQS数据结构</h4><p>AQS中最基本的数据结构——Node，Node即为上面<code>CLH变体队列</code>中的节点。<br><img src="/posts/30988/AQS-Node.png"></p><p>解释一下几个方法和属性值的含义：</p><table><thead><tr><th align="left">方法和属性值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">volatile int waitStatus</td><td align="left">当前节点在队列中的状态</td></tr><tr><td align="left">volatile Thread thread</td><td align="left">表示处于该节点的线程</td></tr><tr><td align="left">volatile Node prev</td><td align="left">前驱指针</td></tr><tr><td align="left">Node nextWaiter</td><td align="left">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td></tr><tr><td align="left">volatile Node next</td><td align="left">后继指针</td></tr><tr><td align="left">final Node predecessor()</td><td align="left">返回前驱节点，没有的话抛出npe</td></tr></tbody></table><p>线程两种锁的模式：</p><ul><li>SHARED    表示线程以共享的模式等待锁</li><li>EXCLUSIVE    表示线程正在以独占的方式等待锁</li></ul><p>waitStatus有下面几个枚举值：</p><ul><li>0 当一个Node被初始化的时候的默认值</li><li>CANCELLED 为1，表示线程获取锁的请求已经取消了</li><li>CONDITION 为-2，表示节点在等待队列中，节点线程等待唤醒</li><li>PROPAGATE 为-3，当前线程处在SHARED情况下，该字段才会使用</li><li>SIGNAL 为-1，表示线程已经准备好了，就等资源释放了</li></ul><h4 id="2-1-2-同步状态State"><a href="#2-1-2-同步状态State" class="headerlink" title="2.1.2 同步状态State"></a>2.1.2 同步状态State</h4><p>AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>下面提供了几个访问这个字段的方法：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected final int getState()</td><td align="left">获取State的值</td></tr><tr><td align="left">protected final void setState(int newState)</td><td align="left">设置State的值</td></tr><tr><td align="left">protected final boolean compareAndSetState(int expect, int update)</td><td align="left">使用CAS方式更新State</td></tr></tbody></table><p>这几个方法都是Final修饰的，说明子类中无法重写它们。<br>我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。<br><img src="/posts/30988/AQS-%E7%8B%AC%E5%8D%A0&%E5%85%B1%E4%BA%AB.png"></p><p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p><h3 id="2-2-AQS重要方法与ReentrantLock的关联"><a href="#2-2-AQS重要方法与ReentrantLock的关联" class="headerlink" title="2.2 AQS重要方法与ReentrantLock的关联"></a>2.2 AQS重要方法与ReentrantLock的关联</h3><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。<br>自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。</p><p>自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected boolean isHeldExclusively()</td><td align="left">该线程是否正在独占资源。只有用到Condition才需要去实现它。</td></tr><tr><td align="left">protected boolean tryAcquire(int arg)</td><td align="left">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td></tr><tr><td align="left">protected boolean tryRelease(int arg)</td><td align="left">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td></tr><tr><td align="left">protected int tryAcquireShared(int arg)</td><td align="left">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td></tr><tr><td align="left">protected boolean tryReleaseShared(int arg)</td><td align="left">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td></tr></tbody></table><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。<br>AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。<br>ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p><p>以<code>非公平锁</code>为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。<br><img src="/posts/30988/AQS-ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png"></p><p>为了更好地理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。<br><img src="/posts/30988/AQS-ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81&%E8%A7%A3%E9%94%81.png"></p><p>加锁：</p><ul><li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li><li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</li><li>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li><li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li></ul><p>解锁：</p><ul><li>通过ReentrantLock的解锁方法Unlock进行解锁。</li><li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li><li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li><li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li></ul><p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。<br><img src="/posts/30988/AQS-ReentrantLock-API%E5%B1%82.png"></p><h3 id="2-3-通过ReentrantLock理解AQS"><a href="#2-3-通过ReentrantLock理解AQS" class="headerlink" title="2.3 通过ReentrantLock理解AQS"></a>2.3 通过ReentrantLock理解AQS</h3><p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p><p>在非公平锁中，有一段这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下这个Acquire是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下tryAcquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。<br>如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。</p><p>ReentrantLock.NonfairSync非公平锁的tryAcquire实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.NonfairSync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p><h4 id="2-3-1-线程加入等待队列"><a href="#2-3-1-线程加入等待队列" class="headerlink" title="2.3.1 线程加入等待队列"></a>2.3.1 线程加入等待队列</h4><h5 id="2-3-1-1-加入队列的时机"><a href="#2-3-1-1-加入队列的时机" class="headerlink" title="2.3.1.1 加入队列的时机"></a>2.3.1.1 加入队列的时机</h5><p>当执行Acquire(1)时，会通过tryAcquire获取锁。<br>在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p><h5 id="2-3-1-2-如何加入队列"><a href="#2-3-1-2-如何加入队列" class="headerlink" title="2.3.1.2 如何加入队列"></a>2.3.1.2 如何加入队列</h5><p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列。<br>具体实现方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的流程如下：</p><ol><li>通过当前的线程和锁模式新建一个节点。</li><li>Pred指针指向尾节点Tail。</li><li>将New中Node的Prev指针指向Pred。</li><li>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。<br> tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。<br> 同时，由于是双向链表，也需要将前一个节点指向尾节点。</li><li>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Node t = tail;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.prev = t;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next = node;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果没有被初始化，需要进行初始化一个头结点出来。<br> 但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。<br> 其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</li></ol><h5 id="2-3-1-3-等待队列中线程出队列时机"><a href="#2-3-1-3-等待队列中线程出队列时机" class="headerlink" title="2.3.1.3 等待队列中线程出队列时机"></a>2.3.1.3 等待队列中线程出队列时机</h5><p>回到最初的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。<br>acquireQueued方法可以对排队中的线程进行“获锁”操作。</p><p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p><p>下面从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 标记是否成功拿到资源</span></span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 标记等待过程中是否中断过</span></span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 开始自旋，要么获取锁，要么中断</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span></span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"><span class="comment">// 获取锁成功，头指针移动到当前node</span></span><br><span class="line">setHead(node);</span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span></span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">head = node;</span><br><span class="line">node.thread = <span class="keyword">null</span>;</span><br><span class="line">node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="comment">// 靠前驱节点判断当前线程是否应该被阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取头结点的节点状态</span></span><br><span class="line"><span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line"><span class="comment">// 说明头结点处于唤醒状态</span></span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line"><span class="comment">// 通过枚举值我们知道waitStatus&gt;0是取消状态</span></span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 循环向前查找取消节点，把取消节点从队列中剔除</span></span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">pred.next = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 设置前任节点等待状态为SIGNAL</span></span><br><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法的流程图如下：<br><img src="/posts/30988/AQS-%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%87%BA%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95.png"><br>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。</p><p>为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起。<br>具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：<br><img src="/posts/30988/AQS-%E6%B5%81%E7%A8%8B%E5%9B%BE-shouldParkAfterFailedAcquire.png"></p><p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p><ol><li>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</li><li>是在什么时间释放节点通知到被挂起的线程呢？</li></ol><h4 id="2-3-2-CANCELLED状态节点生成"><a href="#2-3-2-CANCELLED状态节点生成" class="headerlink" title="2.3.2 CANCELLED状态节点生成"></a>2.3.2 CANCELLED状态节点生成</h4><p>acquireQueued方法中的Finally代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">...</span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将无效节点过滤</span></span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 设置该节点不关联任何线程，也就是虚节点</span></span><br><span class="line">node.thread = <span class="keyword">null</span>;</span><br><span class="line">Node pred = node.prev;</span><br><span class="line">  <span class="comment">// 通过前驱节点，跳过取消状态的node</span></span><br><span class="line"><span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">  <span class="comment">// 获取过滤后的前驱节点的后继节点</span></span><br><span class="line">Node predNext = pred.next;</span><br><span class="line">  <span class="comment">// 把当前node的状态设置为CANCELLED</span></span><br><span class="line">node.waitStatus = Node.CANCELLED;</span><br><span class="line">  <span class="comment">// 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span></span><br><span class="line">  <span class="comment">// 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span></span><br><span class="line"><span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ws;</span><br><span class="line">    <span class="comment">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span></span><br><span class="line">    <span class="comment">// 如果1和2中有一个为true，再判断当前节点的线程是否为null</span></span><br><span class="line">    <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span></span><br><span class="line"><span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">Node next = node.next;</span><br><span class="line"><span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">compareAndSetNext(pred, predNext, next);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span></span><br><span class="line">unparkSuccessor(node);</span><br><span class="line">&#125;</span><br><span class="line">node.next = node; <span class="comment">// help GC</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的流程：</p><ul><li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li><li>根据当前节点的位置，考虑以下三种情况：<ol><li>当前节点是尾节点。</li><li>当前节点是Head的后继节点。</li><li>当前节点不是Head的后继节点，也不是尾节点。</li></ol></li></ul><p>根据上述第二条，我们来分析每一种情况的流程。<br>当前节点是尾节点。<br><img src="/posts/30988/AQS-CANCELLED-1.png"></p><p>当前节点是Head的后继节点。<br><img src="/posts/30988/AQS-CANCELLED-2.png"></p><p>当前节点不是Head的后继节点，也不是尾节点。<br><img src="/posts/30988/AQS-CANCELLED-3.png"></p><p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p><blockquote><p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。<br>shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-3-3-如何解锁"><a href="#2-3-3-如何解锁" class="headerlink" title="2.3.3 如何解锁"></a>2.3.3 如何解锁</h4><p>剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。<br>由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质释放锁的地方，是通过框架来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">Node h = head;</span><br><span class="line"><span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync</span></span><br><span class="line"><span class="comment">// 方法返回当前锁是不是没有被线程持有</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 减少可重入次数</span></span><br><span class="line"><span class="keyword">int</span> c = getState() - releases;</span><br><span class="line"><span class="comment">// 当前线程不是持有锁的线程，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"><span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">free = <span class="keyword">true</span>;</span><br><span class="line">setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">setState(c);</span><br><span class="line"><span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来解释下述源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"><span class="comment">// 获取头结点</span></span><br><span class="line">Node h = head;</span><br><span class="line"><span class="comment">// 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span></span><br><span class="line"><span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的判断条件为什么是<code>h != null &amp;&amp; h.waitStatus != 0</code>？</p><blockquote><p>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。<br>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。<br>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p></blockquote><p>再看一下unparkSuccessor方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取头结点waitStatus</span></span><br><span class="line"><span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">Node s = node.next;</span><br><span class="line"><span class="comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span></span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span></span><br><span class="line"><span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line"><span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">s = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把当前节点unpark</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。<br>之前的addWaiter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，<code>node.prev = pred; compareAndSetTail(pred, node)</code>这两个地方可以看作Tail入队的原子操作，但是此时<code>pred.next = node;</code>还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。<br>还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。<br>继续执行acquireQueued方法以后，中断如何处理？</p><h4 id="2-3-4-中断恢复后的执行流程"><a href="#2-3-4-中断恢复后的执行流程" class="headerlink" title="2.3.4 中断恢复后的执行流程"></a>2.3.4 中断恢复后的执行流程</h4><p>唤醒后，会执行<code>return Thread.interrupted();</code>，这个函数返回的是当前执行线程的中断状态，并清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">setHead(node);</span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果acquireQueued为True，就会执行selfInterrupt方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容。这里简单介绍一下：</p><ol><li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li><li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li></ol><p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，可以看下ThreadPoolExecutor源码。</p><h4 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h4><blockquote><p>Q：某个线程获取锁失败的后续流程是什么呢？<br>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？<br>A：是CLH变体的FIFO双端队列。</p><p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？<br>A：可以详细看下2.3.1.3小节。</p><p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？<br>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p><p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？<br>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p></blockquote><h3 id="3-AQS应用"><a href="#3-AQS应用" class="headerlink" title="3 AQS应用"></a>3 AQS应用</h3><h4 id="3-1-ReentrantLock的可重入应用"><a href="#3-1-ReentrantLock的可重入应用" class="headerlink" title="3.1 ReentrantLock的可重入应用"></a>3.1 ReentrantLock的可重入应用</h4><p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，很容易得知ReentrantLock实现可重入的方法。<br>在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p><ul><li>公平锁  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>非公平锁  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires))&#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。<br>State是Volatile修饰的，用于保证一定的可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>接下来看State这个字段主要的过程：</p><ol><li>State初始化的时候为0，表示没有任何线程持有锁。</li><li>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</li><li>解锁也是对这个字段-1，一直到0，此线程对锁释放。</li></ol><h4 id="3-2-JUC中的应用场景"><a href="#3-2-JUC中的应用场景" class="headerlink" title="3.2 JUC中的应用场景"></a>3.2 JUC中的应用场景</h4><table><thead><tr><th align="left">同步工具</th><th align="left">同步工具与AQS的关联</th></tr></thead><tbody><tr><td align="left">ReentrantLock</td><td align="left">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td align="left">Semaphore</td><td align="left">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td align="left">CountDownLatch</td><td align="left">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td align="left">ReentrantReadWriteLock</td><td align="left">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td align="left">ThreadPoolExecutor</td><td align="left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table><h4 id="3-3-自定义同步工具"><a href="#3-3-自定义同步工具" class="headerlink" title="3.3 自定义同步工具"></a>3.3 自定义同步工具</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-asset-image &amp; hexo-abbrlink</title>
      <link href="/posts/39037.html"/>
      <url>/posts/39037.html</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-asset-image"><a href="#hexo-asset-image" class="headerlink" title="hexo-asset-image"></a>hexo-asset-image</h2><ol><li>/node_modules/hexo-asset-image/index.js</li><li><code>post_asset_folder: true</code></li><li><code>![](/example.jpg)</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">      <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">  <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">     <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">  <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">      <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">      <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">         !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">        <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">        <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">        <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">        srcArray.shift();</span><br><span class="line">        src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="hexo-asset-image-amp-hexo-abbrlink"><a href="#hexo-asset-image-amp-hexo-abbrlink" class="headerlink" title="hexo-asset-image &amp; hexo-abbrlink"></a>hexo-asset-image &amp; hexo-abbrlink</h2><p><strong>hexo-abbrlink</strong>插件功能：<br>全自动生成惟一的不带中文的博客链接</p><p>原理：<br>对<strong>标题+时间</strong>进行<strong>md5</strong>而后再转<strong>base64</strong>，保存在<strong>front-matter</strong>中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span></span><br><span class="line"><span class="comment">#abbrlink</span></span><br><span class="line"><span class="attr">abbrink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">dec</span></span><br></pre></td></tr></table></figure><p>链接是修改了，但是图片不能成功显示。<br>后来发现是与<strong>hexo-asset-image</strong>不能适配的问题，<strong>hexo-abbrlink使用后导致图片路径变化</strong>，所以不能成功识别图片。<br>所以需要修改下面的文件：<strong>\node_modules\hexo-asset-image\index.js</strong></p><ol><li>在源码的12行附近<code>var link = data.permalink;</code>这一行的下面，添加一行<code>var abbrlink = data.abbrlink</code>（意思是定义一个变量abbrlink）</li><li>在44行附近，源码的<code>$(this).attr(&#39;src&#39;, config.root + link + src);</code>这一行，修改 为下面一行：<br><code>$(this).attr(&#39;src&#39;, config.root + &#39;posts/&#39; + abbrlink + &#39;/&#39; + src); //适配abbrlink</code>（意思是生成的图片链接中，拼接abbrlink）</li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-锁</title>
      <link href="/posts/1005.html"/>
      <url>/posts/1005.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/1005/main.png"></p><h2 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。<br>在Java和数据库中都有此概念对应的实际应用。</p><p>对于同一个数据的并发操作，<code>悲观锁</code>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<br>Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p><code>乐观锁</code>认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。<br>如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。<br>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p><img src="/posts/1005/%E4%B9%90%E8%A7%82%E9%94%81vs%E6%82%B2%E8%A7%82%E9%94%81.png"></p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><blockquote><p>如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。<br>资金相关的金融敏感信息，使用悲观锁策略。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized 同步关键字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock 加锁</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。<br>那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？</p><h3 id="CAS技术原理"><a href="#CAS技术原理" class="headerlink" title="CAS技术原理"></a>CAS技术原理</h3><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。<br>在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。<br>java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><h4 id="AtomicInteger的源码"><a href="#AtomicInteger的源码" class="headerlink" title="AtomicInteger的源码"></a>AtomicInteger的源码</h4><p>jdk11</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This class intended to be implemented using VarHandles, but there</span></span><br><span class="line"><span class="comment">     * are unresolved cyclic startup dependencies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><p>AtomicInteger的自增函数incrementAndGet() -&gt; unsafe.getAndAddInt()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicInteger的自增函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>根据OpenJDK 8的源码可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><h4 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h4><ol><li><code>ABA问题。</code>CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。<ul><li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li></ul></li><li><code>循环时间长开销大。</code>CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li><code>只能保证一个共享变量的原子操作。</code>对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。<ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul></li></ol><h2 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h2><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。<br>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="/posts/1005/%E8%87%AA%E6%97%8B%E9%94%81vs%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81.png"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适应性"><a href="#适应性" class="headerlink" title="适应性"></a>适应性</h3><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock。</p><h2 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。</p><h3 id="为什么Synchronized能实现线程同步？"><a href="#为什么Synchronized能实现线程同步？" class="headerlink" title="为什么Synchronized能实现线程同步？"></a>为什么Synchronized能实现线程同步？</h3><p>在回答这个问题之前需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？<br>以<code>Hotspot虚拟机</code>为例，Hotspot的对象头主要包括两部分数据：<code>Mark Word（标记字段）</code>、<code>Klass Pointer（类型指针）</code>。</p><ul><li><code>Mark Word</code>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</li><li><code>Klass Point</code>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。<br>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><blockquote><p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p></blockquote><p>在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为<code>重量级锁</code>。<br>JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了<code>偏向锁</code>和<code>轻量级锁</code>。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><table><thead><tr><th align="left">锁状态</th><th align="center">Mark Word内容</th><th align="right">标志位</th></tr></thead><tbody><tr><td align="left">无锁</td><td align="center">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td align="right">01</td></tr><tr><td align="left">偏向锁</td><td align="center">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td align="right">01</td></tr><tr><td align="left">轻量级锁</td><td align="center">指向栈中锁记录的指针</td><td align="right">00</td></tr><tr><td align="left">重量级锁</td><td align="center">指向互斥量（重量级锁）的指针</td><td align="right">10</td></tr><tr><td align="left">可GC</td><td align="center">～</td><td align="right">11</td></tr></tbody></table><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。<br>如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p><p>CAS原理及应用即是无锁的实现。<br>无锁无法全面代替有锁，但无锁在某些场合下（读多写少）的性能是非常高的。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。<br>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。<br>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，关闭之后程序默认会进入轻量级锁状态。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>升级为重量级锁时，锁标志的状态值变为<code>10</code>，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><ul><li><code>偏向锁</code>通过对比Mark Word解决加锁问题，避免执行CAS操作。</li><li><code>轻量级锁</code>是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</li><li><code>重量级锁</code>是将除了拥有锁的线程以外的线程都阻塞。</li></ul><h2 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h2><p><code>公平锁</code>是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。<br>公平锁的优点是等待锁的线程不会饿死。<br>缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p><code>非公平锁</code>是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。<br>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。<br>缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>通过ReentrantLock的源码来看看公平锁和非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">     * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">     * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">     * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。<br>它有公平锁FairSync和非公平锁NonfairSync两个子类。<br>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p>公平锁与非公平锁的加锁方法的源码:<br><img src="/posts/1005/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%96%B9%E6%B3%95.png" alt="公平锁和非公平锁的加锁方法"></p><p>通过上图中的源代码对比，可以看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">            <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">            <span class="comment">// thread is first in queue.</span></span><br><span class="line">            Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            Node s;</span><br><span class="line">            <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。<br>Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><p>下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。<br>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><h3 id="为什么可重入锁就可以在嵌套调用时可以自动获得锁"><a href="#为什么可重入锁就可以在嵌套调用时可以自动获得锁" class="headerlink" title="为什么可重入锁就可以在嵌套调用时可以自动获得锁"></a>为什么可重入锁就可以在嵌套调用时可以自动获得锁</h3><p><img src="/posts/1005/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81vs%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png"></p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。<br>非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。<br>非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><h2 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h2><p>独享锁和共享锁同样是一种概念。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。<br>JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>ReentrantReadWriteLock的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6992448646407690164L</span>;</span><br><span class="line">    <span class="comment">/** Inner class providing readlock */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** Inner class providing writelock */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">/** Performs all synchronization mechanics */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">     * default (nonfair) ordering properties.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">     * the given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructor for use by subclasses.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> lock the outer lock object</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> NullPointerException if the lock is null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructor for use by subclasses.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> lock the outer lock object</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> NullPointerException if the lock is null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。<br>ReadLock和WriteLock是靠内部类Sync实现的锁。<br>Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。<br>读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><h3 id="读锁和写锁的具体加锁方式"><a href="#读锁和写锁的具体加锁方式" class="headerlink" title="读锁和写锁的具体加锁方式"></a>读锁和写锁的具体加锁方式</h3><p>AQS中的<code>waitStatus</code>字段（int类型，32位），该字段用来描述有多少线程获持有锁。<br>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数）。<br>在共享锁中state就是持有锁的数量。<br>但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。<br><img src="/posts/1005/waitStatus.png"></p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line"><span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"><span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock中公平锁和非公平锁添加的都是独享锁"><a href="#ReentrantLock中公平锁和非公平锁添加的都是独享锁" class="headerlink" title="ReentrantLock中公平锁和非公平锁添加的都是独享锁"></a>ReentrantLock中公平锁和非公平锁添加的都是独享锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。<br>所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-synchronized、volatile、final关键字</title>
      <link href="/posts/51943.html"/>
      <url>/posts/51943.html</url>
      
        <content type="html"><![CDATA[<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized中文意思是同步，也称之为”同步锁“。<br>Synchronized关键字解决的是多个线程之间访问资源的同步性<br>synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。<br>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</p><p>synchronized的3种使用方式：</p><ul><li>类锁<br>  修饰静态方法：其作用的范围是整个静态方法，锁对象为Class对象<br>  修饰代码块：synchronized指定锁对象为Class对象</li><li>对象锁<br>  修饰实例方法：其作用的范围是整个方法，锁对象为this,当前实例对象<br>  修饰代码块：其作用的范围是大括号{}括起来的代码，自己指定锁对象</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="加锁和释放锁的原理：Monitor"><a href="#加锁和释放锁的原理：Monitor" class="headerlink" title="加锁和释放锁的原理：Monitor"></a>加锁和释放锁的原理：Monitor</h4><p>JVM 是通过进入、退出<code>对象监视器(Monitor)</code>来实现对方法、同步块的同步的，而对象监视器的本质依赖于底层操作系统的<code>互斥锁(Mutex Lock)</code>实现。</p><p>具体实现是在编译之后在同步方法调用前加入一个<code>monitor.enter</code>指令，在退出方法和异常处插入<code>monitor.exit</code>的指令。<br>对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程<code>monitor.exit</code>之后才能尝试继续获取锁。</p><h4 id="可重入原理：加锁次数计数器"><a href="#可重入原理：加锁次数计数器" class="headerlink" title="可重入原理：加锁次数计数器"></a>可重入原理：加锁次数计数器</h4><p>在同一锁程中，每个对象拥有一个monitor计数器，当线程获取该对象锁后，monitor计数器就会加一，释放锁后就会将monitor计数器减一，线程不需要再次获取同一把锁。</p><h4 id="保证可见性的原理：内存模型和happens-before规则"><a href="#保证可见性的原理：内存模型和happens-before规则" class="headerlink" title="保证可见性的原理：内存模型和happens-before规则"></a>保证可见性的原理：内存模型和happens-before规则</h4><p>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。</p><p>如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。</p><h3 id="JVM中锁的优化"><a href="#JVM中锁的优化" class="headerlink" title="JVM中锁的优化"></a>JVM中锁的优化</h3><p>简单来说在 JVM中 monitorenter 和 monitorexit 字节码依赖于底层的操作系统的 Mutex Lock 来实现的，但是由于使用 Mutex Lock 需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。<br>然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用 Mutex Lock 那么将严重的影响程序的性能。</p><p>在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。</p><h4 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁 偏向锁 轻量级锁 重量级锁"></a>无锁 偏向锁 轻量级锁 重量级锁</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&mid=2247488192&idx=1&sn=85fa12be29fef85d41c571b2c853de5d&scene=21#wechat_redirect">关于 Synchronized 的一个点</a></p><h4 id="自旋与自适应自旋"><a href="#自旋与自适应自旋" class="headerlink" title="自旋与自适应自旋"></a>自旋与自适应自旋</h4><p>自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态，同时在JDK 1.6中引入了自适应自旋锁。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p><p>锁消除的主要判定依据来源于逃逸分析的数据支持。<br>意思就是：JVM会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p><p>​大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test04</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述的连续append()操作中就属于这类情况。StringBuffer的每个方法都是synchronized修饰的。<br>JVM会检测到这样一连串的操作都是对同一个对象加锁，那么JVM会将加锁同步的范围扩展(粗化)到整个一系列操作的外部，使整个一连串的append()操作只需要加锁一次就可以了。</p><h3 id="syncorinized与Lock"><a href="#syncorinized与Lock" class="headerlink" title="syncorinized与Lock"></a>syncorinized与Lock</h3><h4 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h4><ul><li>效率低<br>  锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程；<br>  相对而言，Lock可以中断和设置获取超时</li><li>不够灵活<br>  加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，<br>  相对而言，读写锁更加灵活</li><li>无法知道是否成功获得锁<br>  相对而言，Lock可以拿到状态，如果成功获取锁，….，如果获取失败，…..<h4 id="Lock解决相应的问题"><a href="#Lock解决相应的问题" class="headerlink" title="Lock解决相应的问题"></a>Lock解决相应的问题</h4></li><li>lock(): 加锁</li><li>unlock(): 解锁</li><li>tryLock(): 尝试获取锁，返回一个boolean值</li><li>tryLock(long,TimeUtil): 尝试获取锁，可以设置超时</li></ul><p>Synchronized加锁只与一个条件(是否获取锁)相关联，不灵活，后来Condition与Lock的结合解决了这个问题。</p><p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断，高并发的情况下会导致性能下降。<br>ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。<br>一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。</p><h3 id="syncorinized使用问题"><a href="#syncorinized使用问题" class="headerlink" title="syncorinized使用问题"></a>syncorinized使用问题</h3><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li><li>synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。</p><p>volatile 变量的<strong>内存可见性</strong>是基于**内存屏障(Memory Barrier)**实现</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><h5 id="volatile-的-happens-before-关系"><a href="#volatile-的-happens-before-关系" class="headerlink" title="volatile 的 happens-before 关系"></a>volatile 的 happens-before 关系</h5><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><h5 id="volatile-禁止重排序"><a href="#volatile-禁止重排序" class="headerlink" title="volatile 禁止重排序"></a>volatile 禁止重排序</h5><p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了<strong>内存屏障</strong>阻止这种重排序。</p><p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。<br>JMM 会针对编译器制定 volatile 重排序规则表。</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。<br>  禁止上面的普通写和下面的 volatile 写重排序。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。<br>  防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。<br>  禁止下面所有的普通读操作和上面的 volatile 读重排序。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。<br>  禁止下面所有的普通写操作和上面的 volatile 读重排序。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><h3 id="volatile的应用场景"><a href="#volatile的应用场景" class="headerlink" title="volatile的应用场景"></a>volatile的应用场景</h3><ol><li>单例模式-双重检查 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            syschronized(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li>所有的final修饰的字段都是编译期常量吗?</li><li>如何理解private所修饰的方法是隐式的final?</li><li>说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做?</li><li>final方法可以被重载吗? 可以</li><li>父类的final方法能不能够被子类重写? 不可以</li><li>说说final域重排序规则?</li><li>说说final的原理?</li><li>使用 final 的限制条件和局限性?</li></ul><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><ul><li><p>修饰类<br>  当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。<br>  final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。</p><p>  设计模式中最重要的两种关系，一种是继承/实现；另外一种是组合关系。所以当遇到不能用继承的(final修饰的类),应该考虑用组合。</p></li><li><p>修饰方法<br>  private 方法是隐式的final，private方法无法被子类继承、覆盖。<br>  final方法是可以被重载的。</p></li><li><p>修饰参数</p></li><li><p>修饰变量</p></li></ul><h3 id="final域重排序规则"><a href="#final域重排序规则" class="headerlink" title="final域重排序规则"></a>final域重排序规则</h3><p>有考虑过final在多线程并发的情况吗?<br>在java内存模型中我们知道java内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说针对底层来说java内存模型就是一弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。<br>那么，在多线程情况下，final会进行怎样的重排序? 会导致线程安全的问题吗? </p><p>关于final重排序的总结<br>按照final修饰的数据类型分类：</p><ul><li>基本数据类型:<ul><li>final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li><li>final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。</li></ul></li><li>引用数据类型：<ul><li>额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-JUC集合-ConcurrentHashMap</title>
      <link href="/posts/34238.html"/>
      <url>/posts/34238.html</url>
      
        <content type="html"><![CDATA[<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ul><li>为什么会有ConcurrentHashMap<br>  HashMap线程不安全，HashTable线程安全但效率低下。</li><li>为什么HashMap线程不安全<br>  1.7中transfer()链表使用头插法，多线程情况下，会成环；<br>  1.8中putVal()，多线程操作，值会出现覆盖情况。</li><li>为什么HashTable效率低下<br>  HashTable之所以效率低下主要是因为它的实现使用了synchronized关键字对put等方法进行加锁，锁的是HashTable实例对象。</li><li>ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别? JDK1.8解決了JDK1.7中什么问题</li><li>ConcurrentHashMap JDK1.7实现的原理是什么? 分段锁机制</li><li>ConcurrentHashMap JDK1.8实现的原理是什么? 数组+链表+红黑树，CAS</li><li>ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少? 为何一旦初始化就不可再扩容?</li><li>ConcurrentHashMap JDK1.7说说其put的机制?</li><li>ConcurrentHashMap JDK1.7是如何扩容的? rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容)</li><li>ConcurrentHashMap JDK1.8是如何扩容的? tryPresize</li><li>ConcurrentHashMap JDK1.8链表转红黑树的时机是什么? 临界值为什么是8?</li><li>ConcurrentHashMap JDK1.8是如何进行数据迁移的? transfe</li></ul><h3 id="ConcurrentHashMap加锁原理"><a href="#ConcurrentHashMap加锁原理" class="headerlink" title="ConcurrentHashMap加锁原理"></a>ConcurrentHashMap加锁原理</h3><h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><p>1.8只有1个table(Map.Entry数组)，同步机制为<code>CAS + synchronized</code>保证并发更新。<br>锁的粒度更细，减少了冲突，提高了并发度。</p><p>1.8放弃了Segment，直接用<code>Node数组+链表+红黑树</code>的数据结构来实现，并发控制使用<code>Synchronized + CAS</code>来实现更细粒度的锁保护，整个看起来就像是优化过且线程安全的HashMap。<br>这里的更细粒度的锁是指锁table的首个Node节点。<br>在添加数据putVal的时候，根据 key 的 hash 值 定位到 Node节点，如果Node节点为空的话，则会使用CAS去赋值；不为空并且发生hash冲突则进入锁代码块，用 synchronized 去锁住首节点，执行插入链表或红黑树或转红黑树操作。</p><blockquote><p>取消segments字段，采用table数组元素作为锁（使用synchronized锁住），从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。<br>可以说将segment和数组合二为一</p></blockquote><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><p>1.7是使用segements(16个segement)，每个segement都有一个table(Map.Entry数组)，相当于16个HashMap，同步机制为分段锁，每个segment继承ReentrantLock。<br>默认并发是16，一旦初始化，Segment 数组大小就固定，后面不能扩容。</p><p>ConcurrentHashMap 是由<code>Segment 数组结构 + HashEntry 数组结构 + 链表</code>组成。<br>Segment 是一种可重入锁 ReentrantLock（Segment 继承了ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色。<br>HashEntry 则用于存储键值对数据。</p><p>put操作时，先获取锁 <code>tryLock()</code>，根据 key 的 hash 值 定位到 Segment ，再根据 key 的 hash 值 找到具体的 HashEntry ，再进行插入或覆盖，最后释放锁。</p><p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是<code>HashEntry数组+链表</code>，这个和HashMap的数据存储结构一样。</p><h2 id="ConcurrentHashMap-JDK-1-8"><a href="#ConcurrentHashMap-JDK-1-8" class="headerlink" title="ConcurrentHashMap - JDK 1.8"></a>ConcurrentHashMap - JDK 1.8</h2><p>在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。<br>因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的<strong>数组+链表+红黑树</strong>的方式实现，而<strong>加锁则采用CAS和synchronized实现</strong>。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/posts/34238/concurrenthashmap-jdk1.8-%E7%BB%93%E6%9E%84.png"></p><p>结构上和Java 8的HashMap基本上一样，不过它要保证线程安全，所以在源码上要复杂一些。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 散列表最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 散列表默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大数组长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 默认并发级别 jdk1.7 之前遗留的 1.8只用于初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表树化条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 取消树化条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 结点树化条件 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 线程迁移数据最小步长 控制线程迁移任务最小区间的一个值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//  扩容用  计算扩容生成一个标识戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 65535 标识并发扩容最大线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 扩容相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node 结点的hash 是-1 表示 当前结点是forwardingNode结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"><span class="comment">// 红黑树的代理结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"><span class="comment">// 临时保留的散列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="comment">// 0x7fffffff = 31个1  用于将一个负数变成一个正数 但是不是取绝对值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统CPu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// 散列表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容用的临时散列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// LongAdder 的baseCount </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">sizeCtl &lt;0 </span></span><br><span class="line"><span class="comment">1. -1 的时候 表示table正在初始化(有线程正在初始化 ， 当前线程应该自旋等待)</span></span><br><span class="line"><span class="comment">2. 其他情况 表示当前map正在进行扩容 高16位表示 扩容的标识戳 ， 低16位表示 扩容线程数量</span></span><br><span class="line"><span class="comment">sizeCtl = 0 </span></span><br><span class="line"><span class="comment">表示创建数组 使用默认容量 16</span></span><br><span class="line"><span class="comment">sizeCtl &gt;0</span></span><br><span class="line"><span class="comment">1. 如果table 未初始化 表示 初始化大小</span></span><br><span class="line"><span class="comment">2. 如果table 已经初始化 表示下次扩容的阈值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容过程中，记录当前进度，所有线程都需要从transferIndex中分配区间任务，去执行自己的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"><span class="comment">// 0 表示 无锁 1 表示加锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"> <span class="comment">// LongAdder 中的cells 数组 当baseCount发生竞争后 会创建cells 数组</span></span><br><span class="line"> <span class="comment">// 线程会通过计算hash值 取到自己的cell中</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这构造函数里，什么都不干</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">               <span class="comment">// &gt;&gt;&gt; 1   无符号右移1位，相当于除2</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。<br>如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p><h3 id="putVal-put过程分析"><a href="#putVal-put过程分析" class="headerlink" title="putVal put过程分析"></a>putVal put过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onlyIfAbsent --&gt; ture 表示如果遇到相同的key 进行不进行置换；false 表示置换</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无论key还是value,不允许空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//此处获取hash值的方法与HashTable类似，通过扰动函数 计算出hash 高16位也参与运算</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//  binCount 表示当前k-v封装成node后插入到指定桶位后，在桶位中所属链表的下标位置</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            f  -&gt; 头结点 </span></span><br><span class="line"><span class="comment">            n  -&gt; 代表table的长度 </span></span><br><span class="line"><span class="comment">            i  -&gt; 索引 </span></span><br><span class="line"><span class="comment">            fh -&gt; 头结点hash</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//1. 如果节点数组为null，或者长度为0，初始化节点数组</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="comment">//   如果数组该位置为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 以cas方式进行替换，替换成功就中断循环</span></span><br><span class="line">            <span class="comment">// 如果CAS替换失败，那就是有并发操作，则进行下一次循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 表已经创建 &amp;&amp; 头结点不是空 </span></span><br><span class="line">        <span class="comment">// 判断头结点的hash 是不是等于-1  看是不是forwardingNode结点 如果是 说明哈希表正在处于扩容的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助进行扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 表已经创建 &amp;&amp; 头结点不是空 &amp;&amp; 不处于扩容中 &amp;&amp; 头结点不是key相同的结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 锁定节点数组的头节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; </span><br><span class="line">                <span class="comment">// 再次查询头结点是不是等于f </span></span><br><span class="line">            <span class="comment">// 防止你加锁的过程中 别人已经修改了头结点的值，导致操作出现问题</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前该节点为链表形态</span></span><br><span class="line">                    <span class="comment">// 头节点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//1. 链表中存在相同的key，判断是否要进行值覆盖</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//2. 如果不存在相同的key，就添加到链表到末尾</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果当前为红黑树形态，进行红黑树到查找和替代(存在相同的key)，或者放入红黑树到新叶节点上(key不存在)</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果一个节点中的数量大于1（只有大于1的才会有binCount）</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果链表长度超过了8，链表转红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//进行转换成红黑树处理</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计节点个数，检查是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-8-中-ConcurrentHashMap-put操作为什么用synchronized？"><a href="#1-8-中-ConcurrentHashMap-put操作为什么用synchronized？" class="headerlink" title="1.8 中 ConcurrentHashMap put操作为什么用synchronized？"></a>1.8 中 ConcurrentHashMap put操作为什么用synchronized？</h4><p>有两个原因：</p><ol><li>减少内存开销<br> 假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</li><li>获得JVM的支持<br> 可重入锁毕竟是API这个级别的，后续的性能优化空间很小。<br> synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</li></ol><h3 id="初始化数组-initTable"><a href="#初始化数组-initTable" class="headerlink" title="初始化数组 initTable"></a>初始化数组 initTable</h3><p>初始化一个合适大小的数组，然后会设置 sizeCtl。<br>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 初始化数组，长度为 16 或初始化时提供的长度</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 如果 n 为 16 的话，那么这里 sc = 12</span></span><br><span class="line">                    <span class="comment">// 其实就是 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 sizeCtl 为 sc，我们就当是 12 吧</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树 treeifyBin"></a>链表转红黑树 treeifyBin</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// MIN_TREEIFY_CAPACITY 为 64</span></span><br><span class="line">        <span class="comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 后面我们再详细分析这个方法</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// b 是头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">// 下面就是遍历链表，建立一颗红黑树</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将红黑树设置到数组相应位置中</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容-tryPresize"><a href="#扩容-tryPresize" class="headerlink" title="扩容 tryPresize"></a>扩容 tryPresize</h3><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是<strong>扩容操作</strong>和<strong>迁移操作</strong>。<br>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c: size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 0.75 * n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span></span><br><span class="line">                <span class="comment">//    此时 nextTab 不为 null</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">            <span class="comment">//     我是没看懂这个值真正的意义是什么? 不过可以计算出来的是，结果是一个比较大的负数</span></span><br><span class="line">            <span class="comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据迁移-transfer"><a href="#数据迁移-transfer" class="headerlink" title="数据迁移 transfer"></a>数据迁移 transfer</h3><h3 id="get过程分析"><a href="#get过程分析" class="headerlink" title="get过程分析"></a>get过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.ConcurrentHashMap#get</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头节点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) <span class="comment">// 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.ConcurrentHashMap#tabAt</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get过程：</p><ol><li>计算 hash 值</li><li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li><li>根据该位置处结点性质进行相应查找 <ol><li>如果该位置为 null，那么直接返回 null 就可以了</li><li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li><li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li><li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li></ol></li></ol><h4 id="JDK-1-8-ConcurrentHashMap-读操作为什么不用加锁？"><a href="#JDK-1-8-ConcurrentHashMap-读操作为什么不用加锁？" class="headerlink" title="JDK 1.8 ConcurrentHashMap 读操作为什么不用加锁？"></a>JDK 1.8 ConcurrentHashMap 读操作为什么不用加锁？</h4><p>读的时候如果不是恰好读到写线程写入相同Hash值的位置(可以认为我们的操作一般是读多写少，这种几率也比较低)<br>ConcurrentHashMap 的 <code>get</code> 方法会调用 <code>tabAt</code> 方法，这是一个Unsafe类volatile的操作，保证每次获取到的值都是最新的。（强制将修改的值立即写入主存）</p><h2 id="ConcurrentHashMap-JDK-1-7"><a href="#ConcurrentHashMap-JDK-1-7" class="headerlink" title="ConcurrentHashMap - JDK 1.7"></a>ConcurrentHashMap - JDK 1.7</h2><p>在JDK1.5~1.7版本，Java使用了分段锁机制实现ConcurrentHashMap。<br>简而言之，ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。因此，ConcurrentHashMap在多线程并发编程中可实现多线程put操作。</p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了<strong>槽</strong>来代表一个 segment。</p><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="/posts/34238/concurrenthashmap-jdk1.7-%E7%BB%93%E6%9E%84.png"></p><p><code>concurrencyLevel</code>: 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。<strong>默认是 16</strong>，也就是说 ConcurrentHashMap 有 16 个 Segments。所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。<br>这个值可以在初始化的时候设置为其他值，但是<strong>一旦初始化以后，它是不可以扩容的</strong>。</p><p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-线程池在业务中的实践</title>
      <link href="/posts/7863.html"/>
      <url>/posts/7863.html</url>
      
        <content type="html"><![CDATA[<p>在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。<br>通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。</p><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><h3 id="场景1：快速响应用户请求"><a href="#场景1：快速响应用户请求" class="headerlink" title="场景1：快速响应用户请求"></a>场景1：快速响应用户请求</h3><p><strong>描述：</strong>用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p><p><strong>分析：</strong>从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p><p><img src="/posts/7863/%E5%BF%AB%E9%80%9F%E5%93%8D%E5%BA%94%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82.png"></p><h3 id="场景2：快速处理批量任务"><a href="#场景2：快速处理批量任务" class="headerlink" title="场景2：快速处理批量任务"></a>场景2：快速处理批量任务</h3><p><strong>描述：</strong>离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p><p><strong>分析：</strong>这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p><p><img src="/posts/7863/%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E6%89%B9%E9%87%8F%E4%BB%BB%E5%8A%A1.png"></p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><ol><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li><li>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</li></ol><h3 id="如何合理配置线程池的大小"><a href="#如何合理配置线程池的大小" class="headerlink" title="如何合理配置线程池的大小"></a>如何合理配置线程池的大小</h3><h4 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h4><h4 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h4><h2 id="实际问题及方案思考"><a href="#实际问题及方案思考" class="headerlink" title="实际问题及方案思考"></a>实际问题及方案思考</h2><p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>。<br>一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大。<br>IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。</p><p>关于线程池配置不合理引发的故障，举例：</p><h3 id="故障实例"><a href="#故障实例" class="headerlink" title="故障实例"></a>故障实例</h3><h4 id="线程数核心设置过小引发RejectExecutionException"><a href="#线程数核心设置过小引发RejectExecutionException" class="headerlink" title="线程数核心设置过小引发RejectExecutionException"></a>线程数核心设置过小引发RejectExecutionException</h4><p>某服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件。<br><img src="/posts/7863/Exception-case1.png" alt="线程数核心设置过小引发RejectExecutionException"></p><h4 id="线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低"><a href="#线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低" class="headerlink" title="线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低"></a>线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低</h4><p>某服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。<br><img src="/posts/7863/Exception-case2.png" alt="线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低"></p><h3 id="动态化线程池"><a href="#动态化线程池" class="headerlink" title="动态化线程池"></a>动态化线程池</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-线程池-ThreadPoolExecutor</title>
      <link href="/posts/6533.html"/>
      <url>/posts/6533.html</url>
      
        <content type="html"><![CDATA[<p>随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。<br>J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。<br>了解并合理使用线程池，是一个开发人员必修的基本功。</p><h2 id="带着BAT大厂的面试问题去理解"><a href="#带着BAT大厂的面试问题去理解" class="headerlink" title="带着BAT大厂的面试问题去理解"></a>带着BAT大厂的面试问题去理解</h2><p><a href="https://mp.weixin.qq.com/s/HWoyHgZiUz7pqFhYxfLDNA">线程池连环17问</a></p><ul><li>为什么要有线程池?</li><li>Java是实现和管理线程池有哪些方式? 请简单举例如何使用。</li><li>为什么很多公司不允许使用Executors去创建线程池? 那么推荐怎么使用呢?</li><li>ThreadPoolExecutor有哪些核心的配置参数? 请简要说明</li><li>ThreadPoolExecutor可以创建哪三种线程池呢?</li><li>当队列满了并且worker的数量达到maxSize的时候，会怎么样?拒绝策略<ul><li>线程池为什么设计为核心线程数满了先入队列，而不是先创建最大线程？</li><li>线程池为什么设计为【队列满+核心线程数满了】才创建新线程？而不是队列积压一定阈值的时候创建新的线程？<br>  <strong>线程池的本意只是让核心数量的线程工作，而任务队列起到一个缓冲的作用。</strong><br>  <strong>最大线程数这个参数更像是无奈之举，在最坏的情况下做最后的努力，新建线程来帮助消化任务。</strong></li><li>Tomcat重写逻辑<br>  原生版线程池的实现可以认为是偏向CPU密集的，也就是当任务过多的时候不是先去创建更多的线程，而是先缓存任务，让核心线程去消化。我们知道，当处理CPU密集型任务的时，线程太多反而会由于线程频繁切换的开销而得不偿失，所以优先堆积任务而不是创建新的线程。<br>  而像 Tomcat 这种业务场景，大部分情况下是需要大量 I/O 处理的情况就做了一些定制，修改了原生线程池的实现，使得在队列没满的时候，可以创建线程至最大线程数。</li></ul></li><li>说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略? 默认是什么策略?</li><li>简要说下线程池的任务执行机制? execute –&gt; addWorker –&gt;runworker (getTask)</li><li>线程池中任务是如何提交的?</li><li>线程池中任务是如何关闭的?</li><li>在配置线程池的时候需要考虑哪些配置因素?</li><li><strong>如何监控线程池的状态，如何动态修改核心线程数和最大线程数?</strong><br>  原生线程池ThreadPoolExecutor已经提供修改配置的方法，也对外暴露出线程池内部执行情况，所以只要我们实时监控情况，调用对应的set方法，即可动态修改线程池对应配置。</li><li>ThreadPoolExecutor中的锁<ul><li>ReentrantLock mainLock，线程池整体层面的锁，控制线程池的核心状态变更</li><li>Worker.lock()，Worker类继承的AQS锁，每个Worker内部层面，用于控制每个Worker执行任务的串行性</li></ul></li></ul><h2 id="为什么要有线程池"><a href="#为什么要有线程池" class="headerlink" title="为什么要有线程池"></a>为什么要有线程池</h2><p>线程池能够对线程进行统一分配，调优和监控:</p><ul><li>降低资源消耗(线程无限制地创建，然后使用完毕后销毁)</li><li>提高响应速度(无须创建线程)</li><li>提高线程的可管理性</li></ul><h3 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h3><p>线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具。</p><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p><p>线程过多会带来额外的开销，其中包括创建/销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。</p><p>线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建/销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><p>使用线程池可以带来一系列的好处：</p><ul><li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>可拓展性</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><h3 id="线程池解决的问题是什么"><a href="#线程池解决的问题是什么" class="headerlink" title="线程池解决的问题是什么"></a>线程池解决的问题是什么</h3><p>线程池解决的核心问题是资源管理问题。</p><p>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li></ol><p>为解决资源分配这个问题，线程池采用了<code>池化（Pooling）</code>思想。池化，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p><p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。<br>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p><ul><li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li><li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li></ul><h2 id="ThreadPoolExecutor例子"><a href="#ThreadPoolExecutor例子" class="headerlink" title="ThreadPoolExecutor例子"></a>ThreadPoolExecutor例子</h2><p>Java是如何实现和管理线程池的？<br>从JDK 5开始，把工作单元与执行机制分离开来，工作单元包括<code>Runnable</code>和<code>Callable</code>，而执行机制由Executor框架提供。</p><ul><li>WorkerThread  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command=s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Start. Command = &quot;</span>+command);</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; End.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>SimpleThreadPool newFixedThreadPool使用示例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Runnable worker = <span class="keyword">new</span> WorkerThread(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown(); <span class="comment">// This will make the executor accept no new threads and finish all existing threads in the queue</span></span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123; <span class="comment">// Wait until all threads are finish,and also you can use &quot;executor.awaitTermination();&quot; to wait</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>RejectedExecutionHandlerImpl<br>  自定义的 RejectedExecutionHandler 接口的实现  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectedExecutionHandlerImpl</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        System.out.println(r.toString() + <span class="string">&quot; is rejected&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>MyMonitorThread<br>  用一个监控线程在特定的时间间隔内打印 executor 信息。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMonitorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seconds;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> run=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMonitorThread</span><span class="params">(ThreadPoolExecutor executor, <span class="keyword">int</span> delay)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="keyword">this</span>.seconds=delay;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.run=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                    String.format(<span class="string">&quot;[monitor] [%d/%d] Active: %d, Completed: %d, Task: %d, isShutdown: %s, isTerminated: %s&quot;</span>,</span><br><span class="line">                        <span class="keyword">this</span>.executor.getPoolSize(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getCorePoolSize(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getActiveCount(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getCompletedTaskCount(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getTaskCount(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.isShutdown(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.isTerminated()));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(seconds*<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>WorkerPool  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//RejectedExecutionHandler implementation</span></span><br><span class="line">        RejectedExecutionHandlerImpl rejectionHandler = <span class="keyword">new</span> RejectedExecutionHandlerImpl();</span><br><span class="line">        <span class="comment">//Get the ThreadFactory implementation to use</span></span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        <span class="comment">//creating the ThreadPoolExecutor</span></span><br><span class="line">        ThreadPoolExecutor executorPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>), threadFactory, rejectionHandler);</span><br><span class="line">        <span class="comment">//start the monitoring thread</span></span><br><span class="line">        MyMonitorThread monitor = <span class="keyword">new</span> MyMonitorThread(executorPool, <span class="number">3</span>);</span><br><span class="line">        Thread monitorThread = <span class="keyword">new</span> Thread(monitor);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">        <span class="comment">//submit work to the thread pool</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            executorPool.execute(<span class="keyword">new</span> WorkerThread(<span class="string">&quot;cmd&quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">        <span class="comment">//shut down the pool</span></span><br><span class="line">        executorPool.shutdown();</span><br><span class="line">        <span class="comment">//shut down the monitor thread</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        monitor.shutdown();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ThreadPoolExecutor使用详解"><a href="#ThreadPoolExecutor使用详解" class="headerlink" title="ThreadPoolExecutor使用详解"></a>ThreadPoolExecutor使用详解</h2><p>其实java线程池的实现原理很简单，说白了就是一个线程集合<code>HashSet&lt;Worker&gt; workers</code>和一个阻塞队列<code>BlockingQueue&lt;Runnable&gt; workQueue</code>。<br><img src="/posts/6533/ThreadPoolExecutor-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3.png"></p><h3 id="execute过程"><a href="#execute过程" class="headerlink" title="execute过程"></a>execute过程</h3><p>当一个任务提交至线程池之后：</p><ol><li>线程池首先判断当前运行的线程数量是否少于<code>corePoolSize</code>。如果是，则创建一个新的工作线程来执行任务；如果都在执行任务，则进入<strong>2</strong>；</li><li>判断BlockingQueue是否已经满了，倘若还没有满，则将线程放入BlockingQueue。否则进入<strong>3</strong>；</li><li>如果创建一个新的工作线程将使当前运行的线程数量超过<code>maximumPoolSize</code>，则交给RejectedExecutionHandler来处理任务。</li></ol><p>当ThreadPoolExecutor创建新线程时，通过CAS来更新线程池的状态ctl。</p><h3 id="线程池核心参数"><a href="#线程池核心参数" class="headerlink" title="线程池核心参数"></a>线程池核心参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong> - 线程池中的核心线程数<br>  需要注意的是在初创建线程池时线程不会立即启动，直到有任务提交才开始启动线程并逐渐使线程数目达到corePoolSize。<br>  若想一开始就创建所有核心线程需调用<code>prestartAllCoreThreads</code>方法。</li><li><strong>maximumPoolSize</strong> - 池中允许的最大线程数。<br>  需要注意的是<code>当核心线程满且阻塞队列也满时</code>才会判断当前线程数是否小于最大线程数，并决定是否创建新线程。<br>  当阻塞队列是无界队列，则maximumPoolSize则不起作用，因为无法提交至核心线程池的线程会一直持续地放入workQueue。</li><li><strong>keepAliveTime</strong> - 当线程数大于核心时，多余的空闲线程最多存活时间</li><li><strong>unit</strong> - keepAliveTime参数的时间单位。</li><li><strong>workQueue</strong> - 当线程数目超过核心线程数时用于保存任务的队列。<br>  此队列仅保存实现Runnable接口的任务。 <ul><li><strong>ArrayBlockingQueue</strong> 基于数组结构的有界阻塞队列，按FIFO排序任务；</li><li><strong>LinkedBlockingQueue</strong> 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；</li><li><strong>SynchronousQueue</strong> 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；</li><li><strong>PriorityBlockingQueue</strong> 具有优先级的无界阻塞队列；</li></ul></li><li><strong>threadFactory</strong> - 执行程序创建新线程时使用的工厂。<br>  通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为DefaultThreadFactory</li><li><strong>handler</strong> - 阻塞队列已满且线程数达到最大值时所采取的拒绝策略。<ul><li><strong>AbortPolicy</strong>: 直接抛出异常，默认策略；</li><li><strong>CallerRunsPolicy</strong>: 用调用者所在的线程来执行任务；</li><li><strong>DiscardOldestPolicy</strong>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li><strong>DiscardPolicy</strong>: 直接丢弃任务；</li><li>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</li></ul></li></ul><h3 id="fixed、single、cached"><a href="#fixed、single、cached" class="headerlink" title="fixed、single、cached"></a>fixed、single、cached</h3><ul><li><p>Executors.newFixedThreadPool</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  线程池的线程数量达corePoolSize后，即使线程池没有可执行任务时，也不会释放线程。FixedThreadPool的工作队列为无界队列LinkedBlockingQueue(队列容量为Integer.MAX_VALUE), 这会导致以下问题:</p><ul><li>线程池里的线程数量不超过corePoolSize,这导致了maximumPoolSize和keepAliveTime将会是个无用参数</li><li>由于使用了无界队列, 所以FixedThreadPool永远不会拒绝, 即饱和策略失效</li></ul></li><li><p>Executors.newSingleThreadExecutor</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行.<br>  由于使用了无界队列, 所以SingleThreadPool永远不会拒绝, 即饱和策略失效.</p></li><li><p>Executors.newCachedThreadPool</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；<br>  和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；</p><p>  执行过程与前两种稍微不同:</p><ol><li>主线程调用SynchronousQueue的offer()方法放入task, 倘若此时线程池中有空闲的线程尝试读取 SynchronousQueue的task, 即调用了SynchronousQueue的poll(), 那么主线程将该task交给空闲线程. 否则执行(2)；</li><li>当线程池为空或者没有空闲的线程, 则创建新的线程执行任务；</li><li>执行完任务的线程倘若在60s内仍空闲, 则会被终止. 因此长时间空闲的CachedThreadPool不会持有任何线程资源。</li></ol></li></ul><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>遍历线程池中的所有线程，然后逐个调用线程的interrupt方法来中断线程。</p><ul><li>shutdown<br>  将线程池里的线程状态设置成SHUTDOWN状态, 然后中断所有没有正在执行任务的线程。</li><li>shutdownNow<br>  将线程池里的线程状态设置成STOP状态, 然后停止所有正在执行或暂停任务的线程。</li></ul><p>只要调用这两个关闭方法中的任意一个，isShutDown() 返回true。<br>当所有任务都成功关闭了，isTerminated()返回true。</p><h3 id="线程池使用规范"><a href="#线程池使用规范" class="headerlink" title="线程池使用规范"></a>线程池使用规范</h3><p>【强制】线程池不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code>的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </p><p>Executors返回的线程池对象的弊端如下：</p><ol><li>FixedThreadPool 和 SingleThreadPool : 允许的请求队列长度为 Integer.MAX_VALUE ，<code>可能会堆积大量的请求</code>，从而导致 OOM 。</li><li>CachedThreadPool 和 ScheduledThreadPool : 允许的创建线程数量为 Integer.MAX_VALUE ，<code>可能会创建大量的线程</code>，从而导致 OOM 。</li></ol><h4 id="Spring配置线程池-ThreadPoolTaskExecutor"><a href="#Spring配置线程池-ThreadPoolTaskExecutor" class="headerlink" title="Spring配置线程池 - ThreadPoolTaskExecutor"></a>Spring配置线程池 - ThreadPoolTaskExecutor</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userThreadPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queueCapacity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;threadFactory&quot;</span> <span class="attr">value</span>= <span class="string">threadFactory</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//in code</span><br><span class="line">userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure><h4 id="配置线程池需要考虑因素"><a href="#配置线程池需要考虑因素" class="headerlink" title="配置线程池需要考虑因素"></a>配置线程池需要考虑因素</h4><p>从<strong>任务的优先级、任务的执行时间长短、任务的性质(CPU密集/ IO密集)、任务的依赖关系</strong>这四个角度来分析。并且近可能地使用有界的工作队列。</p><p>性质不同的任务可用使用不同规模的线程池分开处理:</p><ul><li><strong>CPU密集型</strong>: 尽可能少的线程，<strong>Ncpu+1</strong>；</li><li><strong>IO密集型</strong>: 尽可能多的线程, <strong>Ncpu*2</strong>，比如数据库连接池；</li><li>混合型: CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。</li></ul><h2 id="ThreadPoolExecutor线程池核心设计与实现"><a href="#ThreadPoolExecutor线程池核心设计与实现" class="headerlink" title="ThreadPoolExecutor线程池核心设计与实现"></a>ThreadPoolExecutor线程池核心设计与实现</h2><p>在Java中的体现是<code>ThreadPoolExecutor</code>类。</p><h3 id="2-1-总体设计"><a href="#2-1-总体设计" class="headerlink" title="2.1 总体设计"></a>2.1 总体设计</h3><p>Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。<br><img src="/posts/6533/ThreadPoolExecutor-UML.png" alt="ThreadPoolExecutor UML类图"></p><p><strong>Executor接口</strong><br><code>ThreadPoolExecutor</code>实现的顶层接口是<code>Executor</code>。<br>顶层接口Executor提供了一种思想：<strong>将任务提交和任务执行进行解耦</strong>。<br>用户无需关注如何创建线程、如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交<code>execute</code>到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。</p><p><strong>ExecutorService接口</strong><br>ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的<code>submit</code>方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</p><p><strong>AbstractExecutorService抽象类</strong><br>AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</p><p><strong>ThreadPoolExecutor</strong><br>最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p><p>ThreadPoolExecutor是如何运行，如何同时<strong>维护线程</strong>和<strong>执行任务</strong>的呢？<br>其运行机制如下图所示：<br><img src="/posts/6533/ThreadPoolExecutor-process.png" alt="ThreadPoolExecutor运行流程"></p><p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务、复用线程。<br>线程池的运行主要分成两部分：任务管理、线程管理。</p><ol><li><strong>任务管理部分</strong><br> 充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。</li><li><strong>线程管理部分</strong><br> 是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</li></ol><p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p><ol><li>线程池如何维护自身状态。</li><li>线程池如何管理任务。</li><li>线程池如何管理线程。</li></ol><h4 id="几个关键属性"><a href="#几个关键属性" class="headerlink" title="几个关键属性"></a>几个关键属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个属性是用来存放 当前运行的worker数量以及线程池状态的</span></span><br><span class="line"><span class="comment">//int是32位的，这里把int的高3位拿来充当线程池状态的标志位,后29位拿来充当当前运行worker的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//存放任务的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">//worker的集合,用set来存放</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//历史达到的worker数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//当队列满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//超出coreSize的worker的生存时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//常驻worker的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//最大worker的数量,一般当workQueue满了才会用到这个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure><h3 id="2-2-线程池生命周期管理"><a href="#2-2-线程池生命周期管理" class="headerlink" title="2.2 线程池生命周期管理"></a>2.2 线程池生命周期管理</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。<br>线程池内部使用一个变量维护两个值：<strong>运行状态（runState）</strong>和<strong>线程数量（workerCount）</strong>。<br>在具体实现中，线程池将运行状态（runState）和线程数量（workerCount）两个关键参数的维护放在了一起，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The main pool control state, ctl, is an atomic integer packing</span></span><br><span class="line"><span class="comment"> * two conceptual fields</span></span><br><span class="line"><span class="comment"> *   workerCount, indicating the effective number of threads</span></span><br><span class="line"><span class="comment"> *   runState,    indicating whether running, shutting down etc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p><code>ctl</code>这个AtomicInteger类型，是对<strong>线程池的运行状态</strong>和<strong>线程池中有效线程的数量</strong>进行控制的一个字段。<br>它同时包含两部分的信息：</p><ul><li><strong>线程池的运行状态(runState)</strong></li><li><strong>线程池内有效线程的数量(workerCount)</strong></li><li><strong>高3位保存runState</strong>，<strong>低29位保存workerCount</strong>，两个变量之间互不干扰。</li></ul><p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。</p><p>其实并发包中有很多实现都是<strong>一个字段存多个值</strong>的，比如读写锁的高 16 位存放读锁，低 16 位存放写锁，这种一个字段存放多个值可以更容易的维护多个值之间的一致性，也算是极简主义。</p><p>通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。<br>线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p><p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">//计算当前运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;  <span class="comment">//计算当前线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;   <span class="comment">//通过状态和线程数生成ctl</span></span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的运行状态有5种，分别为：<br><img src="/posts/6533/ThreadPoolExecutor-runState.png" alt="ThreadPoolExecutor运行状态"></p><p>其生命周期状态转换如下图所示：<br><img src="/posts/6533/ThreadPoolExecutor-lifecycle.png" alt="线程池生命周期"></p><h3 id="2-3-任务执行机制"><a href="#2-3-任务执行机制" class="headerlink" title="2.3 任务执行机制"></a>2.3 任务执行机制</h3><p><code>execute –&gt; addWorker –&gt; runworker(getTask)</code></p><h4 id="2-3-1-任务调度-分配"><a href="#2-3-1-任务调度-分配" class="headerlink" title="2.3.1 任务调度/分配"></a>2.3.1 任务调度/分配</h4><p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。<br>了解这部分就相当于了解了线程池的核心运行机制。</p><p>所有任务的调度都是由<code>execute(Runnable command)</code>方法完成的。<br>这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。</p><p><code>execute(Runnable command)</code>方法执行过程如下：</p><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; 线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize &amp;&amp; 线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize &amp;&amp; 线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是AbortPolicy直接抛异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/6533/ThreadPoolExecutor-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6.png" alt="任务调度流程"></p><h4 id="2-3-2-任务缓冲"><a href="#2-3-2-任务缓冲" class="headerlink" title="2.3.2 任务缓冲"></a>2.3.2 任务缓冲</h4><p>任务缓冲模块是线程池能够管理任务的核心部分。<br>线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解藕，不让两者直接关联，才可以做后续的分配工作。<br>线程池中是以生产者消费者模式，通过一个阻塞队列来实现的，<strong>阻塞队列缓存任务</strong>，工作线程从阻塞队列中获取任务。</p><p><strong>阻塞队列（BlockingQueue）</strong>是一个支持两个附加操作的队列。<br>这两个附加的操作是：<strong>1、</strong>在队列为空时，获取元素的线程会等待队列变为非空；<strong>2、</strong>当队列满时，存储元素的线程会等待队列可用。<br>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：<br><img src="/posts/6533/ThreadPoolExecutor-blockingQueue.png" alt="阻塞队列"></p><p>使用不同的队列可以实现不一样的任务存取策略。<br><img src="/posts/6533/ThreadPoolExecutor-bqType.png" alt="阻塞队列类型"></p><h4 id="2-3-3-任务申请"><a href="#2-3-3-任务申请" class="headerlink" title="2.3.3 任务申请"></a>2.3.3 任务申请</h4><p>由2.3.1的任务调度/分配部分可知，任务的执行有两种可能：<strong>1、</strong>任务直接由新创建的线程执行；<strong>2、</strong>线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。<br>第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p><p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信，这部分策略由<strong>getTask方法</strong>实现，其执行流程如下图所示：<br><img src="/posts/6533/ThreadPoolExecutor-task.png"></p><p><code>getTask</code>这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-4-任务拒绝"><a href="#2-3-4-任务拒绝" class="headerlink" title="2.3.4 任务拒绝"></a>2.3.4 任务拒绝</h4><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p><p>拒绝策略是一个接口，其设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：<br><img src="/posts/6533/ThreadPoolExecutor-reject.png"></p><h3 id="2-4-Worker线程管理"><a href="#2-4-Worker线程管理" class="headerlink" title="2.4 Worker线程管理"></a>2.4 Worker线程管理</h3><h4 id="2-4-1-Worker线程"><a href="#2-4-1-Worker线程" class="headerlink" title="2.4.1 Worker线程"></a>2.4.1 Worker线程</h4><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程<code>Worker</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承AQS，实现Runnable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Worker持有的线程，即工作线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">// 初始化的任务，可以为null</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">// 这个worker已经完成的任务数</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="comment">// 创建自身持有的线程</span></span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现Runnable接口的run方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lock methods</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">        <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Worker</strong>这个工作线程，<strong>继承了AbstractQueuedSynchronizer，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask</strong>。<br><code>thread</code>是在调用<strong>Worker的构造方法</strong>时通过ThreadFactory来创建的线程，可以用来执行任务。<br><code>firstTask</code>用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p><p>Worker执行任务的模型如下图所示：<br><img src="/posts/6533/ThreadPoolExecutor-worker.png"></p><p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。<br>线程池使用<code>HashSet&lt;Worker&gt; workers</code>去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是<strong>如何判断线程是否在运行</strong>。</p><p>Worker是通过继承<code>AQS</code>，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p><ol><li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 </li><li>如果正在执行任务，则不应该中断线程。 </li><li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 </li><li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态，如果线程是空闲状态则可以安全回收。</li></ol><p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：<br><img src="/posts/6533/ThreadPoolExecutor-%E5%9B%9E%E6%94%B6.png"></p><h4 id="2-4-2-Worker线程增加"><a href="#2-4-2-Worker线程增加" class="headerlink" title="2.4.2 Worker线程增加"></a>2.4.2 Worker线程增加</h4><p>增加线程是通过线程池中的<code>addWorker(Runnable firstTask, boolean core)</code>。<br>该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。</p><p>addWorker方法有两个参数：firstTask、core。<br><code>firstTask</code>参数用于指定新增的线程执行的第一个任务，该参数可以为空；<br><code>core</code>参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize。</p><p>其执行流程如下图所示：<br><img src="/posts/6533/ThreadPoolExecutor-addWorker.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;\</span><br><span class="line">    <span class="comment">// CAS更新线程池数量</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = ctl.get();;) &#123;</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="keyword">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// mainLock 线程池重入锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.getState() != Thread.State.NEW)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 线程启动，执行任务(Worker.thread(firstTask).start());</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-Worker线程执行任务"><a href="#2-4-3-Worker线程执行任务" class="headerlink" title="2.4.3 Worker线程执行任务"></a>2.4.3 Worker线程执行任务</h4><p>在Worker类中的run方法调用了<code>runWorker</code>方法来执行任务。</p><p><code>runWorker</code>方法的执行过程如下：</p><ol><li>while循环不断地通过getTask()方法获取任务。 </li><li>getTask()方法从阻塞队列中取任务。 </li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 </li><li>执行任务。 </li><li>如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</li></ol><p><img src="/posts/6533/ThreadPoolExecutor-runWorker.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Worker加锁</span></span><br><span class="line">        <span class="comment">// Worker可以通过获取独占锁的方式在执行任务前进行加锁,执行后释放锁,这可以保证任务串行执行</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                    afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// Worker解锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly); <span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-Worker线程回收"><a href="#2-4-4-Worker线程回收" class="headerlink" title="2.4.4 Worker线程回收"></a>2.4.4 Worker线程回收</h4><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。<br>Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p><p>线程回收的工作是在<code>processWorkerExit</code>方法完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/posts/33757.html"/>
      <url>/posts/33757.html</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot核心组件"><a href="#SpringBoot核心组件" class="headerlink" title="SpringBoot核心组件"></a>SpringBoot核心组件</h2><h3 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h3><p>官方提供的starter是这样的：spring-boot-starter-xxx<br>非官方的starter是这样的：xxx-spring-boot-starter</p><h3 id="autoconfigure"><a href="#autoconfigure" class="headerlink" title="autoconfigure"></a>autoconfigure</h3><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><h3 id="actuator"><a href="#actuator" class="headerlink" title="actuator"></a>actuator</h3><h2 id="SpringBoot集成"><a href="#SpringBoot集成" class="headerlink" title="SpringBoot集成"></a>SpringBoot集成</h2><h3 id="SpringBoot集成SpringMVC"><a href="#SpringBoot集成SpringMVC" class="headerlink" title="SpringBoot集成SpringMVC"></a>SpringBoot集成SpringMVC</h3><h3 id="SpringBoot集成mybatis"><a href="#SpringBoot集成mybatis" class="headerlink" title="SpringBoot集成mybatis"></a>SpringBoot集成mybatis</h3><h3 id="SpringBoot集成Tomcat"><a href="#SpringBoot集成Tomcat" class="headerlink" title="SpringBoot集成Tomcat"></a>SpringBoot集成Tomcat</h3><p>Spring Boot 能支持的最大并发量主要看其对Tomcat的设置，可以在配置文件中对其进行更改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 最大工作线程数，默认200。</span><br><span class="line">server.tomcat.max-threads=200</span><br><span class="line"># 最大连接数，默认值与Tomcat的连接器使用的协议有关</span><br><span class="line">server.tomcat.max-connections=10000</span><br><span class="line"># 等待队列长度，默认100。</span><br><span class="line">server.tomcat.accept-count=100</span><br><span class="line"># 最小工作空闲线程数，默认10。tomcat启动时的初始化的线程数</span><br><span class="line">server.tomcat.min-spare-threads=100</span><br><span class="line">#请求头最大长度kb</span><br><span class="line">server.tomcat.max-http-header-size: 1048576</span><br><span class="line">#请请求体最大长度kb</span><br><span class="line">server.tomcat.max-http-post-size: 2097152</span><br></pre></td></tr></table></figure><p>针对4C8G配置，可以参考建议值：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">   <span class="attr">tomcat:</span></span><br><span class="line">      <span class="attr">accept-count:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">max-connections:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">max-threads:</span> <span class="number">800</span></span><br><span class="line">      <span class="attr">min-spare-threads:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><ul><li>线程数的经验值为：<strong>1核2G内存，线程数经验值200</strong>；<strong>4核8G内存， 线程数经验值800</strong>。<br> 4核8G内存单进程调度线程数800-1000，超过这个并发数之后，将会花费巨大的时间在CPU调度上</li><li>acceptCount<br> accept队列的长度；当accept队列中连接的个数达到acceptCount时，队列满，进来的请求一律被拒绝。默认值是100。</li><li>maxThreads<br> 请求处理线程的最大数量。<br> 默认值是200（Tomcat7和8都是的）。如果该Connector绑定了Executor，这个值会被忽略，因为该Connector将使用绑定的Executor，而不是内置的线程池来执行任务。<br> 规定的是Tomcat线程池最多能起的线程数目，并不是实际running的CPU数量。实际上，maxThreads的大小比CPU核心数量要大得多。<br> 这是因为，处理请求的线程真正用于计算的时间可能很少，大多数时间可能在阻塞，如等待数据库返回数据、等待硬盘读写数据等。<br> 因此，在某一时刻，只有少数的线程真正的在使用物理CPU，大多数线程都在等待；因此线程数远大于物理核心数才是合理的。<br> 也就是说，Tomcat通过使用比CPU核心数量多得多的线程数，可以使CPU忙碌起来，大大提高CPU的利用率。</li><li>maxConnections<br> Tomcat在任意时刻接收和处理的最大连接数。<br> 当Tomcat接收的连接数达到maxConnections时，Acceptor线程不会读取accept队列中的连接；这时accept队列中的线程会一直阻塞着，直到Tomcat接收的连接数小于maxConnections。<br> 如果设置为-1，则连接数不受限制。<br> 默认值与Tomcat的连接器使用的协议有关：NIO的默认值是10000，APR/native的默认值是8192，而BIO的默认值为maxThreads（如果配置了Executor，则默认值是Executor的maxThreads）。</li><li>tomcat同时可以处理的连接数目是maxConnections，但服务器中可以同时接收的连接数为maxConnections + acceptCount。</li></ul><h4 id="Tomcat的连接器Connector"><a href="#Tomcat的连接器Connector" class="headerlink" title="Tomcat的连接器Connector"></a>Tomcat的连接器Connector</h4><h4 id="Tomcat的线程池"><a href="#Tomcat的线程池" class="headerlink" title="Tomcat的线程池"></a>Tomcat的线程池</h4><h3 id="SpringBoot中线程池的使用"><a href="#SpringBoot中线程池的使用" class="headerlink" title="SpringBoot中线程池的使用"></a>SpringBoot中线程池的使用</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ol><li>基于ExecutorService自定义线程池<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(InitBeanConfig.class);</span><br><span class="line">   </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExecutorService <span class="title">callbackThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ThreadFactory factory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">            .setUncaughtExceptionHandler((t, e) -&gt; logger.error(t.getName() + <span class="string">&quot; excute error:&quot;</span>, e))</span><br><span class="line">            .setNameFormat(<span class="string">&quot;my-pool-%d&quot;</span>).build();</span><br><span class="line">   <span class="keyword">int</span> corePoolSize = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">int</span> maxPoolSize = <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">long</span> keepAliveTime = <span class="number">5</span>;</span><br><span class="line">   ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maxPoolSize, keepAliveTime, TimeUnit.MINUTES,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">100000</span>), factory, <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">   <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Spring默认线程池applicationTaskExecutor<br><img src="/posts/33757/springboot-%E7%BA%BF%E7%A8%8B%E6%B1%A0-applicationTaskExecutor.png"></li><li>基于ThreadPoolTaskExecutor自定义线程池<br><strong>ThreadPoolTaskExecutor</strong>，最常使用，推荐。其实质是对<strong>java.util.concurrent.ThreadPoolExecutor</strong>的包装。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean(&quot;partFileUploadExecutor&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Executor <span class="title">partFileUploadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">      <span class="comment">// 线程名称前缀</span></span><br><span class="line">      executor.setThreadNamePrefix(<span class="string">&quot;partFileUploadExecutor-&quot;</span>);</span><br><span class="line">      <span class="comment">// 核心线程数</span></span><br><span class="line">      executor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">      <span class="comment">// 阻塞队列长度</span></span><br><span class="line">      executor.setQueueCapacity(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 线程池注册优雅停机：当要停止应用时，等待所有线程执行完再停止</span></span><br><span class="line">      executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 设置等待时间，如果超过这个时间还没有销毁就强制销毁，以确保应用最后能够被关闭，而不是阻塞住</span></span><br><span class="line">      executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">      </span><br><span class="line">      executor.initialize();</span><br><span class="line">      <span class="keyword">return</span> executor;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Async"><a href="#Async" class="headerlink" title="@Async"></a>@Async</h4><p>如果不指定自定义线程池的名称，@Async注解使用Spring默认的线程池。<br>查看源码，@Async的默认线程池为<strong>SimpleAsyncTaskExecutor</strong>。<br>SimpleAsyncTaskExecutor，不是真的线程池，这个类不重用线程，默认每次调用都会创建一个新的线程。</p><ul><li>无返回值调用<br> 无返回值的异步方法，异常不会传播到调用线程，需要添加额外的配置来处理异常。<br> 通过实现<strong>AsyncUncaughtExceptionHandler</strong>接口来创建自定义异步异常处理程序</li><li>有返回值调用<br> 当异步方法返回类型为Future时，Future.get()方法将抛出异常。<ul><li>Future</li><li>CompletableFuture</li></ul></li></ul><h4 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h4><h4 id="实际使用问题"><a href="#实际使用问题" class="headerlink" title="实际使用问题"></a>实际使用问题</h4><ol><li>任务执行异常丢失问题<ul><li>无返回值的异步方法<br> 无返回值的异步方法，异常不会传播到调用线程，需要添加额外的配置来处理异常。<br> 通过实现<strong>AsyncUncaughtExceptionHandler</strong>接口来创建自定义异步异常处理程序</li><li>有返回值的异步方法<br> 当异步方法返回类型为Future时，Future.get()方法将抛出异常。</li></ul></li><li>整个服务全局共享一个线程池问题<br>   次要逻辑拖垮主要逻辑。<br>   不同业务逻辑定义各自的线程池。</li><li>跟ThradLocal配合使用的问题</li><li>自定义拒绝策略</li><li>RejectedExecutionException<br>   当拒绝策略为<strong>AbortPolicy</strong>时，如何捕获RejectedExecutionException进行补偿？   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ThreadPoolTaskExecutor#execute</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">     Executor executor = getThreadPoolExecutor();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        executor.execute(task);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">&quot;Executor [&quot;</span> + executor + <span class="string">&quot;] did not accept task: &quot;</span> + task, ex);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ThreadPoolTaskExecutor#submit</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">     ExecutorService executor = getThreadPoolExecutor();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> executor.submit(task);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">&quot;Executor [&quot;</span> + executor + <span class="string">&quot;] did not accept task: &quot;</span> + task, ex);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>   对execute、sumit方法进行try-catch，处理相应的异常。</li></ol><h3 id="SpringBoot集成数据库连接池"><a href="#SpringBoot集成数据库连接池" class="headerlink" title="SpringBoot集成数据库连接池"></a>SpringBoot集成数据库连接池</h3><h4 id="SpringBoot2-x默认-Hikari"><a href="#SpringBoot2-x默认-Hikari" class="headerlink" title="SpringBoot2.x默认 Hikari"></a>SpringBoot2.x默认 Hikari</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> </span><br><span class="line">    <span class="attr">username:</span> </span><br><span class="line">    <span class="attr">password:</span> </span><br><span class="line">    <span class="comment"># 指定为HikariDataSource</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="comment">#最小空闲连接数</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment"># 数据库连接超时时间,默认30秒</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">2000</span></span><br><span class="line">      <span class="comment"># 连接池最大连接数，默认是10</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 此属性控制从池返回的连接的默认自动提交行为,默认值：true</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">data-source-properties:</span></span><br><span class="line">        <span class="attr">cachePrepStmts:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">prepStmtCacheSize:</span> <span class="number">250</span></span><br><span class="line">        <span class="attr">prepStmtCacheSqlLimit:</span> <span class="number">2048</span></span><br><span class="line">        <span class="attr">useServerPrepStmts:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认30分钟</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">570000</span></span><br><span class="line">      <span class="comment"># 空闲连接存活最大时间，默认10分钟</span></span><br><span class="line">      <span class="attr">idle-timeout:</span> <span class="number">500000</span></span><br></pre></td></tr></table></figure><ul><li><strong>SpringBoot2.x默认连接池Hikari是如何起作用的</strong><ul><li>spring-boot-autoconfigure<pre><code>DataSourceAutoConfiguration自动配置类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(type = &quot;io.r2dbc.spi.ConnectionFactory&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAutoConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 先import DataSourceConfiguration.Hikari.class</span></span><br><span class="line">   <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">   <span class="meta">@Conditional(PooledDataSourceCondition.class)</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line">   <span class="meta">@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</span></span><br><span class="line"><span class="meta">         DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class,</span></span><br><span class="line"><span class="meta">         DataSourceJmxConfiguration.class &#125;)</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li>springboot-starter-jdbc<pre><code>springboot-starter-jdbc默认加载了Hikari</code></pre></li></ul></li><li><strong>为什么Hikari会成为默认连接池</strong></li></ul><h3 id="SpringBoot集成Redis"><a href="#SpringBoot集成Redis" class="headerlink" title="SpringBoot集成Redis"></a>SpringBoot集成Redis</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>spring-boot-starter</li><li>spring-data-redis<br> spring对redis相关操作的人性化封装，使得redis的操作只需简单的调用接口即可。<br> redis的操作的实现过程则有lettuce或jedis驱动(客户端)实现，spring-data-redis只是在接口层对他们做了统一。</li><li>io.lettuce.lettuce-core<br> spring-boot-starter-data-redis 2.x选择的默认驱动</li></ul><h4 id="Lettuce和Jedis的区别"><a href="#Lettuce和Jedis的区别" class="headerlink" title="Lettuce和Jedis的区别"></a>Lettuce和Jedis的区别</h4><p>从 Spring Boot 2.x 开始 Lettuce 已取代 Jedis 成为首选 Redis 的客户端。</p><ul><li>Lettuce<br> Lettuce是一个可伸缩的线程安全的 Redis 客户端，支持同步、异步和响应式模式。<br> 多个线程可以共享一个连接实例，而不必担心多线程并发问题。<br> 它基于优秀 Netty NIO 框架构建，支持 Redis 的高级功能，如 Sentinel，集群，流水线，自动重新连接和 Redis 数据模型</li><li>Jedis<br> Jedis在实现上是直接连接的redis server，如果在多线程环境下是非线程安全的。</li></ul><h4 id="修改RedisTemplate的序列化器"><a href="#修改RedisTemplate的序列化器" class="headerlink" title="修改RedisTemplate的序列化器"></a>修改RedisTemplate的序列化器</h4><p>RedisTemplate间接实现了InitializingBean，故在Bean的生命周期内会被回调其afterPropertiesSet方法，此方法用来初始化key和value的序列化器，默认是JDK序列化器，但该序列化器需要数据对象实现Serializable接口，最后显示声明序列化ID，容易出错。<br>可以修改利用json的序列化与反序列化能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot集成WebSocket"><a href="#SpringBoot集成WebSocket" class="headerlink" title="SpringBoot集成WebSocket"></a>SpringBoot集成WebSocket</h3><ol><li>添加 starter 依赖</li><li>添加 WebSocket 配置：<ul><li>实现接口<code>WebSocketConfigurer</code>，并重写相应方法</li></ul></li><li>添加处理器，作用类似 SpringMVC 的处理器映射：<ul><li>实现接口 <code>WebSocketHandler</code>，并重写相应方法</li></ul></li><li>添加拦截器（可选），可在 websocket 握手阶段做一些处理，例如校验、保存用户信息。<ul><li>实现接口：<code>HandshakeInterceptor</code>，并重写相应方法</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SpringBoot集成Kafka"><a href="#SpringBoot集成Kafka" class="headerlink" title="SpringBoot集成Kafka"></a>SpringBoot集成Kafka</h3><h3 id="SpringBoot集成ElasticSearch"><a href="#SpringBoot集成ElasticSearch" class="headerlink" title="SpringBoot集成ElasticSearch"></a>SpringBoot集成ElasticSearch</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="/posts/55324.html"/>
      <url>/posts/55324.html</url>
      
        <content type="html"><![CDATA[<h2 id="Web容器基础认知"><a href="#Web容器基础认知" class="headerlink" title="Web容器基础认知"></a>Web容器基础认知</h2><h3 id="如何实现服务器和浏览器的交互"><a href="#如何实现服务器和浏览器的交互" class="headerlink" title="如何实现服务器和浏览器的交互"></a>如何实现服务器和浏览器的交互</h3><p>客户端和服务器端之间的交互式通过Socket来实现的，它属于应用层的协议。</p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>Socket是网络连接的一个端点。套接字使得一个应用可以从网络中读取和写入数据。<br>放在两个不同计算机上的两个应用可以通过<strong>连接</strong>发送和接受字节流。为了从你的应用发送一条信息到另一个应用，你需要知道另一个应用的 IP 地址和套接字端口。<br>在 Java 里边，套接字指的是<strong>java.net.Socket</strong>类。</p><h4 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h4><p>Socket 类代表一个客户端套接字，即任何时候你想连接到一个远程服务器应用的时候你构造的套接字。<br>现在，假如你想实施一个服务器应用，例如一个 HTTP 服务器或者 FTP 服务器，你需要一种不同的做法。这是因为你的服务器必须随时待命，因为它不知道一个客户端应用什么时候会尝试去连接它。<br>为了让你的应用能随时待命，你需要使用<strong>java.net.ServerSocket</strong>类。这是<strong>服务器套接字</strong>的实现。</p><p>ServerSocket 和 Socket 不同，服务器套接字的角色是等待来自客户端的连接请求。<strong>一旦服务器套接字获得一个连接请求，它创建一个 Socket 实例来与客户端进行通信。</strong></p><h3 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h3><blockquote><p>所谓Servlet，其实就是Sun为了让Java能实现动态可交互的网页，从而进入Web编程领域而制定的一套标准！</p></blockquote><p>一个Servlet主要做下面三件事情：</p><ol><li>创建并填充Request对象，包括：URI、参数、method、请求头信息、请求体信息等</li><li>创建Response对象</li><li>执行业务逻辑，将结果通过Response的输出流输出到客户端</li></ol><p>Servlet没有main方法，所以，如果要执行，则需要在一个容器里面才能执行，这个容器就是为了支持Servlet的功能而存在。<br>Tomcat其实就是一个Servlet容器的实现。</p><h2 id="Tomcat和Spring、Spring-MVC的关系"><a href="#Tomcat和Spring、Spring-MVC的关系" class="headerlink" title="Tomcat和Spring、Spring MVC的关系"></a>Tomcat和Spring、Spring MVC的关系</h2><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p><img src="/posts/55324/springmvc-%E7%BB%84%E6%88%90.png"></p><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。<br>DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Tomcat是HTTP服务器和Servlet容器，负责给类似Spring这种servlet提供一个运行的环境。<ul><li>Http服务器，可以把HTTP服务器想象成前台的接待，负责网络通信和解析请求；</li><li>Servlet容器是业务部门，负责处理业务请求。</li></ul></li><li>Tomcat作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。<ul><li>Servlet是规范。</li><li>HttpServletRequest对象是Tomcat提供的，Tomcat是实现规范的Servlet容器。</li><li>SpringMVC是处理Servlet请求的应用，其中DispatcherServlet实现了Servlet接口，Tomcat负责加载和调用DispatcherServlet。</li><li>DispatcherServlet有自己的容器-Spring MVC容器（子容器），这个容器负责管理Spring MVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean，比如Service和DAO等，这些由全局的Spring IOC容器（父容器）管理。</li></ul></li><li>如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</li><li>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</li></ol><h2 id="Tomcat架构设计"><a href="#Tomcat架构设计" class="headerlink" title="Tomcat架构设计"></a>Tomcat架构设计</h2><blockquote><p>Tomcat的前身为Catalina，Catalina又是一个轻量级的Servlet容器<br>在美国，catalina是一个很美的小岛。所以Tomcat作者的寓意可能是想把Tomcat设计成一个优雅美丽且轻量级的web服务器。<br>Tomcat从4.x版本开始除了作为支持Servlet的容器外，额外加入了很多的功能，比如：jsp、el、naming等等，所以说Tomcat不仅仅是Catalina。</p></blockquote><p><img src="/posts/55324/tomcat-%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg"></p><h3 id="从组件的角度看"><a href="#从组件的角度看" class="headerlink" title="从组件的角度看"></a>从组件的角度看</h3><p>Tomcat 要实现 2 个核心功能：</p><ul><li>处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。</li><li>加载和管理 Servlet，以及具体处理 Request 请求。</li></ul><p><strong>Connector 连接器</strong>和<strong>Container 容器</strong>可以说是 Tomcat 架构里最重要的两部分。</p><ul><li>Server<br>  表示服务器，它提供了一种优雅的方式来启动和停止整个系统，不必单独启停连接器和容器。<br>  它是Tomcat构成的顶级构成元素，所有一切均包含在Server中。</li><li>Service<br>  表示服务，Server可以运行多个服务。比如一个Tomcat里面可运行订单服务、支付服务、用户服务等等；<br>  Server的实现类StandardServer可以包含一个到多个Services, Service的实现类为StandardService调用了容器(Container)接口，其实是调用了Servlet Engine(引擎)，而且StandardService类中也指明了该Service归属的Server。</li><li><strong>Container</strong><br>  表示容器，可以看做Servlet容器。<br>  引擎(Engine)、主机(Host)、上下文(Context)和Wraper均继承自Container接口，所以它们都是容器。<ul><li>Engine – 引擎</li><li>Host – 主机</li><li>Context – 上下文</li><li>Wrapper – 包装器</li></ul></li><li><strong>Connector</strong><br>  表示连接器, <strong>它将Service和Container连接起来</strong>。<br>  注册在Service中，指定要监听的端口port。<br>  用于监听端口，接受来自客户端的请求，并将请求转交给Engine处理，同时将来自Engine的答复返回给客户端。</li><li>Service内部组件<br>  Manager – 管理器，用于管理会话Session<br>  Logger – 日志器，用于管理日志<br>  Loader – 加载器，和类加载有关，只会开放给Context所使用<br>  Pipeline – 管道组件，配合Valve实现过滤器功能<br>  Valve – 阀门组件，配合Pipeline实现过滤器功能<br>  Realm – 认证授权组件</li></ul><h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h4><p><img src="/posts/55324/tomcat-webxml.jpeg"></p><h3 id="从一个完整请求的角度看"><a href="#从一个完整请求的角度看" class="headerlink" title="从一个完整请求的角度看"></a>从一个完整请求的角度看</h3><p>假设来自客户的请求为：<a href="http://localhost:8080/test/index.jsp">http://localhost:8080/test/index.jsp</a> </p><ul><li>请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得</li><li>Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应</li><li>Engine获得请求localhost:8080/test/index.jsp，匹配它所有虚拟主机Host</li><li>Engine匹配到名为localhost的Host(即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机)</li><li>localhost Host获得请求/test/index.jsp，匹配它所拥有的所有Context</li><li>Host匹配到路径为/test的Context(如果匹配不到就把该请求交给路径名为””的Context去处理)</li><li>path=”/test”的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet</li><li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类，构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法</li><li>Context把执行完了之后的HttpServletResponse对象返回给Host</li><li>Host把HttpServletResponse对象返回给Engine</li><li>Engine把HttpServletResponse对象返回给Connector</li><li>Connector把HttpServletResponse对象返回给客户browser</li></ul><p>简而言之，Connector 连接器接收连接请求，创建Request和Response对象用于和请求端交换数据，然后分配线程让Engine（也就是Servlet容器）来处理这个请求，并把产生的Request和Response对象传给Engine。当Engine处理完请求后，通过Connector将响应返回给客户端。</p><h4 id="Tomcat如何接收到一个http请求"><a href="#Tomcat如何接收到一个http请求" class="headerlink" title="Tomcat如何接收到一个http请求"></a>Tomcat如何接收到一个http请求</h4><p>Connector组件的Endpoint中的Acceptor监听客户端套接字连接并接收Socket。</p><h2 id="Tomcat的网络模型"><a href="#Tomcat的网络模型" class="headerlink" title="Tomcat的网络模型"></a>Tomcat的网络模型</h2><h2 id="Tomcat-类加载机制"><a href="#Tomcat-类加载机制" class="headerlink" title="Tomcat 类加载机制"></a>Tomcat 类加载机制</h2><h3 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h3><p><strong>为什么Tomcat的类加载器不是双亲委派模型</strong><br>Java默认的类加载机制是通过双亲委派模型来实现的，而Tomcat实现的方式又和双亲委派模型有所区别。</p><p>原因在于一个Tomcat容器允许同时运行多个Web程序，每个Web程序依赖的类又必须是相互隔离的。<br>因此，如果Tomcat使用双亲委派模式来加载类的话，将导致Web程序依赖的类变为共享的。</p><p>举个例子，假如我们有两个Web程序，一个依赖A库的1.0版本，另一个依赖A库的2.0版本，他们都使用了类xxx.xx.Clazz，其实现的逻辑因类库版本的不同而结构完全不同。那么这两个Web程序的其中一个必然因为加载的Clazz不是所使用的Clazz而出现问题！而这对于开发来说是非常致命的！</p><p><img src="/posts/55324/tomcat-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9B%BE.png"></p><ul><li>Common类加载器，负责加载Tomcat和Web应用都复用的类 <ul><li>Catalina类加载器，负责加载Tomcat专用的类，而这些被加载的类在Web应用中将不可见</li><li>Shared类加载器，负责加载Tomcat下所有的Web应用程序都复用的类，而这些被加载的类在Tomcat中将不可见 <ul><li>WebApp类加载器，负责加载具体的某个Web应用程序所使用到的类，而这些被加载的类在Tomcat和其他的Web应用程序都将不可见</li><li>Jsp类加载器，每个jsp页面一个类加载器，不同的jsp页面有不同的类加载器，方便实现jsp页面的热插拔</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——Apache Pulsar</title>
      <link href="/posts/21914.html"/>
      <url>/posts/21914.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-理论基础&amp;线程基础</title>
      <link href="/posts/19039.html"/>
      <url>/posts/19039.html</url>
      
        <content type="html"><![CDATA[<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><ul><li>多线程的出现是要解决什么问题的?</li><li>线程不安全是指什么? 举例说明</li><li>并发出现线程不安全的本质什么? 可见性，原子性和有序性。</li><li>Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before</li><li>线程安全是不是非真即假? 不是</li><li>线程安全有哪些实现思路?</li><li>如何理解并发和并行的区别?</li></ul><h3 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h3><p>CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致<code>可见性</code>问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致<code>原子性</code>问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致<code>有序性</code>问题</li></ul><p>优点</p><ul><li>资源利用率更好</li><li>程序设计在某些情况下更简单</li><li>程序响应更快<br>缺点</li><li>设计更复杂</li><li>上下文切换的开销</li><li>增加资源消耗</li></ul><h3 id="线程不安全是指什么"><a href="#线程不安全是指什么" class="headerlink" title="线程不安全是指什么"></a>线程不安全是指什么</h3><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>例如，1000个线程同时对 一个int变量 执行自增操作，操作结束之后它的值有可能小于1000。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">        ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                example.add();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(example.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发出现问题的根源-并发三要素"><a href="#并发出现问题的根源-并发三要素" class="headerlink" title="并发出现问题的根源: 并发三要素"></a>并发出现问题的根源: 并发三要素</h3><p>上述示例输出为什么不是1000? 并发出现问题的根源是什么?</p><h4 id="可见性-CPU缓存引起"><a href="#可见性-CPU缓存引起" class="headerlink" title="可见性 CPU缓存引起"></a>可见性 CPU缓存引起</h4><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p><p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。</p><p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h4 id="原子性-分时复用引起"><a href="#原子性-分时复用引起" class="headerlink" title="原子性 分时复用引起"></a>原子性 分时复用引起</h4><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里需要注意的是：<code>i += 1</code>需要三条 CPU 指令</p><ul><li>将变量 i 从内存读取到 CPU寄存器；</li><li>在CPU寄存器中执行 i + 1 操作；</li><li>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li></ul><p>由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。</p><h4 id="有序性-重排序引起"><a href="#有序性-重排序引起" class="headerlink" title="有序性 重排序引起"></a>有序性 重排序引起</h4><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。</p><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。<br>重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><img src="/posts/19039/%E6%9C%89%E5%BA%8F%E6%80%A7-java%E9%87%8D%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png"><br>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。<br><strong>对于编译器</strong>，JMM 的<strong>编译器重排序规则</strong>会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。<br><strong>对于处理器重排序</strong>，JMM 的<strong>处理器重排序规则</strong>会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><h3 id="JAVA是怎么解决并发问题的-JMM-Java内存模型"><a href="#JAVA是怎么解决并发问题的-JMM-Java内存模型" class="headerlink" title="JAVA是怎么解决并发问题的: JMM(Java内存模型)"></a>JAVA是怎么解决并发问题的: JMM(Java内存模型)</h3><p><a href="https://www.pdai.tech/md/java/jvm/java-jvm-jmm.html">JVM 基础 - Java 内存模型详解</a></p><ul><li><p>理解的第一个维度：核心知识点<br>  <strong>JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。</strong><br>  具体来说，这些方法包括：</p><ul><li><strong>volatile、synchronized 和 final 三个关键字</strong></li><li><strong>Happens-Before 规则</strong></li></ul></li><li><p>理解的第二个维度：可见性，有序性，原子性</p><ul><li><p>原子性<br>  在Java中，<strong>对基本数据类型的变量的读取和赋值操作</strong>是<strong>原子性</strong>操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>  请分析以下哪些操作是原子性操作：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;        <span class="comment">//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span></span><br><span class="line">y = x;         <span class="comment">//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span></span><br><span class="line">x++;           <span class="comment">//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4： 同语句3</span></span><br></pre></td></tr></table></figure><p>  上面4个语句只有语句1的操作具备原子性。<br>  也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><p>  Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></li><li><p>可见性<br>  Java提供了<strong>volatile关键字</strong>来保证可见性。</p><p>  <strong>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</strong></p><p>  而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p></li><li><p>有序性<br>  在Java里面，可以通过volatile关键字来保证一定的“有序性”。<br>  另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br>  当然JMM是通过Happens-Before 规则来保证有序性的。</p></li></ul></li></ul><h4 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h4><p>JVM 规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><ol><li><strong>单一线程原则</strong><br> 在一个线程内，在程序前面的操作先行发生于后面的操作。<br> <img src="/posts/19039/Happens-Before-single-thread-rule.png"></li><li><strong>管程锁定规则</strong><br> 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。<br> <img src="/posts/19039/Happens-Before-monitor-lock-rule.png"></li><li><strong>volatile 变量规则</strong><br> 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。<br> <img src="/posts/19039/Happens-Before-volatile-variable-rule.png"></li><li><strong>线程启动规则</strong><br> Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。<br> <img src="/posts/19039/Happens-Before-thread-start-rule.png"></li><li><strong>线程加入规则</strong><br> Thread 对象的结束先行发生于 join() 方法返回。<br> <img src="/posts/19039/Happens-Before-thread-join-rule.png"></li><li><strong>线程中断规则</strong><br> 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</li><li><strong>对象终结规则</strong><br> 一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。</li><li><strong>传递性</strong><br> 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</li></ol><h3 id="线程安全-不是一个非真即假的命题"><a href="#线程安全-不是一个非真即假的命题" class="headerlink" title="线程安全: 不是一个非真即假的命题"></a>线程安全: 不是一个非真即假的命题</h3><p>一个类在可以被多个线程安全调用时就是线程安全的。</p><p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。</p><p>多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型:</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p><h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。<br>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p><h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。<br>Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p><h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><table><thead><tr><th align="left">状态</th><th align="center">释义</th></tr></thead><tbody><tr><td align="left">NEW</td><td align="center">一个创建了但还没有开始启动的线程</td></tr><tr><td align="left">RUNNABLE</td><td align="center">线程start后变为可执行状态，具体是否执行取决于系统cpu调度，ready/running</td></tr><tr><td align="left">BLOCKED</td><td align="center">阻塞，等待锁，比如等待进入synchronized代码块</td></tr><tr><td align="left">WAITING</td><td align="center">线程里调用了wait/join等方法后进入等待状态</td></tr><tr><td align="left">TIMED_WAITING</td><td align="center">超时等待，类似WAITING，但是有时间限制，时间到了，自动进入RUNNABLE状态</td></tr><tr><td align="left">TERMINATED</td><td align="center">结束</td></tr></tbody></table><p><img src="/posts/19039/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"></p><h4 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread.sleep()"></a>Thread.sleep()</h4><p>当前线程调用Thread.sleep(1000)陷入休眠，进入TIMED_WAITING状态，同时系统内核中会根据sleep中的参数设置一个定时器，定时器倒计时结束后，内核会重新唤醒线程，线程状态进入RUNNABLE状态；</p><h4 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield()"></a>Thread.yield()</h4><p>线程状态在RUNNABLE状态下，由系统cpu决定是否执行，所以该状态下，线程在内核中实际有“运行中”和“就绪”两种状态。</p><p>当前线程在“运行中”时，调用Thread.yield()，会立即让出cpu的使用权，让cpu执行优先级更高的或其它同优先级的线程，线程从RUNNABLE状态下的“运行中”变为“就绪”。</p><h4 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h4><p>内部其实就是wait方法，不同于wait的是，它会主动等使用了Object的锁对象的线程彻底执行结束后，自动从WAITING状态进入RUNNABLE状态。</p><h4 id="Object-wait"><a href="#Object-wait" class="headerlink" title="Object.wait()"></a>Object.wait()</h4><p>当前线程获取Object锁后，调用Object的wait方法，则会使当前线程进入WAITING或TIMED_WAITING状态，并释放Object的持有锁，当前线程会被放入等待队列中，直到超时或者被其他线程调用锁对象的notify方法唤醒。</p><h4 id="Object-notify-notifyAll"><a href="#Object-notify-notifyAll" class="headerlink" title="Object.notify()/notifyAll()"></a>Object.notify()/notifyAll()</h4><p>当前线程获取Object锁后，调用Object的notify/notifyAll方法，会使此前调用了该Object的wait线程从WAITING状态进入RUNNABLE状态。<br>notify只会唤醒一个线程，而notifyAll方法可以唤醒所有线程。<br>notify()或者notifyAll()调用时并不会真正释放对象锁, 必须等到synchronized方法或者语法块执行完才真正释放锁。</p><h3 id="线程使用方式"><a href="#线程使用方式" class="headerlink" title="线程使用方式"></a>线程使用方式</h3><h4 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h4><p>继承Thread类，重写run()方法，调用start()方法</p><h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><p>实现Runnable接口并实现run()方法，在Thread类的构造函数中传入实现Runnable接口的类的实例对象</p><h4 id="3-实现Callable接口，通过FutureTask来封装"><a href="#3-实现Callable接口，通过FutureTask来封装" class="headerlink" title="3. 实现Callable接口，通过FutureTask来封装"></a>3. 实现Callable接口，通过FutureTask来封装</h4><p>实现Callable接口并实现run()方法<br>与 Runnable 相比，<strong>Callable 可以有返回值</strong>，返回值通过<strong>FutureTask</strong>进行封装。</p><p>Callable负责产生结果，Future负责获取结果。<br>Callable任务除了返回正常结果之外，如果发生异常，该异常也会被返回，即Future可以拿到异步执行任务各种结果。<br>Future.get()方法会导致主线程阻塞，直到Callable任务执行完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h4><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><p>线程中断是一种线程间协作的机制。<br>当一个线程在执行过程中受到中断请求时，它可以选择立即响应中断，也可以稍后响应，或者根本不响应。</p><p>中断机制是一种软件层面上的线程协作机制，线程可以自己决定何时以及如何响应中断。</p><h4 id="interrupt-amp-InterruptedException"><a href="#interrupt-amp-InterruptedException" class="headerlink" title="interrupt() &amp; InterruptedException"></a>interrupt() &amp; InterruptedException</h4><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞block、限期等待time_waiting或者无限期等待waiting状态，那么就会抛出 InterruptedException，从而提前结束该线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$<span class="number">0</span>(InterruptExample.java:<span class="number">5</span>)</span><br><span class="line">    at InterruptExample$$Lambda$<span class="number">1</span>/<span class="number">713338599.</span>run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h4><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等能够抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。<br>但是调用 <code>interrupt()</code> 方法会设置线程的中断标记，此时调用 <code>interrupted()</code> 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized-VS-ReentrantLock"><a href="#synchronized-VS-ReentrantLock" class="headerlink" title="synchronized VS ReentrantLock"></a>synchronized VS ReentrantLock</h3><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ol><li>锁的实现<br> synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li><li>性能<br> 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</li><li>等待可中断<br> 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br> ReentrantLock 可中断，而 synchronized 不行。</li><li>公平锁<br> 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br> synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</li><li>锁绑定多个条件<br> 一个 ReentrantLock 可以同时绑定多个 Condition 对象。</li></ol><h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。<br>这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。<br>并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> Java并发和多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDE插件开发-VS Code</title>
      <link href="/posts/26185.html"/>
      <url>/posts/26185.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> IDE插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDE插件开发-IntelliJ平台</title>
      <link href="/posts/24764.html"/>
      <url>/posts/24764.html</url>
      
        <content type="html"><![CDATA[<h2 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h2><h2 id="plugin-xml"><a href="#plugin-xml" class="headerlink" title="plugin.xml"></a>plugin.xml</h2><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><h2 id="applicationService"><a href="#applicationService" class="headerlink" title="applicationService"></a>applicationService</h2><h2 id="applicationConfigurable"><a href="#applicationConfigurable" class="headerlink" title="applicationConfigurable"></a>applicationConfigurable</h2><h2 id="toolWindow"><a href="#toolWindow" class="headerlink" title="toolWindow"></a>toolWindow</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> IDE插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码-Object</title>
      <link href="/posts/2067.html"/>
      <url>/posts/2067.html</url>
      
        <content type="html"><![CDATA[<p>Object类是一切类的超类，在类继承的树形结构上，Object是所有类的根节点。所有的对象，包括数据，都继承了Object类的方法。</p><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives"></a>registerNatives</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol><li>hashCode 表示对象在 hash 表中的位置，对于同一个对象来说，多次调用，返回相同的 hashCode。</li><li>如果 Object.equal () 相等，Object.hashCode () 也必然相等。重写时也建议保证此特性。</li><li>如果 Object.equal () 相等，这并不要求 Object.hashCode () 也返回不同值。如果真出现这种情况，最好优化代码，充分利用 hash 表的性能。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">intptr_t</span> <span class="title">get_next_hash</span><span class="params">(Thread * Self, oop obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> value = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">     <span class="comment">// so it&#x27;s possible for two threads to race and generate the same RNG.</span></span><br><span class="line">     <span class="comment">// On MP system we&#x27;ll have lots of RW access to a global, so the</span></span><br><span class="line">     <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">     value = os::<span class="built_in">random</span>() ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">     <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">     <span class="comment">// synchronization schemes.</span></span><br><span class="line">     <span class="keyword">intptr_t</span> addrBits = <span class="built_in">intptr_t</span>(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">     value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">     value = <span class="number">1</span> ;            <span class="comment">// for sensitivity testing</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">     value = ++GVars.hcSequence ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">     value = <span class="built_in">intptr_t</span>(obj) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Marsaglia&#x27;s xor-shift scheme with thread-specific state</span></span><br><span class="line">     <span class="comment">// This is probably the best overall implementation -- we&#x27;ll</span></span><br><span class="line">     <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">     <span class="keyword">unsigned</span> t = Self-&gt;_hashStateX ;</span><br><span class="line">     t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">     <span class="keyword">unsigned</span> v = Self-&gt;_hashStateW ;</span><br><span class="line">     v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">     Self-&gt;_hashStateW = v ;</span><br><span class="line">     value = v ;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  value &amp;= markOopDesc::hash_mask;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="number">0</span>) value = <span class="number">0xBAD</span> ;</span><br><span class="line">  <span class="built_in">assert</span> (value != markOopDesc::no_hash, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">TEVENT</span> (hashCode: GENERATE) ;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中的 hashCode 其实就是 JVM 启动的一个参数，每一个分支对应一个生成策略。通过 -XX:hashCode，可以任意切换 hashCode 的生成策略。</p><p>首先解释一下入参 oop obj 就是对象的逻辑地址。所以与地址相关的生成策略有两条，在 hashCode 等于 1 或 4 的时候。</p><ul><li>hashCode==1：这种方式具有幂等的性质，在 STW（stop-the-world）操作中，这种策略通常用于同步方案中。利用对象地址计算，使用不经常更新的随机数参与运算。</li><li>hashCode==4：与创建对象的内存位置有关，原样输出。</li></ul><p>其他情况：</p><ul><li>hashCode==0：简单地返回随机数，与对象的内存地址没有联系。然而根据随机数生成并全局地读写在多处理器下并不占优势。</li><li>hashCode==2：始终返回完全相同的标识，即 hashCode=1。这可用于测试依赖对象标识的代码。</li><li>hashcode==3：从零开始计算哈希代码值。它看起来不是线程安全的，因此多个线程可以生成具有相同哈希代码的对象。</li><li>hashCode&gt;=5（默认）：在 jdk1.8 中，这是默认的 hashCode 生成算法，支持多线程生成。使用了 Marsaglia 的 xor-shift 算法产生伪随机数。</li></ul><h4 id="xor-shift-算法"><a href="#xor-shift-算法" class="headerlink" title="xor-shift 算法"></a>xor-shift 算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint32_t xor128(void) &#123;</span><br><span class="line"> static uint32_t x = 123456789;</span><br><span class="line"> static uint32_t y = 362436069;</span><br><span class="line"> static uint32_t z = 521288629;</span><br><span class="line"> static uint32_t w = 88675123;</span><br><span class="line"> uint32_t t;</span><br><span class="line"> </span><br><span class="line"> t = x ^ (x &lt;&lt;11);</span><br><span class="line"> x = y; y = z; z = w;</span><br><span class="line"> return w = w ^ (w&gt;&gt; 19) ^ (t ^ (t&gt;&gt; 8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String重写hashCode"><a href="#String重写hashCode" class="headerlink" title="String重写hashCode"></a>String重写hashCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相同的字符串调用hashCode()方法，得到的值是一样的，与内存地址、进程、及其无关。</p><p>为什么计算时选择<code>31</code>？</p><ol><li>31 是个奇质数，不大不小，一般质数非常适合 hash 计算。<br> 偶数相当于移位运算，容易溢出，数据信息丢失。<br> 如果太小，则产生的哈希值区间小；太大则容易溢出，数据信息丢失。</li><li>31 * i == (i &lt;&lt; 5) - i。非常易于维护，将移位代替乘除，会有性能的提升，并且 JVM 执行时能够自动优化成这个样子。</li><li>通过实验计算，选用 31 后出现 hash 冲突的概率相比于其他数字要小。</li></ol><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当重写hashCode方法的时候，通常都需要重写该方法，以便维护hashCode方法的常规约定，该方法申明相等的对象必须具有相同的hashCode。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Map - HashMap源码分析</title>
      <link href="/posts/39767.html"/>
      <url>/posts/39767.html</url>
      
        <content type="html"><![CDATA[<p>HashMap 1.7及以前，底层数据结构使用 [数组+链表]，1.8 后使用 [数组+链表/红黑树] ，使用数组存储元素是因为查找快，链表是为了解决哈希冲突存在的，而红黑树是为了解决链表中查询速度慢对链表进行优化的一种数据结构。</p><p>HashMap 是非线程安全的，如果需要线程安全，使用 ConcurrentHashMap 或者 Collections.synchronizedMap() 包裹 HashMap 达到线程安全的目的。</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="1、HashMap为什么线程不安全"><a href="#1、HashMap为什么线程不安全" class="headerlink" title="1、HashMap为什么线程不安全"></a>1、HashMap为什么线程不安全</h3><ol><li><p>初始化懒加载</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个HashMap的时候，其实只是定义了initialCapacity和loadFactor这两个值，</span></span><br><span class="line"><span class="comment">// 并没有初始化数组，而是懒加载的思想，在第一次put时候通过resize()方法去加载。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                        initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                        loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次个线程不安全的地方</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在jdk1.8中，在多线程环境下，在并发执行put操作时会发生数据覆盖的情况。<br> JDK1.7出现的问题，在JDK1.8中已经得到了很好的解决，JDK1.8直接在resize函数中完成了数据迁移。在进行元素插入时使用的是尾插法然后在扩容。</p><p> 但是在1.8中仍会有数据覆盖这样的问题，先看put源码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//判断是否出现hash碰撞，如果没有hash碰撞则直接插入元素，此处线程不安全</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//++size此处线程不安全</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中代码<code>if ((p = tab[i = (n - 1) &amp; hash]) == null) </code>是判断是否出现hash碰撞：<br> 比如两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</p><p> 还有一种情况就是代码<code>if (++size &gt; threshold)</code>中的<code>++size</code>：<br> 同样还是线程A、B，这两个线程同时进行put操作时，假设当前HashMap的zise大小为10，当线程A执行到此行代码时，从主内存中获得size的值为10后准备进行+1操作，但是由于时间片耗尽只好让出CPU，线程B快乐的拿到CPU还是从主内存中拿到size的值10进行+1操作，完成了put操作并将size=11写回主内存，然后线程A再次拿到CPU并继续执行(此时size的值仍为10)，当执行完put操作后，还是将size=11写回内存，此时线程A、B都执行了一次put操作，但是size的值只增加了1，所有说还是由于数据覆盖又导致了线程不安全。</p></li><li><p>在jdk1.7中，在多线程环境下，当并发执行扩容时会造成死循环(环形链)或数据丢失。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p> JDK1.7中HashMap的transfer函数如上，扩容操作（先扩容再头插法插入）会重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。头插法会将链表的顺序翻转，这也是造成死循环和数据丢失的关键。</p></li></ol><h3 id="2、HashMap为什么选用红黑树这种数据结构优化链表"><a href="#2、HashMap为什么选用红黑树这种数据结构优化链表" class="headerlink" title="2、HashMap为什么选用红黑树这种数据结构优化链表"></a>2、HashMap为什么选用红黑树这种数据结构优化链表</h3><p>在JDK1.8之后，Java对HashMap做了改进，在链表长度大于<code>8</code>的时候，将后面的数据存到<code>红黑树</code>中，以<code>加快检索速度</code>。</p><p>红黑树也是一种平衡二叉树，每个节点有一个储存位表示节点的颜色，可以是红色或者黑色。通过对任意一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有任意一条从根到叶子的路径超过最短路径的两倍，因此红黑树是一种弱平衡二叉树。</p><p>相对于AVL树来说，红黑树的旋转次数少，对于搜索、插入、删除多的操作下用红黑树。</p><p>红黑树不追求”完全平衡”，即不像AVL那样要求节点的 |balFact| &lt;= 1，它只要求部分达到平衡，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。</p><p><strong>HashMap中链表转为红黑树的条件</strong><br>在JDK1.8之后，HashMap中的链表在满足以下两个条件时，将会转化为红黑树(即自平衡的排序二叉树)：</p><ol><li>条件一<br> 数组 arr[i] 处存放的链表长度大于8；</li><li>条件二<br> 数组长度大于等于64。</li></ol><p>满足以上两个条件，数组 arr[i] 处的链表将自动转化为红黑树，其他位置如 arr[i+1] 处的数组元素仍为链表，不受影响</p><h3 id="3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲-HashMap-扰动函数？"><a href="#3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲-HashMap-扰动函数？" class="headerlink" title="3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲 HashMap 扰动函数？"></a>3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲 HashMap 扰动函数？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 如果没有hash碰撞则直接插入元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n 为 2次幂，可以保证数据的均匀插入，降低哈希冲突的概率，毕竟冲突越大，代表数组中的链表/红黑树越大，从而降低Hashmap 的性能。</p><p>不管是规定 Hashmap 的 n 为 2次幂，还是扰动函数，都是为了一个目标，降低哈希冲突的概率，从而使 HashMap 性能得到优化。<br>规定 n 为 2次幂，是在新建 Hashmap对象初始化时，规定其容量大小的角度来优化。<br>扰动函数是插入 key 值时改变 key 的散列值，增大key的散列程度，降低哈希碰撞的概率来达到优化效果。</p><h3 id="4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）"><a href="#4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）" class="headerlink" title="4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）"></a>4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算索引下标，key的hashCode的高16位与低16位异或 对数组的长度取余</span></span><br><span class="line">    tab[i = (n -<span class="number">1</span>) &amp; hash]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hash值是一个int类型，二进制位为32位，而HashMap的table数组初始化size为16，计算索引下标的取余操作为<code>hash &amp; (length - 1) ==&gt; hash &amp; 1111</code>，这里面的问题是，1111只会与hashCode的低4位进行与操作，hashCode的高位并没有参与运算，会导致很多hashCode值不同而高位有区别的数最后算出来的索引是一样的。</p><p>举个例子，假设hashCode为1111110001，那么<code>1111110001 &amp; 1111 = 0001</code>，高位发生变化时<code>1011110001 &amp; 1111 = 0001</code>，<code>1001110001 &amp; 1111 = 0001</code>，也就是说在高位发生变化时，你最后算出来的索引都一样了，这样就会导致很多数据都被放到一个数组里面了，造成性能退化。</p><p>为了避免这种情况，HashMap将 key 的<code>高16位与低16位进行异或</code>，这样可以保证高位的数据也参与到与运算中来，以增大索引的散列程度，让数据分布得更为均匀 (个人觉得很多博客说的减小哈希碰撞是错误的说法，因为hash碰撞指的是两个hashCode相同，这里显然不是)。</p><p>主要原因是保留高16位与低16位的特性，增大散列程度。</p><p><strong>为什么用异或</strong>，不用<code>&amp;</code>或者<code>|</code>操作。因为异或可以保证两个数值的特性，<code>&amp;</code>运算使得结果向0靠近， <code>|</code>运算使得结果向1靠近。</p><h4 id="Object类中的hashCode方法"><a href="#Object类中的hashCode方法" class="headerlink" title="Object类中的hashCode方法"></a>Object类中的hashCode方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法不是抽象方法，带有native关键字，底层调用C++程序。</p><p>hashCode()方法返回的是哈希码：实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值。所以hashCode()方法的执行结果可以等同看做一个java对象的内存地址。</p><h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p><img src="/posts/39767/java8hashmap.png"></p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16, 默认初始化容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//负载系数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;   <span class="comment">// 取消树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 最小树化数组容量，转换为红黑树的最小数组长度为64</span></span><br></pre></td></tr></table></figure><h3 id="影响HashMap性能的两个因素"><a href="#影响HashMap性能的两个因素" class="headerlink" title="影响HashMap性能的两个因素"></a>影响HashMap性能的两个因素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>初始容量。创建哈希表时的容量。</li><li>负载系数。衡量哈希表在自动增加容量之前的填充程度的容量，当哈希表中的数据数量超过 (负载因子 * 当前容量) 时，哈希表将被扩容、重建。<br> loadFactor的默认值为<code>0.75f</code> 是官方给出的一个比较好的临界值，这个值是经过多次推测得出的</li></ol><h3 id="防蠢货能力"><a href="#防蠢货能力" class="headerlink" title="防蠢货能力"></a>防蠢货能力</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法-put过程分析"><a href="#put方法-put过程分析" class="headerlink" title="put方法 put过程分析"></a>put方法 put过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第五个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1. 节点数组为空</span></span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2. 节点为空</span></span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 3. 节点不为空，发生冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用HashMap的put方法，实际上调用了HashMap的putVal方法。</li><li>首先putVal()先用<code>hash(key)</code>函数计算键值对key的hash。hash(key)与数组长度做取余的位运算，得到这个键值对节点在数组中的具体下标。</li><li>进入putVal()方法，如果第一次插入元素，会调用resize()方法，初始化数组长度以及负载因子。</li><li>如果不是第一次插入，先看这个下标有没有元素，如果没有的话，直接放在这个下标。</li><li>如果这个下标已经有元素了，就会发生哈希冲突，遍历这个下标的链表，如果key值相等，就替换value；如果key值不相等，就继续向下遍历，如果遍历完成仍然key不相等，就用尾插法将元素插入到链表中，然后判断链表是否要转化成红黑树。</li><li>插入完成后，HashMap的size++，如果size大于阈值就进行数组的扩容操作。（先插入，再扩容）</li></ol><h3 id="resize方法-扩容"><a href="#resize方法-扩容" class="headerlink" title="resize方法 扩容"></a>resize方法 扩容</h3><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化或增加表的大小，如果表为空，根据初始容量分配。扩容表，2次幂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 获取旧元素数组的各种信息</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧数组长度 </span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧数组临界值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 定义新数组的长度及扩容的临界值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果原 table 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组长度达到最大值,修改临界值为最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容操作(2倍)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 新数组初始容量和阈值使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;  <span class="comment">// 16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 16 * 0.75 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 临界值还为0，设置临界值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新负载因子</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 红黑树调整</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表调整</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="treeifyBin方法"><a href="#treeifyBin方法" class="headerlink" title="treeifyBin方法"></a>treeifyBin方法</h3><ol><li>判断是否真的需要转换红黑树，如果数组长度小于<code>MIN_TREEIFY_CAPACITY = 64</code> 将会扩容resize()；</li><li>如果符合转换的条件，<code>数组长度大于等于MIN_TREEIFY_CAPACIT(64) &amp;&amp; 链表长度大于TREEIFY_THRESHOLD(8)</code>，将该槽中所有的链表节点转换成树形节点，并且构造成双链表，为 treeify 转换成红黑树准备。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果table为null  或者table数组的长度小于MIN_TREEIFY_CAPACITY  64</span></span><br><span class="line">    <span class="comment">//MIN_TREEIFY_CAPACITY这个其实是转化成红黑树的另外一个条件，就是数组长度要大于64</span></span><br><span class="line">    <span class="comment">//如果小于64 就可以通过扩容的方法，来减小冲突，没有必要转换成红黑树，因为红黑树的转换也是需要很大是 时间和空间的代价</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">//进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">        <span class="comment">//获得需要树形化的 链表的第一个节点 也就是数组对应的数组节点table[i]</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//将普通的node节点 构造成TreeNode  拥有更多的属性</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * parent</span></span><br><span class="line"><span class="comment">                 * right</span></span><br><span class="line"><span class="comment">                 * left</span></span><br><span class="line"><span class="comment">                 * red</span></span><br><span class="line"><span class="comment">                 * key</span></span><br><span class="line"><span class="comment">                 * value</span></span><br><span class="line"><span class="comment">                 * next</span></span><br><span class="line"><span class="comment">                 * prev</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//构造成双链表形式</span></span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//替换成 构造成双链表的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//进行红黑树转换</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="treeify方法"><a href="#treeify方法" class="headerlink" title="treeify方法"></a>treeify方法</h3><p>该方法的主要作用就是，将链表的元素一个一个的插入到树中，并且保持排序树的特性：当左、右子树不为空的时候 左子树小于根节点 右子树大于根节点。<br>这里的大小通过comparable方法比较key的大小。如果key没有实现该接口，那么通过比较hash值来判定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将链表中每个值进行红黑树插入操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K, V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K, V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K, V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        <span class="comment">//根据链表进行遍历</span></span><br><span class="line">        next = (TreeNode&lt;K, V&gt;) x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果根节点还没设置则当前节点设置为根节点root</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//根节点一定是黑色的</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前循环节点的key和哈希值</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//每次都从根节点开始循环</span></span><br><span class="line">            TreeNode&lt;K, V&gt; p = root;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="comment">//遍历当前红黑树</span></span><br><span class="line">                <span class="keyword">int</span> dir;</span><br><span class="line">                <span class="comment">//获得p的hash值和key</span></span><br><span class="line">                <span class="keyword">int</span> ph = p.hash;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="comment">//比较hash值，然后根据比较值dir决定插入左边还是右边</span></span><br><span class="line">                <span class="keyword">if</span> (ph &gt; h) &#123;</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) &#123;</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//k不是不是课比较类或者比较结果为0，使用tieBreakOrder方法比较</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line">                TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">                p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right;</span><br><span class="line">                <span class="comment">//仅当当前要插入的位置上没有节点时才进行插入，否则继续向下遍历</span></span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置父节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//根据dir值设置为父节点的左右子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//插入成功后平衡红黑树</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="comment">//跳出当前循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保当前的root是直接落在table数组上的</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><p><img src="/posts/39767/java7hashmap.png"></p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet仅仅是对HashMap做了一层包装，也就是说HashSet里面有一个HashMap(适配器模式)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/posts/38008.html"/>
      <url>/posts/38008.html</url>
      
        <content type="html"><![CDATA[<p>Maven是一个项目管理和整合工具。Maven为开发者提供了一套完整的构建生命周期框架。开发团队几乎不用花多少时间就能够自动完成工程的基础构建配置，因为Maven使用了一个标准的目录结构和一个默认的构建生命周期。</p><p>Maven的主要目的是为开发者提供：​</p><ul><li>​一个可复用、可维护、更易理解的工程综合模型，与这个模型交互的插件或工具​</li><li>​Maven工程结构和内容定义在一个xml文件中（一般是pom.xml）</li></ul><h2 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h2><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li>mvn -e 显示详细错误</li><li>mvn -U 强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖）</li><li>mvn -o 运行offline模式，不联网更新依赖</li><li>mvn -N 仅在当前项目模块执行命令，关闭reactor</li><li>mvn -pl module_name在指定模块上执行命令</li><li>mvn -ff 在递归执行命令过程中，一旦发生错误就直接退出</li><li>mvn -Dxxx=yyy 指定java全局属性</li><li>mvn -Pxxx 引用profile xxx</li><li>mvn -s setting.xml -gs setting.xml -Dmaven.repo.local=$(pwd)/repos package -Dmaven.test.skip=true</li></ul><h3 id="mvn-package"><a href="#mvn-package" class="headerlink" title="mvn package"></a>mvn package</h3><p>完成项目编译、单元测试、打包功能，打包到本项目，一般在项目target目录下。</p><p>打包文件未部署到本地Maven仓库和远程Maven仓库。</p><h3 id="mvn-install"><a href="#mvn-install" class="headerlink" title="mvn install"></a>mvn install</h3><p>完成项目编译、单元测试、打包功能，同时把打包文件部署到本地Maven仓库，但未部署到远程Maven仓库。</p><h3 id="mvn-deploy"><a href="#mvn-deploy" class="headerlink" title="mvn deploy"></a>mvn deploy</h3><p>完成项目编译、单元测试、打包功能，同时把打包文件部署到本地Maven仓库和远程Maven仓库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy:deploy-file </span><br><span class="line">    -Dmaven.test.skip=<span class="literal">true</span> </span><br><span class="line">    -DgroupId=com.example </span><br><span class="line">    -DartifactId=demo </span><br><span class="line">    -Dversion=1.0.0 </span><br><span class="line">    -Dpackaging=jar </span><br><span class="line">    -Dfile=demo-1.0.0.jar </span><br><span class="line">    -DrepositoryId=x-repo </span><br><span class="line">    -Durl=http://localhost:8081/nexus/content/repositories/thirdparty/ </span><br><span class="line">    -DpomFile=pom.xml</span><br></pre></td></tr></table></figure><ul><li>-DgeneratePom<br>生成pom文件，默认为true，只会生成一个最简单的pom，缺少依赖，会导致依赖该组件的服务无法获取组件的依赖。</li><li>-DpomFile<br>指定本地pom文件作为组件的pom。</li></ul><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p>当执行 mvn deploy 命令时，Maven 会通过<code>maven-deploy-plugin</code>将构件上传到 Nexus 的 Maven 仓库对应的 REST API。</p><h2 id="Maven执行原理"><a href="#Maven执行原理" class="headerlink" title="Maven执行原理"></a>Maven执行原理</h2><p><a href="https://blog.csdn.net/u014534566/article/details/106269680?spm=1001.2014.3001.5502">https://blog.csdn.net/u014534566/article/details/106269680?spm=1001.2014.3001.5502</a><br><a href="https://blog.csdn.net/yin18827152962/article/details/121482340">https://blog.csdn.net/yin18827152962/article/details/121482340</a></p><p>Maven本质上是定义并实现了一套管理和执行插件扩展能力的框架，从<code>mvn</code>式命令（这里的命令可以是手动输入，也可以是某些工具集成从而以程序语言执行）输入开始，mvn命令通过maven框架解析并映射到对应的maven插件库找到对应的插件包，相应的插件包接收到命令及入参执行相应行为，这是最直接的解释</p><h3 id="mvn命令的解析"><a href="#mvn命令的解析" class="headerlink" title="mvn命令的解析"></a>mvn命令的解析</h3><p>maven是由本质是执行命令，因为maven构建框架是固定的，变化的是插件，因此一级命令<code>mvn</code>（我们通常看到的mvn -v查看maven版本，就是这个mvn）是一致的。<br><img src="/posts/38008/mvn%E5%8E%9F%E7%90%86-mvn%E8%84%9A%E6%9C%AC.png"><br><img src="/posts/38008/mvn%E5%8E%9F%E7%90%86-mvn%E8%84%9A%E6%9C%AC-mvn%E7%9A%84%E5%89%AF%E6%9C%AC.png"></p><p><strong>一级命令取决于脚本的名称</strong>。毫无疑问，脚本文件的逻辑含义是maven核心之一。<br>接下来深入看看这些脚本干了啥。</p><h4 id="mvn"><a href="#mvn" class="headerlink" title="mvn"></a>mvn</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CLASSWORLDS_JAR=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;MAVEN_HOME&#125;</span>&quot;</span>/boot/plexus-classworlds-*.jar`</span><br><span class="line">CLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$JAVACMD</span>&quot;</span> \</span><br><span class="line">  <span class="variable">$MAVEN_OPTS</span> \</span><br><span class="line">  <span class="variable">$MAVEN_DEBUG_OPTS</span> \</span><br><span class="line">  -classpath <span class="string">&quot;<span class="variable">$&#123;CLASSWORLDS_JAR&#125;</span>&quot;</span> \</span><br><span class="line">  <span class="string">&quot;-Dclassworlds.conf=<span class="variable">$&#123;MAVEN_HOME&#125;</span>/bin/m2.conf&quot;</span> \</span><br><span class="line">  <span class="string">&quot;-Dmaven.home=<span class="variable">$&#123;MAVEN_HOME&#125;</span>&quot;</span> \</span><br><span class="line">  <span class="string">&quot;-Dlibrary.jansi.path=<span class="variable">$&#123;MAVEN_HOME&#125;</span>/lib/jansi-native&quot;</span> \</span><br><span class="line">  <span class="string">&quot;-Dmaven.multiModuleProjectDirectory=<span class="variable">$&#123;MAVEN_PROJECTBASEDIR&#125;</span>&quot;</span> \</span><br><span class="line">  <span class="variable">$&#123;CLASSWORLDS_LAUNCHER&#125;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><h4 id="mvn-cmd"><a href="#mvn-cmd" class="headerlink" title="mvn.cmd"></a>mvn.cmd</h4><p><img src="/posts/38008/mvn%E5%8E%9F%E7%90%86-mvncmd.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (<span class="string">&quot;%MAVEN_HOME%&quot;</span>\boot\plexus-classworlds-*) <span class="keyword">do</span> <span class="built_in">set</span> CLASSWORLDS_JAR=<span class="string">&quot;%%i&quot;</span></span><br><span class="line"><span class="built_in">set</span> CLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;%JAVACMD%&quot;</span> ^</span><br><span class="line">  %JVM_CONFIG_MAVEN_PROPS% ^</span><br><span class="line">  %MAVEN_OPTS% ^</span><br><span class="line">  %MAVEN_DEBUG_OPTS% ^</span><br><span class="line">  -classpath %CLASSWORLDS_JAR% ^</span><br><span class="line">  <span class="string">&quot;-Dclassworlds.conf=%MAVEN_HOME%\bin\m2.conf&quot;</span> ^</span><br><span class="line">  <span class="string">&quot;-Dmaven.home=%MAVEN_HOME%&quot;</span> ^</span><br><span class="line">  <span class="string">&quot;-Dlibrary.jansi.path=%MAVEN_HOME%\lib\jansi-native&quot;</span> ^</span><br><span class="line">  <span class="string">&quot;-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%&quot;</span> ^</span><br><span class="line">  %CLASSWORLDS_LAUNCHER% %MAVEN_CMD_LINE_ARGS%</span><br><span class="line"><span class="keyword">if</span> ERRORLEVEL 1 goto error</span><br><span class="line">goto end</span><br></pre></td></tr></table></figure><p>这里干了四件事：</p><ol><li>关联配置<code>m2.conf</code>；</li><li>关联入口<code>plexus-classworlds-*.jar</code>及入口方法；</li><li>写入配置参数；</li><li>截取命令输入作为参数执行<code>2</code>中的方法。</li></ol><h4 id="m2-conf"><a href="#m2-conf" class="headerlink" title="m2.conf"></a>m2.conf</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main is org.apache.maven.cli.MavenCli from plexus.core</span><br><span class="line"></span><br><span class="line">set maven.conf default $&#123;maven.home&#125;/conf</span><br><span class="line"></span><br><span class="line">[plexus.core]</span><br><span class="line">load       $&#123;maven.conf&#125;/logging</span><br><span class="line">optionally $&#123;maven.home&#125;/lib/ext/*.jar</span><br><span class="line">load       $&#123;maven.home&#125;/lib/*.jar</span><br></pre></td></tr></table></figure><h4 id="plexus-classworlds-jar"><a href="#plexus-classworlds-jar" class="headerlink" title="plexus-classworlds-*.jar"></a>plexus-classworlds-*.jar</h4><p>plexus-classworlds-*.jar逐行解析m2.conf配置项，主要干了三件事：</p><ol><li>根据环境变量获取maven路径下lib的jar包，加载到当前的运行态中（URLClassLoader加载到URLClassPath中），包括maven-embedder-*.jar这个包，即maven执行命令<code>MavenCli</code>的入口；</li><li>据配置得到入口函数（MavenCli）及一些配置项，很难相信main is和from这种字符串能作为代码解析配置参数的标识；</li><li>结合输入命令截取的字符串作为入参，获取到的入口类通过反射调用其唯一默认的main方法，至此，maven成功进入命令解析并作出特异性插件行为阶段；</li></ol><h3 id="Maven插件路由映射"><a href="#Maven插件路由映射" class="headerlink" title="Maven插件路由映射"></a>Maven插件路由映射</h3><p>到了<code>org.apache.maven.cli.MavenCli</code>解析二级命令（即mvn之后的去前后空格字符串，如mvn deploy:deploy-file）并对应到相应的maven插件并指定该插件执行的goal，执行特定构建行为。</p><p>下面代码是执行mvn的核心方法，不难看出有一系列的子方法完善CliRequest类，它包含了执行插件所需要的所有参数，一条命令可能包含多条maven command line关键字，随着<code>doMain</code>方法的执行，关键字被依次解析，最终所有关键字都得以匹配，达到用户的意图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doMain</span><span class="params">( CliRequest cliRequest )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PlexusContainer localContainer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//完善工作路径workingDirectory，若为空则默认为当前用户路径，多模块项目路径multiModuleProjectDirectory</span></span><br><span class="line">      <span class="comment">//若为空，则取maven.multiModuleProjectDirectory环境变量</span></span><br><span class="line">      initialize( cliRequest );</span><br><span class="line">      <span class="comment">//完善commandLine，解析命令，匹配程序内置的命令-v， -h</span></span><br><span class="line">      <span class="comment">//判断commandLine是否为-v或者-h，是就在控制台打印出相应的信息并退出</span></span><br><span class="line">      cli( cliRequest );</span><br><span class="line">      <span class="comment">//将系统参数和用户参数写入到请求当中systemProperties以及userProperties属性的设置</span></span><br><span class="line">      <span class="comment">//1.设置系统参数System.getenv(),一些系统级别的参数变量</span></span><br><span class="line">      <span class="comment">//2.设置运行相关参数System.getProperties()，主要是java相关的属性</span></span><br><span class="line">      <span class="comment">//3.设置maven构建的版本信息,主要从/org/apache/maven/messages/build.properties</span></span><br><span class="line">      <span class="comment">//  里获取构建信息:在maven-core的messages包下获取，就是一些版本及发布者信息等</span></span><br><span class="line">      properties( cliRequest );</span><br><span class="line">      <span class="comment">//完善执行请求中的日志属性配置，-x,-q,-e 设置MavenExecutionRequest日志级别，实际上是执行插件的日志级别</span></span><br><span class="line">      <span class="comment">//设置打印日志的消息字体颜色是否启用，其底层是用org.fusesource.jansi.Ansi来控制多色输出；</span></span><br><span class="line">      <span class="comment">//若命令中包含-b和-l部分，则控制台输出字体颜色为默认颜色</span></span><br><span class="line">      <span class="comment">//对于-l file命令，重定向日志输出到file里，通过PrintStream将System日志写入,包含setOut及setErr;</span></span><br><span class="line">      logging( cliRequest );</span><br><span class="line">      <span class="comment">//debug模式下解析解析到-V后打印版本信息</span></span><br><span class="line">      version( cliRequest );</span><br><span class="line">      <span class="comment">//构建Maven.class,负责执行maven指定的构建行为，组装了一些参数</span></span><br><span class="line">      localContainer = container( cliRequest );</span><br><span class="line">      <span class="comment">//打印一些设置信息是否开启，诸如错误日志开启，CHECKSUM_POLICY_FAIL是否开启</span></span><br><span class="line">      commands( cliRequest );</span><br><span class="line">      <span class="comment">//EventSpyDispatcher初始化及设置，-s,-gs命令解析，设置用户配置文件及全局配置文件</span></span><br><span class="line">      configure( cliRequest );</span><br><span class="line">      <span class="comment">//-t,-gt命令解析，设置toolchains</span></span><br><span class="line">      toolchains( cliRequest );</span><br><span class="line">      <span class="comment">//1.校验将会废弃的maven命令，&#123; &quot;up&quot;, &quot;npu&quot;, &quot;cpu&quot;, &quot;npr&quot; &#125;，并打印警告信息</span></span><br><span class="line">      <span class="comment">//2. 解析-b(批处理),-nsu（进展快照更新），-N（不递归到子项目中），-ff（在构建响应堆中首次失败时停止构建）</span></span><br><span class="line">      <span class="comment">//-fae(仅仅是当前失败的构建才会置为失败，其余不受影响的构建会继续)，-fn（所有的构建失败都会被忽略，无论个中构建任务失败与否）[-ff,-fae,-fn是顺序检测取第一个]</span></span><br><span class="line">      <span class="comment">//-o(设置线下操作标识)，-U（标识是否更新快照）</span></span><br><span class="line">      <span class="comment">//-C与-c（互斥出现），当checksum不匹配的时候，使用什么处理策略，默认是-c（警告）-C会使得checksum不匹配后使构建失败退出</span></span><br><span class="line">      <span class="comment">//-P xxx,xxxx（用以引入配置文件list，以逗号间隔，这里不涉及配置文件的格式及解析过程）</span></span><br><span class="line">      <span class="comment">//-ntp（在上传或者下载时不显示进度信息,这个在进度显示优先级最高）,然后如果有-l xxxx.log等日志文件，</span></span><br><span class="line">      <span class="comment">//就使用Slf4jMavenTransferListener监听并写入到日志文件，如果没有且日志级别为debug的，使用ConsoleMavenTransferListener监听进度</span></span><br><span class="line">      <span class="comment">//-f xxxx/pom.xml,加载pom.xml文件到执行参数里，如果没有设置，默认为基础路径下的pom文件,如果有父文件则进行加载和引用</span></span><br><span class="line">      <span class="comment">//-rf xxxxx（当构建失败后，重新执行从某个特定模块重新执行，选项后可跟随[groupId]:artifactId）</span></span><br><span class="line">      <span class="comment">//-pl xxxxxx（project list，以逗号间隔多个模块的相对路径，或者模块以[groupId]:artifactId的形式表示）,后面跟的每个参数项，会以+，-，!，或其他符号开始，+或其他符号为头标会被exclude，其余则被include</span></span><br><span class="line">      <span class="comment">//-am xxx，-amd xxx，xxx表示模块，设置编译行为或者编译作用域，前者表示同时编译选定模块所依赖的模块（上游make），后者表示编译依赖选定模块的部分（下游make），根据实际需求选定，若没有指定，则make时会默认把上游和下游模块都加载进来</span></span><br><span class="line">      <span class="comment">//依次在用户配置和系统配置（用户配置没有取到）里加载maven.repo.local，加载本地仓库路径到运行参数里</span></span><br><span class="line">      <span class="comment">//-T xxx（设置构建并发的并行线程数，可以在数字之后跟C，表示这个线程数需要跟当前运行时jvm可用的processor数量相乘，即针对每个内核都派发那么多线程，通过Runtime.getRuntime().availableProcessors()获取）</span></span><br><span class="line">      <span class="comment">//-b xxxxxx（指定构建器的id，默认是multithreaded构建器（builder））</span></span><br><span class="line">      populateRequest( cliRequest );</span><br><span class="line">      <span class="comment">//-emp xxx（单独的工具，对master密码进行加密并打印）,不参与构建过程</span></span><br><span class="line">      <span class="comment">//-ep xxx（单独的工具，对服务器密码进行加密并打印）,不参与构建过程</span></span><br><span class="line">      encryption( cliRequest );</span><br><span class="line">      <span class="comment">//通过两种方式判断是否使用maven2老版本的本地库而不使用远程仓库：</span></span><br><span class="line">      <span class="comment">//-llr（即legacy-local-repository,设置使用老版本参数）</span></span><br><span class="line">      <span class="comment">//系统配置maven.legacyLocalRepo为true，则使用老版本maven库</span></span><br><span class="line">      repository( cliRequest );</span><br><span class="line">      <span class="comment">//执行命令入参</span></span><br><span class="line">      <span class="keyword">return</span> execute( cliRequest );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略catch语法</span></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( localContainer != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            localContainer.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户的执行目标及需求配置确认并封装完成之后，就开始执行构建操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.设置构建的初始化属性</span></span><br><span class="line"><span class="comment">//2.校验本地依赖库的可访问性</span></span><br><span class="line"><span class="comment">//3.创建RepositorySystemSession</span></span><br><span class="line"><span class="comment">//4.创建MavenSession</span></span><br><span class="line"><span class="comment">//5.执行AbstractLifecycleParticipant.afterSessionStart(session)</span></span><br><span class="line"><span class="comment">//6.获取校验pom对象error的对象</span></span><br><span class="line"><span class="comment">//7.创建ProjectDependencyGraph用以调整--projects和reactor模式（确保所有传递到ReactorReader的项目仅仅是指定的项目）</span></span><br><span class="line"><span class="comment">//8.创建ReactorReader用以获取对象映射（getProjectMap( projects )），在获取的时候会对对象做唯一性校验，这些对象是从第6步中获取的对象集合</span></span><br><span class="line"><span class="comment">//9.执行AbstractLifecycleParticipant.afterProjectsRead(session)后置处理</span></span><br><span class="line"><span class="comment">//10.创建ProjectDependencyGraph，不用再调整，第7步已经做了这个工作，这里要完成对AbstractLifecycleParticipants的拓扑排序，可能会改变依赖进而影响构建顺序</span></span><br><span class="line"><span class="comment">//11.开始执行LifecycleStarter.start()生命周期开始</span></span><br><span class="line"><span class="comment">//=============================================================================</span></span><br><span class="line"><span class="comment">//上述为构建执行的准备步骤，接下来是构建的详细步骤，会涉及到获取maven插件（plugin）配置的获取以及插件goal的执行，直到每个插件执行自己的构建逻辑：</span></span><br><span class="line"><span class="comment">//1.每个插件的goal执行是基于某个生命周期运行的，这里是执行插件某个gaol的入口：org.apache.maven.lifecycle.internal.LifecycleStarter#execute(MavenSession)</span></span><br><span class="line"><span class="comment">//2.执行DefaultLifecycleTaskSegmentCalculator#calculateTaskSegments，获取配置插件对应的goal集合，如果找不到就会默认用MavenSession.getTopLevelProject().getDefaultGoal(),走默认maven构建（获得的构建任务放在TaskSegment里）</span></span><br><span class="line"><span class="comment">//3.根据2中得出的构建任务，计算得出构建对象集合，封装在ProjectBuildList里，实际上是做了一个映射，当前MavenSession的所有projects都必须执行TaskSegment集合里的任务</span></span><br><span class="line"><span class="comment">//4.获取执行参数里的builderId，分为两种，单例构建或多线程构建，默认是多线程，可以通过-T命令设置线程数量，然后通过指定构建器着手进行构建工作</span></span><br><span class="line"><span class="comment">//5.构建逻辑，单例构建遍历任务集合（TaskSegment）与构建对象集合ProjectBuildList逐一进行构建，多线程按照指定的线程数量作为上限进行并发构建</span></span><br><span class="line"><span class="comment">//6.一个项目（project）构建策略，计算得出当前项目的构建计划MavenExecutionPlan，统一Project中的PluginManagement与BuildPlugin（构建模块的版本），获得MojoExecution，</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProject</span><span class="params">( MavenSession session, MavenSession rootSession, ReactorContext reactorContext,</span></span></span><br><span class="line"><span class="params"><span class="function">                              MavenProject currentProject, TaskSegment taskSegment )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        session.setCurrentProject( currentProject );</span><br><span class="line">        <span class="keyword">long</span> buildStartTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// session may be different from rootSession seeded in DefaultMaven</span></span><br><span class="line">        <span class="comment">// explicitly seed the right session here to make sure it is used by Guice</span></span><br><span class="line">        sessionScope.enter( reactorContext.getSessionScopeMemento() );</span><br><span class="line">        sessionScope.seed( MavenSession.class, session );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( reactorContext.getReactorBuildStatus().isHaltedOrBlacklisted( currentProject ) ) &#123;</span><br><span class="line">                eventCatapult.fire( ExecutionEvent.Type.ProjectSkipped, session, <span class="keyword">null</span> );</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BuilderCommon.attachToThread( currentProject );</span><br><span class="line">            projectExecutionListener.beforeProjectExecution( <span class="keyword">new</span> ProjectExecutionEvent( session, currentProject ) );</span><br><span class="line">            eventCatapult.fire( ExecutionEvent.Type.ProjectStarted, session, <span class="keyword">null</span> );</span><br><span class="line">            <span class="comment">//获取构建执行计划</span></span><br><span class="line">            MavenExecutionPlan executionPlan =</span><br><span class="line">                builderCommon.resolveBuildPlan( session, currentProject, taskSegment, <span class="keyword">new</span> HashSet&lt;Artifact&gt;() );</span><br><span class="line">            <span class="comment">//通过执行计划得到执行器</span></span><br><span class="line">            List&lt;MojoExecution&gt; mojoExecutions = executionPlan.getMojoExecutions();</span><br><span class="line">            projectExecutionListener.beforeProjectLifecycleExecution( <span class="keyword">new</span> ProjectExecutionEvent( session,</span><br><span class="line">                                                                                                 currentProject,</span><br><span class="line">                                                                                                 mojoExecutions ) );</span><br><span class="line">            <span class="comment">//执行插件构建任务，其内部是循环执行mojoExecutions对应的执行器，</span></span><br><span class="line">            <span class="comment">//具体逻辑是通过MavenPluginManager拿到插件对应的Mojo接口实例</span></span><br><span class="line">            <span class="comment">//然后执行Mojo实例，由此执行扩展接口逻辑，得到插件提供的强大扩展能力</span></span><br><span class="line">            mojoExecutor.execute( session, mojoExecutions, reactorContext.getProjectIndex() );</span><br><span class="line">            <span class="keyword">long</span> buildEndTime = System.currentTimeMillis();</span><br><span class="line">            projectExecutionListener.afterProjectExecutionSuccess( <span class="keyword">new</span> ProjectExecutionEvent( session, currentProject,</span><br><span class="line">                                                                                              mojoExecutions ) );</span><br><span class="line">            reactorContext.getResult().addBuildSummary( <span class="keyword">new</span> BuildSuccess( currentProject,</span><br><span class="line">                                                                          buildEndTime - buildStartTime ) );</span><br><span class="line">            eventCatapult.fire( ExecutionEvent.Type.ProjectSucceeded, session, <span class="keyword">null</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Throwable t ) &#123;</span><br><span class="line">            builderCommon.handleBuildError( reactorContext, rootSession, session, currentProject, t, buildStartTime );</span><br><span class="line">            projectExecutionListener.afterProjectExecutionFailure( <span class="keyword">new</span> ProjectExecutionEvent( session, currentProject, t ) );</span><br><span class="line">            <span class="comment">// rethrow original errors and runtime exceptions</span></span><br><span class="line">            <span class="keyword">if</span> ( t <span class="keyword">instanceof</span> RuntimeException ) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( t <span class="keyword">instanceof</span> Error ) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            sessionScope.exit();</span><br><span class="line">            session.setCurrentProject( <span class="keyword">null</span> );</span><br><span class="line">            Thread.currentThread().setContextClassLoader( reactorContext.getOriginalContextClassLoader() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================执行Mojo简要说明=========================</span></span><br><span class="line">执行方法org.apache.maven.plugin.DefaultBuildPluginManager#executeMojo，调用Mojo（一个goal对应一个Mojo）能力，</span><br><span class="line">执行org.apache.maven.plugin.MavenPluginManager#getConfiguredMojo获得Mojo实例</span><br><span class="line">执行org.apache.maven.plugin.Mojo#execute执行扩展插件的实现，至此，构建脱离公共流程，</span><br><span class="line">进入插件构建运行阶段</span><br></pre></td></tr></table></figure><h2 id="Maven插件分析"><a href="#Maven插件分析" class="headerlink" title="Maven插件分析"></a>Maven插件分析</h2><h3 id="mvn-deploy-deploy-file-mven-deploy-plugin"><a href="#mvn-deploy-deploy-file-mven-deploy-plugin" class="headerlink" title="mvn deploy:deploy-file - mven-deploy-plugin"></a>mvn deploy:deploy-file - mven-deploy-plugin</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mojo( name = &quot;deploy-file&quot;, requiresProject = false, threadSafe = true )</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeployFileMojo</span> <span class="keyword">extends</span> <span class="title">AbstractDeployMojo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initProperties</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> MojoExecutionException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( pomFile != <span class="keyword">null</span> ) &#123;</span><br><span class="line">          processModel( readModel( pomFile ) );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> foundPom = <span class="keyword">false</span>;</span><br><span class="line">          JarFile jarFile = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span></span><br><span class="line">          &#123;</span><br><span class="line">              Pattern pomEntry = Pattern.compile( <span class="string">&quot;META-INF/maven/.*/pom\\.xml&quot;</span> );</span><br><span class="line">              jarFile = <span class="keyword">new</span> JarFile( file );</span><br><span class="line">              Enumeration&lt;JarEntry&gt; jarEntries = jarFile.entries();</span><br><span class="line"></span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> ( !foundPom ) &#123;</span><br><span class="line">                  getLog().info( <span class="string">&quot;pom.xml not found in &quot;</span> + file.getName() );</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 核心逻辑执行方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对pom文件的处理</span></span><br><span class="line">    initProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deploymentRepository</span></span><br><span class="line">    ArtifactRepository deploymentRepository = createDeploymentArtifactRepository( repositoryId, url );</span><br><span class="line">    <span class="comment">// deployableArtifacts</span></span><br><span class="line">    List&lt;Artifact&gt; deployableArtifacts = <span class="keyword">new</span> ArrayList&lt;Artifact&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// deploy</span></span><br><span class="line">        artifactDeployer.deploy( getSession().getProjectBuildingRequest(), deploymentRepository, deployableArtifacts );</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( ArtifactDeployerException e ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MojoExecutionException( e.getMessage(), e );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> DevOps </category>
          
          <category> 制品管理 </category>
          
          <category> Nexus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nexus-升级https过程</title>
      <link href="/posts/13516.html"/>
      <url>/posts/13516.html</url>
      
        <content type="html"><![CDATA[<ul><li>maven 3.8.1 版本之后，在 settings.xml 中通过配置 mirror 禁用了不安全的 http 链接，默认情况下必须使用 https 的仓库地址。</li></ul><p>10.200.17.45 测试机</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8093:8081  -u root --name=nexus-lcf --privileged=<span class="literal">true</span> -v /data/nexus-https-lcf:/nexus-data -e INSTALL4J_ADD_VM_PARAMS=<span class="string">&quot;-Xms256m -Xmx512m -XX:MaxDirectMemorySize=1024m&quot;</span> sonatype/nexus3:latest</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8443:8443 -p 8094:8081  -u root --name=nexus-lcf-https --privileged=<span class="literal">true</span> -v r/data/nexus-https-lcf:/nexus-data -e INSTALL4J_ADD_VM_PARAMS=<span class="string">&quot;-Xms256m -Xmx512m -XX:MaxDirectMemorySize=1024m&quot;</span> nexus-https:latest</span><br></pre></td></tr></table></figure><ul><li>-d</li><li>-u root –privileged=true</li><li>-p 8093:8081</li><li>–name=nexus-lcf</li><li>-v /data/nexus-https-lcf:/nexus-data</li><li>-e INSTALL4J_ADD_VM_PARAMS=”-Xms256m -Xmx512m -XX:MaxDirectMemorySize=1024m”</li></ul><p>10.163.204.79</p><h2 id="Nexus部署"><a href="#Nexus部署" class="headerlink" title="Nexus部署"></a>Nexus部署</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/sonatype/nexus3    // 拉取最新nexus镜像</span><br><span class="line">docker stop 7d6824229a9a &amp;&amp; docker rm 7d6824229a9a   // 停掉旧容器</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run -d        </span><br><span class="line"> -p 80:8081        </span><br><span class="line"> --name=nexus         </span><br><span class="line">--restart=always         </span><br><span class="line">--<span class="built_in">ulimit</span> nofile=655360         </span><br><span class="line">--<span class="built_in">ulimit</span> memlock=-1         </span><br><span class="line">--memory=16G         </span><br><span class="line">--memory-swap=-1         </span><br><span class="line">--cpuset-cpus=<span class="string">&#x27;0-7&#x27;</span>         </span><br><span class="line">-eINSTALL4J_ADD_VM_PARAMS=<span class="string">&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;</span>         </span><br><span class="line">-v /etc/localtime:/etc/localtime         </span><br><span class="line">-v /data/nexus:/nexus-data         </span><br><span class="line">sonatype/nexus3:latest</span><br></pre></td></tr></table></figure><h2 id="升级https"><a href="#升级https" class="headerlink" title="升级https"></a>升级https</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv _.haier.net.* ~/</span><br><span class="line"></span><br><span class="line">// 这里需要输入密码  用password，如果不用这个，需要修改镜像里的<span class="variable">$&#123;jetty.etc&#125;</span>/jetty-https.xml，具体操作参考百度。</span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -out keystore.pkcs12 -inkey _.haier.net.key -<span class="keyword">in</span> _.haier.net.crt</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> sonatype/nexus3</span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> keystore.pkcs12 /keystore.pkcs12</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> keytool -v -importkeystore -srckeystore keystore.pkcs12 -srcstoretype PKCS12 -destkeystore keystore.jks -deststoretype JKS -storepass password -srcstorepass password  &amp;&amp;\</span></span><br><span class="line"><span class="bash">    cp keystore.jks /opt/sonatype/nexus/etc/ssl/</span></span><br><span class="line"><span class="keyword">USER</span> nexus</span><br></pre></td></tr></table></figure><p>基于此nexus镜像<code>docker.io/sonatype/nexus3 b7c023b6a9b9 655 MB</code></p><h3 id="在最新的nexus镜像的基础上构建，找不到keystore-pkcs12"><a href="#在最新的nexus镜像的基础上构建，找不到keystore-pkcs12" class="headerlink" title="在最新的nexus镜像的基础上构建，找不到keystore.pkcs12"></a>在最新的nexus镜像的基础上构建，找不到keystore.pkcs12</h3><p>8da03e408fae<br><img src="/posts/13516/nexus-keytool-error.jpg"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t nexus-https -f jdk_dockerfile</span><br><span class="line">docker build . -t nexus-https-2022 -f jdk_dockerfile</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d         -p 80:8081         --name=nexus         --restart=always         --<span class="built_in">ulimit</span> nofile=655360         --<span class="built_in">ulimit</span> memlock=-1         --memory=16G     --memory-swap=-1         --cpuset-cpus=<span class="string">&#x27;0-7&#x27;</span>         -eINSTALL4J_ADD_VM_PARAMS=<span class="string">&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;</span>         -v /etc/localtime:/etc/localtime         -v /data/nexus:/nexus-data         sonatype/nexus3:latest</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d         -p 80:8081     -p 443:8443    --name=nexus         --restart=always         --<span class="built_in">ulimit</span> nofile=655360         --<span class="built_in">ulimit</span> memlock=-1         --memory=16G         --memory-swap=-1         --cpuset-cpus=<span class="string">&#x27;0-7&#x27;</span>         -eINSTALL4J_ADD_VM_PARAMS=<span class="string">&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;</span>         -v /etc/localtime:/etc/localtime         -v /data/nexus:/nexus-data         nexus-https:latest</span><br><span class="line"></span><br><span class="line">docker run -d         -p 80:8081     -p 443:8443    --name=nexus         --restart=always         --<span class="built_in">ulimit</span> nofile=655360         --<span class="built_in">ulimit</span> memlock=-1         --memory=16G         --memory-swap=-1         --cpuset-cpus=<span class="string">&#x27;0-7&#x27;</span>         -eINSTALL4J_ADD_VM_PARAMS=<span class="string">&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;</span>         -v /etc/localtime:/etc/localtime         -v /data/nexus:/nexus-data         nexus-https-2022:latest</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Jetty section</span><br><span class="line">application-port-ssl=8443</span><br><span class="line">application-port=8081</span><br><span class="line">application-host=0.0.0.0</span><br><span class="line">nexus-args=$&#123;jetty.etc&#125;/jetty.xml,$&#123;jetty.etc&#125;/jetty-http.xml,$&#123;jetty.etc&#125;/jetty-requestlog.xml,$&#123;jetty.etc&#125;/jetty-https.xml</span><br><span class="line">nexus-context-path=/$&#123;NEXUS_CONTEXT&#125;</span><br><span class="line"></span><br><span class="line">#Nexus section</span><br><span class="line">nexus-edition=nexus-pro-edition</span><br><span class="line">nexus-features=\</span><br><span class="line"> nexus-pro-feature</span><br><span class="line">nexus.clustered=false</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker run -d        </span><br><span class="line"> -p 80:8081        </span><br><span class="line"> -p 443:8443</span><br><span class="line"> --name=nexus         </span><br><span class="line">--restart=always         </span><br><span class="line">--<span class="built_in">ulimit</span> nofile=655360         </span><br><span class="line">--<span class="built_in">ulimit</span> memlock=-1         </span><br><span class="line">--memory=16G         </span><br><span class="line">--memory-swap=-1         </span><br><span class="line">--cpuset-cpus=<span class="string">&#x27;0-7&#x27;</span>         </span><br><span class="line">-e INSTALL4J_ADD_VM_PARAMS=<span class="string">&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;</span>         </span><br><span class="line">-v /etc/localtime:/etc/localtime         </span><br><span class="line">-v /data/nexus:/nexus-data         </span><br><span class="line">nexus-https:latest</span><br><span class="line"></span><br><span class="line">docker参数</span><br><span class="line">–name 指定docker容器的名称</span><br><span class="line">–net=host 使用host网络模式（和宿主机一个网络）</span><br><span class="line">–restart always docker 异常退出后自动重启</span><br><span class="line">–volume / -v 挂载本地目录，格式 /src:/dst</span><br><span class="line">-e 指定docker启动后环境变量（env）</span><br><span class="line">–privileged 让docker可以拥有root权限</span><br><span class="line">–<span class="built_in">ulimit</span> nofile 系统文件句柄打开数量限制</span><br><span class="line">–<span class="built_in">ulimit</span> memlock 最大锁定内存地址空间，-1表示不限制</span><br><span class="line">–memory 限制docker内存</span><br><span class="line">–memory-swap 限制docker虚拟内存，-1 为不限制，共用宿主机swap</span><br><span class="line">–cpuset-cpus 指定docker绑定的CPU</span><br><span class="line">TERM=dumb 让docker里面可以执行top命令</span><br></pre></td></tr></table></figure><h3 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h3><p>nexus挂载目录/data<br><img src="/posts/13516/df-Th.jpg"><br><img src="/posts/13516/xfs_growfs.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> DevOps </category>
          
          <category> 制品管理 </category>
          
          <category> Nexus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nexus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID</title>
      <link href="/posts/59917.html"/>
      <url>/posts/59917.html</url>
      
        <content type="html"><![CDATA[<h3 id="雪花算法-snowflake"><a href="#雪花算法-snowflake" class="headerlink" title="雪花算法 snowflake"></a>雪花算法 snowflake</h3><p>twitter开源的分布式id生成算法。<br>把一个64位的long型的id，1个bit是不用的，用其中的41 bit作为毫秒数，用10 bit作为工作机器id，12 bit作为序列号。<br>理论上最多支持1024台机器每秒生成4096000个序列号。</p><p><img src="/posts/59917/snowflake.jpeg"></p><ul><li>1 bit：固定值0<br>  因为二进制里第一个bit为如果是1，那么都是负数，但是我们生成的id都是正数，所以第一个bit统一都是0</li><li>41 bit：表示的是时间戳，单位是ms<br>  41 bit可以表示的数字多达2^41 - 1，也就是可以标识2 ^ 41 - 1个毫秒值，换算成年就是表示69年的时间</li><li>10 bit：记录工作机器id<br>  代表的是这个服务最多可以部署在2^10台机器上面，也就是1024台机器。<br>  但是10 bit里<strong>5个bit代表机房id</strong>，<strong>5个bit代表机器id</strong>，意思就是最多代表2 ^ 5个机房(32个机房)，每个机房里可以代表2 ^ 5个机器(32台机器)。</li><li>12 bit：记录同一个毫秒内产生的不同id<br>  12 bit可以代表的最大正整数是2 ^ 12 - 1 = 4096，也就是说可以用这个12bit代表的数字来区分同一个毫秒内的4096个不同的id</li></ul><p>缺点：</p><ul><li>依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成</li></ul><p>优点：</p><ul><li>高并发分布式环境下生成不重复 id，每秒可生成百万个不重复 id。</li><li>基于时间戳，以及同一时间戳下序列号自增，基本保证 id 有序递增。</li><li>不依赖第三方库或者中间件。</li><li>算法简单，在内存中进行，效率高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 架构 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/posts/18358.html"/>
      <url>/posts/18358.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h2><ul><li>线程锁</li><li>进程锁</li><li>分布式锁</li></ul><h2 id="分布式锁的设计原则"><a href="#分布式锁的设计原则" class="headerlink" title="分布式锁的设计原则"></a>分布式锁的设计原则</h2><h2 id="分布式锁的实现方案"><a href="#分布式锁的实现方案" class="headerlink" title="分布式锁的实现方案"></a>分布式锁的实现方案</h2><ul><li>基于<strong>数据库</strong></li><li>基于<strong>Redis</strong><ul><li><strong>单个Redis实例：set NX PX + Lua</strong></li><li><strong>Redis集群：RedLock</strong></li></ul></li><li>基于<strong>zookeeper</strong></li><li>基于<strong>Consul</strong></li></ul><h2 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h2><h3 id="单个Redis实例-set-NX-PX-Lua"><a href="#单个Redis实例-set-NX-PX-Lua" class="headerlink" title="单个Redis实例 - set NX PX + Lua"></a>单个Redis实例 - set NX PX + Lua</h3><ul><li>加锁 set NX PX + 重试 + 重试间隔</li><li>解锁 采用lua脚本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDistributedLock</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 锁的过期时间，单位毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> LOCK_EXPIRE_TIME = <span class="number">30000</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 释放锁的 Lua 脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNLOCK_SCRIPT =</span><br><span class="line">            <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return true; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;else return false; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取分布式锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁不用lua表达式</span></span><br><span class="line">        Boolean result = redisTemplate.opsForValue().setIfAbsent(key, value, expireTime, TimeUnit.SECONDS);</span><br><span class="line">        Boolean result = redisTemplate.execute(script, Arrays.asList(keys), args);</span><br><span class="line">        <span class="keyword">return</span> result != <span class="keyword">null</span> &amp;&amp; result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 释放分布式锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        String[] keys = &#123;key&#125;;</span><br><span class="line">        String[] args = &#123;value&#125;;</span><br><span class="line">        RedisScript&lt;Boolean&gt; script = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(UNLOCK_SCRIPT, Boolean.class);</span><br><span class="line">        Boolean result = redisTemplate.execute(script, Arrays.asList(keys), args);</span><br><span class="line">        <span class="keyword">return</span> result != <span class="keyword">null</span> &amp;&amp; result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么建议用lua脚本来解锁，而不是直接RedisTemplate.detele(key)</strong><br>当多个线程同时争抢同一个 Redis 锁时，如果这些线程都是通过使用 RedisTemplate 的 delete() 方法来释放锁的话，可能会出现以下情况：</p><ol><li>线程 A 成功获取了锁，并设置了一个过期时间；</li><li>过了一段时间后，锁的过期时间到了，Redis 自动将锁删除；</li><li>同时，线程 B 也在尝试获取锁，由于此时锁已经被 Redis 删除了，线程 B 成功获取了锁；</li><li>线程 A 在这个时候调用了 RedisTemplate 的 delete() 方法来释放锁，由于此时 Redis 中已经不存在该锁了，所以线程 A 的操作实际上是删除了线程 B 获取到的锁，从而导致线程 B 的锁失效。</li></ol><p>因此，使用 RedisTemplate 的 delete() 方法来释放锁的方式可能存在删除其他线程获取的锁的风险。为了避免这种情况的发生，可以使用 Redis 的 Lua 脚本，在 Redis 中执行删除操作，确保只删除对应值的 key-value 对，避免误删其他线程的锁。</p><h3 id="Redis集群-RedLock"><a href="#Redis集群-RedLock" class="headerlink" title="Redis集群 - RedLock"></a>Redis集群 - RedLock</h3><p>假设有两个服务A、B都希望获得锁，有一个包含了5个redis master的Redis Cluster，执行过程大致如下：</p><ol><li>客户端获取当前时间戳，单位: 毫秒</li><li>服务A轮寻每个master节点，尝试创建锁。(这里锁的过期时间比较短，一般就几十毫秒) RedLock算法会尝试在大多数节点上分别创建锁，假如节点总数为n，那么大多数节点指的是n/2+1。</li><li>客户端计算成功建立完锁的时间，如果建锁时间小于超时时间，就可以判定锁创建成功。如果锁创建失败，则依次(遍历master节点)删除锁。</li><li>只要有其它服务创建过分布式锁，那么当前服务就必须轮询尝试获取锁。</li></ol><h3 id="Redis的客户端-Redisson"><a href="#Redis的客户端-Redisson" class="headerlink" title="Redis的客户端 Redisson"></a>Redis的客户端 Redisson</h3><p>Redis的客户端（Jedis, Redisson, Lettuce等）都是基于上述两类形式来实现分布式锁的，只是两类形式的封装以及一些优化（比如Redisson的watch dog）。</p><p>以基于<strong>Redisson</strong>实现分布式锁为例（支持了 单实例、Redis哨兵、redis cluster、redis master-slave等各种部署架构）：</p><ul><li>特色<ul><li>redisson所有指令都通过lua脚本执行，保证了操作的原子性</li><li>redisson设置了watchdog看门狗，“看门狗”的逻辑保证了没有死锁发生</li><li>redisson支持Redlock的实现方式。</li></ul></li><li>过程<ol><li>线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。</li><li>线程去获取锁，获取失败: 订阅了解锁消息，然后再尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。</li></ol></li><li>互斥<br>  如果这个时候客户端B来尝试加锁，执行了同样的一段lua脚本。第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在。<br>  接着第二个if判断，判断myLock锁key的hash数据结构中，是否包含客户端B的ID，但明显没有，那么客户端B会获取到pttl myLock返回的一个数字，代表myLock这个锁key的剩余生存时间。<br>  <strong>此时客户端B会进入一个while循环，不停的尝试加锁</strong>。</li><li>watch dog自动延时机制<br>  客户端A加锁的锁key默认生存时间只有30秒，如果超过了30秒，客户端A还想一直持有这把锁，怎么办？其实只要客户端A一旦加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果客户端A还持有锁key，那么就会不断的延长锁key的生存时间。</li><li>可重入<br>  每次lock会调用incrby，每次unlock会减一。</li></ul><h3 id="进一步理解"><a href="#进一步理解" class="headerlink" title="进一步理解"></a>进一步理解</h3><ol><li>借助Redis实现分布式锁时，有一个共同的缺陷: 当获取锁被拒绝后，需要不断的循环，重新发送获取锁(创建key)的请求，直到请求成功。这就造成空转，浪费宝贵的CPU资源。</li><li>RedLock算法本身有争议，具体看这篇文章<a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking</a> 以及作者的回复<a href="http://antirez.com/news/101">Is Redlock safe?</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 架构 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/posts/64143.html"/>
      <url>/posts/64143.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 架构 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/posts/9355.html"/>
      <url>/posts/9355.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h3><p>轻量级的Web服务器、反向代理服务器。</p><h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><ul><li><p>正向代理<br><img src="/posts/9355/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.jpeg"><br>由于防火墙的原因，我们不能直接访问谷歌，可以借助VPN来实现，这是简单的正向代理的例子。<br>正向代理“代理”的是客户端，而且客户端是知道目标的，但是目标不知道客户端是通过VPN访问的。</p></li><li><p>反向代理<br><img src="/posts/9355/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.jpeg"><br>当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。</p></li></ul><h3 id="Nginx的Master-Worker模式"><a href="#Nginx的Master-Worker模式" class="headerlink" title="Nginx的Master-Worker模式"></a>Nginx的Master-Worker模式</h3><p><img src="/posts/9355/Nginx%E8%BF%9B%E7%A8%8B.jpeg"><br>启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</p><h4 id="Master进程"><a href="#Master进程" class="headerlink" title="Master进程"></a>Master进程</h4><ul><li>读取并验证配置文件nginx.conf</li><li>管理Worker进程</li></ul><h4 id="Worker进程"><a href="#Worker进程" class="headerlink" title="Worker进程"></a>Worker进程</h4><p>每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求。Worker进程的个数由配置文件决定，一般和CPU个数有关（利于进程切换）。</p><h3 id="Nginx如何做到热部署"><a href="#Nginx如何做到热部署" class="headerlink" title="Nginx如何做到热部署"></a>Nginx如何做到热部署</h3><h3 id="Nginx如何做到高并发下的高效处理"><a href="#Nginx如何做到高并发下的高效处理" class="headerlink" title="Nginx如何做到高并发下的高效处理"></a>Nginx如何做到高并发下的高效处理</h3><p>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。Worker进程只需要从epoll队列循环处理即可。</p><h4 id="epoll模型是什么"><a href="#epoll模型是什么" class="headerlink" title="epoll模型是什么"></a>epoll模型是什么</h4><h3 id="Nginx挂了怎么办"><a href="#Nginx挂了怎么办" class="headerlink" title="Nginx挂了怎么办"></a>Nginx挂了怎么办</h3><p>Keepalived+Nginx实现高可用。<br>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）<br>Keepalived+Nginx实现高可用的思路：</p><ol><li>请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</li><li>Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）<br><img src="/posts/9355/Keepalived+Nginx.jpeg"></li></ol><h3 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h3><h4 id="虚拟主机-server"><a href="#虚拟主机-server" class="headerlink" title="虚拟主机 server"></a>虚拟主机 server</h4><p><img src="/posts/9355/conf-server.jpeg"></p><h4 id="反向代理-proxy-pass"><a href="#反向代理-proxy-pass" class="headerlink" title="反向代理 proxy_pass"></a>反向代理 proxy_pass</h4><p>在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。</p><p>反向代理的过程是透明的，比如说request -&gt; Nginx -&gt; Tomcat，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER。</p><h4 id="负载均衡-upstream"><a href="#负载均衡-upstream" class="headerlink" title="负载均衡 upstream"></a>负载均衡 upstream</h4><p>上面的反向代理中，我们通过proxy_pass来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？</p><ol><li>通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</li><li>将proxy_pass替换成upstream指定的值即可。</li></ol><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存，是Nginx提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。</p><ol><li>定义缓存存储目录并指定共享内存空间</li><li>在location里指定共享内存空间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">user www;</span><br><span class="line">worker_processes auto;</span><br><span class="line">events &#123;</span><br><span class="line">worker_connections 4096;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">include mime.types;</span><br><span class="line">default_type application/octet-stream;</span><br><span class="line">sendfile on;</span><br><span class="line">gzip on;</span><br><span class="line">keepalive_timeout 65;</span><br><span class="line"></span><br><span class="line"># 以下是缓存相关配置</span><br><span class="line">proxy_cache_path /data/nginx/cache2 levels=1:2 keys_zone=mycache:1024m max_size=2048m inactive=1d ;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name localhost;</span><br><span class="line">#charset koi8-r;</span><br><span class="line">#access_log logs/host.access.log main;</span><br><span class="line">location /apis/test/img &#123;</span><br><span class="line">proxy_pass http://192.168.1.2/;</span><br><span class="line"></span><br><span class="line"># 以下三行是缓存相关配置</span><br><span class="line">proxy_cache mycache;</span><br><span class="line">proxy_cache_valid 200 1d;</span><br><span class="line">proxy_cache_use_stale error timeout invalid_header updating http_500 http_503 http_404;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 500 502 503 504 /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>proxy_cache_path:定义缓存目录，需要手动创建此目录；缓存数据存放至此。</li><li>/data/nginx/cache2：自定义的缓存目录，缓存中的文件名称是应用MD5的结果；另外，首先是将缓存响应写入临时文件，然后文件才被重命名；</li><li>levels=1:2：定义缓存的层次结构级别；这里表示缓存目录的第一级目录是1个字符，第二级目录是2个字符；</li><li>keys_zone=mycache:1024m：内核中建立的用于缓存数据原数据的共享内存空间；这里存放缓存数据的原数据；查找缓存的时候，先从这个内核空间中找到，缓存数据的原数据，然后再到对应目录中查找缓存；我这里定义的zone名称为‘mycache’;</li><li>max_size=2048m：设置缓存空间的最大值；</li><li>inactive=1d: 设置缓存的数据保留时间，这里自定义1天内没有被访问过就删除；</li><li>proxy_cache：在location里设置内存缓存源数据空间名字，对应我们前面的设定’mycache’;</li><li>proxy_cache_valid: 可以为不同的响应状态码设置不同的缓存时间，比如这里200状态码，设置为1天；</li><li>proxy_cache_use_stale：指定后端服务器出现状况时，nginx可以使用的过期缓存</li><li>另外可以设置proxy_cache_key：用来指定缓存所使用的key的组合字符串，然后用md5进行加密。如不指定默认使用：$scheme$proxy_host$request_uri;</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式缓存</title>
      <link href="/posts/35802.html"/>
      <url>/posts/35802.html</url>
      
        <content type="html"><![CDATA[<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><h3 id="客户端缓存-浏览器缓存"><a href="#客户端缓存-浏览器缓存" class="headerlink" title="客户端缓存/浏览器缓存"></a>客户端缓存/浏览器缓存</h3><p>对于B/S架构的互联网应用来说客户端缓存主要分为页面缓存和浏览器缓存两种，对于APP而言主要是自身所使用的缓存。</p><p>客户端Client/Server是建立在局域网的基础上的。浏览器Browser/Server是建立在广域网的基础上的。</p><h3 id="网络中缓存"><a href="#网络中缓存" class="headerlink" title="网络中缓存"></a>网络中缓存</h3><ul><li>CDN缓存</li><li>代理服务器缓存</li></ul><h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><ul><li>本地缓存</li><li>分布式缓存，Redis、Memcached、MongoDB等NoSql</li><li>数据库缓存</li></ul><h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><h3 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h3><p><code>Content Delivery Network</code>，内容分发网络，是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。</p><p>CDN是将源站内容（image、html、js、css等）分发至全国所有的节点，从而缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性的技术。它能够有效解决网络带宽小、用户访问量大、网点分布不均等问题。</p><h2 id="代理服务器缓存"><a href="#代理服务器缓存" class="headerlink" title="代理服务器缓存"></a>代理服务器缓存</h2><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>Proxy Server，其功能就是代理网络用户去取得网络信息。<br>形象的说：它是网络信息的中转站。在一般情况下，我们使用网络浏览器直接去连接其他Internet站点取得网络信息时，须送出Request信号来得到回答，然后对方再把信息以bit方式传送回来。代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。</p><h4 id="代理功能"><a href="#代理功能" class="headerlink" title="代理功能"></a>代理功能</h4><ol><li>突破自身IP访问限制，访问国外站点。教育网、169网等网络用户可以通过代理访问国外网站。</li><li>访问一些单位或团体内部资源。如某大学FTP(前提是该代理地址在该资源 的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</li><li>突破中国电信的IP封锁。中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国外的代理服务器试试。</li><li>提高访问速度。通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li><li>隐藏真实IP。上网者也可以通过这种方法隐藏自己的IP，免受攻击。</li></ol><h2 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h2><ol><li>定义缓存存储目录并指定共享内存空间</li><li>在location里指定共享内存空间</li></ol><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>即内存，本地缓存是一级缓存，位于服务本机的内存中，读写速度快，缺点是不能持久化，一旦项目关闭，数据就会丢失，而且不能满足分布式系统的应用场景(比如数据不一致的问题)。<br>存在的问题：</p><ol><li>本读缓存数据直接保存在JVM中，需要考虑缓存数据的大小、JVM的垃圾回收性能消耗</li><li>单服务是集群部署的时候，应该考虑是否需要做集群中本地缓存的数据同步</li><li>无法进行持久化</li><li>无法保证多实例数据一致性</li></ol><h3 id="EhCache"><a href="#EhCache" class="headerlink" title="EhCache"></a>EhCache</h3><h3 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h3><h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>利用缓存数据库，最常见的就是Redis。Redis的访问速度同样很快，可以设置过期时间、设置持久化方法，缺点是会受到网络和并发访问的影响。</p><h3 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h3><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>Jedis 是直连模式，在多个线程间共享一个 Jedis 实例是线程不安全的，每个线程都去拿自己的 Jedis 实例，当连接数量增多时，物理连接成本就较高了。</p><p>底层使用阻塞的I/O，且其方法调用都是同步的，程序流需要等到sockets处理完I/O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。</p><h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p>相比较Jedis，Lettuce基于优秀Netty NIO框架构建，支持Redis的高级功能，如Sentinel，集群，流水线，自动重新连接和Redis数据模型，线程安全，适用于分布式缓存。</p><p>如果需要集群、读写分离、异步等特性支持需要使用Lettuce客户端。</p><h4 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h4><p>让使用者对Redis的关注分离，提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列，也是基于Netty框架的事件驱动的通信层。</p><h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><p>Spring Data Redis是Spring大家族的一部分，提供了在Srping应用中通过简单的配置访问Redis服务，对Reids底层开发包(Jedis, JRedis, RJC)进行了高度封装，RedisTemplate提供了Redis各种操作、异常处理及序列化，支持发布订阅。</p><h2 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h2><h2 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="FIFO-先进先出"><a href="#FIFO-先进先出" class="headerlink" title="FIFO 先进先出"></a>FIFO 先进先出</h4><h4 id="LRU-Least-Recently-Used"><a href="#LRU-Least-Recently-Used" class="headerlink" title="LRU(Least Recently Used)"></a>LRU(Least Recently Used)</h4><p>最近最少使用。淘汰最长时间没有被使用的，以时间作为参考。</p><h4 id="LFU-Least-Frequently-Used"><a href="#LFU-Least-Frequently-Used" class="headerlink" title="LFU(Least Frequently Used)"></a>LFU(Least Frequently Used)</h4><p>最不经常使用。淘汰一段时间内，使用次数最少的，以次数作为参考。</p><h3 id="Redis缓存淘汰策略"><a href="#Redis缓存淘汰策略" class="headerlink" title="Redis缓存淘汰策略"></a>Redis缓存淘汰策略</h3><ol><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li><li>volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。</li><li>allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。</li><li>no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。</li></ol><p>总体上分为4种：</p><ul><li>lru</li><li>lfu</li><li>random</li><li>ttl</li></ul><h2 id="缓存、数据库-最终-一致性"><a href="#缓存、数据库-最终-一致性" class="headerlink" title="缓存、数据库(最终)一致性"></a>缓存、数据库(最终)一致性</h2><p>主要有两种情况，会导致缓存和DB的一致性问题：</p><ol><li>并发的场景下，导致读取老的DB数据，更新到缓存中</li><li>缓存和DB的操作，不在一个事务中，可能只有一个操作成功，而另一个操作失败，导致不一致</li><li>数据库主从结构，主从同步不及时带来的缓存、数据库数据不一致<h3 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h3>数据更新前后双删除缓存策略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line"></span><br><span class="line">redis.del(key);</span><br><span class="line"></span><br><span class="line">db.update(data);</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">redis.del(key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>先淘汰缓存</li><li>写数据库</li><li>休眠1秒，再次淘汰缓存。高并发情况下确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<h4 id="延迟双删-同步删除，吞吐量降低如何处理"><a href="#延迟双删-同步删除，吞吐量降低如何处理" class="headerlink" title="延迟双删 - 同步删除，吞吐量降低如何处理"></a>延迟双删 - 同步删除，吞吐量降低如何处理</h4>将第二次删除作为异步的，提交一个延迟的执行任务<h4 id="延迟双删-解决删除失败的方式"><a href="#延迟双删-解决删除失败的方式" class="headerlink" title="延迟双删 - 解决删除失败的方式"></a>延迟双删 - 解决删除失败的方式</h4>添加重试机制，例如：将删除失败的key，写入消息队列；但对业务耦合有些严重；</li></ol><h2 id="一二级缓存一致性"><a href="#一二级缓存一致性" class="headerlink" title="一二级缓存一致性"></a>一二级缓存一致性</h2><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p><p>这就是缓存雪崩。<br><img src="/posts/35802/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li><li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。<br><img src="/posts/35802/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3><p>对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。<br>黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。<br>举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。<br><img src="/posts/35802/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png"></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>缓存空值，并设置过期时间。</p><p>每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p><h2 id="热数据"><a href="#热数据" class="headerlink" title="热数据"></a>热数据</h2><h2 id="数据并发竞争"><a href="#数据并发竞争" class="headerlink" title="数据并发竞争"></a>数据并发竞争</h2><h3 id="redis的并发竞争问题是什么"><a href="#redis的并发竞争问题是什么" class="headerlink" title="redis的并发竞争问题是什么"></a>redis的并发竞争问题是什么</h3><p>多客户端同时并发写一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>某个时刻，多个系统实例都去更新某个 key。可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。</p><h3 id="redis事务的CAS方案"><a href="#redis事务的CAS方案" class="headerlink" title="redis事务的CAS方案"></a>redis事务的CAS方案</h3><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><h2 id="缓存的数据结构"><a href="#缓存的数据结构" class="headerlink" title="缓存的数据结构"></a>缓存的数据结构</h2><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 架构 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础 - Q&amp;A</title>
      <link href="/posts/37896.html"/>
      <url>/posts/37896.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h3><p>封装、继承、多态</p><h3 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h3><p><img src="/posts/37896/JDK-JRE-JVM.png"></p><h3 id="Http请求、Tomcat线程、Java线程"><a href="#Http请求、Tomcat线程、Java线程" class="headerlink" title="Http请求、Tomcat线程、Java线程"></a>Http请求、Tomcat线程、Java线程</h3><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><table><thead><tr><th align="left">数据类型</th><th align="left">名称</th><th align="left">大小(B) 注：1B = 8b</th><th align="left">包装器</th></tr></thead><tbody><tr><td align="left">byte</td><td align="left">字节型</td><td align="left">1</td><td align="left">Byte</td></tr><tr><td align="left">short</td><td align="left">字符型</td><td align="left">2</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">短整型</td><td align="left">4</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">整形</td><td align="left">8</td><td align="left">Long</td></tr><tr><td align="left">float</td><td align="left">单精度浮点型</td><td align="left">4</td><td align="left">Float</td></tr><tr><td align="left">double</td><td align="left">双精度浮点型</td><td align="left">8</td><td align="left">Double</td></tr><tr><td align="left">char</td><td align="left">字符型</td><td align="left">2</td><td align="left">Character</td></tr><tr><td align="left">boolean</td><td align="left">布尔</td><td align="left">不同情况下不同</td><td align="left">Boolean</td></tr></tbody></table><p><strong>Q：为什么char类型是2个字节？</strong></p><h3 id="重载（Overload）和重写（Override）的区别？"><a href="#重载（Overload）和重写（Override）的区别？" class="headerlink" title="重载（Overload）和重写（Override）的区别？"></a>重载（Overload）和重写（Override）的区别？</h3><p>方法的重载和重写都是实现多态的方式，区别在于重载实现的事编译时的多态性，重写实现的是运行时的多态性。<br>重载发生在一个类中，同名方法的参数列表（参数类型、参数个数、参数顺序）不同，与返回值类型无关。<br>重写发生在子类与父类之间，要求方法名、参数列表、返回类型必须相同，访问修饰符的限制要大于被重写方法，不能抛出比被重写方法更宽泛的异常。</p><h3 id="String-和-StringBuffer、StringBuilder-的区别？"><a href="#String-和-StringBuffer、StringBuilder-的区别？" class="headerlink" title="String 和 StringBuffer、StringBuilder 的区别？"></a>String 和 StringBuffer、StringBuilder 的区别？</h3><p>java.lang.String/StringBuffer/StringBuilder，三者的共同之处都是final类，不允许被继承。</p><ul><li>String <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>,</span></span><br><span class="line"><span class="class">            <span class="title">Constable</span>, <span class="title">ConstantDesc</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>StringBuilder<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">StringBuilder</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>StringBuffer<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">StringBuffer</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment">     * whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String toStringCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  StringBuffer中的许多方法是用<code>synchronized</code>关键字修饰的。</li><li>AbstractStringBuilder<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The id of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span> coder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String-为什么是不可变的？"><a href="#String-为什么是不可变的？" class="headerlink" title="String 为什么是不可变的？"></a>String 为什么是不可变的？</h4><p>不可变的对象：一个对象在它创建完成之后，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><p>String 用 <code>value[]</code> 来保存字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><p><code>value[]</code>是final修饰的，不能再指向其他数组对象，但是可以通过反射，反射出String对象的value属性，进而通过获得的value引用改变数组的结构。</p><h4 id="String是线程安全的吗？"><a href="#String是线程安全的吗？" class="headerlink" title="String是线程安全的吗？"></a>String是线程安全的吗？</h4><p>是。<br>String是不可变的，多线程操作同一个String变量时，修改String的值只会改变当前String变量的引用，各线程之间该String的引用会不同，但value值不会造成数据污染、覆盖。</p><h4 id="string-“”-和-new-String的区别"><a href="#string-“”-和-new-String的区别" class="headerlink" title="string = “” 和 new String的区别"></a>string = “” 和 new String的区别</h4><ol><li><p>String str1 = “abc”</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">System.out.println(str1 == <span class="string">&quot;abc&quot;</span>); </span><br></pre></td></tr></table></figure><p> 栈中开辟一块空间存放引用str1；<br> String池中开辟一块空间，存放String常量”abc”；<br> 引用str1指向池中String常量”abc”；<br> str1所指代的地址即常量”abc”所在地址，输出为true；</p></li><li><p>String str2 = new String(“abc”);</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); </span><br><span class="line">System.out.println(str2 == <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p> 栈中开辟一块空间存放引用str2；<br> 堆中开辟一块空间存放一个新建的String对象”abc”；<br> 引用str2指向堆中的新建的String对象”abc”；<br> str2所指代的对象地址为堆中地址，而常量”abc”地址在池中，输出为false；</p><p> String s = new String(“xyz”); 产生几个对象？<br> 一个或两个。如果常量池中原来没有 ”xyz”, 就是两个。如果原来的常量池中存在“xyz”时，就是一个。</p></li><li><p>final String str1 = “a”</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (3)</span></span><br><span class="line">String str1 = <span class="string">&quot;a&quot;</span>；</span><br><span class="line">String str2 = <span class="string">&quot;b&quot;</span>；</span><br><span class="line">String str3 = str1 + <span class="string">&quot;b&quot;</span>；</span><br><span class="line"><span class="comment">//str1 和 str2 是字符串常量，所以在编译期就确定了。</span></span><br><span class="line"><span class="comment">//str3 中有个 str1 是引用，所以不会在编译期确定。</span></span><br><span class="line"><span class="comment">//又因为String是 final 类型的，所以在 str1 + &quot;b&quot; 的时候实际上是创建了一个新的对象，在把新对象的引用传给str3。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）</span></span><br><span class="line"><span class="keyword">final</span> String str1 = <span class="string">&quot;a&quot;</span>；</span><br><span class="line">String str2 = <span class="string">&quot;b&quot;</span>；</span><br><span class="line">String str3 = str1 + <span class="string">&quot;b&quot;</span>；</span><br><span class="line"><span class="comment">//这里和(3)的不同就是给 str1 加上了一个final，这样str1就变成了一个常量。</span></span><br><span class="line"><span class="comment">//这样 str3 就可以在编译期中就确定了</span></span><br></pre></td></tr></table></figure></li><li><p>intern()<br> intern()方法：当调用 intern 方法时，如果常量池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回常量池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;ab&quot;</span>；</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">System.out.println(str1== str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2.intern() == str1);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1== str2);<span class="comment">//false</span></span><br><span class="line">str2 = str2.intern();</span><br><span class="line">System.out.println(str1== str2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p> str1 指向的是常量池对象 “ab”；<br> str2 指向的是堆中的对象 “ab”；<br> 调用了 str2 = str2.intern() 后，str2.intern()判断常量池中是否有 “ab”对象，如果有就返回，没有就创建并返回，此时就返回的 str1 所指向的那个对象 “ab” 。</p></li></ol><h3 id="final、finalize、finally"><a href="#final、finalize、finally" class="headerlink" title="final、finalize、finally"></a>final、finalize、finally</h3><ul><li>final是一个修饰符，可以修饰变量、方法和类</li><li>Java技术允许使用<code>finalize</code>方法在垃圾收集器将对象从内存中清楚出去之间做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用没有保证。</li><li>finally是一个关键字，与try、catch一起用于异常的处理。finally块一定会被执行，无论在try块中是否发生异常。</li></ul><h3 id="接口与抽象类的区别？"><a href="#接口与抽象类的区别？" class="headerlink" title="接口与抽象类的区别？"></a>接口与抽象类的区别？</h3><ul><li>一个子类只能继承一个抽象类，但能实现多个接口</li><li>抽象类可以有构造方法，接口没有构造方法</li><li>抽象类可以有普通成员变量，接口没有普通成员变量</li><li>抽象类和接口都可以有静态成员变量。抽象类中静态成员变量访问类型任意，接口只能<code>public stativ final</code></li><li>抽象类可以没有抽象方法，抽象类可以有偶同方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9允许有私有private普通方法</li><li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类对象调用）</li><li>抽象类中的方法可以是public、protected；接口方法在JDK8之前只有<code>publi abstrct</code>，在JDK8可以有default方法，在JDK9允许有私有private普通方法</li></ul><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>基本数据类型和其包装类型的自动转换。<br>自动装箱都是通过包装类的valueOf()方法来实现的。<br>自动拆箱都是通过包装类对象的xxxValue()来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装箱</span></span><br><span class="line">Integer integer = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//反编译结果</span></span><br><span class="line">Integer integer = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆箱</span></span><br><span class="line"><span class="keyword">int</span> i = integer; </span><br><span class="line"><span class="comment">// 反编译结果</span></span><br><span class="line"><span class="keyword">int</span> i = integer.valueOf;</span><br></pre></td></tr></table></figure><h4 id="自动拆装箱与缓存"><a href="#自动拆装箱与缓存" class="headerlink" title="自动拆装箱与缓存"></a>自动拆装箱与缓存</h4><p>Integer的缓存机制：</p><ul><li>适用于整数值区间 -128到+127</li><li>只适用于自动装箱</li><li>使用构造函数创建对象不适用<br>当需要进行自动装箱时，如果数字在-128到+127之间，会直接使用缓存中的对象，而不是重新创建一个对象。</li></ul><h3 id="与-equals-？"><a href="#与-equals-？" class="headerlink" title="== 与 equals()？"></a>== 与 equals()？</h3><ul><li>==<br>  基本数据类型<code>==</code>判断值是否相等；<br>  引用数据类型<code>==</code>判断变量指向的引用地址是否相等。</li><li>equals()方法<br>  基本数据类型没有equals()方法；<br>  Object类中equals方法默认用<code>==</code>比较两个对象的引用地址。<br>  引用数据类型如果没有重写eqals()则是比较两个对象的引用地址。<br>  String类重写了equals方法，比较的是字符串的值。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>,</span></span><br><span class="line"><span class="class">            <span class="title">Constable</span>, <span class="title">ConstantDesc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String anotherString = (String)anObject;</span><br><span class="line">                <span class="keyword">int</span> n = value.length;</span><br><span class="line">                <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Object类的常见方法？"><a href="#Object类的常见方法？" class="headerlink" title="Object类的常见方法？"></a>Object类的常见方法？</h3><ul><li>toString()<br>  获取对象信息方法。将对象的信息变为字符串返回，默认输出对象地址。</li><li>equals(Object obj)<br>  对象相等判断方法。用于比较对象是否相等，而且此方法必须被重写。基本数据类型没有equals()方法。</li><li>hashCode()<br>  对象签名。用来返回该对象的物理地址(哈希码值)，常会和<code>equals()</code>方法同时重写，确保两个相等的对象拥有相等的hashcode。</li><li>getClass()<br>  返回此Object的运行时类。常用于<code>反射</code>中。</li><li>wait()</li><li>notify()</li><li>notifyAll()</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h2 id="Java基础-泛型"><a href="#Java基础-泛型" class="headerlink" title="Java基础 - 泛型"></a>Java基础 - 泛型</h2><h3 id="如何理解Java中的泛型是伪泛型"><a href="#如何理解Java中的泛型是伪泛型" class="headerlink" title="如何理解Java中的泛型是伪泛型"></a>如何理解Java中的泛型是伪泛型</h3><p>Java泛型这个特性是JDK5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了<strong>伪泛型</strong>的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的<strong>泛型擦除</strong>，将所有的范型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。</p><h2 id="Java基础-注解"><a href="#Java基础-注解" class="headerlink" title="Java基础 - 注解"></a>Java基础 - 注解</h2><h2 id="Java基础-异常"><a href="#Java基础-异常" class="headerlink" title="Java基础 - 异常"></a>Java基础 - 异常</h2><h2 id="Java基础-反射"><a href="#Java基础-反射" class="headerlink" title="Java基础 - 反射"></a>Java基础 - 反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。<br>这种动态获取信息以及动态调用对象的方法的功能成为Java语言的反射机制。<br><img src="/posts/37896/java-basic-reflection-1"></p><h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h3><p>在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。<br>在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)</p><h2 id="Java基础-SPI机制"><a href="#Java基础-SPI机制" class="headerlink" title="Java基础 - SPI机制"></a>Java基础 - SPI机制</h2><h3 id="什么是SPI机制"><a href="#什么是SPI机制" class="headerlink" title="什么是SPI机制"></a>什么是SPI机制</h3><p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。<br>Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 解耦。</p><p>SPI整体机制图如下：<br><img src="/posts/37896/java-base-spi-1.jpeg"></p><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。</p><h3 id="SPI机制的应用"><a href="#SPI机制的应用" class="headerlink" title="SPI机制的应用"></a>SPI机制的应用</h3><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="描述一下-JVM-加载-Class-文件的原理机制？"><a href="#描述一下-JVM-加载-Class-文件的原理机制？" class="headerlink" title="描述一下 JVM 加载 Class 文件的原理机制？"></a>描述一下 JVM 加载 Class 文件的原理机制？</h3><h3 id="什么是tomcat类加载机制？"><a href="#什么是tomcat类加载机制？" class="headerlink" title="什么是tomcat类加载机制？"></a>什么是tomcat类加载机制？</h3><h3 id="类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？"><a href="#类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？" class="headerlink" title="类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？"></a>类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？</h3><h3 id="垃圾回收常见问题。"><a href="#垃圾回收常见问题。" class="headerlink" title="垃圾回收常见问题。"></a>垃圾回收常见问题。</h3><h3 id="什么是GC-为什么要有-GC？"><a href="#什么是GC-为什么要有-GC？" class="headerlink" title="什么是GC? 为什么要有 GC？"></a>什么是GC? 为什么要有 GC？</h3><h3 id="简述一下Java-垃圾回收机制？"><a href="#简述一下Java-垃圾回收机制？" class="headerlink" title="简述一下Java 垃圾回收机制？"></a>简述一下Java 垃圾回收机制？</h3><h3 id="如何判断一个对象是否存活？"><a href="#如何判断一个对象是否存活？" class="headerlink" title="如何判断一个对象是否存活？"></a>如何判断一个对象是否存活？</h3><h3 id="垃圾回收的优点和原理，并考虑-2-种回收机制？"><a href="#垃圾回收的优点和原理，并考虑-2-种回收机制？" class="headerlink" title="垃圾回收的优点和原理，并考虑 2 种回收机制？"></a>垃圾回收的优点和原理，并考虑 2 种回收机制？</h3><h3 id="Java-中垃圾收集的方法有哪些？"><a href="#Java-中垃圾收集的方法有哪些？" class="headerlink" title="Java 中垃圾收集的方法有哪些？"></a>Java 中垃圾收集的方法有哪些？</h3><h3 id="讲讲你理解的性能评价及测试指标？"><a href="#讲讲你理解的性能评价及测试指标？" class="headerlink" title="讲讲你理解的性能评价及测试指标？"></a>讲讲你理解的性能评价及测试指标？</h3><h3 id="常用的性能优化方式有哪些？"><a href="#常用的性能优化方式有哪些？" class="headerlink" title="常用的性能优化方式有哪些？"></a>常用的性能优化方式有哪些？</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Arraylist-与-LinkedList-异同。"><a href="#Arraylist-与-LinkedList-异同。" class="headerlink" title="Arraylist 与 LinkedList 异同。"></a>Arraylist 与 LinkedList 异同。</h3><h3 id="ArrayList-与-Vector-区别。"><a href="#ArrayList-与-Vector-区别。" class="headerlink" title="ArrayList 与 Vector 区别。"></a>ArrayList 与 Vector 区别。</h3><h3 id="HashMap的底层实现。"><a href="#HashMap的底层实现。" class="headerlink" title="HashMap的底层实现。"></a>HashMap的底层实现。</h3><h3 id="HashMap-和-Hashtable-的区别。"><a href="#HashMap-和-Hashtable-的区别。" class="headerlink" title="HashMap 和 Hashtable 的区别。"></a>HashMap 和 Hashtable 的区别。</h3><h3 id="HashMap-的长度为什么是2的幂次方。"><a href="#HashMap-的长度为什么是2的幂次方。" class="headerlink" title="HashMap 的长度为什么是2的幂次方。"></a>HashMap 的长度为什么是2的幂次方。</h3><h3 id="HashMap-多线程操作导致死循环问题。"><a href="#HashMap-多线程操作导致死循环问题。" class="headerlink" title="HashMap 多线程操作导致死循环问题。"></a>HashMap 多线程操作导致死循环问题。</h3><h3 id="HashSet-和-HashMap-区别。"><a href="#HashSet-和-HashMap-区别。" class="headerlink" title="HashSet 和 HashMap 区别。"></a>HashSet 和 HashMap 区别。</h3><h3 id="ConcurrentHashMap-和-Hashtable-的区别。"><a href="#ConcurrentHashMap-和-Hashtable-的区别。" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别。"></a>ConcurrentHashMap 和 Hashtable 的区别。</h3><ul><li>HashTable是线程安全的，原理和HashMap基本一样，差别在：<ul><li>HashTable不允许key和value为null</li><li>get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁，性能较差</li></ul></li><li>ConcurrentHashMap是线程安全的，但是它是分段锁，容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。</li></ul><h3 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现。"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现。" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现。"></a>ConcurrentHashMap线程安全的具体实现方式/底层具体实现。</h3><h2 id="JUC-多线程与并发"><a href="#JUC-多线程与并发" class="headerlink" title="JUC 多线程与并发"></a>JUC 多线程与并发</h2><h3 id="AQS-原理。"><a href="#AQS-原理。" class="headerlink" title="AQS 原理。"></a>AQS 原理。</h3><h3 id="AQS-对资源的共享方式。"><a href="#AQS-对资源的共享方式。" class="headerlink" title="AQS 对资源的共享方式。"></a>AQS 对资源的共享方式。</h3><h3 id="AQS底层使用了模板方法模式。"><a href="#AQS底层使用了模板方法模式。" class="headerlink" title="AQS底层使用了模板方法模式。"></a>AQS底层使用了模板方法模式。</h3><h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><h3 id="synchronized关键字。"><a href="#synchronized关键字。" class="headerlink" title="synchronized关键字。"></a>synchronized关键字。</h3><h3 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗？"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗？" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？</h3><h4 id="面试题：多线程循环打印ABC"><a href="#面试题：多线程循环打印ABC" class="headerlink" title="面试题：多线程循环打印ABC"></a>面试题：多线程循环打印ABC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抢占式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrintABC_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">0</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">1</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">2</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRINT_NUM = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CURRENT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (CURRENT &lt; PRINT_NUM) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (CURRENT &lt; PRINT_NUM &amp;&amp; CURRENT % <span class="number">3</span> == index) &#123;</span><br><span class="line"><span class="comment">//                    if (CURRENT % 3 == index) &#123;</span></span><br><span class="line">                        System.out.println(CURRENT + <span class="string">&quot; &quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + CURRENT % <span class="number">3</span>));</span><br><span class="line">                        CURRENT ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协作式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrintABC_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">0</span>,<span class="string">&#x27;A&#x27;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">1</span>,<span class="string">&#x27;B&#x27;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintTask(<span class="number">2</span>,<span class="string">&#x27;C&#x27;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 打印控制变量计数器</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> COUNT = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 成员变量 每个线程打印次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sort;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> sort, <span class="keyword">char</span> name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sort = sort;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (COUNT % <span class="number">3</span> == sort) &#123;</span><br><span class="line"><span class="comment">//                        System.out.println(name);</span></span><br><span class="line">                        System.out.println((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + COUNT % <span class="number">3</span>));</span><br><span class="line">                        COUNT ++;</span><br><span class="line">                        num --;</span><br><span class="line">                        LOCK.notifyAll();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.feng.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock Condition CountDownLatch</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ABC</span></span><br><span class="line"><span class="comment"> * ABC</span></span><br><span class="line"><span class="comment"> * END</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrintABC_4</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock LOCK = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition cur;</span><br><span class="line">    <span class="keyword">private</span> Condition next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> aChar;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPrintABC_4</span><span class="params">(Condition cur, Condition next, <span class="keyword">char</span> aChar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cur = cur;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.aChar = aChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= COUNT; i ++) &#123;</span><br><span class="line">                System.out.print(aChar);</span><br><span class="line">                <span class="keyword">if</span> (aChar == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">                next.signal();</span><br><span class="line">                <span class="keyword">if</span> (i &lt; COUNT) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cur.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Condition a = LOCK.newCondition();</span><br><span class="line">        Condition b = LOCK.newCondition();</span><br><span class="line">        Condition c = LOCK.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ThreadPrintABC_4(a, b, <span class="string">&#x27;A&#x27;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> ThreadPrintABC_4(b, c, <span class="string">&#x27;B&#x27;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> ThreadPrintABC_4(c, a, <span class="string">&#x27;C&#x27;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="讲一下-synchronized-关键字的底层原理。"><a href="#讲一下-synchronized-关键字的底层原理。" class="headerlink" title="讲一下 synchronized 关键字的底层原理。"></a>讲一下 synchronized 关键字的底层原理。</h3><h3 id="说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"><a href="#说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？" class="headerlink" title="说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"></a>说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</h3><h3 id="谈谈-synchronized和ReenTrantLock-的区别。"><a href="#谈谈-synchronized和ReenTrantLock-的区别。" class="headerlink" title="谈谈 synchronized和ReenTrantLock 的区别。"></a>谈谈 synchronized和ReenTrantLock 的区别。</h3><h3 id="说说-synchronized-关键字和-volatile-关键字的区别。"><a href="#说说-synchronized-关键字和-volatile-关键字的区别。" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别。"></a>说说 synchronized 关键字和 volatile 关键字的区别。</h3><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><h3 id="实现Runnable接口和Callable接口的区别。"><a href="#实现Runnable接口和Callable接口的区别。" class="headerlink" title="实现Runnable接口和Callable接口的区别。"></a>实现Runnable接口和Callable接口的区别。</h3><h3 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a>执行execute()方法和submit()方法的区别是什么呢？</h3><h3 id="如何创建线程池。"><a href="#如何创建线程池。" class="headerlink" title="如何创建线程池。"></a>如何创建线程池。</h3><h3 id="介绍一下Atomic-原子类。"><a href="#介绍一下Atomic-原子类。" class="headerlink" title="介绍一下Atomic 原子类。"></a>介绍一下Atomic 原子类。</h3><h3 id="JUC-包中的原子类是哪4类？"><a href="#JUC-包中的原子类是哪4类？" class="headerlink" title="JUC 包中的原子类是哪4类？"></a>JUC 包中的原子类是哪4类？</h3><ol><li>基本类型: AtomicInteger, AtomicLong, AtomicBoolean ;</li><li>数组类型: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray ;</li><li>引用类型: AtomicReference, AtomicStampedRerence, AtomicMarkableReference ;</li><li>对象的属性修改类型: AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 。</li></ol><h3 id="讲讲-AtomicInteger-的使用。"><a href="#讲讲-AtomicInteger-的使用。" class="headerlink" title="讲讲 AtomicInteger 的使用。"></a>讲讲 AtomicInteger 的使用。</h3><h3 id="能不能给我简单介绍一下-AtomicInteger-类的原理？"><a href="#能不能给我简单介绍一下-AtomicInteger-类的原理？" class="headerlink" title="能不能给我简单介绍一下 AtomicInteger 类的原理？"></a>能不能给我简单介绍一下 AtomicInteger 类的原理？</h3><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul><li>懒汉式：在第一次调用的时候进行实例化。</li><li>饿汉式：在类初始化时，已经自行实例化。</li></ul><h4 id="饿汉式-直接静态初始化"><a href="#饿汉式-直接静态初始化" class="headerlink" title="饿汉式 - 直接静态初始化"></a>饿汉式 - 直接静态初始化</h4><ul><li>优点：简单，含有 final 关键字</li><li>缺点：程序运行直接加载，耗费资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObject1 instance = <span class="keyword">new</span> SingletonObject1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式-synchronized实现"><a href="#懒汉式-synchronized实现" class="headerlink" title="懒汉式 - synchronized实现"></a>懒汉式 - synchronized实现</h4><ul><li>优点：懒加载实现，即初次获取值时才会初始化</li><li>缺点：synchronized 实现，初始化后每次读操作也会加锁，耗费资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObject3 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonObject3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">           instance = <span class="keyword">new</span> SingletonObject3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式-双重检查"><a href="#懒汉式-双重检查" class="headerlink" title="懒汉式 - 双重检查"></a>懒汉式 - 双重检查</h4><ul><li>优点：懒加载 + 双重检查，确保初始化一次，同时优化性能</li><li>缺点：实现较复杂，同时 volatile 也有性能损耗</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonObject4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(SingletonObject4.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonObject4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>加载一个类时，其内部类不会同时被加载。<br>一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。<br>由于在调用 SingletonObject5.getInstance() 的时候，才会对单例进行初始化，而且通过反射，是不能从外部类获取内部类的属性的；由于静态内部类的特性，只有在其被第一次引用的时候才会被加载，所以可以保证其线程安全性。</p><ul><li>优点：使用内部类机制实现懒加载，最佳实践之一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObject5 INSTANCE = <span class="keyword">new</span> SingletonObject5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h4><p>单元素的枚举类型已经成为实现Singleton的最佳方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EnumSingleton.INSTANCE.test();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="策略模式-模板模式-工厂模式"><a href="#策略模式-模板模式-工厂模式" class="headerlink" title="策略模式 + 模板模式 + 工厂模式"></a>策略模式 + 模板模式 + 工厂模式</h3><ol><li>使用策略模式结合InitializingBean或ApplicationContextAware简化if-else</li><li>模板模式抽取公共方法</li><li>工厂模式：根据不同策略请求类型去拿不同的策略去调用</li></ol><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ol><li>为什么会有线程池？</li><li>简单手写一个线程池？<br> 池内工作线程的管理、任务编排执行、线程池超负荷处理方案(拒绝策略)、监控。</li><li>为什么要把任务先放在任务队列里面，而不是把线程先拉满到最大线程数？</li><li><strong>线程池如何动态修改核心线程数和最大线程数？</strong><br> 其实之所以会有这样的需求是因为<strong>线程数是真的不好配置</strong>。<br> 线程数真的很难通过一个公式一劳永逸，<strong>线程数的设定是一个迭代的过程，需要压测适时调整</strong>。再者，流量的突发性也是无法判断的，举个例子 1 秒内一共有 1000 个请求量，但是如果这 1000 个请求量都是在第一毫秒内瞬时进来的呢？<br> 原生线程池ThreadPoolExecutor已经提供修改配置的方法，也对外暴露出线程池内部执行情况，所以只要我们实时监控情况，调用对应的set方法，即可动态修改线程池对应配置。</li><li>如果你是 JDK 设计者，如何设计？</li><li>如果要让你设计一个线程池，你要怎么设计？</li><li>你是如何理解核心线程的？</li><li>你是怎么理解 KeepAliveTime 的？</li><li> 那 workQueue 有什么用？</li><li>你是如何理解拒绝策略的？</li><li>你说你看过源码，那你肯定知道线程池里的 ctl 是干嘛的咯？<br>runState、workerCount</li><li>你知道线程池有几种状态吗？</li><li>你知道线程池的状态是如何变迁的吗？</li><li>如何修改原生线程池，使得可以先拉满线程数再入任务队列排队？<br>参考Tomcat的定制化线程池实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 统计提交的任务数+1</span></span><br><span class="line">    submittedCount.incrementAndGet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用JDK原生线程池ThreadPoolExecutor的execute方法提交任务</span></span><br><span class="line">        executeInternal(command);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123; <span class="comment">// 拒绝异常</span></span><br><span class="line">        <span class="comment">// TaskQueue</span></span><br><span class="line">        <span class="keyword">if</span> (getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">            <span class="comment">// If the Executor is close to maximum pool size, concurrent</span></span><br><span class="line">            <span class="comment">// calls to execute() may result (due to Tomcat&#x27;s use of</span></span><br><span class="line">            <span class="comment">// TaskQueue) in some tasks being rejected rather than queued.</span></span><br><span class="line">            <span class="comment">// If this happens, add them to the queue.</span></span><br><span class="line">            <span class="keyword">final</span> TaskQueue queue = (TaskQueue) getQueue();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再次尝试把任务塞进任务队列里</span></span><br><span class="line">                <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                    <span class="comment">// 如果塞不进去，把之前统计的任务数-1</span></span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(sm.getString(<span class="string">&quot;threadPoolExecutor.queueFull&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                <span class="comment">// 被打断了，任务数-1</span></span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是定制的任务队列，任务数-1</span></span><br><span class="line">            submittedCount.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> rx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>代码里出现的<strong>TaskQueue</strong>，这个就是Tomcat线程池的定制关键点了。<br><strong>Tomcat自定义队列TaskQueue重写了LinkedBlockingQueue的offer方法</strong>，这是关键所在！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池调用任务队列的方法时，当前线程数肯定已经大于核心线程数了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有找到Tomcat扩展线程池的话，直接调用父类的offer方法</span></span><br><span class="line">        <span class="keyword">if</span> (parent==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果线程数已经到了最大值，不能创建新线程了，只能把任务添加到任务队列</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getPoolSizeNoLock() == parent.getMaximumPoolSize()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里，表明当前线程数大于核心线程数 &amp;&amp; 小于最大线程数</span></span><br><span class="line">        <span class="comment">// 表明是可以创建新线程的，分两种情况</span></span><br><span class="line">        <span class="comment">// 1. 如果已提交的任务数小于当前线程数，表示还有空闲线程，无需创建新线程</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getSubmittedCount() &lt;= parent.getPoolSizeNoLock()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 如果已提交的任务数大于当前线程数，返回false去创建新线程</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getPoolSizeNoLock() &lt; parent.getMaximumPoolSize()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Tomcat中的定制化线程池实现，如果线程池中的线程在执行任务的时候，抛异常了，会怎么样？</li><li>原生线程池的核心线程一定伴随着任务慢慢创建的吗？<br>并不是，线程池提供了两个方法：<ul><li>prestartCoreThread：启动一个核心线程</li><li>prestartAllCoreThreads ：启动所有核心线程<br>不要小看这个预创建方法，预热很重要，不然刚重启的一些服务有时是顶不住瞬时请求的，就立马崩了，所以有预热线程、缓存等等操作。</li></ul></li><li>线程池的核心线程在空闲的时候一定不会被回收吗？<br>有个<strong>allowCoreThreadTimeOut</strong>参数，把它设置为 true ，则所有线程都会超时，不会有核心数那条线的存在。<br>具体是会调用<strong>interruptIdleWorkers</strong>这个方法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愛彌留</title>
      <link href="/posts/36238.html"/>
      <url>/posts/36238.html</url>
      
        <content type="html"><![CDATA[<p>爱弥留 - 达明一派<br>词：周耀辉<br>曲：刘以达</p><p>请收起你的温柔<br>浮在水仙中的杀手<br>请收起你的风流<br>垂在钟摆间的借口<br>明白我始终必须远走<br>但请不要为我忧愁<br>蝴蝶总比沙丘永久<br>但请相信我的荒谬<br>纵使真的不想远走<br>明白我始终必须远走<br>象我这永没法解释的苍白<br>象永远盖着扑克<br>象永远在转圈圈的笔画<br>一生不过揣测<br>象我这永没法青春的生命<br>象永远转换布景<br>象永远在转圈圈的花瓶<br>一生不过一声<br>没一刻可以安静</p><p>请不要问我今后<br>藏在死水中的缺口<br>请相信我的恳求<br>忘掉总比思忆永久<br>明白我始终必须远走<br>象我这永没法解释的苍白<br>象永远盖着扑克<br>象永远在转圈圈的笔画<br>一生不过揣测<br>象我这永没法青春的生命<br>象永远转换布景<br>象永远在转圈圈的花瓶<br>一生不过一声<br>没一刻可以安静</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今天起的每晚 你要珍惜岁月</title>
      <link href="/posts/57834.html"/>
      <url>/posts/57834.html</url>
      
        <content type="html"><![CDATA[<p>今天花了几个小时的时间把hexo从windows迁到mac上。<br>上一次的记录时间是<code>2019-11-24</code>，今天是<code>2021-11-21</code>。<br>两年了，重新出发吧。</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-MVC</title>
      <link href="/posts/6963.html"/>
      <url>/posts/6963.html</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC与传统MVC"><a href="#SpringMVC与传统MVC" class="headerlink" title="SpringMVC与传统MVC"></a>SpringMVC与传统MVC</h2><h3 id="传统MVC"><a href="#传统MVC" class="headerlink" title="传统MVC"></a>传统MVC</h3><p>MVC的全称为<strong>Model View Controller</strong>，是一种软件架构模式，将web应用程序分为<strong>模型、视图、控制器</strong>三部分。</p><p>最典型的MVC就是<strong>JSP + servlet + javabean</strong>的模式。</p><ul><li>Model<br>  模型层，指工程中的JavaBean（entity、service、dao），作用是处理数据。</li><li>View<br>  视图层，指工程中的html或jsp等页面，作用是与用户进行交互、展示数据。</li><li>Controller<br>  控制层，指工程中的servlet，作用是接受请求和响应浏览器。</li></ul><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>Spring MVC是Spring在Spring Container Core和AOP等技术基础上，遵循上述Web MVC的规范推出的web开发框架，目的是为了简化Java栈的web开发。 </p><p>Spring Web MVC 框架也是一个基于请求驱动的Web 框架，并且也使用了前端控制器模式来进行设计，再根据请求映射规则分发给相应的页面控制器（动作/处理器）进行处理。</p><h2 id="SpringMVC的工作流程"><a href="#SpringMVC的工作流程" class="headerlink" title="SpringMVC的工作流程"></a>SpringMVC的工作流程</h2><p><img src="/posts/6963/springmvc-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><ol><li><strong>首先用户发送请求 —&gt; DispatcherServlet</strong>，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</li><li><strong>DispatcherServlet —&gt; HandlerMapping</strong>，HandlerMapping 把请求映射为 HandlerExecutionChain 处理器执行链对象（包含一个Handler 处理器（页面控制器）、多个HandlerInterceptor 拦截器），通过这种策略模式，很容易添加新的映射策略；</li><li><strong>DispatcherServlet —&gt; HandlerAdapter</strong>，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器， 即适配器设计模式的应用，从而很容易支持很多类型的处理器；</li><li><strong>HandlerAdapter —&gt; Handler（具体的handler或者业务逻辑Controller）</strong>，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；</li><li><strong>ModelAndView 的逻辑视图名 —&gt; ViewResolver</strong>，ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</li><li><strong>View —&gt; 渲染</strong>，View 会根据传进来的Model 模型数据进行渲染，此处的Model 实际是一个Map 数据结构，因此 很容易支持其他视图技术；</li><li><strong>返回控制权给DispatcherServlet</strong>，由DispatcherServlet 返回响应给用户，到此一个流程结束。</li></ol><h2 id="SpringMVC的核心组件"><a href="#SpringMVC的核心组件" class="headerlink" title="SpringMVC的核心组件"></a>SpringMVC的核心组件</h2><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><h3 id="HandlerExecutionChain"><a href="#HandlerExecutionChain" class="headerlink" title="HandlerExecutionChain"></a>HandlerExecutionChain</h3><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><h4 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h4><h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><h3 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h3><p>ViewResolver<br>LocaleResolver<br>ThemeResolver<br>MultipartResolver</p><h3 id="Filter-vs-HandlerInterceptor"><a href="#Filter-vs-HandlerInterceptor" class="headerlink" title="Filter vs HandlerInterceptor"></a>Filter vs HandlerInterceptor</h3><p><img src="/posts/6963/Filter-vs-HandlerInterceptor.png"></p><ol><li>Filter 是 Servlet 规范中的，而 HandlerInterceptor 是 Spring 中的一个概念</li><li>拦截器位置相对于过滤器更靠后，过滤器的生命周期比拦截器更长</li></ol><h4 id="过滤器-Filter"><a href="#过滤器-Filter" class="headerlink" title="过滤器 Filter"></a>过滤器 Filter</h4><p>过滤器是被Servlet容器执行的类。请求在进入容器时、响应在离开容器时，会经过一个个的过滤器。过滤器的实例，在容器中是以过滤器链的形式执行的。<br>如果在应用中，我们定义了多个过滤器，那么执行的先后顺序，可以通过 <code>@Order</code> 注解来指定。</p><p>Filter 接口的核心方法，也是其生命周期方法：</p><ul><li>init(FilterConfig config)<br>  此方法只调用一次，用于初始化过滤器</li><li>doFilter(HttpServletRequest request, HttpServletResponse response, FilterChian chian)<br>  此方法在每一个请求打到映射的资源上时都会调用，比如定义一个 Filter 拦截 /path/* ，那么每一个匹配 /path/* 访问资源的请求进来时，都会执行此方法。这个方法中就是拦截器的具体逻辑</li><li>destroy()<br>  此方法也只执行一次，用于销毁过滤器</li></ul><h4 id="拦截器-HandlerInterceptor"><a href="#拦截器-HandlerInterceptor" class="headerlink" title="拦截器 HandlerInterceptor"></a>拦截器 HandlerInterceptor</h4><ol><li>接口<code>HandlerInterceptor</code>定义在<code>org.springframework.web.servlet</code>包中。</li><li>核心方法<ul><li>preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)<br>  该方法在请求到达 Controller 之前执行操作，返回一个布尔值。<br>  返回 true 时，继续往下执行；当返回 false 时，不再执行对应的 handler。</li><li>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)<br>  该方法在响应返回客户端之前执行</li><li>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception)<br>  该方法在请求和响应流程完成之后执行</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链式调用，按拦截器的添加顺序依次往下执行</span></span><br><span class="line">        <span class="comment">// HandlerInterceptor的preHandle方法若返回true 继续执行下一个拦截器</span></span><br><span class="line">        <span class="comment">// 若为false 则停止</span></span><br><span class="line"></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> AuthInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line"><span class="comment">//                .excludePathPatterns(&quot;/**/i_scheduler/**&quot;);</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> SchedulerInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String userAccount = request.getHeader(<span class="string">&quot;X-USER&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (userAccount == <span class="keyword">null</span> || userAccount.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;user not login&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;AuthInterceptor x-user:&#123;&#125;&quot;</span>, userAccount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="params"><span class="function">ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String servletPath = request.getServletPath();</span><br><span class="line">        <span class="comment">// 非任务请求，直接通过</span></span><br><span class="line">        <span class="keyword">if</span> (!servletPath.startsWith(<span class="string">&quot;/i_scheduler&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;SchedulerInterceptor not i_scheduler&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String path = servletPath.replaceAll(<span class="string">&quot;/i_scheduler/&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 心跳探测</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;ping&quot;</span>.equals(path)) &#123;</span><br><span class="line">            response.setStatus(<span class="number">200</span>);</span><br><span class="line">            log.info(<span class="string">&quot;SchedulerInterceptor ping&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;SchedulerInterceptor do i_scheduler&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC实现原理之DispatcherServlet"><a href="#SpringMVC实现原理之DispatcherServlet" class="headerlink" title="SpringMVC实现原理之DispatcherServlet"></a>SpringMVC实现原理之DispatcherServlet</h2><p>DispatcherServlet是SpringMVC中唯一的Servlet，Servlet容器（Tomcat）把所有的请求都转发到DispatcherServlet，然后通过HandlerMapping把请求路由到具体的Controller中。</p><p><img src="/posts/6963/DispatcherServlet-%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><h3 id="DispatcherServlet的初始化过程"><a href="#DispatcherServlet的初始化过程" class="headerlink" title="DispatcherServlet的初始化过程"></a>DispatcherServlet的初始化过程</h3><ul><li>DispatcherServlet和ApplicationContext有何关系？</li><li>DispatcherServlet是如何初始化的？</li></ul><h3 id="DispatcherServlet处理请求的过程"><a href="#DispatcherServlet处理请求的过程" class="headerlink" title="DispatcherServlet处理请求的过程"></a>DispatcherServlet处理请求的过程</h3><p>一个请求发出，经过DispatcherServlet进行了什么样的处理，最后将内容返回的呢？<br>以一个GET请求为例，请求URL是<a href="http://localhost:8080/api/v1/test">http://localhost:8080/api/v1/test</a></p><h4 id="doGet-入口"><a href="#doGet-入口" class="headerlink" title="doGet 入口"></a>doGet 入口</h4><h4 id="doDispatch-请求分发"><a href="#doDispatch-请求分发" class="headerlink" title="doDispatch 请求分发"></a>doDispatch 请求分发</h4><h4 id="映射和适配器处理"><a href="#映射和适配器处理" class="headerlink" title="映射和适配器处理"></a>映射和适配器处理</h4><h4 id="视图渲染"><a href="#视图渲染" class="headerlink" title="视图渲染"></a>视图渲染</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-AOP</title>
      <link href="/posts/17849.html"/>
      <url>/posts/17849.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>Spring 框架通过定义切面, 通过拦截切点实现了不同业务模块的解耦，这个就叫<strong>面向切面编程 - Aspect Oriented Programming (AOP)</strong></li><li>为什么@Aspect注解使用的是aspectj的jar包呢？这就引出了<strong>Aspect4J和Spring AOP的历史渊源</strong>，只有理解了Aspect4J和Spring的渊源才能理解有些注解上的兼容设计</li><li>如何支持更多拦截方式来实现解耦， 以满足更多场景需求呢？ 这就是@Around, @Pointcut… 等切面通知和切点的设计</li><li>那么Spring框架又是如何实现AOP的呢？ 这就引入<strong>代理技术</strong>，分<strong>静态代理和动态代理</strong>，<strong>动态代理又包含JDK代理和CGLIB代理</strong>等</li></ol><h2 id="如何理解AOP"><a href="#如何理解AOP" class="headerlink" title="如何理解AOP"></a>如何理解AOP</h2><p>AOP的本质也是为了解耦，它是一种设计思想； 在理解时也应该简化理解。</p><h3 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h3><blockquote><p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程。</p></blockquote><p>AOP最早是AOP联盟的组织提出的，制定的一套规范。Spring将AOP的思想引入框架之中，通过<strong>预编译方式</strong>和<strong>运行期间动态代理</strong>实现程序的统一维护。</p><p>将记录日志功能解耦为日志切面，它的目标是解耦。进而引出AOP的理念：就是将分散在各个业务逻辑代码中相同的代码通过<strong>横向切割</strong>的方式抽取到一个独立的模块中。<br><img src="/posts/17849/aop-%E6%98%AF%E4%BB%80%E4%B9%88-1.png"></p><p>OOP面向对象编程，针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。<br>OOP面向对象，允许开发者定义纵向的关系，但并不适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程的某个步骤或阶段，以获得逻辑过程的中各部分之间低耦合的隔离效果。<br>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</p><p>这两种设计思想在目标上有着本质的差异。</p><p><img src="/posts/17849/aop-%E6%98%AF%E4%BB%80%E4%B9%88-2.png"></p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p>首先从一些重要的AOP概念和术语开始，这些术语不是Spring特有的。<br><img src="/posts/17849/aop-%E6%9C%AF%E8%AF%AD.png"></p><h3 id="Spring-AOP和AspectJ是什么关系"><a href="#Spring-AOP和AspectJ是什么关系" class="headerlink" title="Spring AOP和AspectJ是什么关系"></a>Spring AOP和AspectJ是什么关系</h3><h4 id="AspectJ是什么？"><a href="#AspectJ是什么？" class="headerlink" title="AspectJ是什么？"></a>AspectJ是什么？</h4><p>AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）。</p><p>可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。</p><p>了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。<br>对于这个过程，一般分为<strong>动态织入</strong>和<strong>静态织入</strong>：</p><ul><li>动态织入<br>  动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的。<br>  如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术。</li><li>静态织入<br>  ApectJ采用的就是静态织入的方式。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。<br>  <img src="/posts/17849/aop-AspectJ-%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5.png"></li></ul><h4 id="为什么需要理清楚Spring-AOP和AspectJ的关系？"><a href="#为什么需要理清楚Spring-AOP和AspectJ的关系？" class="headerlink" title="为什么需要理清楚Spring AOP和AspectJ的关系？"></a>为什么需要理清楚Spring AOP和AspectJ的关系？</h4><p>我们看下@Aspect以及增强的几个注解，为什么不是Spring包，而是来源于aspectJ呢？<br><img src="/posts/17849/aop-AspectJ-jar.png"></p><h4 id="Spring-AOP和AspectJ是什么关系？"><a href="#Spring-AOP和AspectJ是什么关系？" class="headerlink" title="Spring AOP和AspectJ是什么关系？"></a>Spring AOP和AspectJ是什么关系？</h4><p>AspectJ可以做Spring AOP干不了的事情，它是AOP编程的完全解决方案。<br>Spring AOP则致力于解决企业级开发中最普遍的AOP（方法织入）。</p><table><thead><tr><th align="left">Spring AOP</th><th align="left">AspectJ</th></tr></thead><tbody><tr><td align="left">在纯 Java 中实现</td><td align="left">使用 Java 编程语言的扩展实现</td></tr><tr><td align="left">不需要单独的编译过程</td><td align="left">除非设置 LTW，否则需要 AspectJ 编译器 (ajc)</td></tr><tr><td align="left">只能使用运行时织入</td><td align="left">运行时织入不可用。支持编译时、编译后和加载时织入</td></tr><tr><td align="left">功能不强-仅支持方法级编织</td><td align="left">更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等……。</td></tr><tr><td align="left">只能在由 Spring 容器管理的 bean 上实现</td><td align="left">可以在所有域对象上实现</td></tr><tr><td align="left">仅支持方法执行切入点</td><td align="left">支持所有切入点</td></tr><tr><td align="left">代理是由目标对象创建的, 并且切面应用在这些代理上</td><td align="left">在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入</td></tr><tr><td align="left">比 AspectJ 慢多了</td><td align="left">更好的性能</td></tr><tr><td align="left">易于学习和应用</td><td align="left">相对于 Spring AOP 来说更复杂</td></tr></tbody></table><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>AOP实现的关键在于代理模式，AOP代理主要分为静态代理和动态代理。<br>静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><h3 id="静态代理-AspectJ"><a href="#静态代理-AspectJ" class="headerlink" title="静态代理 - AspectJ"></a>静态代理 - AspectJ</h3><p>AspectJ是静态代理的增强。</p><p>所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><h3 id="动态代理-Spring-AOP"><a href="#动态代理-Spring-AOP" class="headerlink" title="动态代理 - Spring AOP"></a>动态代理 - Spring AOP</h3><p>所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>Spring AOP中的动态代理主要有两种方式：</p><ul><li>JDK动态代理</li><li>CGLIB动态代理</li></ul><p><strong>Spring 5.x中AOP默认依旧使用JDK动态代理</strong><br><strong>SpringBoot在2.x默认使用Cglib动态代理   （1.x中默认使用JDK动态代理）</strong></p><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>只提供接口的代理，不支持类的代理。</p><p>核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.feng.proxy.dynamic.jdk.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserJDKProxy2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realObject 被代理的真实对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Object realObject, Class clazz)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;clazz&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 在代理真实对象前的操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;在调用之前，干点啥呢？&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Method:&quot;</span> + method);</span><br><span class="line">                <span class="comment">// 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">                Object returnValue = method.invoke(realObject, args);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在代理真实对象后的操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;在调用之后，干点啥呢？&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;[after] execute method: &quot;</span> + method.getName() + <span class="string">&quot;, return value: &quot;</span> + returnValue);</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>如果目标类没有实现接口，那么Spring AOP会选择使用<code>CGLIB</code>来动态代理目标类。</p><p>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。<br>CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.feng.proxy.dynamic.cglib.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCglibProxy</span><span class="params">(Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建加强器，用来创建动态代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 为加强器指定要代理的业务类（即为下面生成的代理类指定父类）</span></span><br><span class="line">        enhancer.setSuperclass(targetClass);</span><br><span class="line">        <span class="comment">// 设置回调：对于代理类上所有的方法的调用，都会调用callback，而callback则需要实现intercept()方法进行拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理类对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// log - before method</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[before] execute method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call method</span></span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// log - after method</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[after] execute method: &quot;</span> + method.getName() + <span class="string">&quot;, return value: &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他代理方式-Java字节码操作框架"><a href="#其他代理方式-Java字节码操作框架" class="headerlink" title="其他代理方式 - Java字节码操作框架"></a>其他代理方式 - Java字节码操作框架</h3><h4 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h4><h4 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h4><h4 id="Byte-Buddy"><a href="#Byte-Buddy" class="headerlink" title="Byte-Buddy"></a>Byte-Buddy</h4><h2 id="Spring动态代理"><a href="#Spring动态代理" class="headerlink" title="Spring动态代理"></a>Spring动态代理</h2><h3 id="相关使用场景"><a href="#相关使用场景" class="headerlink" title="相关使用场景"></a>相关使用场景</h3><ol><li><p>AOP切面 @Aspect<br> 为被切点切到的bean生成代理对象。</p></li><li><p>@Configuration<br> 在Spring中只要被<code>@Configuration</code>注解修饰的类，Spring就会为其生成代理对象，至于这样做的主要原因就是<strong>为了解决生成对象的单例问题</strong>。<br> 取决于<code>@Configuration注解</code>的<strong>proxyBeanMethods属性</strong>。<br> 如果是true的话，那么这个配置类就会被代理了，如果是false的话，那么就不会被代理。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Configuration注解 proxyBeanMethods属性</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxyBeanMethods代表的是，如果是true的话，那么这个配置类就会被代理了，如果是false的话，那么就不会被代理。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Lazy</p></li><li><p>@Async</p></li><li><p>@Transactional</p></li></ol><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。<br>真正的数据库层的事务提交和回滚是通过binlog或者redo log/undo log实现的。</p><p>Spring的核心事务管理抽象是<code>TransactionManager</code>，管理封装了一组独立于技术的方法，无论使用Spring的哪种事务管理策略（编程式或声明式），事务管理器都是必须的。</p><h3 id="事务的种类"><a href="#事务的种类" class="headerlink" title="事务的种类"></a>事务的种类</h3><h4 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h4><p>通过 TransactionTemplate或者TransactionManager手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</p><h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p>推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）。</p><h3 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h3><ul><li>隔离级别</li><li>传播行为</li><li>回滚规则</li><li>是否只读</li><li>事务超时</li></ul><h3 id="Transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a>@Transactional 注解使用详解</h3><h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><ul><li>方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。</li><li>类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li><li>接口 ：不推荐在接口上使用。</li></ul><h4 id="常用配置参数"><a href="#常用配置参数" class="headerlink" title="常用配置参数"></a>常用配置参数</h4><ul><li>propagation 事务的传播行为，默认值为 REQUIRED</li><li>isolation 事务的隔离级别，默认值采用 DEFAULT</li><li>timeout 事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li><li>readOnly 指定事务是否为只读事务，默认值为 false。</li><li>rollbackFor 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</li></ul><h4 id="Transactional事务注解原理"><a href="#Transactional事务注解原理" class="headerlink" title="@Transactional事务注解原理"></a>@Transactional事务注解原理</h4><p><code>@Transactional</code>的工作机制是基于AOP实现的，Spring AOP又是使用动态代理实现的。<br>如果目标对象实现了接口，默认情况下会采用JDK的动态代理，如果目标对象没有实现接口，会使用CGLIB动态代理。</p><p><code>createAopProxy()</code>决定了是使用 JDK 还是 CGLIB 来做动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line"><span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类或者一个类中的 public 方法上被标注 @Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。<br>这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p><h4 id="Spring-AOP自调用问题"><a href="#Spring-AOP自调用问题" class="headerlink" title="Spring AOP自调用问题"></a>Spring AOP自调用问题</h4><p>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有 @Transactional 注解的方法的事务会失效。</p><p>这是由于 Spring AOP 代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring事务管理才生效。</p><p>MyService 类中的method1()调用method2()就会导致method2()的事务失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     method2();</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法就是避免同一类中自调用或者使用AspectJ静态代理取代Spring AOP代理。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-IOC</title>
      <link href="/posts/19065.html"/>
      <url>/posts/19065.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><strong>Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean</strong>，这个就叫<strong>控制反转 - Inversion of Control (IoC)</strong></li><li>Spring 框架托管创建的Bean放在哪里呢？ 这便是<strong>Spring容器（IoC Container）</strong></li><li>Spring 框架为了更好让用户配置Bean，必然会引入<strong>不同方式来配置Bean</strong>？ 这便是<strong>xml配置，Java配置，注解配置</strong>等支持</li><li>Spring 框架既然接管了Bean的生成，必然需要<strong>管理整个Bean的生命周期</strong>等</li><li><strong>应用程序代码从Ioc Container中获取依赖的Bean，注入到应用程序中</strong>，这个过程叫 <strong>依赖注入(Dependency Injection，DI)</strong> ； 所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong></li><li>在依赖注入时，有哪些方式呢？这就是构造器方式，**@Autowired, @Resource, @Qualifier**… 同时Bean之间存在依赖（可能存在先后顺序问题，以及<strong>循环依赖</strong>问题等）</li></ol><h2 id="如何理解IoC"><a href="#如何理解IoC" class="headerlink" title="如何理解IoC"></a>如何理解IoC</h2><h3 id="Spring-Bean是什么"><a href="#Spring-Bean是什么" class="headerlink" title="Spring Bean是什么"></a>Spring Bean是什么</h3><p>IoC Container管理的是Spring Bean， 那么Spring Bean是什么呢？</p><p>Spring里面的bean就类似是定义的一个组件，而这个组件的作用就是实现某个功能的，这里所定义的bean就相当于给了你一个更为简便的方法来调用这个组件去实现你要完成的功能。</p><h3 id="IoC是什么"><a href="#IoC是什么" class="headerlink" title="IoC是什么"></a>IoC是什么</h3><p>Ioc—Inversion of Control，即“控制反转”，<strong>不是什么技术，而是一种设计思想</strong>。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p><ul><li><strong>谁控制谁，控制什么？</strong><br>  传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建。<br>  谁控制谁？当然是IoC 容器控制了对象。<br>  控制什么？那就是主要控制了外部资源获取（不只是对象，包括比如文件等）。</li><li><strong>为何是反转，哪些方面反转了？</strong><br>  有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象。<br>  为何是反转？因为由容器帮我们查找及注入依赖对象，程序只是被动的接受容器中的依赖对象，所以是反转。<br>  哪些方面反转了？依赖对象的获取方式被反转了。</li><li>图例说明<ul><li>传统程序设计<br>  <img src="/posts/19065/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-%E4%BC%A0%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.png"></li><li>IoC DI<br>  <img src="/posts/19065/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-ioc%E5%AE%B9%E5%99%A8.png"></li></ul></li></ul><h3 id="Ioc能做什么"><a href="#Ioc能做什么" class="headerlink" title="Ioc能做什么"></a>Ioc能做什么</h3><p>IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。</p><p>传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试。</p><p>有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p><h3 id="IoC和DI是什么关系"><a href="#IoC和DI是什么关系" class="headerlink" title="IoC和DI是什么关系"></a>IoC和DI是什么关系</h3><p>控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是IoC是设计思想，DI是实现方式。</p><p>DI—Dependency Injection，即依赖注入：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。<br>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><ul><li><strong>谁依赖于谁？</strong><br>  应用程序依赖于IoC容器。</li><li><strong>为什么需要依赖？</strong><br>  应用程序需要IoC容器注入应用程序依赖的对象。</li><li><strong>谁注入谁？</strong><br>  IoC容器将应用程序所依赖的对象注入应用程序中。</li><li><strong>注入了什么？</strong><br>  注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</li><li><strong>IoC和DI有什么关系？</strong><br>  “依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。<br>  通俗来说就是IoC是设计思想，DI是实现方式。</li></ul><h2 id="IoC和DI的使用"><a href="#IoC和DI的使用" class="headerlink" title="IoC和DI的使用"></a>IoC和DI的使用</h2><h3 id="IoC配置的三种方式"><a href="#IoC配置的三种方式" class="headerlink" title="IoC配置的三种方式"></a>IoC配置的三种方式</h3><p>总体上目前的主流方式是 注解 + Java 配置。</p><h4 id="xml配置-古老"><a href="#xml配置-古老" class="headerlink" title="xml配置 - 古老"></a>xml配置 - 古老</h4><p>就是将bean的信息配置<code>.xml文件</code>里，通过Spring加载文件为我们创建bean。<br>这种方式出现很多早前的SSM项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是由于第三方类不支持Spring注解。</p><h4 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h4><p>将类的创建交给我们配置的JavcConfig类来完成，Spring只负责维护和管理，采用纯Java创建方式。<br>其本质上就是把在XML上的配置声明转移到Java配置类中。</p><ul><li>创建一个配置类， 添加@Configuration注解声明为配置类</li><li>创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDaoImpl <span class="title">userDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userService&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserServiceImpl <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>通过在类上加注解的方式，来声明一个类交给Spring管理。<br>Spring会自动扫描带有@Component、@Controller、@Service、@Repository这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器@ComponentScan。</p><h3 id="依赖注入的三种方式"><a href="#依赖注入的三种方式" class="headerlink" title="依赖注入的三种方式"></a>依赖注入的三种方式</h3><p>常用的注入方式主要有三种：构造方法注入（Construct注入），setter注入，基于注解的注入（接口注入）</p><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><p>在Spring3.x刚推出的时候，推荐使用注入的就是这种, 但是这种方式比较麻烦，所以在Spring4.x版本中推荐构造函数注入。</p><h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><p>在Spring4.x版本中推荐的注入方式就是这种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDaoImpl userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDaoImpl user dao impl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 这里@Autowired也可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(<span class="keyword">final</span> UserDaoImpl userDaoImpl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDaoImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find user list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么推荐构造器注入方式？</strong><br>构造器注入的方式能够保证注入的组件不可变，并且确保需要的依赖不为空。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。</p><ul><li>依赖不可变：其实说的就是final关键字。</li><li>依赖不为空（省去了我们对其检查）：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数-&gt;传入，OK 。2：无该类型的参数-&gt;报错。</li><li>完全初始化的状态：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。</li></ul><p>如果使用setter注入，缺点显而易见，对于IOC容器以外的环境，除了使用反射来提供它需要的依赖之外，无法复用该实现类。而且将一直是个潜在的隐患，因为你不调用将一直无法发现NPE的存在。</p><p><strong>循环依赖的问题</strong>：使用field注入可能会导致循环依赖，即A里面注入B，B里面又注入A。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用构造器注入，在spring项目启动的时候，就会抛出：BeanCurrentlyInCreationException：Requested bean is currently in creation: Is there an unresolvable circular reference？从而提醒你避免循环依赖，如果是field注入的话，启动的时候不会报错，在使用那个bean的时候才会报错。</p><p>实际上，Spring 5.x中使用@Autowired属性注入，发生循环依赖时，在SpringBootApplication启动时就会报循环依赖的错误。</p><h4 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h4><p><strong>@Autowired、@Resource、@Inject等注解注入有何区别？</strong></p><p>Spring对于@Autowired、@Resource注解使用不同的后置处理器进行处理。<br>Spring使用<strong>AutowiredAnnotationBeanPostProcessor</strong>和<strong>CommonAnnotationBeanPostProcessor</strong>类分别处理<code>@Autowired注解</code>和<code>@Resource注解</code>，它们都实现了InstantiationAwareBeanPostProcessor类，所以标注了@Autowired、@Resource会在第六次调用bean的后置处理器的时候完成属性注入。</p><p>对于static属性，如果标注了@Resource的是static静态的属性或方法，那么会直接报错；如果标注了@Autowired的是static静态的属性或方法，那么Spring会直接忽略，但不会报错。</p><ul><li><p>@Autowired</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Autowired可以用在这些地方</span></span><br><span class="line"><span class="meta">@Target(ElementType.CONSTRUCTOR)</span> #构造函数</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> #方法</span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span> #方法参数</span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量</span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span> #注解</span><br></pre></td></tr></table></figure><p>  @Autowired是Spring自带的注解，通过AutowiredAnnotationBeanPostProcessor类实现的依赖注入<br>  @Autowired可以作用在CONSTRUCTOR、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE<br>  @Autowired默认是根据类型（byType ）进行自动装配的<br>  如果有多个类型一样的Bean候选者，需要指定按照名称（byName ）进行装配，则需要配合@Qualifier。</p></li><li><p>@Resource</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Resource &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> #接口、类、枚举、注解</span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> #方法</span><br></pre></td></tr></table></figure><p>  @Resource是JSR250规范的实现，在javax.annotation包下<br>  @Resource可以作用TYPE、FIELD、METHOD上<br>  @Resource是默认根据属性名称进行自动装配的，如果有多个类型一样的Bean候选者，则可以通过name进行指定进行注入</p></li><li><p>@Inject</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; METHOD, CONSTRUCTOR, FIELD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inject &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.CONSTRUCTOR)</span> #构造函数</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> #方法</span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量</span><br></pre></td></tr></table></figure><p>  @Inject是JSR330 (Dependency Injection for Java)中的规范，需要导入javax.inject.Inject jar包，才能实现注入<br>  @Inject可以作用CONSTRUCTOR、METHOD、FIELD上<br>  @Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named</p></li></ul><h2 id="站在设计者的角度考虑设计IOC容器"><a href="#站在设计者的角度考虑设计IOC容器" class="headerlink" title="站在设计者的角度考虑设计IOC容器"></a>站在设计者的角度考虑设计IOC容器</h2><p>如果让你来设计一个IoC容器，你会怎么设计？我们初步的通过这个问题，来帮助我们更好的理解IOC的设计。</p><p>在设计时，首先需要考虑的是IOC容器的功能（输入和输出），初步的画出IOC容器的整体功能。<br><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%80%83%E8%99%91%E8%AE%BE%E8%AE%A1.png"></p><p>在此基础上，我们初步的去思考，如果作为一个IOC容器的设计者，主体上应该包含哪几个部分：</p><ul><li>加载Bean的配置（比如xml配置、注解配置等） <ul><li>比如不同类型资源的加载，解析成生成统一Bean的定义</li></ul></li><li>根据Bean的定义加载生成Bean的实例，并放置在Bean容器中 <ul><li>比如Bean的依赖注入，Bean的嵌套，Bean存放（缓存）等</li></ul></li><li>除了基础Bean外，还有常规针对企业级业务的特别Bean <ul><li>比如国际化Message，事件Event等生成特殊的类结构去支撑</li></ul></li><li>对容器中的Bean提供统一的管理和调用 <ul><li>比如用工厂模式管理，提供方法根据名字/类的类型等从容器中获取Bean</li></ul></li><li>…</li></ul><h2 id="IOC体系结构设计"><a href="#IOC体系结构设计" class="headerlink" title="IOC体系结构设计"></a>IOC体系结构设计</h2><h3 id="BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册"><a href="#BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册" class="headerlink" title="BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册"></a>BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册</h3><p>Spring Bean的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用，这是IOC容器的基础。<br>在顶层的结构设计主要围绕着BeanFactory和xxxRegistry进行：</p><ul><li>BeanFactory： 工厂模式定义了IOC容器的基本功能规范</li><li>BeanRegistry： 向IOC容器手工注册 BeanDefinition 对象的方法</li></ul><p><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-beanfactory&beanregistry.png"></p><p><strong>BeanFactory定义了IOC容器基本功能规范？</strong><br>BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范。<br>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和AutowireCapableBeanFactory。</p><p>看下BeanFactory接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//用于取消引用实例并将其与FactoryBean创建的bean区分开来。例如，如果命名的bean是FactoryBean，则获取将返回Factory，而不是Factory返回的实例。</span></span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>; </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//根据bean的名字或者Class类型等来得到bean实例    </span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;    </span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Class requiredType)</span> <span class="keyword">throws</span> BeansException</span>;    </span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回指定bean的Provider</span></span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查工厂中是否包含给定name的bean，或者外部注册的bean</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查所给定name的bean是否为单例/原型</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断所给name的类型与type是否匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取给定name的bean的类型</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回给定name的bean的别名</span></span><br><span class="line">    String[] getAliases(String name);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BeanFactory为何要定义这么多层次的接口？定义了哪些接口？</strong><br>主要是为了<strong>区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制</strong>。</p><ul><li><strong>ListableBeanFactory</strong><br>  该接口定义了访问容器中 Bean 基本信息的若干方法，如查看Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法；</li><li><strong>HierarchicalBeanFactory</strong><br>  父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器。<br>  通过 HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。<br>  Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</li><li><strong>ConfigurableBeanFactory</strong><br>  是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li><li><strong>ConfigurableListableBeanFactory</strong><br>  ListableBeanFactory 和 ConfigurableBeanFactory的融合；</li><li><strong>AutowireCapableBeanFactory</strong><br>  定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；</li></ul><p><strong>如何将Bean注册到BeanFactory中？BeanRegistry</strong><br>Spring 配置文件中每一个<code>&lt;bean&gt;</code>节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。</p><h3 id="BeanDefinition：各种Bean对象及其相互的关系"><a href="#BeanDefinition：各种Bean对象及其相互的关系" class="headerlink" title="BeanDefinition：各种Bean对象及其相互的关系"></a>BeanDefinition：各种Bean对象及其相互的关系</h3><p>Bean对象存在依赖嵌套等关系，所以设计者设计了BeanDefinition，它用来对Bean对象及关系定义。<br>我们在理解时只需要抓住如下三个要点：</p><ul><li>BeanDefinition 定义了各种Bean对象及其相互的关系</li><li>BeanDefinitionReader 这是BeanDefinition的解析器</li><li>BeanDefinitionHolder 这是BeanDefination的包装类，用来存储BeanDefinition、name以及aliases等。</li></ul><p>SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，在Spring实现中是以<strong>BeanDefinition</strong>来描述的，其继承体系如下：<br><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-BeanDefinition%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p><h3 id="ApplicationContext：IOC接口设计和实现"><a href="#ApplicationContext：IOC接口设计和实现" class="headerlink" title="ApplicationContext：IOC接口设计和实现"></a>ApplicationContext：IOC接口设计和实现</h3><p>IoC容器的接口类是ApplicationContext，很显然它必然继承BeanFactory对Bean规范（最基本的ioc容器的实现）进行定义。</p><p><strong>ApplicationContext表示的是应用的上下文</strong>，除了<strong>对Bean的管理</strong>外，还至少应该包含了</p><ul><li>访问资源： 对不同方式的Bean配置（即资源）进行加载。(实现ResourcePatternResolver接口)</li><li>国际化: 支持信息源，可以实现国际化。（实现MessageSource接口）</li><li>应用事件: 支持应用事件。(实现ApplicationEventPublisher接口)</li></ul><p><strong>ApplicationContext接口的设计</strong><br><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-ApplicationContext-%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1.png"></p><ul><li><strong>HierarchicalBeanFactory 和 ListableBeanFactory</strong><br>  ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能：</li><li><strong>ApplicationEventPublisher</strong><br>  让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。<br>  实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件，并对事件进行响应处理。<br>  在 ApplicationContext 抽象实现类AbstractApplicationContext 中，我们可以发现存在一个 ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。</li><li><strong>MessageSource</strong><br>  为应用提供 i18n 国际化消息访问的功能；</li><li><strong>ResourcePatternResolver</strong><br>  所有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。</li><li><strong>LifeCycle</strong><br>  该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。<br>  在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现，ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</li></ul><p><strong>ApplicationContext接口的实现</strong><br>在考虑ApplicationContext接口的实现时，关键的点在于，不同Bean的配置方式（比如xml、groovy、annotation等）有着不同的资源加载方式，这便衍生出了众多ApplicationContext的实现类。</p><p><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-ApplicationContext-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0.png"></p><ul><li>第一，从<strong>类结构设计</strong>上看，围绕着<strong>是否需要Refresh容器</strong>衍生出两个抽象类<ol><li><strong>GenericApplicationContext</strong><br> 初始化的时候就创建容器，往后的每次refresh都不会更改。</li><li><strong>AbstractRefreshableApplicationContext</strong><br> AbstractRefreshableApplicationContext及子类的每次refresh都是先清除已有(如果不存在就创建)的容器，然后再重新创建；<br> AbstractRefreshableApplicationContext及子类无法做到GenericApplicationContext混合搭配从不同源头获取bean的定义信息</li></ol></li><li>第二，从<strong>加载的源</strong>来看（比如xml、groovy、annotation等），衍生出众多类型的ApplicationContext<ul><li><strong>FileSystemXmlApplicationContext</strong><br>  从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说<strong>系统盘符中加载xml配置文件</strong>。</li><li><strong>ClassPathXmlApplicationContext</strong><br>  从<strong>类路径下的一个或多个xml配置文件</strong>中加载上下文定义，适用于<strong>xml配置</strong>的方式。</li><li><strong>AnnotationConfigApplicationContext</strong><br>  从一个或多个基于java的配置类中加载上下文定义，适用于<strong>java注解</strong>的方式。</li><li><strong>ConfigurableApplicationContext</strong><br>  扩展于 ApplicationContext，它新增加了两个主要的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。<br>  在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。<br>  这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。</li></ul></li></ul><p>设计者在设计时<strong>AnnotationConfigApplicationContext</strong>为什么是继承<strong>GenericApplicationContext</strong>？<br>因为基于注解的配置，是不太会被运行时修改的，这意味着不需要进行动态Bean配置和刷新容器，所以只需要GenericApplicationContext。</p><p>而基于XML这种配置文件，这种文件是容易修改的，需要动态性刷新Bean的支持，所以XML相关的配置必然继承AbstractRefreshableApplicationContext； 且存在多种xml的加载方式（位置不同的设计），所以必然会设计出AbstractXmlApplicationContext, 其中包含对XML配置解析成BeanDefination的过程。</p><p>为什么<strong>AnnotationWebConfigApplicationContext</strong>继承自<strong>AbstractRefreshableApplicationContext</strong>呢？<br>因为用户可以通过ApplicationContextInitializer来设置contextInitializerClasses（context-param / init-param），在这种情况下用户倾向于<strong>刷新Bean</strong>的，所以设计者选择让AnnotationWebConfigApplicationContext继承了AbstractRefreshableApplicationContext。</p><p>把之前的设计要点和设计结构结合起来看：<br><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9B%B8%E7%BB%93%E5%90%88.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-索引原理及慢查询优化</title>
      <link href="/posts/24905.html"/>
      <url>/posts/24905.html</url>
      
        <content type="html"><![CDATA[<p>基于MySQL InnoDB</p><p>索引对查询的速度有着至关重要的的影响，理解索引也是进行数据库性能调优的起点。<br>索引就是提高数据查询的效率的一种数据结构。</p><h2 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h2><h3 id="索引目的"><a href="#索引目的" class="headerlink" title="索引目的"></a>索引目的</h3><p>索引的目的在于提高查询效率。</p><p>可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。<br>如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p><h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。<br>它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p><p>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。</p><p>数据库应该选择怎么样的方式来应对所有的问题呢？<br>我们回想字典的例子，能不能把数据分成段，然后分段查询呢？<br>最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。<br>但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。</p><p>但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p><h3 id="磁盘IO与预读"><a href="#磁盘IO与预读" class="headerlink" title="磁盘IO与预读"></a>磁盘IO与预读</h3><p>前面提到了访问磁盘，那么这里先简单介绍一下磁盘IO和预读。</p><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。<br>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；<br>旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；<br>传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</p><p>那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p><p>下图是计算机硬件延迟的对比图，供大家参考：<br><a href="mysql-index-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%BB%B6%E8%BF%9F%E5%AF%B9%E6%AF%94%E5%9B%BE"></a></p><p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为<code>局部预读性原理</code>告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。<br>每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。<br>那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？<br>就这样，b+树应运而生。</p><h2 id="MySQL为什么使用B-TRee"><a href="#MySQL为什么使用B-TRee" class="headerlink" title="MySQL为什么使用B+TRee"></a>MySQL为什么使用B+TRee</h2><p>文件系统及数据库系统普通采用<code>B-/+Tree</code>作为索引结构。<br>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。<br>这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。<br>换句话说，<code>索引的结构要尽量减少查找过程中磁盘I/O的存取次数</code>。</p><h3 id="B树-VS-B-树"><a href="#B树-VS-B-树" class="headerlink" title="B树 VS B+树"></a>B树 VS B+树</h3><ul><li>B树<ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li></ol></li><li>B+树<ol><li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)。B+树只有叶子节点保存了data，时间复杂度固定为 O(log n)。</li><li>为所有叶子结点增加了一个链指针</li></ol></li></ul><h4 id="InnoDB-B-树的存储结构"><a href="#InnoDB-B-树的存储结构" class="headerlink" title="InnoDB B+树的存储结构"></a>InnoDB B+树的存储结构</h4><p>B+树的叶子节点和非叶子节点的大小为一页，16K。</p><ul><li>叶子节点存放<code>数据</code>，非叶子节点存放<code>指针和键值</code></li><li>主键索引：叶子节点存放真正的数据</li><li>二级索引：叶子节点存放主键索引的值</li></ul><p><img src="/posts/24905/innodb-b+.jpg"></p><h4 id="B-树如何检索记录"><a href="#B-树如何检索记录" class="headerlink" title="B+树如何检索记录"></a>B+树如何检索记录</h4><ul><li>首先找到根页，你怎么知道一张表的根页在哪呢？</li><li>其实每张表的根页位置在表空间文件中是固定的，即上图中page number=3的页</li><li>找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中</li><li>然后再去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录</li></ul><p>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据。</p><h3 id="MySQL-InnoDB存储引擎中B-树一个节点有多大？一千万条数据，B-树多高？"><a href="#MySQL-InnoDB存储引擎中B-树一个节点有多大？一千万条数据，B-树多高？" class="headerlink" title="MySQL InnoDB存储引擎中B+树一个节点有多大？一千万条数据，B+树多高？"></a>MySQL InnoDB存储引擎中B+树一个节点有多大？一千万条数据，B+树多高？</h3><h4 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h4><ol><li>数据持久化存储磁盘里，磁盘的最小单元是扇区，一个扇区的大小是 512个字节</li><li>文件系统的最小单元是块，一个块的大小是 4K</li><li>InnoDB存储引擎，有自己的最小单元，称之为页，一个页的大小是 16K</li></ol><h4 id="InnoDB引擎的页大小"><a href="#InnoDB引擎的页大小" class="headerlink" title="InnoDB引擎的页大小"></a>InnoDB引擎的页大小</h4><p>InnoDB存储引擎的最小存储单位是页，页的大小为<code>16K = 16384Byte</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_page_size&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/posts/24905/innodb-pagesize.jpg"></p><h4 id="叶子节点可以存放多少行数据"><a href="#叶子节点可以存放多少行数据" class="headerlink" title="叶子节点可以存放多少行数据"></a>叶子节点可以存放多少行数据</h4><p>单个叶子节点（也就是一页）的大小为16K。<br>一行记录的数据大小为数据表各字段的大小的和，假设为1K，叶子结点一页可以存放16行记录。</p><h4 id="非叶子节点可以存放多少指针"><a href="#非叶子节点可以存放多少指针" class="headerlink" title="非叶子节点可以存放多少指针"></a>非叶子节点可以存放多少指针</h4><p>单个非叶子节点的大小也为一页，16K。<br>非叶子节点存储<code>指针和键值</code>，假设主键为bigint类型，长度为8字节，指针大小在InnoDB中的大小为6字节，指针+键值一共14字节。<br>一个页中能够存放<code>16384 / 14 = 1170</code>个单元，这也是指针的个数。</p><h4 id="一颗B-树可以存放多少行记录"><a href="#一颗B-树可以存放多少行记录" class="headerlink" title="一颗B+树可以存放多少行记录"></a>一颗B+树可以存放多少行记录</h4><p>假设树高为k，B+树可存储的记录行数 = （非叶子节点的指针个数）的k-1次方 * 叶子节点的记录行数。</p><p>一行记录的数据大小为数据表各字段的大小的和，假设为1K；主键类型假设为bigint，长度为8字节。<br>三层高的B+树可以存储的记录行数为<code>1170 * 1170 * 16 = 21902400</code>，千万级。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="主键索引-VS-唯一索引-VS-普通索引"><a href="#主键索引-VS-唯一索引-VS-普通索引" class="headerlink" title="主键索引 VS 唯一索引 VS 普通索引"></a>主键索引 VS 唯一索引 VS 普通索引</h3><p>同一个叶子节点(大小为一个内存页或磁盘页，MySQL一页16KB)内的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到<code>装载因子(InnoDB默认为15/16)</code>，则开辟一个新的页(节点)。</p><ul><li><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。<br>这样就会形成一个紧凑的索引结构，近似顺序填满。<br>由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p></li><li><p>如果使用非自增主键(如果身份证号或uuid等)，由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置<br>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，<br>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，<br>后续不得不通过OPTIMIZE TABLE语句来重建表并优化填充页面。因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p></li></ul><h3 id="聚簇索引-VS-非聚簇索引"><a href="#聚簇索引-VS-非聚簇索引" class="headerlink" title="聚簇索引 VS 非聚簇索引"></a>聚簇索引 VS 非聚簇索引</h3><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>当某个索引的索引列覆盖了select的所有字段时，会使用到覆盖索引。<br>覆盖索引能够只通过索引就获取到所需要的数据而不需要在回表一条条的查询，同时由于索引是有顺序的，这样对于I/O密集型的范围查询效率也很高。</p><p>但是，往往我们很少能够遇到覆盖索引的情况，一般情况都是select的列会多于索引列，这样就无法使用到覆盖索引。</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引条件下推（Index Condition Pushdown，ICP），就是过滤的动作由下层的存储引擎层通过使用索引来完成，而不需要上推到Server层进行处理。<br>ICP是在 MySQL5.6 之后完善的功能，它能减少回表查询次数，提高查询效率。</p><p>MySQL Server层负责SQL语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。<br>索引下推的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。</p><p>索引下推一定是在<strong>联合索引</strong>的情况下，根据联合索引本身就有的数据直接做一次过滤，而不用再进行多次无用的回表再到Server层进行过滤。</p><h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><h3 id="建索引的原则"><a href="#建索引的原则" class="headerlink" title="建索引的原则"></a>建索引的原则</h3><ol><li>最左前缀匹配原则<br> mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配。<br> 比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序<br> 比如<code>a = 1 and b = 2 and c = 3</code>，建立(a,b,c)索引可以任意顺序，<strong>mysql的查询优化器会帮你优化成索引可以识别的形式</strong>。</li><li>尽量选择区分度高的列作为索引<br> 区分度的公式是<code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少。<br> 唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0。<br> 那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</li><li>索引列不能参与计算，保持列“干净”<br> 比如<code>from_unixtime(create_time) = ’2014-05-29’</code>就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</li><li>尽量的扩展索引，不要新建索引<br> 比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li></ol><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li><code>or</code>会导致索引失效，但是单列索引是有效的</li><li>不符合左前缀原则会失效</li><li>模糊查询%开头会导致失效</li><li>隐式类型转换会导致失效</li><li>条件中使用函数会失效</li><li>IN肯定会走索引，但是当IN的取值范围较大时会导致索引失效，走全表扫描</li></ul><h3 id="如何定位并优化慢查询sql"><a href="#如何定位并优化慢查询sql" class="headerlink" title="如何定位并优化慢查询sql"></a>如何定位并优化慢查询sql</h3><ul><li>第一步根据慢日志定位慢查询sql。慢日志是用来记录执行比较慢的sql。</li><li>第二步使用explain等工具分析sql。<br>  explain关键字段：rows、type、extra</li><li>第三步修改sql或者尽量让sql走索引。</li></ul><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><ul><li>id<br>  select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序：<ul><li>如果id相同，那么执行顺序从上到下</li><li>如果id不同，id值越大优先级越高，越先被执行</li></ul></li><li>select_type<br>  主要用来分辨查询的类型，是普通查询还是联合查询还是子查询<ul><li>SIMPLE    简单的 select 查询,查询中不包含子查询或者UNION</li><li>PRIMARY    查询中若包含任何复杂的子部分，最外层查询则被标记为Primary</li><li>SUBQUERY    在SELECT或WHERE列表中包含了子查询</li><li>DERIVED    在FROM列表中包含的子查询被标记为DERIVED(衍生);MySQL会递归执行这些子查询, 把结果放在临时表里。</li><li>UNION    若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</li><li>UNION RESULT    从UNION表获取结果的SELECT</li><li>DEPENDENT SUBQUERY    在SELECT或WHERE列表中包含了子查询,子查询基于外层</li><li>UNCACHEABLE SUBQUREY    无法被缓存的子查询</li></ul></li><li>table<br>  对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集<ul><li>如果是具体的表名，则表明从实际的物理表中获取数据</li><li>表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</li><li>当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</li></ul></li><li>partitions</li><li>type （2）<br>  访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下。<br>  访问的类型有很多，效率从最好到最坏依次是：<br>  <code>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code><br>  必须记住<code>const &gt; ref &gt; range &gt; index &gt; all</code>。<br>  一般情况下，得保证查询至少达到range级别，最好能达到ref。<ul><li>ALL                全表扫描</li><li>index              索引树全扫描</li><li>range              索引范围扫描，常用语&lt;,&lt;=,&gt;=,between等操作</li><li>ref                使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</li><li>eq_ref             类似ref，区别在于使用的是唯一索引，使用主键的关联查询</li><li>const/system       单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询</li><li>null               MySQL不访问任何表或索引，直接返回结果</li></ul></li><li>possible_keys<br>  显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</li><li>key （4）<br>  实际使用的索引。<br>  如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</li><li>key_len<br>  表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</li><li>ref<br>  显示索引的哪一列被使用了，如果可能的话，是一个常数</li><li>rows （1）<br>  根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好。<br>  rows是核心指标，绝大部分rows小的语句执行一定很快，所以优化语句基本上都是在优化rows。</li><li>filtered</li><li>extra （3）<br>  包含额外的信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/posts/1079.html"/>
      <url>/posts/1079.html</url>
      
        <content type="html"><![CDATA[<h2 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程间的五种通讯方式"><a href="#进程间的五种通讯方式" class="headerlink" title="进程间的五种通讯方式"></a>进程间的五种通讯方式</h4><ol><li>管道pipe</li><li>FIFO(有名管道)</li><li>消息队列</li><li>信号量</li><li>共享内存</li><li>套接字socket</li><li>文件和记录锁定(UNIX中)</li></ol><h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——RabbitMQ</title>
      <link href="/posts/28776.html"/>
      <url>/posts/28776.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/28776/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="消息队列发展史"><br><img src="/posts/28776/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.jpeg" alt="主流消息队列对比"></p><h2 id="一、RabbitMQ简介"><a href="#一、RabbitMQ简介" class="headerlink" title="一、RabbitMQ简介"></a>一、RabbitMQ简介</h2><p>MQ全称是Message Queue，可以理解为消息队列的意思，简单来说就是消息以<strong>管道</strong>的方式进行传递。</p><h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><p>我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ，我们后面会一一对比这些消息队列。<br>另外，我们知道队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者发送消息1,2,3…对于消费者就会按照1,2,3…的顺序来消费。但是偶尔也会出现消息被消费的顺序不对的情况，比如某个消息消费失败又或者一个 queue 多个consumer 也会导致消息被消费的顺序不对，我们一定要保证消息被消费的顺序正确。<br>除了上面说的消息消费顺序的问题，使用消息队列，我们还要考虑如何保证消息不被重复消费？如何保证消息的可靠性传输（如何处理消息丢失的问题）？……等等问题。所以说使用消息队列也不是十全十美的，使用它也会让系统可用性降低、复杂度提高，另外需要我们保障一致性等问题。</p><p>RabbitMQ是一个实现了AMQP(Advanced Message Queuing Protocol)高级消息队列协议的消息队列服务，用Erlang语言实现的。</p><h2 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h2><p>在我们秒杀抢购商品的时候，系统会提醒我们稍等排队中，而不是页面卡死或报错给用户。<br>像这种排队结算就用到了消息队列机制，放入通道里面一个一个结算处理，而不是某个时间段突然涌入大批量的查询新增把数据库给搞宕机，所以RabbitMQ本质上起到的作用就是削峰，为业务保驾护航。<br>在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。</p><h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><ul><li><p>通过异步处理提高系统性能（削峰、减少响应所需时间）<br>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。<br>消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。<br>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，</strong>以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p></li><li><p>降低系统耦合性<br>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。<br>我们最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。<br>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<br>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。<br>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。<br>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p></li><li><p>不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。 另外，这两种消息模型是JMS提供的，AMQP协议还提供了5种消息模型。</p></li></ul><h3 id="使用消息队列带来的一些问题"><a href="#使用消息队列带来的一些问题" class="headerlink" title="使用消息队列带来的一些问题"></a>使用消息队列带来的一些问题</h3><ul><li>系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！</li><li>系统复杂性提高： 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li>一致性问题： 上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><h2 id="三、JMS对比AMQP"><a href="#三、JMS对比AMQP" class="headerlink" title="三、JMS对比AMQP"></a>三、JMS对比AMQP</h2><h3 id="3-1-JMS"><a href="#3-1-JMS" class="headerlink" title="3.1 JMS"></a>3.1 JMS</h3><h4 id="3-1-1-JMS简介"><a href="#3-1-1-JMS简介" class="headerlink" title="3.1.1 JMS简介"></a>3.1.1 JMS简介</h4><p>JMS（JAVA Message Service,java消息服务）是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。JMS（JAVA Message Service，Java消息服务）API是一个消息服务的标准或者说是规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。<br>ActiveMQ 就是基于 JMS 规范实现的。</p><h4 id="3-1-2-JMS两种消息模型"><a href="#3-1-2-JMS两种消息模型" class="headerlink" title="3.1.2 JMS两种消息模型"></a>3.1.2 JMS两种消息模型</h4><ol><li>点到点模型(P2P)<br>使用队列（Queue）作为消息通信载体；满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</li><li>发布/订阅模型(Pub/Sub)<br>发布订阅模型（Pub/Sub） 使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。</li></ol><h4 id="3-1-3-JMS五种不同的消息正文格式"><a href="#3-1-3-JMS五种不同的消息正文格式" class="headerlink" title="3.1.3 JMS五种不同的消息正文格式"></a>3.1.3 JMS五种不同的消息正文格式</h4><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p><ul><li>StreamMessage – Java原始值的数据流</li><li>MapMessage–一套名称-值对</li><li>TextMessage–一个字符串对象</li><li>ObjectMessage–一个序列化的 Java对象</li><li>BytesMessage–一个字节的数据流</li></ul><h3 id="3-2-AMQP"><a href="#3-2-AMQP" class="headerlink" title="3.2 AMQP"></a>3.2 AMQP</h3><h4 id="3-2-1-AMQP简介"><a href="#3-2-1-AMQP简介" class="headerlink" title="3.2.1 AMQP简介"></a>3.2.1 AMQP简介</h4><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。<br>RabbitMQ 就是基于 AMQP 协议实现的。</p><h4 id="3-2-2-五种消息模型"><a href="#3-2-2-五种消息模型" class="headerlink" title="3.2.2 五种消息模型"></a>3.2.2 五种消息模型</h4><ol><li>direct exchange</li><li>fanout exchange</li><li>topic exchange</li><li>headers exchange</li><li>system exchange</li></ol><h3 id="3-3-JMS对比AMQP"><a href="#3-3-JMS对比AMQP" class="headerlink" title="3.3 JMS对比AMQP"></a>3.3 JMS对比AMQP</h3><ul><li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。</li><li>JMS支持TextMessage、MapMessage等复杂的消息类型；而AMQP仅支持byte[]消息类型（复杂的类型可序列化后发送）。</li><li>由于Exchange提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而JMS仅支持队列和主题/订阅方式两种。</li></ul><h2 id="四、常见的消息队列对比"><a href="#四、常见的消息队列对比" class="headerlink" title="四、常见的消息队列对比"></a>四、常见的消息队列对比</h2><ol><li><strong>吞吐量：</strong>万级的ActiveMQ和RabbitMQ的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的RocketMQ和Kafka低一个数量级。</li><li><strong>可用性：</strong>都可以实现高可用。ActiveMQ和RabbitMQ都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。kafka也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用。</li><li><strong>时效性：</strong>RabbitMQ基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是ms级。</li><li><strong>功能支持：</strong>支持    除了Kafka，其他三个功能都较为完备。Kafka功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准。</li><li><strong>消息丢失：</strong>ActiveMQ和RabbitMQ丢失的可能性非常低，RocketMQ和Kafka理论上不会丢失。<br>总结：</li></ol><ul><li>ActiveMQ的社区算是比较成熟，但是较目前来说，ActiveMQ的性能比较差，而且版本迭代很慢，不推荐使用。</li><li>RabbitMQ在吞吐量方面虽然稍逊于Kafka和RocketMQ，但是由于它基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为RabbitMQ基于erlang开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li><li>RocketMQ阿里出品，Java系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且RocketMQ有阿里巴巴的实际业务场景的实战考验。RocketMQ社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的。</li><li>kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量。kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li></ul><p>参考：《Java工程师面试突击第1季-中华石杉老师》</p><h2 id="RabbitMQ核心概念"><a href="#RabbitMQ核心概念" class="headerlink" title="RabbitMQ核心概念"></a>RabbitMQ核心概念</h2><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。<br><img src="/posts/28776/rabbitmq.jpg" alt="RabbitMQ整体模型架构"></p><h3 id="1-Producer-生产者-和Consumer-消费者"><a href="#1-Producer-生产者-和Consumer-消费者" class="headerlink" title="1. Producer(生产者)和Consumer(消费者)"></a>1. Producer(生产者)和Consumer(消费者)</h3><ul><li>Producer(生产者) :生产消息的一方（邮件投递者）</li><li>Consumer(消费者) :消费消息的一方（邮件收件人）<br>消息一般由 2 部分组成：消息头（或者说是标签 Label）和 消息体。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</li></ul><h3 id="2-Exchange-交换器"><a href="#2-Exchange-交换器" class="headerlink" title="2. Exchange(交换器)"></a>2. Exchange(交换器)</h3><p>在 RabbitMQ 中，消息并不是直接被投递到 Queue(消息队列) 中的，中间还必须经过 Exchange(交换器) 这一层，Exchange(交换器) 会把我们的消息分配到对应的 Queue(消息队列) 中。<br>Exchange(交换器) 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 Producer(生产者) ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。<br>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略：direct(默认)，fanout, topic, 和 headers，不同类型的Exchange转发消息的策略有所区别。<br><img src="/posts/28776/exchange.jpg"><br>生产者将消息发给交换器的时候，一般会指定一个 RoutingKey(路由键)，用来指定这个消息的路由规则，而这个 RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。<br>RabbitMQ 中通过 Binding(绑定) 将 Exchange(交换器) 与 Queue(消息队列) 关联起来，在绑定的时候一般会指定一个 BindingKey(绑定建) ,这样 RabbitMQ 就知道如何正确将消息路由到队列了。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。<br><img src="/posts/28776/bind.jpg"><br>生产者将消息发送给交换器时，需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p><h3 id="3-Queue-消息队列"><a href="#3-Queue-消息队列" class="headerlink" title="3. Queue(消息队列)"></a>3. Queue(消息队列)</h3><p>Queue(消息队列) 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。<br>RabbitMQ 中消息只能存储在 队列 中，这一点和 Kafka 这种消息中间件相反。Kafka 将消息存储在 topic（主题） 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。<br>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。<br>RabbitMQ 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p><h3 id="4-Broker-消息中间件的服务节点"><a href="#4-Broker-消息中间件的服务节点" class="headerlink" title="4. Broker(消息中间件的服务节点)"></a>4. Broker(消息中间件的服务节点)</h3><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。<br><img src="/posts/28776/liucheng.jpg"></p><h3 id="5-Exchange-Types-交换器类型"><a href="#5-Exchange-Types-交换器类型" class="headerlink" title="5. Exchange Types(交换器类型)"></a>5. Exchange Types(交换器类型)</h3><ol><li>fanout：fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</li><li>direct：direct 类型的Exchange路由规则也很简单，一对一的匹配，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。<br><img src="/posts/28776/direct.jpg"><br>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为”Info”或者”debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。<br>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</li><li>topic：direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：<ul><li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li><li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li><li>BindingKey 中可以存在两种特殊字符串“”和“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li></ul></li><li>headers：headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)’对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</li></ol><h3 id="6-RoutingKey-路由键-和BindingKey-绑定键"><a href="#6-RoutingKey-路由键-和BindingKey-绑定键" class="headerlink" title="6. RoutingKey(路由键)和BindingKey(绑定键)"></a>6. RoutingKey(路由键)和BindingKey(绑定键)</h3><p>RoutingKey（路由键）：用于把生成者的数据分配到交换器上；<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上；</p><h2 id="消息发送原理"><a href="#消息发送原理" class="headerlink" title="消息发送原理"></a>消息发送原理</h2><p>首先你必须连接到Rabbit才能发布和消费消息，那怎么连接和发送消息的呢？<br>你的应用程序和Rabbit Server之间会创建一个TCP连接，一旦TCP打开，并通过了认证，认证就是你试图连接Rabbit之前发送的Rabbit服务器连接信息和用户名和密码，有点像程序连接数据库，使用Java有两种连接认证的方式，后面代码会详细介绍，一旦认证通过你的应用程序和Rabbit就创建了一条AMQP信道（Channel）。<br>信道是创建在“真实”TCP上的虚拟连接，AMQP命令都是通过信道发送出去的，每个信道都会有一个唯一的ID，不论是发布消息，订阅队列或者介绍消息都是通过信道完成的。</p><h4 id="为什么不通过TCP直接发送命令？"><a href="#为什么不通过TCP直接发送命令？" class="headerlink" title="为什么不通过TCP直接发送命令？"></a>为什么不通过TCP直接发送命令？</h4><p>对于操作系统来说创建和销毁TCP会话是非常昂贵的开销，假设高峰期每秒有成千上万条连接，每个连接都要创建一条TCP会话，这就造成了TCP连接的巨大浪费，而且操作系统每秒能创建的TCP也是有限的，因此很快就会遇到系统瓶颈。<br>如果我们每个请求都使用一条TCP连接，既满足了性能的需要，又能确保每个连接的私密性，这就是引入信道概念的原因。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/posts/27273.html"/>
      <url>/posts/27273.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis，英文全称是Remote Dictionary Server（远程字典服务），Key-Value数据库。</p><p>可用于缓存，事件发布或订阅，高速队列等场景。<br>提供字符串、哈希、列表、队列、集合结构直接存取，基于内存，可持久化。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>热点数据的缓存</li><li>限时业务的运用<br>  redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。</li><li>计数器相关问题<br>  redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成。<br>  具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</li><li>分布式锁<br>  这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存，同时返回1，否则返回0 。<br>  这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。<br>  当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。<br>  在分布式锁的场景中，主要用在比如秒杀系统等。</li><li>延时操作<br>  比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。<br>  由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。<br>  所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期，我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。<br>  当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</li><li>排行榜相关问题<br>  关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。<br>  比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息。</li><li>点赞、好友等相互关系的存储<br>  Redis 利用集合的一些命令，比如求交集、并集、差集等。</li><li>简单队列<br>  由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。</li></ul><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h3 id="为什么单线程的Redis可以支持高并发访问？"><a href="#为什么单线程的Redis可以支持高并发访问？" class="headerlink" title="为什么单线程的Redis可以支持高并发访问？"></a>为什么单线程的Redis可以支持高并发访问？</h3><ul><li>为什么Redis选择单线程的实现方式<ol><li>redis是基于内存的，内存的读写速度非常快。CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽；</li><li>核心是基于非阻塞的IO多路复用机制；</li><li>redis是单线程的，反而省去了很多上下文切换线程的时间，避免了多线程的实现复杂度；</li></ol></li><li>为什么Redis能支持高并发访问<br>  从IO模型角度来说，Redis使用的是IO多路复用模型，使得它可以在网络IO操作并发处理数十万的客户端网络连接，实现非常高的网络吞吐率。<br>  这也是Redis可以实现高并发访问的最主要的原因。</li></ul><h2 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h2><h3 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h3><p>所谓redis的并发竞争key的问题也就是多个系统同时对一个key进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。</p><p>解决方案：分布式锁(zookeeper和redis都可以实现分布式锁)。如果不存在redis的并发竞争key问题，不要使用分布式锁，这样会影响性能。</p><p>基于zookeeper临时有序节点可以实现的分布式锁。<br>大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务器宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>只要使用缓存，就可能会涉及到缓存与数据库双存储双写，只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><h2 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h2><p>Redis内部使用<code>文件事件处理器 file event handler</code>，这个文件事件处理器是<code>单线程</code>的，所以redis才叫做单线程的模型。<br>Redis的线程模型是基于单Reactor单线程模型实现。</p><p><img src="/posts/27273/redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png"></p><p>文件事件处理器的结构包含4个部分：</p><ul><li>多个socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)</li></ul><p><strong>文件事件处理器采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。</strong><br>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h3 id="Redis的IO多路复用"><a href="#Redis的IO多路复用" class="headerlink" title="Redis的IO多路复用"></a>Redis的IO多路复用</h3><p>Redis的多路IO复用模型核心思想就是<strong>IO多路复用+事件派发</strong>，有事件发生了，通过事件派发器将其交给不同的处理器进行处理。</p><h3 id="Redis-6-0的多线程"><a href="#Redis-6-0的多线程" class="headerlink" title="Redis 6.0的多线程"></a>Redis 6.0的多线程</h3><p>Redis的瓶颈主要在 IO 而不是 CPU，所以为了省开发量，在6.0版本前是单线程模型；其次，<strong>Redis 是单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程</strong>。（但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的）。</p><p>Redis 6.0版本中引入了多线程，目的是为了提高IO读写效率，因此在解析客户端命令和写响应结果时采用了多线程。<br>核心的读写命令执行和IO多路复用模块依然是由主线程执行：<br><img src="/posts/27273/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-6.0%E7%89%88%E6%9C%AC.png"></p><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><ul><li>5种基础类型<ul><li>String 字符串</li><li>Hash 哈希</li><li>List 列表</li><li>Set 集合</li><li>Sorted Set 有序集合</li></ul></li><li>3种特殊类型<ul><li>Bitmap 位图</li><li>HyperLogLog 基数统计</li><li>Geospatial 地理位置</li></ul></li><li>Stream类型 v5.0</li></ul><p><img src="/posts/27273/redis-5%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpeg"></p><h3 id="基本数据类型-1-String-字符串"><a href="#基本数据类型-1-String-字符串" class="headerlink" title="基本数据类型 1.String 字符串"></a>基本数据类型 1.String 字符串</h3><blockquote><p>String是redis中最基本的数据类型，一个key对应一个value。</p></blockquote><p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。<br>Redis中string(字符串)是动态字符串，允许修改,，可以对字符串进行操作，比如增加字符或者求子串：如果是整数或者浮点数，可以实现计算，比如自增等<br>string类型是Redis最基本的数据结构，一个redis中字符串value最多可以是512M。</p><table><thead><tr><th align="left">命令</th><th align="left">简述</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">获取存储在给定键中的值</td><td align="left">GET name</td></tr><tr><td align="left">SET</td><td align="left">设置存储在给定键中的值</td><td align="left">SET name value</td></tr><tr><td align="left">DEL</td><td align="left">删除存储在给定键中的值</td><td align="left">DEL name</td></tr><tr><td align="left">INCR</td><td align="left">将键存储的值加1</td><td align="left">INCR key</td></tr><tr><td align="left">DECR</td><td align="left">将键存储的值减1</td><td align="left">DECR key</td></tr><tr><td align="left">INCRBY</td><td align="left">将键存储的值加上整数</td><td align="left">INCRBY key amount</td></tr><tr><td align="left">DECRBY</td><td align="left">将键存储的值减去整数</td><td align="left">DECRBY key amount</td></tr></tbody></table><h3 id="基本数据类型-2-Hash-哈希"><a href="#基本数据类型-2-Hash-哈希" class="headerlink" title="基本数据类型 2.Hash 哈希"></a>基本数据类型 2.Hash 哈希</h3><blockquote><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p></blockquote><table><thead><tr><th align="left">命令</th><th align="left">简述</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">HSET</td><td align="left">添加键值对</td><td align="left">HSET hash-key sub-key1 value1</td></tr><tr><td align="left">HGET</td><td align="left">获取指定散列键的值</td><td align="left">HGET hash-key key1</td></tr><tr><td align="left">HGETALL</td><td align="left">获取散列中包含的所有键值对</td><td align="left">HGETALL hash-key</td></tr><tr><td align="left">HDEL</td><td align="left">如果给定键存在于散列中，那么就移除这个键</td><td align="left">HDEL hash-key sub-key1</td></tr></tbody></table><h3 id="基本数据类型-3-List-列表"><a href="#基本数据类型-3-List-列表" class="headerlink" title="基本数据类型 3.List 列表"></a>基本数据类型 3.List 列表</h3><blockquote><p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p></blockquote><table><thead><tr><th align="left">命令</th><th align="left">简述</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">RPUSH</td><td align="left">将给定值推入到列表右端</td><td align="left">RPUSH key value</td></tr><tr><td align="left">LPUSH</td><td align="left">将给定值推入到列表左端</td><td align="left">LPUSH key value</td></tr><tr><td align="left">RPOP</td><td align="left">从列表的右端弹出一个值，并返回被弹出的值</td><td align="left">RPOP key</td></tr><tr><td align="left">LPOP</td><td align="left">从列表的左端弹出一个值，并返回被弹出的值</td><td align="left">LPOP key</td></tr><tr><td align="left">LRANGE</td><td align="left">获取列表在给定范围上的所有值</td><td align="left">LRANGE key 0 -1</td></tr><tr><td align="left">LINDEX</td><td align="left">通过索引获取列表中的元素。也可以使用负数下标，以-1表示列表的最后一个元素，-2表示列表的倒数第二个元素，以此类推。</td><td align="left">LINDEX key index</td></tr></tbody></table><ul><li>lpush+lpop=Stack(栈)</li><li>lpush+rpop=Queue（队列）</li><li>lpush+ltrim=Capped Collection（有限集合）</li><li>lpush+brpop=Message Queue（消息队列）</li></ul><h3 id="基本数据类型-4-Set-集合"><a href="#基本数据类型-4-Set-集合" class="headerlink" title="基本数据类型 4.Set 集合"></a>基本数据类型 4.Set 集合</h3><blockquote><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p></blockquote><table><thead><tr><th align="left">命令</th><th align="left">简述</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">SADD</td><td align="left">向集合添加一个或多个成员</td><td align="left">SADD key value</td></tr><tr><td align="left">SCARD</td><td align="left">获取集合的成员数</td><td align="left">SCARD key</td></tr><tr><td align="left">SMEMBERS</td><td align="left">返回集合中的所有成员</td><td align="left">SMEMBERS key member</td></tr><tr><td align="left">SISMEMBER</td><td align="left">判断 member 元素是否是集合 key 的成员</td><td align="left">SISMEMBER key member</td></tr></tbody></table><h3 id="基本数据类型-5-Sorted-Set-有序集合"><a href="#基本数据类型-5-Sorted-Set-有序集合" class="headerlink" title="基本数据类型 5.Sorted Set 有序集合"></a>基本数据类型 5.Sorted Set 有序集合</h3><blockquote><p>Redis 有序集合，和集合一样也是 string 类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p></blockquote><p>有序集合的成员是唯一的, 但分数(score)却可以重复。<br>有序集合是通过两种数据结构实现：</p><ul><li>压缩列表(ziplist)<br>  ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。<br>  它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。<br>  它能在O(1)的时间复杂度下完成list两端的push和pop操作。<br>  但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li><li>跳跃表（zSkiplist）<br>  跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。<br>  跳跃表的复杂度是O(log(n))。</li></ul><table><thead><tr><th align="left">命令</th><th align="left">简述</th><th align="left">使用</th></tr></thead><tbody><tr><td align="left">ZADD</td><td align="left">将一个带有给定分值的成员添加到有序集合里面</td><td align="left">ZADD zset-key 178 member1</td></tr><tr><td align="left">ZRANGE</td><td align="left">根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td><td align="left">ZRANGE zset-key 0-1 withccores</td></tr><tr><td align="left">ZREM</td><td align="left">如果给定元素成员存在于有序集合中，那么就移除这个元素</td><td align="left">ZREM zset-key member1</td></tr></tbody></table><h3 id="特殊类型-6-Bitmaps"><a href="#特殊类型-6-Bitmaps" class="headerlink" title="特殊类型 6.Bitmaps"></a>特殊类型 6.Bitmaps</h3><blockquote><p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0和1两个状态。</p></blockquote><p>在平时开发过程中，经常会有一些 bool 类型数据需要存取。比如记录用户一年内签到的次数，签了是 1，没签是 0。如果使用 key-value 来存储，那么每个用户都要记录 365 次，当用户成百上亿时，需要的存储空间将非常巨大。为了解决这个问题，可以考虑Redis提供的位图结构。</p><p>位图（bitmap）同样属于 string 数据类型。Redis 中一个字符串类型的值最多能存储 512 MB 的内容，每个字符串由多个字节组成，每个字节又由 8 个 Bit 位组成。位图结构正是使用<strong>位</strong>来实现存储的，它通过将比特位设置为0或1来达到数据存取的目的，这大大增加了 value 存储数量，它存储上限为2^32 。<br>位图本质上就是一个普通的字节串，也就是 bytes 数组。</p><h3 id="特殊类型-7-HyperLogLog"><a href="#特殊类型-7-HyperLogLog" class="headerlink" title="特殊类型 7.HyperLogLog"></a>特殊类型 7.HyperLogLog</h3><blockquote><p>Redis 2.8.9 版本更新了 Hyperloglog 数据结构，用来做基数统计！<br>基数定义：一个集合中不重复的元素个数就表示该集合的基数，比如集合{1,2,3,1,2}，它的基数集合为 {1,2,3}，所以基数为 3。<br>HyperLogLog 是通过基数估计算法来统计输入元素的基数。</p></blockquote><p>HyperLoglog 采用了一种基数估计算法，因此，最终得到的结果会存在一定范围的误差（标准误差为 0.81%）。每个 HyperLogLog key 只占用 12 KB 内存，所以理论上可以存储大约2^64个值，而 set（集合）则是元素越多占用的内存就越多，两者形成了鲜明的对比。</p><ul><li>PFADD key element [element …]             添加指定元素到 HyperLogLog key 中。</li><li>PFCOUNT key [key …]                         返回指定 HyperLogLog key 的基数估算值。</li><li>PFMERGE destkey sourcekey [sourcekey …]     将多个 HyperLogLog key 合并为一个 key。</li><li>hyperloglog 只统计基数数量，不在内部存储数据，所以无法判断元素是否存在（因此不能提供contains、exist方法）。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>最典型的应用场景就是统计网站用户月活量，或者网站页面的UV(网站独立访客)数据等。<br>UV 与 PV(页面浏览量) 不同，UV 需要去重，同一个用户一天之内的多次访问只能计数一次。这就要求用户的每一次访问都要带上自身的用户 ID，无论是登陆用户还是未登陆用户都需要一个唯一ID来标识。<br>当一个网站拥有巨大的用户访问量时，我们可以使用 Redis 的 HyperLogLog 来统计网站的 UV（网站独立访客）数据，它提供的去重计数方案，虽说不精确，但 0.81% 的误差足以满足 UV 统计的需求。</p><h3 id="特殊类型-8-Geospatial"><a href="#特殊类型-8-Geospatial" class="headerlink" title="特殊类型 8.Geospatial"></a>特殊类型 8.Geospatial</h3><blockquote><p>在 Redis 3.2 版本中，新增了存储地理位置信息的功能，即 GEO（英文全称 geographic）。</p></blockquote><ul><li>GEOADD    将指定的地理空间位置（纬度、经度、名称）添加到指定的 key 中。</li><li>GEOPOS    从 key 里返回所有给定位置元素的位置（即经度和纬度）</li><li>GEODIST    返回两个地理位置间的距离，如果两个位置之间的其中一个不存在， 那么命令返回空值。</li><li>GEORADIUS    根据给定地理位置坐标(经纬度)获取指定范围内的地理位置集合。</li><li>GEORADIUSBYMEMBER    根据给定地理位置(具体的位置元素)获取指定范围内的地理位置集合。</li><li>GEOHASH    获取一个或者多个的地理位置的 GEOHASH 值。</li><li>ZREM    通过有序集合的 zrem 命令实现对地理位置信息的删除。</li></ul><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>举一个简单的例子，外卖以及打车软件，在这种 APP上会显示“店家距离你有多少米”或者“司机师傅距离你有多远”，类似这种功能就可以使用 Redis GEO 实现。数据库中存放着商家所处的经纬度，你的位置则由手机定位获取，这样 APP 就计算出了最终的距离。<br>再比如微信中附近的人、摇一摇、实时定位等功能都依赖地理位置实现。</p><h3 id="Stream类型"><a href="#Stream类型" class="headerlink" title="Stream类型"></a>Stream类型</h3><blockquote><p>Redis5.0中增加了一个数据类型Stream，它借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的消息队列。</p></blockquote><h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><blockquote><p>为什么需要持久化？<br>Redis是个基于内存的数据库。服务一旦宕机，内存中的数据将全部丢失。<br>通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复，1、会对数据库带来巨大的压力，2、数据库的性能不如Redis，导致程序响应慢。<br>所以对Redis来说，实现数据的持久化，避免从后端数据库中恢复数据，是至关重要的。</p></blockquote><h3 id="RDB-Redis-DataBase-持久化"><a href="#RDB-Redis-DataBase-持久化" class="headerlink" title="RDB(Redis DataBase)持久化"></a>RDB(Redis DataBase)持久化</h3><p>RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。</p><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><ul><li><p>手动触发</p><ul><li>save命令<br>  阻塞当前Redis服务器，直到RDB过程完成为止。<br>  对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</li><li>bgsave命令<br>  Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。<br>  阻塞只发生在fork阶段，一般时间很短。</li></ul></li><li><p>自动触发</p><ul><li><code>redis.conf</code>中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</li><li>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</li><li>执行debug reload命令重新加载redis时也会触发bgsave操作；</li><li>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；</li></ul></li></ul><h4 id="redis-conf中配置RDB"><a href="#redis-conf中配置RDB" class="headerlink" title="redis.conf中配置RDB"></a>redis.conf中配置RDB</h4><ul><li>Redis中默认的周期性设置  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 周期性执行条件的设置格式为</span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"># 默认的设置为：</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"># 以下设置方式为关闭RDB快照功能</span><br><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure></li><li>其它相关配置  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># RDB文件在磁盘上的名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 文件保存路径</span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"># 如果持久化出错，主进程是否停止写入</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"># 是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 导入时是否检查</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure></li></ul><h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul><li>优点<ul><li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li><li>Redis加载RDB文件恢复数据要远远快于AOF方式；</li></ul></li><li>缺点<ul><li>RDB方式实时性不够，无法做到秒级的持久化；</li><li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li><li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li><li>版本兼容RDB文件问题；</li></ul></li></ul><h4 id="RDB深入理解：Copy-on-Write"><a href="#RDB深入理解：Copy-on-Write" class="headerlink" title="RDB深入理解：Copy-on-Write"></a>RDB深入理解：Copy-on-Write</h4><blockquote><p>由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢？</p></blockquote><p>RDB中的核心思路是<strong>Copy-on-Write（写时复制）</strong>，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。<br>在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。<br><img src="/posts/27273/redis-rdb-cow.jpg"></p><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决</p><h3 id="AOF-append-only-file-持久化"><a href="#AOF-append-only-file-持久化" class="headerlink" title="AOF(append-only file)持久化"></a>AOF(append-only file)持久化</h3><blockquote><p><strong>Redis是写后日志，Redis先执行命令，把数据写入内存，然后才记录日志</strong>。<br>日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。<br>PS: 大多数的<strong>数据库采用的是写前日志（Write Ahead Log，WAL），例如MySQL</strong>，通过写前日志和两阶段提交，实现数据和逻辑的一致性。</p></blockquote><p>AOF日志采用写后日志，即<code>先写内存，后写日志</code>。</p><ul><li><strong>为什么MySQL是日志先行？</strong><ul><li>首先区分MySQL的日志类型：InnoDB引擎层的undo log和redo log，Server层的binlog</li><li>InnoDB插入一条数据先写到Buffer pool中，并不立即刷盘，所以要先写redo log日志保证持久化，事务提交成功之后写入binlog。数据刷入磁盘后会将redo log中的记录删除，redo log只保存没有落盘的数据。</li><li>MySQL在server层会对sql语句进行合法性检查，记入日志中的sql语句一定是没有错误的。</li></ul></li><li><strong>Redis为什么先执行命令再写日志？</strong><ul><li>Redis没有预检测，在执行时才知道命令是否正确，正确执行之后再写日志。</li><li>Redis的AOF持久化日志的定位与MySQL的定位的区别。</li><li>Redis是基于内存的，先修改到内存再持久化命令到日志文件。</li></ul></li></ul><h4 id="如何实现AOF"><a href="#如何实现AOF" class="headerlink" title="如何实现AOF"></a>如何实现AOF</h4><p>AOF日志记录Redis的每个写命令，步骤分为：<strong>命令追加（append）</strong>、<strong>文件写入（write）</strong>和<strong>文件同步（sync）</strong>。</p><ul><li><strong>命令追加</strong><br>  当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</li><li><strong>文件写入和同步</strong><br>  关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：<ul><li>Always 同步写回<br>  每个写命令执行完，立马同步地将日志写回磁盘。可靠性高，数据基本不丢失。每个写命令都要落盘，性能影响较大。</li><li>Everysec 每秒写回<br>  每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘。性能适中。宕机时丢失1秒内的数据。</li><li>No 操作系统控制的写回<br>  每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。性能好。宕机时丢失数据较多。</li></ul></li></ul><blockquote><p>上面的三种写回策略体现了一个重要原则：trade-off，取舍，指在性能和可靠性保证之间做取舍。<br>关于AOF的同步策略是涉及到操作系统的 <strong>write 函数</strong>和 <strong>fsync 函数</strong>的，在《Redis设计与实现》中是这样说明的：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</span><br><span class="line">这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。</span><br><span class="line">为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。</span><br></pre></td></tr></table></figure><h4 id="redis-conf中配置AOF"><a href="#redis-conf中配置AOF" class="headerlink" title="redis.conf中配置AOF"></a>redis.conf中配置AOF</h4><p>默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># appendonly参数开启AOF持久化</span><br><span class="line">appendonly no/yes</span><br><span class="line"># AOF持久化的文件名，默认是appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"># 同步策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"># 加载aof出错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。<br>为了解决AOF文件体积膨胀的问题，Redis提供<strong>AOF文件重写机制</strong>来对AOF文件进行“瘦身”。</p><p>Redis 提供了 bgrewriteaof 指令用于对 AOF 日志进行瘦身。<br>其原理就是开辟一个子进程<strong>对内存进行遍历转换成一系列 Redis 的操作指令</strong>，序列化到一个新的 AOF 日志文件中。序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。<br><img src="/posts/27273/redis-aof%E9%87%8D%E5%86%99.jpeg"></p><p><strong>AOF重写会阻塞吗？</strong><br>AOF重写过程是由后台进程<strong>bgrewriteaof</strong>来完成的。<br>主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>所以aof在重写时，在fork进程时是会阻塞住主线程的。</p><p><strong>AOF日志何时会重写？</strong><br>有两个配置项控制AOF重写的触发：<br><code>auto-aof-rewrite-min-size</code>：表示运行AOF重写时文件的最小大小，默认为64MB。<br><code>auto-aof-rewrite-percentage</code>：这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。</p><p><strong>重写日志时，有新数据写入咋整？</strong><br>主线程fork出子进程重写aof日志；<br>子进程重写日志完成后，主线程追加aof日志缓冲；<br>替换日志文件。<br><img src="/posts/27273/redis-aof%E9%87%8D%E5%86%99-%E9%87%8D%E5%86%99%E7%BC%93%E5%86%B2.jpg"></p><p><strong>主线程fork出子进程时是如何复制内存数据的？</strong><br>fork采用操作系统提供的<strong>写时复制（copy on write）机制</strong>，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork子进程时，子进程时会拷贝父进程的页表，即虚实映射关系（虚拟内存和物理内存的映射索引表），而不会拷贝物理内存。这个拷贝会消耗大量cpu资源，并且拷贝完成前会阻塞主线程，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。</p><p>但主进程是可以有数据写入的，这时候就会拷贝物理内存中的数据。如下图（进程1看做是主进程，进程2看做是子进程）：<br><img src="/posts/27273/redis-aof%E9%87%8D%E5%86%99-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png"><br>在主进程有数据写入时，而这个数据刚好在页c中，操作系统会创建这个页面的副本（页c的副本），即拷贝当前页的物理数据，将其映射到主进程中，而子进程还是使用原来的的页c。</p><p><strong>在重写日志整个过程时，主线程有哪些地方会被阻塞？</strong></p><ul><li>fork子进程时，需要拷贝虚拟页表，会对主线程阻塞。</li><li>主进程有bigkey写入时，操作系统会创建页面的副本，并拷贝原有的数据，会对主线程阻塞。</li><li>子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞。</li></ul><p><strong>为什么AOF重写不复用原AOF日志？</strong></p><ol><li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li><li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。</li></ol><h3 id="RDB和AOF的混合持久化"><a href="#RDB和AOF的混合持久化" class="headerlink" title="RDB和AOF的混合持久化"></a>RDB和AOF的混合持久化</h3><p>重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p><p>Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。<br>将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自RDB持久化开始到RDB持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。</p><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。<br>在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p><h2 id="Redis消息传递：发布订阅模式"><a href="#Redis消息传递：发布订阅模式" class="headerlink" title="Redis消息传递：发布订阅模式"></a>Redis消息传递：发布订阅模式</h2><p>Redis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><h3 id="发布-订阅使用"><a href="#发布-订阅使用" class="headerlink" title="发布/订阅使用"></a>发布/订阅使用</h3><h4 id="基于频道-Channel-的发布-订阅"><a href="#基于频道-Channel-的发布-订阅" class="headerlink" title="基于频道(Channel)的发布/订阅"></a>基于频道(Channel)的发布/订阅</h4><p>发布者可以向指定的频道(channel)发送消息; 订阅者可以订阅一个或者多个频道(channel)，所有订阅此频道的订阅者都会收到此消息。</p><ul><li>发布 <ul><li>publish channel message</li></ul></li><li>订阅<ul><li>订阅 subscribe channel1 [channel2 …]</li><li>退订 unsubscribe</li></ul></li></ul><h4 id="基于模式-pattern-的发布-订阅"><a href="#基于模式-pattern-的发布-订阅" class="headerlink" title="基于模式(pattern)的发布/订阅"></a>基于模式(pattern)的发布/订阅</h4><ul><li>订阅 psubscribe c? b* d?*<br>  使用psubscribe命令可以重复订阅同一个频道。<br>  如客户端执行了<code>psubscribe c? c*</code>。这时向c1发布消息客户端会接受到两条消息，而同时publish命令的返回值是2而不是1。<br>  如果客户端执行了<code>subscribe c1</code>和<code>psubscribe c?*</code>的话，向c1发送一条消息该客户顿也会受到两条消息(但是是两种类型:message和pmessage)，同时publish命令也返回2。</li><li>退订<br>  punsubscribe命令可以退订指定的规则，用法是: <strong>punsubscribe [pattern [pattern …]]</strong>,如果没有参数则会退订所有规则。<br>  使用punsubscribe只能退订通过psubscribe命令订阅的规则，不会影响直接通过subscribe命令订阅的频道；同样unsubscribe命令也不会影响通过psubscribe命令订阅的规则。<br>  punsubscribe命令退订某个规则时不会将其中的通配符展开，而是进行严格的字符串匹配，所以<code>punsubscribe *</code>无法退订<code>c*</code>规则，而是必须使用<code>punsubscribe c*</code>才可以退订。（它们是相互独立的，后文可以看到数据结构上看也是两种实现）</li></ul><h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><h4 id="基于频道-Channel-的发布-订阅如何实现的？"><a href="#基于频道-Channel-的发布-订阅如何实现的？" class="headerlink" title="基于频道(Channel)的发布/订阅如何实现的？"></a>基于频道(Channel)的发布/订阅如何实现的？</h4><p>底层是通过字典（图中的pubsub_channels）实现的，这个字典用于保存订阅频道的信息：字典的键为正在被订阅的频道，而字典的值则是一个链表，链表中保存了所有订阅这个频道的客户端。<br><strong>数据结构</strong><br>在下图展示的这个 pubsub_channels 示例中， client2、client5和client1就订阅了channel1，而其他频道也分别被别的客户端所订阅：<br><img src="/posts/27273/redis-pubsub-channel-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpeg"></p><h4 id="基于模式-pattern-的发布-订阅如何实现的？"><a href="#基于模式-pattern-的发布-订阅如何实现的？" class="headerlink" title="基于模式(pattern)的发布/订阅如何实现的？"></a>基于模式(pattern)的发布/订阅如何实现的？</h4><p>底层是pubsubPattern节点的链表。<br>redisServer.pubsub_patterns 属性是一个链表，链表中保存着所有和模式相关的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">    redisClient *client;</span><br><span class="line">    robj *pattern;</span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure><p>链表中的每个节点都包含一个 redis.h/pubsubPattern 结构：client 属性保存着订阅模式的客户端，而 pattern 属性则保存着被订阅的模式。</p><p>每当调用 PSUBSCRIBE 命令订阅一个模式时， 程序就创建一个包含客户端信息和被订阅模式的 pubsubPattern 结构， 并将该结构添加到 redisServer.pubsub_patterns 链表中。<br><img src="/posts/27273/redis-pubsub-pattern-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><h4 id="SpringBoot结合Redis发布-订阅实例？"><a href="#SpringBoot结合Redis发布-订阅实例？" class="headerlink" title="SpringBoot结合Redis发布/订阅实例？"></a>SpringBoot结合Redis发布/订阅实例？</h4><p><a href="https://blog.csdn.net/llll234/article/details/80966952">springboot集成redis实现消息发布订阅模式-双通道</a></p><h2 id="Redis事件机制"><a href="#Redis事件机制" class="headerlink" title="Redis事件机制"></a>Redis事件机制</h2><blockquote><p>Redis的单线程模型核心的文件事件处理器采用事件驱动机制来处理大量的网络IO。<br>自己实现一个非常简洁的事件驱动库 ae_event。</p></blockquote><p>Redis中的事件驱动库只关注网络IO，以及定时器。</p><ul><li>文件事件(file event)<br>  用于处理 Redis 服务器和客户端之间的网络IO。</li><li>时间事件(time eveat)<br>  Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li></ul><p><img src="/posts/27273/redis-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%BA%93.png" alt="src/ae.c"><br><strong>aeEventLoop</strong>是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis基于Reactor模式开发了自己的网络事件处理器，也就是文件事件处理器。<br>文件事件处理器使用IO多路复用技术，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p><h4 id="Redis事件响应框架ae-event"><a href="#Redis事件响应框架ae-event" class="headerlink" title="Redis事件响应框架ae_event"></a>Redis事件响应框架ae_event</h4><p>Redis 使用的IO多路复用技术主要有：select、epoll、evport和kqueue等。<br>每个IO多路复用函数库在 Redis 源码中都对应一个单独的文件，比如ae_select.c，ae_epoll.c，ae_kqueue.c等。<br>Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。<br>事件响应框架一般都采用该架构，比如 netty 和 libevent。<br><img src="/posts/27273/redis-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6-aeEvent.png"></p><h4 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h4><p>文件事件处理器有四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器以及事件处理器。<br><img src="/posts/27273/redis-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6-%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png"></p><p><strong>文件事件是对套接字操作的抽象</strong>，每当一个<strong>套接字</strong>准备好执行<strong>accept、read、write和close</strong>等操作时，就会产生一个文件事件。</p><h4 id="Redis-IO多路复用模型"><a href="#Redis-IO多路复用模型" class="headerlink" title="Redis IO多路复用模型"></a>Redis IO多路复用模型</h4><p>在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。<br><img src="/posts/27273/redis-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6-io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.jpg"></p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><h3 id="aeEventLoop的实现"><a href="#aeEventLoop的实现" class="headerlink" title="aeEventLoop的实现"></a>aeEventLoop的实现</h3><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><blockquote><p>Redis 事务的本质是一组命令的集合。<br>事务支持一次执行多个命令，一个事务中所有命令都会被序列化。<br>在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p></blockquote><h3 id="Redis事务相关命令和使用"><a href="#Redis事务相关命令和使用" class="headerlink" title="Redis事务相关命令和使用"></a>Redis事务相关命令和使用</h3><ul><li>MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li><li>EXEC：执行事务中的所有操作命令。</li><li>DISCARD：取消事务，放弃执行事务块中的所有命令。</li><li>WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li><li>UNWATCH：取消WATCH对所有key的监视。</li></ul><h4 id="CAS操作实现乐观锁"><a href="#CAS操作实现乐观锁" class="headerlink" title="CAS操作实现乐观锁"></a>CAS操作实现乐观锁</h4><h4 id="Redis事务执行步骤"><a href="#Redis事务执行步骤" class="headerlink" title="Redis事务执行步骤"></a>Redis事务执行步骤</h4><h3 id="深入理解Redis事务"><a href="#深入理解Redis事务" class="headerlink" title="深入理解Redis事务"></a>深入理解Redis事务</h3><h4 id="为什么Redis不支持回滚"><a href="#为什么Redis不支持回滚" class="headerlink" title="为什么Redis不支持回滚"></a>为什么Redis不支持回滚</h4><h4 id="如何理解Redis与事务的ACID"><a href="#如何理解Redis与事务的ACID" class="headerlink" title="如何理解Redis与事务的ACID"></a>如何理解Redis与事务的ACID</h4><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul><h4 id="Redis事务的其他实现"><a href="#Redis事务的其他实现" class="headerlink" title="Redis事务的其他实现"></a>Redis事务的其他实现</h4><ul><li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</li><li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li></ul><h2 id="Redis高可用-主从复制"><a href="#Redis高可用-主从复制" class="headerlink" title="Redis高可用 - 主从复制"></a>Redis高可用 - 主从复制</h2><p>要避免单点故障，即保证高可用，便需要冗余（副本）方式提供集群服务。<br>Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。</p><p><strong>Redis的主从复制</strong>，是指将一台Redis服务器的数据，复制到其他的Redis服务器。<br>前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p><p><strong>主从复制的作用</strong>主要包括：</p><ul><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p>注意：在2.8版本之前只有全量复制，而2.8版本后有全量和增量复制</p><ul><li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li><li>增量复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li></ul><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过<strong>replicaof（Redis 5.0 之前使用 slaveof）</strong>命令<strong>形成主库和从库的关系</strong>，之后会按照三个阶段完成数据的第一次同步。</p><p><strong>确立主从关系</strong><br>例如，现在有实例1（ip：172.16.19.3）和实例2（ip：172.16.19.5），我们在实例2上执行以下这个命令后，实例2就变成了实例1的从库，并从实例1上复制数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 172.16.19.3 6379</span><br></pre></td></tr></table></figure><p><strong>全量复制的三个阶段</strong><br><img src="/posts/27273/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6.png"></p><ul><li><strong>第一阶段是主从库间建立连接、协商同步的过程</strong>，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。<br>  具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。<br>  psync 命令包含了主库的 runID 和复制进度 offset 两个参数。runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。offset，此时设为 -1，表示第一次复制。<br>  主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。<br>  这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。</li><li><strong>第二阶段，主库将所有数据同步给从库</strong>。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。<br>  具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。<br>  从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。<br>  在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的<strong>replication buffer</strong>，记录 RDB 文件生成后收到的所有写操作。</li><li><strong>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库</strong>。<br>  具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</li></ul><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p><strong>为什么会设计增量复制</strong><br>如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。<br>从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。</p><p><img src="/posts/27273/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6.png"></p><ul><li><strong>repl_backlog_buffer</strong>：它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量复制带来的性能开销。如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量复制，所以repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量复制的概率。而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。</li><li><strong>replication buffer</strong>：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。所以<strong>主从在增量同步时</strong>，<strong>从库作为一个client，也会分配一个buffer</strong>，只不过这个buffer专门用来<strong>传播用户的写命令到从库</strong>，保证主从数据一致，我们通常把它叫做replication buffer。</li></ul><p><strong>如果在网络断开期间，repl_backlog_buffer环形缓冲区写满之后，从库是会丢失掉那部分被覆盖掉的数据，还是直接进行全量复制呢？</strong></p><h4 id="深入理解-1"><a href="#深入理解-1" class="headerlink" title="深入理解"></a>深入理解</h4><p><strong>为什么还有无磁盘复制模式？</strong><br>Redis 默认是磁盘复制，但是如果使用比较低速的磁盘，这种操作会给主服务器带来较大的压力。Redis从2.8.18版本开始尝试支持无磁盘的复制。使用这种设置时，子进程直接将RDB通过网络发送给从服务器，不使用磁盘作为中间存储。<br>无磁盘复制模式：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。<br>使用repl-diskless-sync配置参数来启动无磁盘复制。<br>使用repl-diskless-sync-delay 参数来配置传输开始的延迟时间；master等待一个repl-diskless-sync-delay的秒数，如果没slave来的话，就直接传，后来的得排队等了; 否则就可以一起传。</p><p><strong>为什么还会有从库的从库的设计？</strong><br>通过分析主从库间第一次数据同步的过程，你可以看到，一次全量复制中，对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件</strong>和<strong>传输 RDB 文件</strong>。<br>如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量复制。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。<br>那么，有没有好的解决方法可以分担主库压力呢？其实是有的，这就是<strong>主-从-从</strong>模式。</p><p><strong>读写分离及其中的问题</strong></p><ul><li><p><strong>延迟与不一致问题</strong></p></li><li><p><strong>数据过期问题</strong><br>  在单机版的Redis中，存在两种删除策略：</p><ul><li><strong>惰性删除</strong>：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</li><li><strong>定期删除</strong>：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</li></ul><p>  在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。<br>  由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。<br>  Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。</p></li><li><p><strong>故障切换问题</strong></p></li></ul><h2 id="Redis高可用-哨兵机制"><a href="#Redis高可用-哨兵机制" class="headerlink" title="Redis高可用 - 哨兵机制"></a>Redis高可用 - 哨兵机制</h2><p>在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的问题。</p><p>Redis Sentinel，即Redis哨兵，在Redis 2.8版本开始引入。哨兵的核心功能是主节点的自动故障转移。</p><p>下图是一个典型的哨兵集群监控的逻辑图：<br><img src="/posts/27273/redis-%E5%93%A8%E5%85%B5-%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>哨兵实现了什么功能呢？下面是Redis官方文档的描述：</p><ul><li>监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。</li><li>自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li>通知（Notification）：哨兵可以将故障转移的结果发送给客户端。</li></ul><h3 id="哨兵集群的组建"><a href="#哨兵集群的组建" class="headerlink" title="哨兵集群的组建"></a>哨兵集群的组建</h3><p>哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制。<br>在主从集群中，主库上有一个名为**<strong>sentinel</strong>:hello**的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</p><p>在下图中，哨兵1把自己的IP（172.16.19.3）和端口（26579）发布到**<strong>sentinel</strong>:hello**频道上，哨兵2和3订阅了该频道。那么此时，哨兵2和3就可以从这个频道直接获取哨兵1的IP地址和端口号。然后，哨兵2、3可以和哨兵1建立网络连接。通过这个方式，哨兵2和3也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，比如说对主库有没有下线这件事儿进行判断和协商。<br><img src="/posts/27273/redis-%E5%93%A8%E5%85%B5-sentinelhello.jpeg"></p><p><strong>Redis 1主4从，5个哨兵，哨兵配置quorum为2，如果3个哨兵故障，当主库宕机时，哨兵能否判断主库“客观下线”？能否自动切换？</strong></p><ul><li>哨兵集群可以判定主库“主观下线”。<br>  由于<strong>quorum=2</strong>，所以当一个哨兵判断主库“主观下线”后，询问另外一个哨兵后也会得到同样的结果，2个哨兵都判定“主观下线”，达到了quorum的值，因此，哨兵集群可以判定主库为“客观下线”。</li><li>不能完成主从切换。<br>  哨兵标记主库“客观下线后”，在选举“哨兵领导者”时，一个哨兵必须拿到超过多数的选票(5/2+1=3票)。但目前只有2个哨兵活着，无论怎么投票，一个哨兵最多只能拿到2票，永远无法达到N/2+1选票的结果。</li></ul><h2 id="Redis高可扩展-分片技术"><a href="#Redis高可扩展-分片技术" class="headerlink" title="Redis高可扩展 - 分片技术"></a>Redis高可扩展 - 分片技术</h2><p><strong>主从复制</strong>和<strong>哨兵机制</strong>保障了高可用，就读写分离而言，虽然slave节点扩展了主从的读并发能力，但是<strong>写能力</strong>和<strong>存储能力</strong>是无法进行扩展，就只能是master节点能够承载的上限。如果面对海量数据，那么必然需要构建mster（主节点分片）之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave从节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现。<br>在Redis 3.0版本中对应的设计就是Redis Cluster。</p><h2 id="缓存并发问题"><a href="#缓存并发问题" class="headerlink" title="缓存并发问题"></a>缓存并发问题</h2><h3 id="数据库和缓存一致性"><a href="#数据库和缓存一致性" class="headerlink" title="数据库和缓存一致性"></a>数据库和缓存一致性</h3><blockquote><p>更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching</p></blockquote><p>Cache Aside Pattern</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，先更新数据库，然后再删除缓存。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，导致数据库压力巨大。<br>如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上重启数据库，马上又会有新的流量把数据库打死。</p><p>造成缓存雪崩的关键在于同一时间大规模的key失效。第一种可能是Redis宕机，第二种可能是采用了相同的过期时间。</p><p>解决办法：</p><ul><li>事前：<ol><li>尽量保证整个redis集群的高可用性，发现机器宕机尽快补上。</li><li>选择合适的内存淘汰策略，避免采用相同的过期时间。</li></ol></li><li>事中：本地ehcache+hystrix限流&amp;降级，避免mysql崩掉</li><li>事后：利用redis持久化机制保存的数据尽快恢复缓存</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存雪崩是大规模的key失效。<br>缓存击穿是一个热点的key，有大并发集中对其进行访问，突然间这个key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。</p><p>造成缓存击穿的关键在于某个热点的key失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</p><p>解决方案：</p><ul><li>设置热点数据永不过期。</li><li>加互斥锁。<br>  如果缓存失效，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库被打死，当然这样会导致系统的性能变差。</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是查询的key是redis和数据库中都不存在的数据。</p><p>一般是黑客故意去请求缓存和数据库中都不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决办法：</p><ul><li>采用布隆过滤器<br>  布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。</li><li>缓存空结果<br>  如果一个查询返回的数据为空(不管是数据不存在，还是系统故障)，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li></ul><h3 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h3><p>缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。</p><p>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。<br>缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。<br>这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</p><h4 id="最大缓存设置"><a href="#最大缓存设置" class="headerlink" title="最大缓存设置"></a>最大缓存设置</h4><p>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置缓存大小为4G</span><br><span class="line">CONFIG SET maxmemory 4gb</span><br></pre></td></tr></table></figure><p>缓存被写满是不可避免的, 所以需要数据淘汰策略。</p><h4 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h4><p><strong>触发条件是Redis使用的内存达到阈值。</strong></p><ul><li>不淘汰 <ul><li>noeviction （v4.0后默认的）</li></ul></li><li>对设置了过期时间的数据中进行淘汰 <ul><li>随机：volatile-random</li><li>ttl：volatile-ttl 移除即将过期的键值对</li><li>lru：volatile-lru 移除最近最少使用的键值对 跟使用的最后一次时间有关，淘汰最近使用时间离现在最久的</li><li>lfu：volatile-lfu 移除最近最不频繁使用的键值对 跟使用的次数有关，淘汰使用次数最少的</li></ul></li><li>全部数据进行淘汰 <ul><li>随机：allkeys-random</li><li>lru：allkeys-lru</li><li>lfu：allkeys-lfu</li></ul></li></ul><h2 id="版本特性-Redis-4-0"><a href="#版本特性-Redis-4-0" class="headerlink" title="版本特性 - Redis 4.0"></a>版本特性 - Redis 4.0</h2><h3 id="布隆过滤器-Bloom-Filter"><a href="#布隆过滤器-Bloom-Filter" class="headerlink" title="布隆过滤器 Bloom Filter"></a>布隆过滤器 Bloom Filter</h3><p>布隆过滤器（Bloom Filter）是 Redis 4.0 版本提供的新功能，它被作为插件加载到 Redis 服务器中，给 Redis 提供强大的去重功能。<br>相比于 Set 集合的去重功能而言，布隆过滤器在空间上能节省 90% 以上，但是它的不足之处是去重率大约在 99% 左右，也就是说有 1% 左右的误判率，这种误差是由布隆过滤器的自身结构决定的。</p><p><strong>常用命令</strong></p><ul><li>bf.add    添加一个元素到布隆过滤器。</li><li>bf.exists    判断某个元素是否在于布隆过滤器中。</li><li>bf.madd    同时添加多个元素到布隆过滤器。</li><li>bf.mexists    同时判断多个元素是否存在于布隆过滤器中。</li><li>bf.reserve    以自定义的方式设置布隆过滤器参数值，共有 3 个参数分别是 key、error_rate(错误率)、initial_size(初始大小)。</li></ul><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>布隆过滤器（Bloom Filter）是一个高空间利用率的概率性数据结构，由二进制向量（即位数组）和一系列随机映射函数（即哈希函数）两部分组成。<br>当布隆过滤器判定某个值存在时，其实这个值只是有可能存在；当它说某个值不存在时，那这个值肯定不存在，这个误判概率大约在 1% 左右。</p><p><img src="/posts/27273/redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p><ul><li><strong>bf.add</strong><br>  当使用布隆过滤器添加 key 时，会使用不同的 hash 函数对 key 存储的元素值进行哈希计算，从而会得到多个哈希值。根据哈希值计算出一个整数索引值，将该索引值与位数组长度做取余运算，最终得到一个位数组位置，并将该位置的值变为 1。每个 hash 函数都会计算出一个不同的位置，然后把数组中与之对应的位置变为 1。</li><li><strong>bf.exist</strong><br>  当我们需要判断一个元素是否存时，其流程如下：首先对给定元素再次执行哈希计算，得到与添加元素时相同的位数组位置，判断所得位置是否都为 1，如果其中有一个为 0，那么说明元素不存在，若都为 1，则说明元素有可能存在。</li><li><strong>为什么是可能存在</strong><br>  那些被置为 1 的位置也可能是由于其他元素的操作而改变的。比如元素1 和 元素2，这两个元素同时将一个位置变为了 1（如图所示）。在这种情况下，我们就不能判定元素1和元素2一定存在，这是布隆过滤器存在误判的根本原因。</li></ul><h2 id="版本特性-Redis-5-0"><a href="#版本特性-Redis-5-0" class="headerlink" title="版本特性 - Redis 5.0"></a>版本特性 - Redis 5.0</h2><h2 id="版本特性-Redis-6-0"><a href="#版本特性-Redis-6-0" class="headerlink" title="版本特性 - Redis 6.0"></a>版本特性 - Redis 6.0</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令总结</title>
      <link href="/posts/35817.html"/>
      <url>/posts/35817.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="服务器ip、端口连通情况"><a href="#服务器ip、端口连通情况" class="headerlink" title="服务器ip、端口连通情况"></a>服务器ip、端口连通情况</h3><ul><li>ping<br>  ping出域名对应的服务器ip</li><li>telnet<br>  telnet ip port</li><li>nc -vz -w2 ip port<br>  mac测试远程端口是否正常，netcat</li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>linux下面根据文件名，查找文件路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name 具体目录名 -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><h2 id="linux性能监控命令"><a href="#linux性能监控命令" class="headerlink" title="linux性能监控命令"></a>linux性能监控命令</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>可以实时显示系统中各个进程的占用情况。<br><img src="/posts/35817/top.png"><br>上部分列出了系统整体的统计信息：任务、CPU、内存、交换区等信息。<br>下部分列出进程的详细情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line">d : 监控内容刷新的时间间隔。</span><br><span class="line">p : 只监控指定PID的进程。</span><br><span class="line">H : 显示进程下的线程，一般结合p参数使用，查看某个进程下的线程，例如: top -Hp 8080。</span><br><span class="line">c : 切换显示模式，只显示名称，或者显示完整的路径与名称。</span><br><span class="line">s : 安全模式，交谈式指令无法使用, 例如k指令。</span><br><span class="line">i : 不显示任何闲置或无用的进程，也可以理解成只显示正在执行的进程。</span><br><span class="line">n : 限定监控内容刷新的次数，完成后将会退出 top 视图。例如 top -n 5，默认3秒刷新一次，那么在15s后，自动退出top视图。</span><br></pre></td></tr></table></figure><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>可以查看系统负载。显示的和top命令第一行一样。<br><img src="/posts/35817/uptime.png"></p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看所有进程<br><img src="/posts/35817/ps.png"></p><ul><li>grep<br>  全局正则表达式文本</li><li>ps -ef<br>  用标准格式显示进程</li><li>ps aux<br>  用BSD格式来显示进程</li><li>ps -T -p [进程id]<br>  查看进程下的线程</li></ul><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>这个命令用来查看当前建立的网络连接(深刻理解netstat每一项代表的含义)。最经典的案例就是查看本地系统打开了哪些端口：<br><img src="/posts/35817/netstat.png"></p><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>可以用来监控虚拟内存。可对操作系统的虚拟内存、IO、CPU等多个指标的整体情况进行监视。<br><img src="/posts/35817/vmstat.png"></p><ul><li><p>内存方面：<br>  swpd：已经使用的交换内存（kb）<br>  free：空闲的物理内存（kb）<br>  buff：用作缓冲区的内存数（kb）<br>  cache：用作高速缓存的内存数（kb）<br>  si、so 两列，表示磁盘和内存之间交换的频繁程度。</p><p>  分析思路：<br>  如果 si、so 数值长期很大并且free长期很小，表示物理内存不能满足需要，也就是内存不足。由于磁盘的性能比内存是慢很多的，所以如果存在大量的页面交换，那么系统的性能必然会受到很大影响。</p></li><li><p>CPU方面：<br>  r：展示了正在执行和等待cpu资源的任务个数。当这个值超过了cpu个数，就会出现cpu瓶颈。<br>  us：用户CPU时间。<br>  sy：系统CPU时间。<br>  id：空闲CPU时间。<br>  wa：等等I/O CPU时间。<br>  us+sy+id+wa=100%</p><p>  分析思路：<br>  如果 r 经常大于4，且id经常小于40，表面CPU的负荷很重。</p></li></ul><h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><p>pidstat，观测单个进程的性能情况</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>可以用来观察内存使用情况。<br><img src="/posts/35817/free.png"></p><p>total= used + free<br>分析思路：<br>当 –/+ buffers/cache中的free长时间接近0，且 swap used长时间比较大时，说明物理内存已经不够用了，需要升级内存或降低内存的使用量。</p><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>可以用来监控磁盘I/O的情况。<br><img src="/posts/35817/iostat.png"></p><h3 id="磁盘命令"><a href="#磁盘命令" class="headerlink" title="磁盘命令"></a>磁盘命令</h3><h4 id="df-（disk-free）"><a href="#df-（disk-free）" class="headerlink" title="df （disk free）"></a>df （disk free）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-a：全部文件系统列表，包含虚拟文件系统</span><br><span class="line">-B：指定显示scale size，比如以M，G为单位显示</span><br><span class="line">-h：方便人阅读方式显示。</span><br><span class="line">-H：和-h相似，不过其中1k = 1000byte， 1M=1000k</span><br><span class="line">-i：列出inode的信息</span><br><span class="line">-k ：区块为1024字节</span><br><span class="line">-l ：显示本地文件系统</span><br><span class="line">-p：使用POSIX规范输出</span><br><span class="line">-t：打印指定的文件系统类型</span><br><span class="line">-T：显示文件系统类型</span><br><span class="line">-x：不打印指定的文件系统类型</span><br></pre></td></tr></table></figure><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-l 列出素所有分区表</span><br></pre></td></tr></table></figure><h2 id="java性能监控命令"><a href="#java性能监控命令" class="headerlink" title="java性能监控命令"></a>java性能监控命令</h2><ul><li><p>top<br>  查看当前所有进程cpu、内存使用情况<br>  <strong>top -H -p [java pid]： 查看java进程下所有线程的情况</strong></p></li><li><p>ps<br>  ps -ef | grep java<br>  查看java进程</p></li><li><p>pidstat<br>  pidstat -p [java pid]<br>  进程监控命令</p><p>  安装方式：<br>  Debian/Ubuntu：apt-get install sysstat<br>  CentOS/Fedora/RHEL：yum install sysstat</p></li><li><p>jstat </p></li><li><p>jstack</p></li><li><p>jps</p></li><li><p>jmap</p></li></ul><h3 id="Java线上故障"><a href="#Java线上故障" class="headerlink" title="Java线上故障"></a>Java线上故障</h3><p>线上故障主要会包括 CPU、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。<br>基本上出问题就是 df、free、top 三连，然后依次 jstack、jmap 伺候，具体问题具体分析即可。</p><p><a href="https://blog.csdn.net/weixin_39609166/article/details/114825626">https://blog.csdn.net/weixin_39609166/article/details/114825626</a></p><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>异常常见原因：</p><ol><li>业务逻辑问题（死循环）</li><li>频繁gc</li><li>上下文切换过多</li></ol><p>CPU问题排查步骤</p><ol><li>执行<code>“top”</code>命令：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</li><li>执行<code>“top -H -p 进程号”</code>命令：查看java进程下的所有线程占CPU的情况。<br> -H参数：显示进程下的线程，一般结合p参数使用，查看某个进程下的线程，例如: top -H -p 1。</li><li>执行<code>“printf &quot;%x\n&quot; 线程号</code>命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到线程堆栈信息，需要把线程号转成16进制。<br> 例如, printf “%x\n” 10 -》打印：a，那么在jstack中线程号就是0xa。</li><li>执行<code>“jstack 进程号 | grep 线程ID”</code> 查找某进程下 -》线程ID（jstack堆栈信息中的nid）=0xa的线程堆栈信息。<br> 如果“”VM Thread” os_prio=0 tid=0x00007f871806e000 nid=0xa runnable”，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了</li><li>jstat</li><li>jmap</li></ol><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>内存问题排查起来相对比 CPU 麻烦一些，场景也比较多。<br>主要包括：</p><ul><li>OOM</li><li>GC问题</li><li>堆外内存。</li></ul><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-前言</title>
      <link href="/posts/9977.html"/>
      <url>/posts/9977.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-Server体系结构"><a href="#MySQL-Server体系结构" class="headerlink" title="MySQL Server体系结构"></a>MySQL Server体系结构</h2><p><img src="/posts/9977/mysql-server-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p><h2 id="一条SQL的执行过程"><a href="#一条SQL的执行过程" class="headerlink" title="一条SQL的执行过程"></a>一条SQL的执行过程</h2><h3 id="系统是如何与MySQL交互的"><a href="#系统是如何与MySQL交互的" class="headerlink" title="系统是如何与MySQL交互的"></a>系统是如何与MySQL交互的</h3><h4 id="1-MySQL驱动、数据库连接池"><a href="#1-MySQL驱动、数据库连接池" class="headerlink" title="1. MySQL驱动、数据库连接池"></a>1. MySQL驱动、数据库连接池</h4><p>我们的系统在和 MySQL 数据库进行通信的时候，不是平白无故的就能接收和发送请求。就是这个<strong>MySQL驱动</strong>在底层帮我们做了对数据库的连接，只有建立了连接了，才能够有后面的交互。看下图：<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-1-mysql%E9%A9%B1%E5%8A%A8-1.png"></p><p>在系统和 MySQL 进行交互之前，MySQL 驱动会帮我们建立好连接，然后我们只需要发送 SQL 语句就可以执行 CRUD 了。一次 SQL 请求就会建立一个连接，多个请求就会建立多个连接，那么问题来了，我们系统肯定不是一个人在使用的，换句话说肯定是<strong>存在多个请求同时去争抢连接</strong>的情况。<br>我们的 web 系统一般都是部署在 tomcat 容器中的，而 tomcat 是可以并发处理多个请求的，这就会导致多个请求会去建立多个连接，然后使用完再都去关闭，这样会有什么问题呢？如下图：<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-1-mysql%E9%A9%B1%E5%8A%A8-2.png"></p><p>java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，所以如果每个请求都是新建连接和销毁连接，那这样势必会造成不必要的浪费和性能的下降，也就说上面的多线程请求的时候频繁的创建和销毁连接显然是不合理的，必然会大大降低我们系统的性能。<br>但是如果能提供一些固定的用来连接的线程，这样是不是不需要反复的创建和销毁连接了呢？这就是<strong>数据库连接池</strong>。</p><p><strong>数据库连接池</strong>，维护一定的连接数，方便系统获取连接，使用就去池子中获取，用完放回去就可以了，我们不需要关心连接的创建与销毁，也不需要关心线程池是怎么去维护这些连接的。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-1-mysql%E9%A9%B1%E5%8A%A8-3.png"></p><h4 id="2-MySQL连接池"><a href="#2-MySQL连接池" class="headerlink" title="2. MySQL连接池"></a>2. MySQL连接池</h4><p>业务系统是并发的，而 MySQL 接受请求的线程呢，只有一个吗？<br>其实 MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连接池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-2-mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0.png"></p><h3 id="MySQL在接收到系统发送的sql语句时做了哪些事情"><a href="#MySQL在接收到系统发送的sql语句时做了哪些事情" class="headerlink" title="MySQL在接收到系统发送的sql语句时做了哪些事情"></a>MySQL在接收到系统发送的sql语句时做了哪些事情</h3><h4 id="3-MySQL线程调用SQL接口"><a href="#3-MySQL线程调用SQL接口" class="headerlink" title="3. MySQL线程调用SQL接口"></a>3. MySQL线程调用SQL接口</h4><p>网络中的连接都是由线程来处理的，所谓网络连接说白了就是一次请求，每次请求都会有相应的线程去处理的。<br>也就是说<strong>对于 SQL 语句的请求在 MySQL 中是由一个个的线程去处理的</strong>。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-3-mysql%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86sql%E8%AF%B7%E6%B1%82.png"></p><p>那这些线程会怎么去处理这些请求？会做哪些事情？<br>MySQL 中处理请求的线程在获取到请求以后获取 SQL 语句去交给 SQL 接口去处理。</p><h4 id="4-解析器"><a href="#4-解析器" class="headerlink" title="4. 解析器"></a>4. 解析器</h4><p>假设现在有这样一个SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stuName,age,sex <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但是这个 SQL 是写给我们人看的，机器哪里知道你在说什么？这个时候解析器就上场了。他会将 SQL 接口传递过来的 SQL 语句进行解析，翻译成 MySQL 自己能认识的语言。具体可以看<strong>MySQL - MySQL中SQL是如何解析的</strong>。</p><p><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-4-%E8%A7%A3%E6%9E%90%E5%99%A8.png"></p><p>现在 SQL 已经被解析成 MySQL 认识的样子的，那下一步是不是就是执行吗？理论上是这样子的，但是 MySQL 的强大远不止于此，它还会帮我们<strong>选择最优的查询路径</strong>。<br>什么叫最优查询路径？就是 MySQL 会按照自己认为的效率最高的方式去执行查询。<br>具体是怎么做到的呢？这就要说到 MySQL 的查询优化器了。</p><h4 id="5-优化器"><a href="#5-优化器" class="headerlink" title="5. 优化器"></a>5. 优化器</h4><p>查询优化器内部具体怎么实现的我们不需要关心，我们需要知道的是 MySQL 会帮我们去使用它自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本。</p><ul><li><strong>IO成本</strong><br>  即从磁盘把数据加载到内存的成本。<br>  默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是 1。所以 IO 的成本主要和页的大小有关。</li><li><strong>CPU成本</strong><br>  将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是 0.2。</li></ul><p>MySQL 优化器 会计算「IO 成本 + CPU成本」最小的那个索引来执行。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-5-%E4%BC%98%E5%8C%96%E5%99%A8.png"></p><p>优化器执行选出最优索引等步骤后，会去调用存储引擎接口，开始去执行被 MySQL 解析过和优化过的 SQL 语句。</p><h4 id="6-执行器、存储引擎"><a href="#6-执行器、存储引擎" class="headerlink" title="6. 执行器、存储引擎"></a>6. 执行器、存储引擎</h4><p>执行器是一个非常重要的组件，因为前面那些组件的操作最终必须通过执行器去调用存储引擎接口才能被执行。<br>执行器最终根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-6-%E6%89%A7%E8%A1%8C%E5%99%A8.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="MySQL中一条SQL是如何执行的"><a href="#MySQL中一条SQL是如何执行的" class="headerlink" title="MySQL中一条SQL是如何执行的"></a>MySQL中一条SQL是如何执行的</h4><p>大致过程如下：<br><strong>SQL ==&gt; 查询缓存 ==&gt; 解析器 ==&gt; 优化器 ==&gt; 执行器</strong></p><ul><li>客户端SQL发送到MySQL服务端，首先会去查询缓存里面查找，如果多次执行同一个SQL是会命中缓存中，此时直接通过缓存来取数据</li><li>若没有命中查询缓存，则将SQL发送给解析器，解析器会对SQL进行语法、语义分析，同时也会对SQL合法性进行校验</li><li>SQL语义解析出来后，优化器会对SQL语义进行优化，比如，是走索引还是全表扫描，优化器会根据实际情况来确定一个最优的执行方案（当然，不一定是最优的，只是给出MySQL认为是最优的执行方案）</li><li>优化完毕后，就给到执行器（调用具体某个存储引擎，例如innodb）进行执行SQL，取出SQL执行结果</li><li>最后将执行结果返回给客户端</li></ul><h4 id="准备更新一条数据到事务的提交的流程描述"><a href="#准备更新一条数据到事务的提交的流程描述" class="headerlink" title="准备更新一条数据到事务的提交的流程描述"></a>准备更新一条数据到事务的提交的流程描述</h4><p>从准备更新一条数据到事务的提交的流程描述：</p><ul><li>首先执行器根据 MySQL 的执行计划来查询数据，MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中</li><li>在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</li><li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据记录到 redo log buffer 中</li><li>完成以后就可以提交事务，在提交的同时会做以下三件事 <ul><li>将redo log buffer中的数据刷入到 redo log 文件中</li><li>将本次操作记录写入到 bin log文件中</li><li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li></ul></li><li>至此表示整个更新事务已经完成</li></ul><p><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png"></p><p>如果在数据被写入到bin log文件的时候，刚写完，数据库宕机了，数据会丢失吗？<br>首先可以确定的是，只要redo log最后没有 commit 标记，说明本次的事务一定是失败的。但是数据是没有丢失了，因为已经被记录到redo log的磁盘文件中了。在 MySQL 重启的时候，就会将 redo log 中的数据恢复（加载）到Buffer Pool中。</p><p>这个时候被更新记录仅仅是在内存中执行的，哪怕是宕机又恢复了也仅仅是将更新后的记录加载到Buffer Pool中，这个时候 MySQL 数据库中的这条记录依旧是旧值，也就是说内存中的数据在我们看来依旧是脏数据，那这个时候怎么办呢？<br>其实 MySQL InnoDB存储引擎会有一些<strong>后台线程</strong>，它会在某个时机将我们Buffer Pool中的数据刷到 MySQL 数据库中，这样就将内存和数据库的数据保持统一了。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B-%E5%88%B7%E5%85%A5db.png"></p><h2 id="MySQL中SQL是如何解析的"><a href="#MySQL中SQL是如何解析的" class="headerlink" title="MySQL中SQL是如何解析的"></a>MySQL中SQL是如何解析的</h2><p>在<strong>一条SQL是如何在数据库中执行的过程</strong>中，其中有一个阶段是<strong>SQL的解析</strong>。这个阶段对于更全面的SQL优化功能、多维度的慢查询分析、辅助故障分析等有很大帮助。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h3 id="SQL解析的原理"><a href="#SQL解析的原理" class="headerlink" title="SQL解析的原理"></a>SQL解析的原理</h3><p>SQL解析与优化是属于编译器范畴，和C等其他语言的解析没有本质的区别。其中分为，词法分析、语法和语义分析、优化、执行代码生成。<br>对应到MySQL的部分，如下图：<br><img src="/posts/9977/sql%E8%A7%A3%E6%9E%90-%E5%8E%9F%E7%90%86-%E8%BF%87%E7%A8%8B%E5%9B%BE.png"></p><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="MySQL-Server层日志"><a href="#MySQL-Server层日志" class="headerlink" title="MySQL Server层日志"></a>MySQL Server层日志</h3><h4 id="1-二进制日志（binlog）"><a href="#1-二进制日志（binlog）" class="headerlink" title="1. 二进制日志（binlog）"></a>1. 二进制日志（binlog）</h4><p>记录所有更改数据（insert、update、delete等）的语句，还用于复制。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>主从复制</li><li>数据恢复</li></ul><h5 id="STATMENT、ROW、MIXED"><a href="#STATMENT、ROW、MIXED" class="headerlink" title="STATMENT、ROW、MIXED"></a>STATMENT、ROW、MIXED</h5><ul><li>STATMENT<br>  基于 SQL 语句的复制(statement-based replication, SBR)，每一条修改数据的 SQL 语句都会记录到 bin log 中<ul><li>优点 不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</li><li>缺点 在某些情况下会导致主从数据不一致，比如执行sysdate()、sleep()等</li></ul></li><li>ROW<br>  基于行的复制(row-based replication, RBR)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了<ul><li>优点 不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题</li><li>缺点 会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</li></ul></li><li>MIXED<br>  基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 bin log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 bin log。<br>  <strong>当 MySQL 判断可能数据不一致时，就用 row 格式，否则就用 statement 格式。</strong></li></ul><h4 id="2-错误日志（errorlog）"><a href="#2-错误日志（errorlog）" class="headerlink" title="2. 错误日志（errorlog）"></a>2. 错误日志（errorlog）</h4><p>记录启动、运行或停止mysqld时出现的问题。</p><h4 id="3-慢查询日志（slow-query-log）"><a href="#3-慢查询日志（slow-query-log）" class="headerlink" title="3. 慢查询日志（slow query log）"></a>3. 慢查询日志（slow query log）</h4><p>记录所有执行时间超过long_query_time秒的所有查询或者不适用索引的查询。</p><h4 id="4-一般查询日志（general-log）"><a href="#4-一般查询日志（general-log）" class="headerlink" title="4. 一般查询日志（general log）"></a>4. 一般查询日志（general log）</h4><p>记录建立的客户端连接和执行语句。</p><h3 id="InnoDB存储引擎事务相关日志"><a href="#InnoDB存储引擎事务相关日志" class="headerlink" title="InnoDB存储引擎事务相关日志"></a>InnoDB存储引擎事务相关日志</h3><h4 id="1-重做日志（redo-log）"><a href="#1-重做日志（redo-log）" class="headerlink" title="1. 重做日志（redo log）"></a>1. 重做日志（redo log）</h4><p>redo log 记录的是数据被事务操作后的样子。<br>redo log是InnoDB存储引擎层实现的（也就是说是 Innodb 存储引擎独有的），用于保障事务的持久性，主要用于掉电等故障恢复。</p><p>redo log记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。<br>redo log是用来恢复数据的，用于保障已提交事务的持久化特性。</p><h4 id="2-回滚日志（undo-log）"><a href="#2-回滚日志（undo-log）" class="headerlink" title="2. 回滚日志（undo log）"></a>2. 回滚日志（undo log）</h4><p>Undo log 记录的是数据被事务操作前的样子。<br>undo log是InnoDB存储引擎层实现的（也就是说是 Innodb 存储引擎独有的），用于保障事务的原子性，主要用于事务回滚和MVCC。</p><p>因此假如由于系统错误或者<code>rollback</code>操作而回滚的话可以根据undo log的信息来进行回滚到被修改前的状态。<br>undo log是用来回滚数据的，用于保障未提交事务的原子性。</p><p>由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。<br>undo log主要分为3种：</p><ul><li>Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li><li>Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li><li>Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 <ul><li>删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。</li><li>为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。<br>  为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）。<br>  如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li></ul></li></ul><h3 id="主从同步从数据库"><a href="#主从同步从数据库" class="headerlink" title="主从同步从数据库"></a>主从同步从数据库</h3><h4 id="中继日志（relay-log）"><a href="#中继日志（relay-log）" class="headerlink" title="中继日志（relay log）"></a>中继日志（relay log）</h4><p>一般情况下它在MySQL主从同步读写分离集群的从节点才开启，主节点不需要这个日志。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 中间件 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——树</title>
      <link href="/posts/23547.html"/>
      <url>/posts/23547.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/23547/tree.png"></p><ul><li>二叉树</li><li>动态查找树<ol><li>二叉查找树 BST</li><li>平衡二叉树 AVL</li><li>红黑树 RBT</li><li>哈夫曼树</li></ol></li><li>多路查找树<ol><li>B树</li><li>B+树</li><li>R树</li></ol></li></ul><h3 id="1-二分搜索树（BST）"><a href="#1-二分搜索树（BST）" class="headerlink" title="1.二分搜索树（BST）"></a>1.二分搜索树（BST）</h3><p>二叉树——&gt;完全二叉树——&gt;满二叉树<br>二叉树具有天然递归结构：每个节点的左子树也是二叉树，每个节点的右子树也是二叉树。</p><h4 id="二分搜索树的每个节点的值"><a href="#二分搜索树的每个节点的值" class="headerlink" title="二分搜索树的每个节点的值"></a>二分搜索树的每个节点的值</h4><p>大于其左子树的所有节点的值，小于其右子树的所有节点的值。<br>二分搜索树中存储的元素必须有可比较性。</p><h4 id="二分搜索树的前中后序遍历"><a href="#二分搜索树的前中后序遍历" class="headerlink" title="二分搜索树的前中后序遍历"></a>二分搜索树的前中后序遍历</h4><h3 id="2-平衡二叉树-AVL"><a href="#2-平衡二叉树-AVL" class="headerlink" title="2.平衡二叉树(AVL)"></a>2.平衡二叉树(AVL)</h3><p>基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。</p><p>AVL树的应用场景：</p><ul><li>windows对进程地址空间的管理</li></ul><h3 id="3-红黑树（R-B-Tree）"><a href="#3-红黑树（R-B-Tree）" class="headerlink" title="3.红黑树（R-B Tree）"></a>3.红黑树（R-B Tree）</h3><ol><li>任何一个节点都有颜色，黑色或者红色。</li><li>根节点是黑色的。</li><li>父子节点之间不能出现两个连续的红节点。</li><li>任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等。</li><li>空节点被认为是黑色的。</li></ol><p>红黑树的应用场景：</p><ol><li>epoll在内核中的实现，用红黑树管理事件块（文件描述符）</li><li>Java的TreeMap实现</li><li>nginx中，用红黑树管理timer</li><li>linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块</li></ol><h3 id="4-B-树"><a href="#4-B-树" class="headerlink" title="4.B-树"></a>4.B-树</h3><p>B-树是一种多路平衡查找树，在文件系统中很有用。<br>一颗m阶的B-树，或为空树，或为满足下列特性的m叉树：<br>1)树中每个节点至多有m棵子树；<br>2)若根节点不是叶子节点，则至少有两棵子树；<br>3)除根之外的所有非终端节点至少有m/2上限棵子树；<br>4)所有的非终端节点中包含下列信息数据：(n，A0，K1，A1，K2，A2，……，Kn，An)。其中，n(m/2-1&lt;=n&lt;=m-1)为关键字的个数(或n+1为该节点子树的个数)；Ki(1&lt;=i&lt;=n)为关键字，且Ki&lt; Ki+1；Ai(0&lt;=i&lt;=n)为指向该节点子树根节点的指针，且指针Ai-1所指子树中所有节点的关键字均小于Ki，An所指子树中所有的节点的关键字均大于Kn。<br>5)所有叶子结点位于同一层。保证平衡。<br><img src="/posts/23547/B%E6%A0%91.jpg"></p><h4 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h4><p>在B-树上进行查找的过程是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程。<br>由于B-树用作文件的索引，因此它的查找涉及外存的存取。<br>在B-树上进行查找包含两种操作：(1)在B-树中找节点；(2)在节点中找关键字。由于B-树通常存储在磁盘上，则前一查找操作是在磁盘上进行的，而后一查找操作实在内存中进行的，即在磁盘上找到指针p所指节点后，先将节点中的信息读入内存，然后再利用顺序查找或折半查找查询等于K的关键字。</p><h4 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h4><p>插入和分裂<br>m阶的B树，每个结点最多m-1个关键字，保证最多有m棵子树。</p><h4 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h4><h4 id="B树怎么保证绝对平衡的？"><a href="#B树怎么保证绝对平衡的？" class="headerlink" title="B树怎么保证绝对平衡的？"></a>B树怎么保证绝对平衡的？</h4><h3 id="5-B-树"><a href="#5-B-树" class="headerlink" title="5.B+树"></a>5.B+树</h3><p>B+树是应文件系统所需而出的一种B-树的变型树(严格来说，它已不是此前定义的树了)。<br>一棵m阶的B+树和m阶的B-树的差异在于：<br>1)有n棵子树的节点中含有n个关键字；<br>2)所有的叶子节点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接；<br>3)所有的非终端节点可以看成是索引部分，节点中仅含有其子树(根节点)中的最大(或最小)关键字。<br><img src="/posts/23547/B+%E6%A0%91.jpg"></p><h4 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B+树的查找"></a>B+树的查找</h4><h4 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h4><p>B+树的插入仅在叶子节点上进行，当节点中的关键字个数大于m时要分裂成两个节点，它们所含关键字的个数分别为(m+1)/2的上界，并且它们的双亲结点中应同时包含这两个结点中的最大关键字。</p><h4 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h4><p>B+树的删除也仅在叶子节点进行，当叶子结点中的最大关键字被删除时，其在非终端结点中的值可以作为一个“分界关键字”存在。若因删除而使节点中关键字的个数少于m/2时，其和兄弟节点的合并过程和B-树类似。</p><h3 id="6-线段树-区间树"><a href="#6-线段树-区间树" class="headerlink" title="6.线段树(区间树)"></a>6.线段树(区间树)</h3><p>线段树不是完全二叉树，是平衡二叉树。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假如我是一个诗人</title>
      <link href="/posts/63042.html"/>
      <url>/posts/63042.html</url>
      
        <content type="html"><![CDATA[<p>6<br>有一天<br>我和晚风做了一个约定<br>天色将暗时<br>我们互换身体<br>我有一个额外的条件<br>我要带走关于你的记忆</p><p>于是<br>那一晚我变成了风<br>我只做了一件事<br>三月中旬<br>满月当空<br>我吹来一大团水汽<br>然后云雾笼罩<br>月色朦胧</p><p>月亮是存在于十四行诗里的光辉<br>你是白日梦尽头的天光大放<br>当我看见你的那一刻<br>我对你说，“我看见了月亮”<br>今夜<br>我不要地球上的人观赏<br>我妄图独享</p><p>那个与晚风交换的“我”呢<br>他呆坐在荒野的尽头<br>不知道在凝望着什么<br>一如往常的许许多多个夜晚<br>他什么也做不了<br>除了凝望</p><p>第二天天色将暗时<br>我又坐在荒野的尽头<br>晚风袭来，带着显然的怒气<br>他再也不会与我交换<br>除非我什么也不带走，尤其关于你的记忆<br>他没有想到：<br>我所带走的，已经是我的全部</p><p>晚风再次提议<br>他想知道那种感觉<br>那种我装着你的时候的感觉<br>我拒绝了<br>晚风不解<br>他在我身边想了一整个晚上</p><p>于是那个夜晚<br>我又呆坐在荒野的尽头<br>不知道在凝望些什么<br>一如往常的许许多多个夜晚<br>我什么也做不了<br>除了凝望<br>我只觉得冷</p><p>5<br>假如我是一个诗人<br>一个乐观的诗人<br>我就会留意到我和你在一起时<br>天气很好，阳光温柔，风也善良<br>我们一起走在路上，想到什么便说什么<br>要是不说话，也十分美好<br>好像我们就该这样，从清晨到日暮<br>吃过饭后看月亮爬上来<br>听你说，“今晚的月亮好圆啊”</p><p>可我总在和你见面时便想到将要分别<br>想到这些我就难过到说不出话来<br>可是你明明什么也没有问我<br>美好的时光很短，短到让人看不见<br>美好不再<br>若是悲观者寿<br>我将长久且寂寥地等待下去</p><p>4<br>假如我是一个诗人<br>一个多情的诗人<br>我想象自己也许会为很多人动情<br>生活有时很长，还夹杂着苦难<br>我需要不断地去爱人方不至于难过</p><p>我遇到一些人像十八岁的云<br>一些人像十二月初冬的雪<br>像三四月的蝴蝶从蓝色里飞来<br>像鲜红的玫瑰、在夜晚醒来的星星<br>和睡不着的白日梦</p><p>我在同一段时间只钟情一个人<br>我不知道怎么会忽然不再了<br>有时候怪我，而有时不怪我<br>当我无法再把她写进字里行间<br>我知道，这已经不对了<br>喜欢一个人，才会为她写诗</p><p>从此朝也不思，夜也不想<br>诗和好梦都追随她而去<br>我只是在偶尔看到那些美好事物时恍然：<br>她是美好本身<br>而我呢，什么也不是</p><p>3<br>假如我是一个诗人<br>一个历经沧桑的诗人</p><p>我自深深处走来，向你走来<br>轻声唤你：我的爱人</p><p>2<br>假如我是一个诗人<br>一个不羁的诗人<br>我在和你有关的事物中迸发灵感<br>譬如初见你时，我写“星光颤抖”<br>沉沦之后，写“夜色零落”<br>大可以在你忽远忽近时抽身离去<br>为什么我却越来越虚弱了</p><p>我想你<br>而有时你也想到我</p><p>1<br>我在上帝之上爱你<br>在时间之外想你</p><p>如果明天下落不明<br>你知道我曾为你动过情吗</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础</title>
      <link href="/posts/28758.html"/>
      <url>/posts/28758.html</url>
      
        <content type="html"><![CDATA[<h2 id="在浏览器中输入一个网址，按下回车后，发生了什么？"><a href="#在浏览器中输入一个网址，按下回车后，发生了什么？" class="headerlink" title="在浏览器中输入一个网址，按下回车后，发生了什么？"></a>在浏览器中输入一个网址，按下回车后，发生了什么？</h2><ol><li><p><strong>域名解析</strong><br> 浏览器通过浏览器缓存、系统缓存、路由器缓存、域名服务器搜索该域名的ip地址。</p></li><li><p><strong>发起TCP3次握手，建立TCP连接</strong><br> 拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序的80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p><p> 为什么HTTP协议要基于TCP来实现？<br> 目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p></li><li><p><strong>建立TCP连接后发起HTTP请求</strong></p></li><li><p><strong>服务器端响应http请求，浏览器得到html代码</strong><br> 服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件。</p></li><li><p><strong>浏览器解析html代码，并请求html代码中的资源</strong><br> 浏览器拿到html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以请求成功显示的顺序并不一定是代码里面的顺序。</p><p> 浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p></li><li><p><strong>浏览器对页面进行渲染呈现给用户</strong><br> 浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</p></li></ol><h2 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h2><p><img src="/posts/28758/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png"></p><h2 id="物理层和数据链路层"><a href="#物理层和数据链路层" class="headerlink" title="物理层和数据链路层"></a>物理层和数据链路层</h2><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>IP ICMP ARP RARP AKP UUCP</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>TCP和UDP Socket</p><h3 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP 传输控制协议"></a>TCP 传输控制协议</h3><ol><li>TCP是面向连接的。面向连接，三次握手建立连接，四次挥手释放连接；</li><li>TCP提供可靠交付的服务。通过TCP连接传送的数据无差错、不丢失、不重复，并且按序到达。TCP的报文段是交给IP层(网络层)传送的，而IP层只能提供最大努力服务，网络提供的是不可靠的传输。</li><li>基于字节流。应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成是一连串的无结构的字节流。在TCP连接中传送的字节流的每一个字节都按顺序编号。</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。TCP连接的端点叫套接字(socket)。根据RFC793的定义，端口号拼接到IP地址即构成了套接字(IP地址：端口号)。每一条TCP连接唯一的被通信两端的两个套接字确定。</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li><li>TCP首部20个字节。源端口、目的端口，序号seq，确认号ack，同步位SYN，终止位FIN，确认位ACK，检验和，窗口，……</li><li>因为TCP下面的网络提供的是不可靠的传输，所以TCP必须采用适当的措施使得两个运输层之间的通信变得可靠：传输信道不产生差错；不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li></ol><h3 id="UDP-用户数据报协议"><a href="#UDP-用户数据报协议" class="headerlink" title="UDP 用户数据报协议"></a>UDP 用户数据报协议</h3><ol><li>UDP是无连接的，发送数据之前不需要建立连接。</li><li>UDP使用尽最大努力交付，不保证可靠交付。因此主机不需要维持复杂的连接状态表。</li><li>UDP是面向报文的。发送方的UDP(传输层)对应用层的应用程序交下来的报文，在添加UDP数据报首部后就向下交付给IP层，UDP对应用层交下来的报文既不合并也不拆分，而是保留这些报文的边界；在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。</li><li>UDP没有拥塞控制。网络出现的拥塞不会使源主机的发送速率降低，吞吐量只受限于数据生成速率、传输速率以及机器性能。</li><li>UDP支持一对一、一对多、多对一、多对多的交互通信。</li><li>UDP的首部开销小。UDP的首部：源端口，目的端口，长度(UDP用户数据报的长度)，检验和，每个字段两个字节，一共只有8个字节。</li></ol><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>ACK：确认序号标志<br>SYN：同步序号，用于建立连接过程<br>FIN：finish标志，用于释放连接(只有连接释放请求报文中置1)<br><img src="/posts/28758/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>第一次握手，建立连接时，客户端发送<strong>SYN包(syn=x)<strong>到服务器，并进入</strong>SYN_SEND</strong>状态，等待服务器确认；<br>第二次握手，服务器收到SYN包，必须确认客户的SYN(ack=x+1)，同时自己也发送一个SYN包(syn=y)，即<strong>SYN+ACK</strong>包，此时服务器进入<strong>SYN_RCVD</strong>状态；<br>第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包<strong>ACK(ack=y+1)<strong>，此包发送完毕，客户端和服务器进入</strong>ESTABLISHED</strong>状态，完成三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/posts/28758/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"><br>第一次挥手：客户端发送连接释放报文，FIN=1，seq=u，客户端进入终止等待1状态。<br>第二次挥手：服务器对连接释放的确认，ACK=1，ack=u+1，seq=v，至此客户端进入终止等待2状态，但是服务器进入关闭等待状态，还能向客户端发送数据。<br>第三次挥手：服务器发送连接释放报文，FIN=1，ACK=1，ack=u+1，seq=w，因为服务器在关闭等待状态可能向客户端发送了数据，所以seq不是v，服务器进入最终确认状态。<br>第四次挥手：客户端对服务器发来的连接释放进行确认，ACK=1，ack=w+1，seq=u+1。服务器收到这个确认报文进入CLOSED状态，而客户端还没有关闭连接，客户端此时进入TIME_WAIT状态，需等待2MSL时间。</p><p><strong>为什么会有TIME_WAIT状态？</strong><br>TCP连接必须经过时间2MSL后才真正释放掉。</p><ol><li>确保A发送的最后一个确认报文段ACK能够到达B，这个报文段有可能丢失，使得LAST_ACK状态的B收不到对已发送的FIN+ACK的确认，B就会重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器。如果A不等待2MSL时间，而是马上进入CLOSED状态，那么B很有可能无法正常进入CLOSED状态；</li><li>防止已失效的连接请求报文段出现在本连接中，避免新旧连接混淆。</li></ol><p><strong>为什么需要四次挥手才能断开连接？</strong><br>因为TCP连接是全双工的，发送方和接收方都需要FIN报文和ACK报文。</p><h3 id="流量控制、拥塞控制"><a href="#流量控制、拥塞控制" class="headerlink" title="流量控制、拥塞控制"></a>流量控制、拥塞控制</h3><h4 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h4><ol><li>以字节为单位的<strong>滑动窗口</strong>。TCP使用滑动窗口做流量控制和乱序重排。</li><li>超时重传时间的选择。报文段往返时间RTT(发送一个数据包到收到相对应的ACK所花费的时间)；超时重传时间RTO(超市计时器设置的重传时间间隔)。</li><li>选择确认(select ACK)。<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以在TCP连接上实现对发送方的流量控制。发送方的发送窗口不能超过接收方给出的接收窗口的数值。TCP的窗口单位是字节，不是报文段。<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4>计算机网络中的链路容量(即带宽)、交换节点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫做拥塞。拥塞：对资源的需求超过了可用资源。<br>拥塞控制防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。</li></ol><p>TCP的拥塞控制算法：慢开始、拥塞避免、快重传、快恢复。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>HTTP和HTTPS WebSocket</p><h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><ul><li>HTTPS是具有安全性的SSL加密协议，是密文传输的，HTTP明文传输</li><li>连接方式不同，HTTPS默认使用<code>443</code>端口，HTTP使用<code>80</code>端口</li><li>HTTPS=HTTP+加密+认证+完整性保护</li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>SSL(Security Sockets Layer，安全套接层)是为网络通信提供安全及数据完整性的一种安全协议，是操作系统对外的API。<br>SSL3.0后更名为TLS，采用身份验证和数据加密保证网络通信的安全和数据的完整性。</p><h3 id="HTTP超文本传输协议"><a href="#HTTP超文本传输协议" class="headerlink" title="HTTP超文本传输协议"></a>HTTP超文本传输协议</h3><p>客户/服务器模式。<br>http协议本身是无连接的，虽然http使用了TCP作为运输层协议，但通信的双方在交换http报文之前不需要先建立http连接。<br>http协议是无状态的。同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。</p><h4 id="HTTP协议与TCP-IP协议的关系"><a href="#HTTP协议与TCP-IP协议的关系" class="headerlink" title="HTTP协议与TCP/IP协议的关系"></a>HTTP协议与TCP/IP协议的关系</h4><p>HTTP的长连接和短连接本质上是TCP的长连接和短连接。<br>HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。<br>IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。</p><h4 id="如何理解HTTP协议是无状态的"><a href="#如何理解HTTP协议是无状态的" class="headerlink" title="如何理解HTTP协议是无状态的"></a>如何理解HTTP协议是无状态的</h4><p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。<br>也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。<br>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议。</p><h4 id="http长连接和短连接"><a href="#http长连接和短连接" class="headerlink" title="http长连接和短连接"></a>http长连接和短连接</h4><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。<br>当客户端浏览器访问的某个HTML或其他类型的web页中包含有其他的web资源(如javaScript文件、图像文件、CSS文件等)，每遇到这样一个web资源，浏览器就会重新建立一个http会话。</p><p>从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。<br>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件(如apache)中设定这个时间。<br>实现长连接需要客户端和服务端都支持长连接。</p><h4 id="http-1-0、http-1-1、http-2-0、http-3-0"><a href="#http-1-0、http-1-1、http-2-0、http-3-0" class="headerlink" title="http/1.0、http/1.1、http/2.0、http/3.0"></a>http/1.0、http/1.1、http/2.0、http/3.0</h4><ul><li>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，HTTP1.1默认支持长连接</li><li>HTTP 1.1支持只发送header信息(不带任何body信息)。还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可</li><li>HTTP1.0是没有host域的，HTTP1.1才支持这个参数</li><li>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求</li><li>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快</li><li>HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取</li></ul><h4 id="http-中-get-和-post-区别"><a href="#http-中-get-和-post-区别" class="headerlink" title="http 中 get 和 post 区别"></a>http 中 get 和 post 区别</h4><p>http报文层面：GET将请求信息放在URL中，POST放在报文体中。<br>数据库层面：GET请求符合幂等性和安全性，POST不符合。<br>其他：GET请求可以被缓存、被存储，而POST不行。</p><h4 id="常见的-web-请求返回的状态码"><a href="#常见的-web-请求返回的状态码" class="headerlink" title="常见的 web 请求返回的状态码"></a>常见的 web 请求返回的状态码</h4><p>1xx表示通知信息，如请求收到了或正在进行处理<br>2xx表示成功，如202接受或知道了，200正常返回信息<br>3xx表示重定向，如要完成请求还必须采取进一步的行动<br>4xx表示客户端错误，如请求中有错误的语法或不能完成<br>5xx表示服务器的差错，如服务器失效无法完成请求<br>400错误的请求；404找不到，请求的资源不存在；401请求未经授权；403服务器收到请求，但是拒绝提供服务<br>302临时移动；301资源永久性地转移到其他URL；<br>500内部服务器错误；503服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p><h3 id="HTTP是无状态协议，如何保存用户状态"><a href="#HTTP是无状态协议，如何保存用户状态" class="headerlink" title="HTTP是无状态协议，如何保存用户状态"></a>HTTP是无状态协议，如何保存用户状态</h3><p>HTTP是一种不保存状态，即无状态(stateless)协议。也就是说HTTP协议自身不对请求和响应之间的通信状态进行保存。<br>那么我们如何保存用户状态呢？<br>Session机制的存在就是为了解决这个问题，session的主要作用就是通过服务端记录用户的状态。<br>典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为HTTP协议是无状态的，服务端给特定的用户创建特定的session之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个session，过了时间限制，就会销毁这个session)。</p><ul><li>在服务端保存session的方法很多，最常用的就是内存和数据库(使用内存数据库redis保存)。</li><li>既然session存放的服务器端，那么我们如何实现seesion跟踪呢？大部分情况下，我们都是通过在Cookie中附加一个Session ID的方式来跟踪。</li></ul><h3 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h3><p>Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><ol><li><strong>Cookie一般用来保存用户信息。</strong>比如①我们在Cookie中保存已经登录过的用户信息，下次访问网站的时候页面可以自动把你登录的一些基本信息给填了；②一般的网站都会有保持登录，也就是说下次再访问网站的时候就不需要重新登录了，这是因为用户登陆的时候我们可以存放一个Token在Cookie中，下次登录的时候只需要根据Token值来查找用户即可(为了安全考虑，重新登陆一般要将Token重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session的主要作用是通过服务端记录用户的状态。</strong>比如购物车场景。</li><li>Cookie数据存放在客户端(浏览器端)，Session数据保存在服务器端；</li><li>Session相对于Cookie更安全，因为Session是存储在服务器的。如果使用Cookie，一些敏感信息不要写入Cookie中，最好能将Cookie信息加密然后使用到的时候再去服务端解密。</li><li>服务器访问增多，Session会增加服务器负担，若考虑减轻服务器负担，应使用Cookie。<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4>在RFC6265中对Cookie进行了定义，规定万维网站点可以使用Cookie来跟踪用户。<br>Cookie表示在HTTP服务器和客户之间传递的状态信息。<br>cookie是由服务器发给客户端的特殊信息，以文本的形式存放在客户端；客户端再次请求的时候，会把cookie回发；服务器接收到后，会解析cookie生成与客户端相对应的内容。<br><img src="/posts/28758/cookie%E8%AE%BE%E7%BD%AE%E5%8F%8A%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B.png"><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4>session机制是服务器端的机制，是在服务器上保存的信息。<br>服务器解析客户端请求并操作session-id，按需保存状态信息。<br>Session是指使用HttpSession对象实现会话跟踪的技术，是一种在服务器端保持会话跟踪的解决方案。</li></ol><p>服务器在创建会话对象时，会为其分配一个唯一的会话标识——SessionID，以“JSESSIONID”的属性名保存在客户端Cookie中，在用户随后的请求中，服务器通过读取Cookie中的JSESSIONID属性值来识别不同的用户，从而实现对每个用户的会话跟踪。</p><p>session的实现方式：1.使用cookie来实现；2.使用URL回写来实现。</p><h4 id="cookie被禁用，如何实现session"><a href="#cookie被禁用，如何实现session" class="headerlink" title="cookie被禁用，如何实现session"></a>cookie被禁用，如何实现session</h4><p>最常用的就是利用URL重写，把SessionID直接附加在URL路径的后面。<br>URL重写通过HttpServletResponse的encodeURL()方法和encodeRedirectURL()方法实现。</p><ul><li>encodeURL()方法可以对任意请求的URL进行重写。</li><li>encodeRedirectURL()方法主要对使用sendRedirect()方法的URL进行重写。</li><li>URL重写方法根据请求信息中是否包含“Set-Cookie”请求头来决定是否进行URL重写，若包含该请求头，会将URL原样输出；若不包含，则会将会话标识重写到URL中。</li></ul><h3 id="Socket和WebSocket"><a href="#Socket和WebSocket" class="headerlink" title="Socket和WebSocket"></a>Socket和WebSocket</h3><p>WebSocket 是一种网络通信协议，类似 http 协议</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http</span></span><br><span class="line">http://example.com:80/some/path</span><br><span class="line"><span class="comment"># websocket</span></span><br><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等<br>域名解析、根域名服务器<br>DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>正向代理、反向代理<br>反向代理服务器</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>应用程序级别的概念。<br>阻塞与非阻塞是应用程序访问某一资源时候，该资源没有准备就绪时应用程序的处理方式。<br>关注的是发起请求之后等待数据返回时的状态。</p><p>被挂起无法执行其他操作的应用程序是阻塞型的；<br>可以立即去进行其他作业的应用程序是非阻塞型的。</p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>操作系统级别的。<br>是否是同步还是异步，关注的是任务完成时消息通知的方式。</p><p>由调用方（应用程序）主动问询的方式是同步调用；<br>由被调用方（操作系统内核）主动通知调用方（应用程序）任务已完成的方式是异步调用。</p><h3 id="网络IO、磁盘IO"><a href="#网络IO、磁盘IO" class="headerlink" title="网络IO、磁盘IO"></a>网络IO、磁盘IO</h3><h3 id="Unix的5种IO模型"><a href="#Unix的5种IO模型" class="headerlink" title="Unix的5种IO模型"></a>Unix的5种IO模型</h3><h4 id="BIO-Block-IO"><a href="#BIO-Block-IO" class="headerlink" title="BIO(Block IO)"></a>BIO(Block IO)</h4><p>BIO同步阻塞IO</p><h4 id="NIO-Non-Block-IO"><a href="#NIO-Non-Block-IO" class="headerlink" title="NIO(Non-Block IO)"></a>NIO(Non-Block IO)</h4><p>NIO同步非阻塞IO</p><h4 id="信号驱动I-O-signal-driven-I-O-SIGIO"><a href="#信号驱动I-O-signal-driven-I-O-SIGIO" class="headerlink" title="信号驱动I/O  signal driven I/O (SIGIO)"></a>信号驱动I/O  signal driven I/O (SIGIO)</h4><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><h4 id="AIO-Asynchronize-IO"><a href="#AIO-Asynchronize-IO" class="headerlink" title="AIO(Asynchronize IO)"></a>AIO(Asynchronize IO)</h4><p>AIO异步非阻塞IO</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——12.4java与线程</title>
      <link href="/posts/56614.html"/>
      <url>/posts/56614.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——12.3java内存模型</title>
      <link href="/posts/54643.html"/>
      <url>/posts/54643.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机内存模型、缓存一致性、MESI-协议"><a href="#计算机内存模型、缓存一致性、MESI-协议" class="headerlink" title="计算机内存模型、缓存一致性、MESI 协议"></a>计算机内存模型、缓存一致性、MESI 协议</h2><h3 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h3><p>由于计算机的存储设备与运算器的运算速度之间有着几个数量级的差距，所以现代计算机系统不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(cache)来作为内存与处理器之间的缓冲。<br>将运算需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。</p><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性(Cache Coherence)。<br>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)。<br><img src="/posts/54643/neicunmoxing.png"></p><p>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？</p><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI、Synapse、Firefly及DragonProtocol等等。<br>Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的。</p><p>MESI是指4种状态的首字母，每个Cache line有4个状态，可用两个bit表示。</p><ul><li>M 修改(Modify)<br>  缓存块已经被改动，必须被写回主存，其他处理器不能再缓存这个块。</li><li>E 独享、互斥(Exclusive)<br>  缓存块还没有被改动，且其他处理器不能装入这个缓存块。</li><li>S 共享(Shared)<br>  缓存块未被改动，且其他处理器能够装入这个缓存块。</li><li>I 无效(Invalid)<br>  缓存块中的数据无效。</li></ul><p>可见性、原子性、有序性、happens-before、内存屏障、synchronized、volatile、final、锁</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。<br>此处的变量(Variable)与java编程中所说的变量略有区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为后者是线程私有的，不会被共享，自然就不存在竞争问题。<br>为了获得较好的执行效能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存在和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权力。</p><p>Java内存模型规定了所有的变量都存储在主内存(MainMemory)中(可以类比物理机的主内存，此处仅是虚拟机内存的一部分)。<br>每条线程还有自己的工作内存(WorkingMemeory，可与处理器高速缓存类比)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量。<br>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p><img src="/posts/54643/javaneicunmoxing.png"></p><h3 id="12-3-2-内存间交互操作"><a href="#12-3-2-内存间交互操作" class="headerlink" title="12.3.2 内存间交互操作"></a>12.3.2 内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8中操作(虚拟机实现时必须保证每一种操作都是原子的、不可再分的)来完成：</p><ul><li>lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write(写入)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><h3 id="12-3-4-对于volatile型变量的特殊规则"><a href="#12-3-4-对于volatile型变量的特殊规则" class="headerlink" title="12.3.4 对于volatile型变量的特殊规则"></a>12.3.4 对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是java虚拟机提供的最轻量级的同步机制，但是它并不容易被正确地、完整地理解，以至于许多程序员都不去使用它，遇到需要处理多线程数据竞争的问题时一律使用synchronized来进行同步。</p><p>Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些规则定义之前，先介绍一下这个关键字的作用。<br>当一个变量被定义成volatile之后，它将具备两种特性，第一是<code>保证此变量对所有线程的可见性</code>；第二是<code>禁止指令重排序优化</code>。</p><p>两种特性产生的原因是Java内存模型对volatile变量的三条特殊规则。</p><ul><li><p>规则1<br>  只有当线程T对变量V执行的前一个操作为load时，线程T才可以对变量V执行use操作;<br>  并且只有当线程T对变量V执行的后一个操作为use时，线程T才可以对变量V执行load操作。</p><p>  该规则令read - load - use形成整体性的原子操作，使得volatile变量在被使用前会从主内存中读取最新值。</p></li><li><p>规则2<br>  只有当线程T对变量V执行的前一个操作为assign时，线程T才可以对变量V执行store动作;<br>  并且只有当线程T对变量V执行的后一个操作为store时，线程T才可以对变量V执行assign动作。</p><p>  该规则令assign - store - write形成整体性的原子操作，使得volatile变量在被赋值后会立即同步回主内存。</p></li><li><p>规则3<br>  假定操作A是线程T对变量V实施的use或assign操作，操作F是和操作A关联的load或store操作，操作P是和操作F相关联的read或write操作；<br>  假定操作B是线程T对变量W实施的use或assign操作，操作G是和操作B关联的load或store操作，操作Q是和操作G相关联的read或write操作；<br>  如果A先于B，则P先于Q。</p></li></ul><p>这里的<code>可见性</code>是指<code>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</code>，而普通变量不能做到这一点，变量值在线程间传递均需要通过主内存来完成。<br>如：线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量的值才会对线程B可见。</p><p>关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。<br>这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。<br>volatile变量在各个线程的工作内存中不存在一致性问题(在各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题)，但是<code>java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的</code>。</p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用synchronized或java.util.concurrent中的原子类)来保证原子性：</p><ol><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ol><p>使用volatile变量的第二个语义是<code>禁止指令重排序优化</code>，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”(Within-Thread-As-If-Serial Semantics)。<br><img src="/posts/54643/volatile-zhilingchongpaixu.png"></p><h5 id="volatile与内存屏障"><a href="#volatile与内存屏障" class="headerlink" title="volatile与内存屏障"></a>volatile与内存屏障</h5><ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障</li></ul><p>解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？<br>确实在某些情况下，volatile同步机制的性能要优于锁(使用synchronized关键字或java.util.concurrent包里面的锁)，但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地说volatile就会比synchronized快上多少。<br>如果让volatile自己与自己比较，则可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障(Memory Barrier或Memory Fence)指令来保证处理器不发生乱序执行。<br>不过即便如此，大多数情况下volatile的总开销仍然要比锁来得低，我们在volatile与锁中选择的唯一判断依据仅仅是volatile的语义能否满足使用场景的需求。</p><p><img src="/posts/54643/volatile-dingyiguize.png"></p><h3 id="12-3-4-对于long和double型变量的特殊规则"><a href="#12-3-4-对于long和double型变量的特殊规则" class="headerlink" title="12.3.4 对于long和double型变量的特殊规则"></a>12.3.4 对于long和double型变量的特殊规则</h3><p>Java内存模型只保证32位数据类型操作的原子性，对于64位数据类型（long和double）操作则由两个32位原子操作组成。</p><p>java内存模型要求lock、unlock、read、load、assign、use、store和write这八个操作都具有原子性。<br>但是对于64位的数据类型(long和double)，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的<code>long和double的非原子性协定</code>。</p><p>如果有多个进程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。<br>不过这种读取到“半个变量”的情况非常罕见，因为java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。<br>在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要将用到的long和double变量专门声明为volatile。</p><h3 id="12-3-5-原子性、可见性与有序性"><a href="#12-3-5-原子性、可见性与有序性" class="headerlink" title="12.3.5 原子性、可见性与有序性"></a>12.3.5 原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。<br>想要线程安全，必须保证原子性、可见行、有序性。</p><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><p>由Java内存模型来直接保证原子性变量操作包括read、load、assign、use、store和write这六个，大致可以认为基本数据类型的访问读写是具备原子性的(long和double的非原子性协定例外)。<br>如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求。<br>尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p><h4 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性(Visibility)"></a>可见性(Visibility)</h4><p>可见性就是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。<br>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。<br>普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新，因此可以说volatile保证了多线程操作时变量的可见性，而普通变量不能保证这一点。</p><p>除了volatile之外，java还有两个关键字能实现可见性，它们是synchronized和final。<br>同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)”这条规则获得的。<br>而final关键字的可见性是指被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去(this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那么在其他线程中就能看见final字段的值。</p><h4 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性(Ordering)"></a>有序性(Ordering)</h4><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。<br>前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。<br>volatile关键字本身就包含了禁止指令重排序的含义。<br>而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p><h3 id="12-3-6-先行发生规则（happens-before）"><a href="#12-3-6-先行发生规则（happens-before）" class="headerlink" title="12.3.6 先行发生规则（happens-before）"></a>12.3.6 先行发生规则（happens-before）</h3><p>先行发生原则（happens - before），如果操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——8虚拟机字节码执行引擎</title>
      <link href="/posts/31406.html"/>
      <url>/posts/31406.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——7虚拟机类加载机制</title>
      <link href="/posts/22986.html"/>
      <url>/posts/22986.html</url>
      
        <content type="html"><![CDATA[<h3 id="7-1概述"><a href="#7-1概述" class="headerlink" title="7.1概述"></a>7.1概述</h3><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。</p><p>在java语言里面，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为java应用程序提供高度的灵活性。<br>java中天生可以<code>动态扩展</code>的语言特性就是依赖<code>运行期动态加载和动态连接</code>这个特点实现的。</p><h3 id="7-2类加载的时机"><a href="#7-2类加载的时机" class="headerlink" title="7.2类加载的时机"></a>7.2类加载的时机</h3><p>类加载机制：jvm把class文件加载到内存，并对数据进行校验、分配、解析和初始化，最终形成jvm可以直接使用的java类型的过程。</p><p><img src="/posts/22986/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"><br>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了以上七个阶段，其中验证、准备和解析三个部分统称为连接。</p><p><code>加载、验证、准备、初始化和卸载</code>这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。<br>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持java语言的运行时绑定。<br>按部就班地“开始”，而不是按部就班地“进行”或“完成”，因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。</p><p>什么情况下需要开始类加载过程的第一个阶段：加载。虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。<br>但是对于初始化阶段，虚拟机规范则是严格规定了有些只有四种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之前开始)：<br><img src="/posts/22986/%E6%9C%89%E4%B8%94%E5%8F%AA%E6%9C%89.png"></p><p>对于这四种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语“有且只有”，这四种场景中的行为称为<code>对一个类进行主动引用</code>。<br>除此之外所有引用类的方式，都不会触发初始化，称为被动引用。</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化；</li><li>通过数组定义来引用类，不会触发此类的初始化；</li><li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li></ul><p><img src="/posts/22986/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A0%E8%BD%BD.png"></p><h3 id="7-3类加载的过程"><a href="#7-3类加载的过程" class="headerlink" title="7.3类加载的过程"></a>7.3类加载的过程</h3><h4 id="7-3-1加载"><a href="#7-3-1加载" class="headerlink" title="7.3.1加载"></a>7.3.1加载</h4><p>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。</p><p>“加载”阶段是“类加载”过程的一个阶段，这两个名词看起来很相似。<br>在加载阶段，虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</li></ol><p><img src="/posts/22986/%E8%8E%B7%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81.png"><br>相对于类加载过程的其他阶段，加载阶段(准确地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员们可以通过定义自己的类加载器去控制字节流的获取方式。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。<br>然后在java堆中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持这固定的先后顺序。</p><h4 id="7-3-2验证"><a href="#7-3-2验证" class="headerlink" title="7.3.2验证"></a>7.3.2验证</h4><p>确保加载的类信息符合jvm规范，没有安全方面的问题。</p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>Java语言本身是相对安全的语言(依然是相对于C/C++来说)，使用纯粹的java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。<br>但前面已经说过，Class文件并不一定要求用java源码编译而来，可以使用任何途径，包括用十六进制编辑器直接编写来产生Class文件。<br>在字节码的语言层面上，上述java代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。<br>虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p><p>尽管验证阶段是非常重要的，并且验证阶段的工作量在虚拟机的类加载子系统中占了很大一部分，但虚拟机规范对这个阶段的限制和指导显得非常笼统，仅仅说了一句如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个java.lang.VerifyError异常或其子类异常，具体应当检查哪些方面，如果检查，何时检查，都没有强制要求或明确说明，所以不同的虚拟机对类验证的实现可能会有所不同，但大致上都会完成下面四个阶段的检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。</p><ol><li><p>文件格式验证<br> 第一阶段是要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。<br> 验证点包括：是否以魔数0xCAFEBABE开头；主、次版本号是否在当前虚拟机处理范围之内；常量池的常量中是否有不被支持的常量类型(检查常量tag标志)；指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据；Class文件中各个部分及文件本身是否有被删除的或附加的其他信息；</p><p> 实际上第一阶段的验证点远不止这些，上面这些只是从HotSpot虚拟机源码中摘抄的一小部分，该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个java类型信息的要求。<br> 这阶段的验证是基于字节流进行的，进行了这个阶段的验证之后，字节流才会进入内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构进行的。</p></li><li><p>元数据验证<br> 第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。<br> 这个阶段可能包括的验证点如下：这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)；这个类的父类是否继承了不允许被继承的类(被final修饰的类)；如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；类中的字段、方法是否与父类产生了矛盾(例如覆盖了父类的final字段，或者出现不符合规则的方法重写)；<br> 第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合java语言规范的元数据信息。</p></li><li><p>字节码验证<br> 第三阶段是整个验证过程中最复杂的一个阶段，主要工作是进行数据流和控制流分析。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析。<br> 这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。<br> 例如：保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况——在操作栈中放置了一个int类型的数据，使用时却按long类型来加载如本地变量表中；保证跳转指令不会跳转到方法体以外的字节码指令上；保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型则是危险和不合法的；</p><p> 如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说名其一定就是安全的。<br> 即使字节码验证之中进行了大量的检查，也不能保证这一点。这里涉及了离散数学中一个很著名的问题“Halting Problem”。通俗一点的说法就是，通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。<br> <img src="/posts/22986/%E5%AD%97%E8%8A%82%E7%A0%81%E9%AA%8C%E8%AF%81.png"></p></li><li><p>符号引用验证<br> 最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。<br> 符号引用验证可以看做是对类自身以外(常量池中的各种符号引用)的信息进行匹配性的校验，通常需要校验以下内容：符号引用中通过字符串描述的全限定名是否能找到对应的类；在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段；符号引用中的类、字段和方法的访问性(private、protected、public、default)是否可被当前类访问；</p><p> 符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p></li></ol><h4 id="7-3-3准备"><a href="#7-3-3准备" class="headerlink" title="7.3.3准备"></a>7.3.3准备</h4><p>正式为类变量(static)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。<br>两个容易混淆的概念：这时候进行内存分配的仅包括类变量(static修饰的变量)，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在java堆中；这里所说的初始值“通常情况”下是数据类型的零值。</p><p>假设一个类变量的定义为：public static int value = 123; 那么变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会被执行。</clinit></p><p>“通常情况”下初始值是零值，相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，public static final int value = 123; 编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><p><img src="/posts/22986/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png"></p><h4 id="7-3-4解析"><a href="#7-3-4解析" class="headerlink" title="7.3.4解析"></a>7.3.4解析</h4><p>虚拟机常量池内的符号引用替换为直接引用的过程。</p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？</p><ul><li><p>符号引用(Symbolic Reference)<br>  符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p></li><li><p>直接引用(Direct Reference)<br>  直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p></li></ul><p><img src="/posts/22986/%E8%A7%A3%E6%9E%90.png"><br>解析动作主要针对类或接口、字段、类方法、接口访问四类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。</p><ol><li>类或接口的解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol><h4 id="7-3-5初始化"><a href="#7-3-5初始化" class="headerlink" title="7.3.5初始化"></a>7.3.5初始化</h4><p>初始化阶段是执行类构造器<clinit>()方法的过程。<br>类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的。<br>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<br>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。<br>当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。</clinit></clinit></clinit></p><ul><li>类的主动引用(一定会发生类的初始化)<ol><li>new一个类的对象；</li><li>调用类的静态成员(除了final常量)和静态方法；</li><li>使用java.lang.reflect包的方法对类进行反射调用；</li><li>当虚拟机启动java Hello，则一定会初始化Hello类，说白了就是先启动mian方法所在的类；</li><li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类。</li></ol></li><li>类的被动引用(不会发生类的初始化)<ol><li>当访问一个静态域时，只有真正声明这个域的类才会被初始化(通过子类引用父类的静态变量，不会导致子类初始化)；</li><li>通过数组定义类引用，不会触发此类的初始化；</li><li>引用常量不会触发此类的初始化(常量在编译阶段就存入调用类的常量池中了)。</li></ol></li></ul><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。<br>到了初始化阶段，才真正开始执行类中定义的java程序代码(或者说是字节码)。<br>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。<br><img src="/posts/22986/clinit.png"><br><img src="/posts/22986/clinit2.png"></clinit></p><h3 id="7-4类加载器"><a href="#7-4类加载器" class="headerlink" title="7.4类加载器"></a>7.4类加载器</h3><p>类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。</p><p>类缓存：标准的javaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间，不过jvm垃圾收集器可以回收这些Class对象。</p><ol><li>启动类加载器(Bootstrap Classloader)<br> 用来加载java的核心库(JAVA_HOME/jre/lib/rt.jar，或sun.boot.class.path路径下的内容)，是用原生代码来实现的，并不继承自java.lang.ClassLoader。<br> 加载扩展类和应用程序类加载器，并指定他们的父类加载器。</li><li>扩展类加载器(Extension Classloader)<br> 用来加载java的扩展库(JAVA_HOME/jre/ext/.jer，或java.ext.dirs路径下的内容)。<br> java虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载java类。<br> 由sun.misc.Launcher$ExtClassLoader实现。</li><li>应用程序类加载器(Application Classloader)<br> 它根据java应用的类路径(classpath，java.class.path路径)来加载类，一般来说，java应用的类都是由它来完成加载的。<br> 由sun.misc.Launcher$AppClassLoader实现。</li><li>自定义类加载器<br> 开发人员可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。</li></ol><p>java.class.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个java类，即java.lang.Class类的一个实例。<br>除此之外，ClassLoader还负责加载java应用所需的资源，如图像文件和配置文件等。</p><p><img src="/posts/22986/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"><br>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，这里类加载器之间的父子关系一般不会以继承(Inheritance)的关系来实现，而是都使用组合(Composition)关系来复用父加载器的代码。</p><p>类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的java程序中，但它并不是一个强制性的约束模型，而是java设计者们推荐给开发者们的一种类加载器实现方法。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。</p><p>双亲委托机制是为了保证java核心库的类型安全，这种机制保证不会出现用户自己能定义java.lang.Object类的情况。</p><p><img src="/posts/22986/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png"></p><p>类加载器的代理模式：交给其他加载器来加载指定的类。<br>双亲委派机制是代理模式的一种，并不是所有的类加载器都采用双亲委派机制；tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。</p><p>自定义类加载器的流程：继承java.lang.ClassLoader；首先检查请求的类型是否已经被这个类加载器加载到命名空间中了，如果已经加载，直接返回；委派类加载请求给父类加载器，如果父类加载器能够完成，则返回父类加载器加载的Class实例；调用本类加载类的findClass(……)方法，试图获取对应的字节码，如果获取的到，则调用defineClass(……)导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass(……)，loadClass(……)转抛异常，终止加载过程。</p><p>实现双亲委派模型的代码都集中来自java.lang.ClassLoader的loadClass()方法：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，则再抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p><p>注意，被两个类加载器加载的同一个类，jvm不认为是相同的类。</p><p>思考：</p><ol><li><p>假如我们自己写了一个java.lang.String的类，我们是否可以替换调JDK本身的类？<br> 答案是否定的。我们不能实现。<br> 为什么呢？<br> 我看很多网上解释是说双亲委托机制解决这个问题，其实不是非常的准确。因为双亲委托机制是可以打破的，你完全可以自己写一个classLoader来加载自己写的java.lang.String类，但是你会发现也不会加载成功，具体就是因为针对java.※开头的类，jvm的实现中已经保证了必须由bootstrp来加载。<br> 因为String已经在启动时被加载，所以用户自定义类ClassLoader是无法加载一个自定义的String。</p></li><li><p>既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？<br> 因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class。<br> 如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。</p><p> 定义自已的类加载器分为两步：</p><ol><li>继承java.lang.ClassLoader</li><li>重写父类的findClass方法</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——6类文件结构</title>
      <link href="/posts/6156.html"/>
      <url>/posts/6156.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——排序</title>
      <link href="/posts/45185.html"/>
      <url>/posts/45185.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/45185/zonghebijiao.jpg"></p><h3 id="一、排序-上-：为什么插入排序比冒泡排序更受欢迎？"><a href="#一、排序-上-：为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="一、排序(上)：为什么插入排序比冒泡排序更受欢迎？"></a>一、排序(上)：为什么插入排序比冒泡排序更受欢迎？</h3><p>分析一个排序算法，从哪几方面入手：</p><h4 id="1-排序算法的执行效率"><a href="#1-排序算法的执行效率" class="headerlink" title="1.排序算法的执行效率"></a>1.排序算法的执行效率</h4><p>1）最好情况、最坏情况、平均情况时间复杂度。<br>2）时间复杂度的系数、常数、低阶。<br>3）比较次数和交换(或移动)次数。基于比较的排序算法会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。</p><h4 id="2-排序算法的内存消耗"><a href="#2-排序算法的内存消耗" class="headerlink" title="2.排序算法的内存消耗"></a>2.排序算法的内存消耗</h4><p>算法的内存消耗可以通过空间复杂度来衡量，针对排序算法的空间复杂度，引入了一个概念——原地排序(Sorted in place)。原地排序算法就是特指空间复杂度为O(1)的排序算法，包括冒泡排序、插入排序、选择排序。</p><h4 id="3-排序算法的稳定性"><a href="#3-排序算法的稳定性" class="headerlink" title="3.排序算法的稳定性"></a>3.排序算法的稳定性</h4><p>除了执行效率和内存消耗，针对排序算法还有一个重要的度量指标——稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。<br>假如现在有一组数据：2，9，3，4，8，3，按照大小排序之后是2，3，3，4，8，9。这组数据里有两个3，经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那这种排序算法就是稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就是不稳定的。<br>数据结构和算法在讲排序的时候，都是用整数来举例，在真正软件开发中，要排序的往往不是单纯的整数，而是一组对象，需要按照对象的某个key来排序。<br>比如，现在要给电商交易系统中的“订单”排序，订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有10万条订单数据，希望按照金额从小到大对订单数据排序。对于金额相同的订单，希望按照下单时间从早到晚有序。<br>对于这样一个排序需求，借助稳定排序算法，先按照下单时间给订单排序，然后用稳定排序算法，按照订单金额重新排序。这样两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间排序。稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</p><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><h4 id="1-1冒泡排序是原地排序算法吗？"><a href="#1-1冒泡排序是原地排序算法吗？" class="headerlink" title="1.1冒泡排序是原地排序算法吗？"></a>1.1冒泡排序是原地排序算法吗？</h4><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是一个原地排序算法。</p><h4 id="1-2冒泡排序是稳定的排序算法吗？"><a href="#1-2冒泡排序是稳定的排序算法吗？" class="headerlink" title="1.2冒泡排序是稳定的排序算法吗？"></a>1.2冒泡排序是稳定的排序算法吗？</h4><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的。</p><h4 id="1-3冒泡排序的时间复杂度"><a href="#1-3冒泡排序的时间复杂度" class="headerlink" title="1.3冒泡排序的时间复杂度"></a>1.3冒泡排序的时间复杂度</h4><p>最好情况下要排序的数据是有序的，只需要进行一次比较操作，是O(n)。而最坏情况下，要排序的数据刚好是倒序排列的，要进行n次冒泡操作，为O(n2)。<br>对于包含n个数据的数组，这n个数据有n!中排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的，如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算很复杂。<br>这里，通过“有序度”和“逆序度”这两个概念来进行分析。<br>有序度是数组中具有有序关系的元素对的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure><p><img src="/posts/45185/youxudu.jpg"><br>对于一个倒序排列的数组，比如654321，有序度为0；对于一个完全有序的数组，比如123456，有序度就是n×(n-1)/2，就是15。我们把这种完全有序的数组的有序度叫做满有序度。<br>逆序度的定义正好跟有序度相反(默认从小到大为有序)。</p><h4 id="逆序度-满有序度-有序度"><a href="#逆序度-满有序度-有序度" class="headerlink" title="逆序度 = 满有序度 - 有序度"></a>逆序度 = 满有序度 - 有序度</h4><p>排序的过程就是增加有序度，减少逆序度的过程，最后达到满有序度。</p><p>对于包含n个数据的数组进行冒泡排序，平均交换次数在最坏情况下，初始状态有序度为0，要进行n×(n-1)/2次交换；最好情况下，初始状态的有序度是n×(n-1)/2，就不需要进行交换。取中间值n×(n-1)/4来表示平均情况。定性分析下平均情况的时间复杂度为O(n2)。</p><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h3><h4 id="2-1插入排序是原地排序算法吗？"><a href="#2-1插入排序是原地排序算法吗？" class="headerlink" title="2.1插入排序是原地排序算法吗？"></a>2.1插入排序是原地排序算法吗？</h4><p>插入排序算法不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。</p><h4 id="2-2插入排序是稳定的排序算法吗？"><a href="#2-2插入排序是稳定的排序算法吗？" class="headerlink" title="2.2插入排序是稳定的排序算法吗？"></a>2.2插入排序是稳定的排序算法吗？</h4><p>在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p><h4 id="2-3插入排序的时间复杂度"><a href="#2-3插入排序的时间复杂度" class="headerlink" title="2.3插入排序的时间复杂度"></a>2.3插入排序的时间复杂度</h4><p>最好情况下从头遍历已经有序的元素O(n)；最坏情况下数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，为O(n2)。平均时间复杂度为O(n2)。</p><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><p>选择排序算法的实现思路有点类似插入排序，也区分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><h4 id="3-1选择排序是原地排序算法吗？"><a href="#3-1选择排序是原地排序算法吗？" class="headerlink" title="3.1选择排序是原地排序算法吗？"></a>3.1选择排序是原地排序算法吗？</h4><p>空间复杂度为O(1)，是一种原地排序算法。</p><h4 id="3-2选择排序是稳定的排序算法吗？"><a href="#3-2选择排序是稳定的排序算法吗？" class="headerlink" title="3.2选择排序是稳定的排序算法吗？"></a>3.2选择排序是稳定的排序算法吗？</h4><p>选择排序是一种不稳定的排序算法。</p><h4 id="3-3选择排序的时间复杂度"><a href="#3-3选择排序的时间复杂度" class="headerlink" title="3.3选择排序的时间复杂度"></a>3.3选择排序的时间复杂度</h4><p>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为O(n2)。</p><h3 id="为什么插入排序要比冒泡排序更受欢迎？"><a href="#为什么插入排序要比冒泡排序更受欢迎？" class="headerlink" title="为什么插入排序要比冒泡排序更受欢迎？"></a>为什么插入排序要比冒泡排序更受欢迎？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line">if (a[j] &gt; a[j+1]) &#123; // 交换</span><br><span class="line">   int tmp = a[j];</span><br><span class="line">   a[j] = a[j+1];</span><br><span class="line">   a[j+1] = tmp;</span><br><span class="line">   flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line">if (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+1] = a[j];  // 数据移动</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码实现上看，冒泡排序的数据交换要比插入排序的数据移动操作要多，cpu处理时间就长。虽然两者时间复杂度一样，但是插入排序优化空间要大，例如其中的希尔排序。</p><h3 id="二、排序-下-：如何用快排思想在O-n-内查找无序数组中第k大元素？"><a href="#二、排序-下-：如何用快排思想在O-n-内查找无序数组中第k大元素？" class="headerlink" title="二、排序(下)：如何用快排思想在O(n)内查找无序数组中第k大元素？"></a>二、排序(下)：如何用快排思想在O(n)内查找无序数组中第k大元素？</h3><p>时间复杂度为O(nlogn)的归并排序和快速排序，都用到了分治思想。</p><h3 id="4-归并排序-Merge-Sort"><a href="#4-归并排序-Merge-Sort" class="headerlink" title="4.归并排序(Merge Sort)"></a>4.归并排序(Merge Sort)</h3><p>思想：要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br>归并排序使用的是分治思想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//归并排序的递推公式</span><br><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure><p>给下标从p到r的数组排序，将这个排序问题转化为两个子问题，p到q和q+1到r，下标q等于p和r的中间位置(p+r)/2。当两个子数组都排好序之后，合并在一起，p到r也就排好序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序算法, A 是数组，n 表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  // 递归终止条件</span><br><span class="line">  if p &gt;= r  then return</span><br><span class="line"></span><br><span class="line">  // 取 p 到 r 之间的中间位置 q</span><br><span class="line">  q = (p+r) / 2</span><br><span class="line">  // 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+1, r)</span><br><span class="line">  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+1...r])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merge(A[p...r], A[p...q], A[q+1...r]) &#123;</span><br><span class="line">  var i := p，j := q+1，k := 0 // 初始化变量 i, j, k</span><br><span class="line">  var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组</span><br><span class="line">  while i&lt;=q AND j&lt;=r do &#123;</span><br><span class="line">    if A[i] &lt;= A[j] &#123;</span><br><span class="line">      tmp[k++] = A[i++] // i++ 等于 i:=i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] = A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 判断哪个子数组中有剩余的数据</span><br><span class="line">  var start := i，end := q</span><br><span class="line">  if j&lt;=r then start := j, end:=r</span><br><span class="line">  </span><br><span class="line">  // 将剩余的数据拷贝到临时数组 tmp</span><br><span class="line">  while start &lt;= end do &#123;</span><br><span class="line">    tmp[k++] = A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 将 tmp 中的数组拷贝回 A[p...r]</span><br><span class="line">  for i:=0 to r-p do &#123;</span><br><span class="line">    A[p+i] = tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1归并排序是稳定的排序算法吗？"><a href="#4-1归并排序是稳定的排序算法吗？" class="headerlink" title="4.1归并排序是稳定的排序算法吗？"></a>4.1归并排序是稳定的排序算法吗？</h4><p>归并排序的稳定性要看merge()合并函数。另外，稳定性是由方法本身决定的，对不稳定的排序方法而言，不管其描述形式如何，总能举出一个说明不稳定的实例来；反之，对稳定的排序方法，总能找到一种不引起不稳定的描述形式。<br>合并前后的前后顺序不变，就是稳定的。</p><h4 id="4-2归并排序的时间复杂度"><a href="#4-2归并排序的时间复杂度" class="headerlink" title="4.2归并排序的时间复杂度"></a>4.2归并排序的时间复杂度</h4><p>归并排序可以递归实现，递归代码的时间复杂度也可以写成递推公式。<br>我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br><span class="line"></span><br><span class="line">T(n) = 2*T(n/2) + n</span><br><span class="line">     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</span><br><span class="line">     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span><br><span class="line">     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     = 2^k * T(n/2^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure><p>当T(n/2^k)=T(1)时，也就是n/2^k=1，得到k=log2n。代入得到T(n)=Cn+nlog2n。大O标记法表示就是T(n)=O(nlogn)。</p><h4 id="4-3归并排序的空间复杂度"><a href="#4-3归并排序的空间复杂度" class="headerlink" title="4.3归并排序的空间复杂度"></a>4.3归并排序的空间复杂度</h4><p>归并排序的时间复杂度任何情况下都是O(nlogn)，但是归并排序并没有像快排那样应用广泛，原因在于它不是原地排序算法。因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。<br>空间复杂度为O(n)。</p><h3 id="5-快速排序-Quick-Sort"><a href="#5-快速排序-Quick-Sort" class="headerlink" title="5.快速排序(Quick Sort)"></a>5.快速排序(Quick Sort)</h3><p>快排利用的也是分治。不稳定。<br>思想：假设要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点)。遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。经过这一步骤之后，数组p到r之间的数据就被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。<br>根据分治、递推的处理思想，递归排序下标从p到<br>q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，说明所有的数据都有序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r</span><br><span class="line"></span><br><span class="line">// 快速排序，A 是数组，n 表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">// 快速排序递归函数，p,r 为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  if p &gt;= r then return</span><br><span class="line">  </span><br><span class="line">  q = partition(A, p, r) // 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-1)</span><br><span class="line">  quick_sort_c(A, q+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的处理过程是从下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程由上到下，先分区，然后再处理子问题。快排通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>现在有10个接口访问日志文件，每个日志文件大小约为300MB，每个文件里的日志都是按照时间戳从小到大排序的。希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB，如何能“快速”地将这10个日志文件合并？</p><h3 id="三、线性排序：如何根据年龄给100万用户数据排序？"><a href="#三、线性排序：如何根据年龄给100万用户数据排序？" class="headerlink" title="三、线性排序：如何根据年龄给100万用户数据排序？"></a>三、线性排序：如何根据年龄给100万用户数据排序？</h3><p>桶排序、计数排序、基数排序，这三种排序算法的时间复杂度是线性的，所以叫做线性排序(Linear Sort)。之所以能做到线性的时间复杂度，是因为这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p><h3 id="6-桶排序"><a href="#6-桶排序" class="headerlink" title="6.桶排序"></a>6.桶排序</h3><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><h4 id="6-1桶排序的时间复杂度"><a href="#6-1桶排序的时间复杂度" class="headerlink" title="6.1桶排序的时间复杂度"></a>6.1桶排序的时间复杂度</h4><p>如果要排序的数据有n个，我们把它们均匀地划分到m个桶内，每个桶内就有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为O(klogk)。m个桶排序的时间复杂度就是O(mklogk)，因为k=n/m，所以整个桶排序的时间复杂度就是O(nlog(n/m))。当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。</p><h4 id="6-2桶排序的应用场景"><a href="#6-2桶排序的应用场景" class="headerlink" title="6.2桶排序的应用场景"></a>6.2桶排序的应用场景</h4><p>桶排序对要排序数据的要求非常苛刻。首先，要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据排序完之后，桶与桶之间的数据不需要在进行排序。其次，数据在各个桶之间的分布是比较均匀的，如果数据经过桶的划分，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了，在极端情况下，如果数据都被分到一个桶里，那就退化为O(nlogn)了。<br>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。<br>比如说我们有10GB的订单数据，希望按订单金额(假设金额都是正整数)进行排序，但是我们内存有限，只有几百MB，没办法一次性把10GB的数据都加载到内存中。这个时候可以借助桶排序的思想来解决这个问题。<br><img src="/posts/45185/tongpaixuyingxu.png"></p><h3 id="7-计数排序-Counting-Sort"><a href="#7-计数排序-Counting-Sort" class="headerlink" title="7.计数排序(Counting Sort)"></a>7.计数排序(Counting Sort)</h3><p>计数排序可以说是桶排序的一种特殊情况。<br>当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。<br>我们都经历过高考，高考查分系统，我们查分数的时候，系统会显示我们的成绩以及所在省的排名。2016年山东省有70万考生，如何通过成绩快速排序得出名次呢？<br>考生的满分是750分，最小是0分，这个数据的范围不算大，所以我们可以分成751个桶，对应分数从0到750分。根据考生的成绩，将这70万考生划分到751个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了70万考生的排序，因为只涉及扫描遍历操作，所以时间复杂度是O(n)。<br>计数排序的算法思想与桶排序类似，只是桶的大小粒度不一样，为什么叫“计数”，“计数”的含义来自哪里？<br><img src="/posts/45185/jishu1.png"><br><img src="/posts/45185/jishu2.png"><br><img src="/posts/45185/jishu3.png"><br><img src="/posts/45185/jishu4.jpg"></p><h3 id="8-基数排序-Radix-Sort"><a href="#8-基数排序-Radix-Sort" class="headerlink" title="8.基数排序(Radix Sort)"></a>8.基数排序(Radix Sort)</h3><p>再来看这样一个排序问题，假设我们有10万个手机号码，希望将这10万个手机号码从小到大排序，有什么比较快速的排序方法？<br>快排可以做到O(nlogn)，手机号码有11位，范围太大，不适合用桶排序、计数排序。<br>可以用基数排序。<br>假设要比较两个手机号码a和b的大小，如果在前面几位中，a手机号码已经比b的大了，那后面的几位就不用看了。<br>基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/41682.html"/>
      <url>/posts/41682.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于模式"><a href="#关于模式" class="headerlink" title="关于模式"></a>关于模式</h2><p>在讨论模式之前，必须对“模式”这个词加以界定，以规范后面的讨论和研究。<br>简而言之，人们在自己的环境中不断发现问题和寻找问题的解决方案的时候，发现有一些问题及其解决方案不断变换面孔反复出现，但在这些不同的面孔后面有着共同的本质，这些共同的本质就是模式。<br>一个围棋下得好的人知道，好的“形”对于围棋非常重要。形是棋子在棋盘上的几何形状的抽象化。形就是模式(pattern)，也是人脑把握和认识外界的关键。模式化的过程是把问题抽象化，在忽略掉不重要的细节后，发现问题的一般性本质，并找到普遍使用的解决方案的过程。</p><h2 id="设计模式的7个原则"><a href="#设计模式的7个原则" class="headerlink" title="设计模式的7个原则"></a>设计模式的7个原则</h2><h3 id="开—闭原则-Open-Closed-Principle-OCP"><a href="#开—闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开—闭原则(Open-Closed Principle,OCP)"></a>开—闭原则(Open-Closed Principle,OCP)</h3><p>一个软件实体应当对扩展开放，对修改关闭。<br>在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。换言之，应当可以在不必修改源代码的前提下改变这个模块的行为。</p><h3 id="里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle,LSP)"></a>里氏代换原则(Liskov Substitution Principle,LSP)</h3><p>一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。<br>反过来的代换不成立，即如果一个软件实体使用的是一个子类，那么它不一定适用于基类。<br>里氏代换要求凡是基类型使用的地方，子类型一定适用，因此子类必须具备基类型的全部接口。</p><h3 id="依赖倒转原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒转原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle,DIP)"></a>依赖倒转原则(Dependence Inversion Principle,DIP)</h3><p>依赖于抽象，而不依赖于具体。<br>针对接口编程。<br>传统的过程性系统的设计办法倾向于使高层次的模块依赖于低层次的模块；抽象层次依赖于具体层次。依赖倒转原则是要把这个错误的依赖关系倒转过来。<br>里氏代换原则是依赖倒转原则的基础，依赖倒转原则是开-闭原则的基础。</p><h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle,ISP)"></a>接口隔离原则(Interface Segregation Principle,ISP)</h3><p>使用多个专门的接口比使用单一的总接口要好。<br>从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小的接口上的。<br>将“接口”理解为一个类所提供的所有方法的特征集合，也就是一种在逻辑上才存在的概念，这样的话，接口的划分就直接带来类型的划分。角色的合理划分。<br>将接口理解为狭义的java接口，这样一来，接口隔离原则讲的就是为同一个角色提供宽、窄不同的接口，以对付不同的客户端。定制服务。</p><h3 id="合成-聚合复用原则-Composite-Aggregate-Reuse-Principle-CARP"><a href="#合成-聚合复用原则-Composite-Aggregate-Reuse-Principle-CARP" class="headerlink" title="合成/聚合复用原则(Composite/Aggregate Reuse Principle,CARP)"></a>合成/聚合复用原则(Composite/Aggregate Reuse Principle,CARP)</h3><p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。<br>尽量使用合成/聚合，尽量不要使用继承。</p><h3 id="迪米特法则-Demeter-Principle"><a href="#迪米特法则-Demeter-Principle" class="headerlink" title="迪米特法则(Demeter Principle)"></a>迪米特法则(Demeter Principle)</h3><p>又叫做最少知识原则(Least Knowledge Principle，LKP)<br>一个对象应当对其他对象有尽可能少的了解。<br>只与你直接的朋友们通信；<br>不要跟“陌生人”说话；<br>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p><h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle, SRP)"></a>单一职责原则(Single Responsibility Principle, SRP)</h3><p>一个类只负责一个功能领域中的相应职责。</p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><h3 id="创建模式-5种"><a href="#创建模式-5种" class="headerlink" title="创建模式(5种)"></a>创建模式(5种)</h3><p>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</p><h3 id="结构模式-7种"><a href="#结构模式-7种" class="headerlink" title="结构模式(7种)"></a>结构模式(7种)</h3><p>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p><h3 id="行为模式-11种"><a href="#行为模式-11种" class="headerlink" title="行为模式(11种)"></a>行为模式(11种)</h3><p>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p><h2 id="设计模式的应用"><a href="#设计模式的应用" class="headerlink" title="设计模式的应用"></a>设计模式的应用</h2><h3 id="模版-策略-工厂"><a href="#模版-策略-工厂" class="headerlink" title="模版+策略+工厂"></a>模版+策略+工厂</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——递归</title>
      <link href="/posts/46890.html"/>
      <url>/posts/46890.html</url>
      
        <content type="html"><![CDATA[<p>推荐注册返佣金——现在很多App都有这个功能。用户A推荐用户B来注册，用户B又推荐了用户C来注册。可以说，用户C的“最终推荐人”为用户A，用户B的“最终推荐人”也为用户A，用户A没有“最终推荐人”。<br>一般来说，会通过数据库来记录这种推荐关系。在数据库表中，可以记录两行数据，其中actor_id表示用户id，referrer_id表示推荐人id。<br><img src="/posts/46890/acre.jpg"><br>基于这个背景，给定一个用户ID，如何查找这个用户的“最终推荐人”？</p><h3 id="1-关于递归"><a href="#1-关于递归" class="headerlink" title="1.关于递归"></a>1.关于递归</h3><p>数据结构与算法，有两个最难理解的知识点，一个是动态规划，一个是递归。<br>递归是一中应用非常广泛的算法(或者编程技巧)，有很多数据结构与算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等。<br>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</p><h3 id="2-递归需要满足的三个条件"><a href="#2-递归需要满足的三个条件" class="headerlink" title="2.递归需要满足的三个条件"></a>2.递归需要满足的三个条件</h3><h4 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1)一个问题的解可以分解为几个子问题的解"></a>1)一个问题的解可以分解为几个子问题的解</h4><p>子问题就是数据规模更小的问题。</p><h4 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2)这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2)这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h4><h4 id="3-存在递归终止条件"><a href="#3-存在递归终止条件" class="headerlink" title="3)存在递归终止条件"></a>3)存在递归终止条件</h4><p>把问题分解为子问题，子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，需要有终止条件。</p><h3 id="3-如何编写递归代码"><a href="#3-如何编写递归代码" class="headerlink" title="3.如何编写递归代码"></a>3.如何编写递归代码</h3><p>写递归代码最关键的是写出递推公式，找到终止条件，将递推公式转化为代码。<br>假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问这n个台阶有多少中走法？<br>如果有7个台阶，可以2，2，2，1这样上去，也可以1，2，1，1，2这样，走法很多，如何用编程求得总共有多少中走法？<br>想一下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法加上先走2阶后，n-2个台阶的走法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure><p>再来看终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法，所以f(1)=1。然而，只有这一个是不够的。<br>n=2时，f(2)=f(1)+f(0)，如果递归终止条件只有一个f(1)=1，那f(2)就无法求解了，而f(0)是客观不可行的，所以要把f(2)=2作为一个终止条件，表示走两个台阶，有两种走法，一步走完或者分两步来走。<br>把递归终止条件和递推公式放到一起就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(1)=1</span><br><span class="line">f(2)=2</span><br><span class="line">f(n)=f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><p>转化为递归代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int f(int n)</span><br><span class="line">&#123;</span><br><span class="line">if(n == 1) return 1;</span><br><span class="line">if(n == 2) return 2;</span><br><span class="line">return f(n-1) + f(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。"><a href="#写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。" class="headerlink" title="写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。"></a>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。</h4><p>当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解。像刚刚这个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归坪铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。<br>对于递归代码，这种试图想搞清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。<br>如果一个问题A可以分解为若干子问题B、C、D，可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而且，只需要思考问题A和子问题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题和子子问题，子子问题和子子子问题之间的关系，屏蔽掉递归细节。</p><h4 id="编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。"><a href="#编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。" class="headerlink" title="编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。"></a>编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。</h4><h3 id="4-递归代码要警惕堆栈溢出"><a href="#4-递归代码要警惕堆栈溢出" class="headerlink" title="4.递归代码要警惕堆栈溢出"></a>4.递归代码要警惕堆栈溢出</h3><p>为什么递归代码容易造成堆栈溢出？如何预防堆栈溢出？<br>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br>上面的例子，如果将系统栈或者JVM堆栈大小设置为1KB，在求解f(1999)时便会出现如下堆栈报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>如何避免出现堆栈溢出？<br>声明一个全局变量，可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度(比如1000)之后，就不继续往下再递归了，直接返回报错。<br>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，会影响代码的可读性。所以，如果最大深度比较小，比如10、50，可以用这种方法，否则这种方法并不是很实用。</p><h3 id="5-递归代码要警惕重复计算"><a href="#5-递归代码要警惕重复计算" class="headerlink" title="5.递归代码要警惕重复计算"></a>5.递归代码要警惕重复计算</h3><p><img src="/posts/46890/fchongfujisuan.jpg"><br>从图中，可以看到，想要计算f(5),需要先计算f(4)和 f(3)，而计算f(4) 还需要计算f(3)，因此f(3) 就被计算了很多次，这就是重复计算问题。<br>为了避免重复计算，可以通过一个数据结构(比如散列表)来保存已经求解过的f(k)。当递归调用到f(k)时，先从中看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">  if (n == 1) return 1;</span><br><span class="line">  if (n == 2) return 2;</span><br><span class="line">  </span><br><span class="line">  // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)</span><br><span class="line">  if (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    return hasSovledList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int ret = f(n-1) + f(n-2);</span><br><span class="line">  hasSovledList.put(n, ret);</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。</p><h3 id="6-递归代码改写为非递归代码"><a href="#6-递归代码改写为非递归代码" class="headerlink" title="6.递归代码改写为非递归代码"></a>6.递归代码改写为非递归代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int f(n)</span><br><span class="line">&#123;</span><br><span class="line">if(n == 1) return 1;</span><br><span class="line">if(n == 2) return 2;</span><br><span class="line"></span><br><span class="line">int ret = 0;</span><br><span class="line">int pre = 2;</span><br><span class="line">int prepre = 1;</span><br><span class="line">for(int i = 3; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = pre + prepre;</span><br><span class="line">prepre = pre;</span><br><span class="line">pre = ret;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">//刚好这个走台阶的问题类似斐波那契数列</span><br></pre></td></tr></table></figure><p>抽象出递推公式、初始值和边界条件，用迭代循环实现改写。<br>是不是所有的递归代码都可以改写为这种迭代循环的非递归写法？<br>笼统地讲，是的。因为递归本身就是借助栈来实现的，因不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。<br>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也没有解决前面讲到的某些问题，徒增了实现的复杂度。</p><h3 id="如何找到“最终推荐人”"><a href="#如何找到“最终推荐人”" class="headerlink" title="如何找到“最终推荐人”"></a>如何找到“最终推荐人”</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long findRootReferrerId(long actorId)</span><br><span class="line">&#123;</span><br><span class="line">Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">if(referrerId == null) return actorId;</span><br><span class="line">return findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际项目中，这三行代码并不能工作，为啥？这里面有两个问题。<br>一，如果递归很深，可能会有堆栈溢出的问题。<br>二，如果数据库里存在脏数据，还需要处理由此产生的无限递归问题。比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果A的推荐人是B，B的推荐人是C，C 的推荐人是A，这样就会发生死循环。<br>第一个问题，可以用限制递归深度来解决。<br>第二个问题，自动检测A-B-C-A这种“环”的存在。如何来检测环的存在？</p><h3 id="思考：对于递归代码，有什么好的调试方法？"><a href="#思考：对于递归代码，有什么好的调试方法？" class="headerlink" title="思考：对于递归代码，有什么好的调试方法？"></a>思考：对于递归代码，有什么好的调试方法？</h3><p>1.打印日志发现，递归值。<br>2.结合条件断点进行调试。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——队列</title>
      <link href="/posts/19167.html"/>
      <url>/posts/19167.html</url>
      
        <content type="html"><![CDATA[<p>我们知道，CPU资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致CPU频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><h4 id="当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？"><a href="#当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？" class="headerlink" title="当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？"></a>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</h4><h4 id="1-如何理解“队列”"><a href="#1-如何理解“队列”" class="headerlink" title="1.如何理解“队列”"></a>1.如何理解“队列”</h4><p>队列这个概念可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。<br>队列跟栈相似，支持的操作也有限，最基本的操作也是两个：入队enqueue()，放一个数据到队列尾部；出队dequeue()，从队列头部取一个元素。<br><img src="/posts/19167/duiliehezhan.jpg"><br>队列和栈一样，也是一种操作受限的线性表数据结构。<br>作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；java concurrent并发包利用ArrayBlockingQueue来实现公平锁等。</p><h4 id="2-顺序队列和链式队列"><a href="#2-顺序队列和链式队列" class="headerlink" title="2.顺序队列和链式队列"></a>2.顺序队列和链式队列</h4><p>用数组实现的队列叫做顺序队列，用链表实现的队列叫做链式队列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//用数组实现的队列</span><br><span class="line">public class ArrayQueue</span><br><span class="line">&#123;</span><br><span class="line">//数组:items 数组大小:n</span><br><span class="line">private String[] items;</span><br><span class="line">private int n=0;</span><br><span class="line">//head表示队头下标 tail表示队尾下标</span><br><span class="line">private int head=0;</span><br><span class="line">private int tail=0;</span><br><span class="line"></span><br><span class="line">//申请一个大小为capacity的数组</span><br><span class="line">public ArrayQueue(int capacity)</span><br><span class="line">&#123;</span><br><span class="line">items = new String[capacity];</span><br><span class="line">n = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入队</span><br><span class="line">public boolean enqueue(String item)</span><br><span class="line">&#123;</span><br><span class="line">//如果tail==n 表示队列已满</span><br><span class="line">if(tail == n) return false;</span><br><span class="line">items[tail] = item;</span><br><span class="line">tail++;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//出队</span><br><span class="line">public String dequeue()</span><br><span class="line">&#123;</span><br><span class="line">//如果head==tail 表示队列为空</span><br><span class="line">if(head == tail) return null;</span><br><span class="line">String ret = item[head];</span><br><span class="line">head++;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于栈来说，只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。<br><img src="/posts/19167/queue1.jpg"><br><img src="/posts/19167/queue2.jpg"><br>随着不停的入队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题如何解决？<br>在数组中，数组的删除操作会导致数组中的数据不连续，解决方法是用数据搬移。但是，每次进行出队操作删除队列头的元素(相当于删除数组下标为0的数据)，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的O(1)变为O(n)。如何优化呢？<br>实际上，在出队时可以不用搬移数据。如果没有空闲空间了，只需要在入队时，集中触发一次数据的搬移操作。借助这个思想，出队函数dequeue()保持不变，改动一下入队函数enqueue():</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//入队操作，将item放入队尾</span><br><span class="line">public boolean enqueue(String item)</span><br><span class="line">&#123;</span><br><span class="line">//tail==n表示队列末尾没有空间了</span><br><span class="line">if(tail == n)</span><br><span class="line">&#123;</span><br><span class="line">//如果tail==n并且head==0表示整个队列都占满了，无法在添加元素</span><br><span class="line">if(head == 0) return false;</span><br><span class="line">//数据搬移</span><br><span class="line">for(int i=head;i&lt;tail;i++)</span><br><span class="line">&#123;</span><br><span class="line">item[i-head] = items[i];</span><br><span class="line">&#125;</span><br><span class="line">//搬移完之后更新head和tail</span><br><span class="line">tail -= head;</span><br><span class="line">head = 0;</span><br><span class="line">&#125;</span><br><span class="line">items[tail] = item;</span><br><span class="line">tail++;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于链表的实现，同样需要两个指针：head指针和tail指针。它们分别指向链表的第一个结点和最后一个结点。入队时，tail-&gt;next=new_node,tail=tail-&gt;next;出队时，head=head-&gt;next。<br><img src="/posts/19167/lianbiaoduilie.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//基于链表的实现</span><br><span class="line">public class QueueBasedOnLinkedList &#123;</span><br><span class="line">private static class Node &#123;</span><br><span class="line">    private String data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(String data, Node next) &#123;</span><br><span class="line">      this.data = data;</span><br><span class="line">      this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getData() &#123;</span><br><span class="line">      return data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private Node head = null;</span><br><span class="line">  private Node tail = null;</span><br><span class="line"></span><br><span class="line">  public void enqueue(String value) &#123;</span><br><span class="line">    if (tail == null) &#123;</span><br><span class="line">      Node newNode = new Node(value, null);</span><br><span class="line">      head = newNode;</span><br><span class="line">      tail = newNode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tail.next = new Node(value, null);</span><br><span class="line">      tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String dequeue() &#123;</span><br><span class="line">    if (head == null) return null;</span><br><span class="line"></span><br><span class="line">    String value = head.data;</span><br><span class="line">    head = head.next;</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">      tail = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void printAll() &#123;</span><br><span class="line">    Node p = head;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">      System.out.print(p.data + &quot; &quot;);</span><br><span class="line">      p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3.循环队列"></a>3.循环队列</h4><p><img src="/posts/19167/jiayichu.JPG"><br>循环队列，顾名思义，它长得像一个环。原本队列是有首有尾的，是一条直线，现在把它首尾相连，扳成了一个环。</p><p><img src="/posts/19167/xunhuanduilie.jpg"><br>图中这个队列的大小为8，当前head=4，tail=7.当有一个新的元素a入队时，放入下标为7的位置。但这个时候，并不把tail更新为8，而是将其在环中后移一位，到下标为0的位置。当再有一个元素b入队时，将b放入下标为0的位置，然后tail+1更新为1。所以，a、b依次入队之后：<br><img src="/posts/19167/xunhuan-ab.jpg"><br>循环队列的代码实现难度要比非循环队列难一些，关键在于，确定好队空和队满的判定条件。<br>用数组实现的非循环队列中，队满的判定条件是tail==n，队空的判定条件是head==tail。<br>循环队列为空的判断条件仍然是head==tail。队满的判断条件稍有不同：<br><img src="/posts/19167/xunhuan-duiman.jpg"></p><h4 id="当队满时，-tail-1-n-head。"><a href="#当队满时，-tail-1-n-head。" class="headerlink" title="当队满时，(tail+1)%n=head。"></a>当队满时，(tail+1)%n=head。</h4><p>当队列满时，图中tail指向的位置实际上是没有存储数据的，这种方法是少用一个元素空间，约定以“队列头指针在队列尾指针的下一位置上”作为队列“满”的标志。<br>另一种方法是另设一个标志位以区别队列是“空”还是“满”。另外占用一个内存空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CircularQueue &#123;</span><br><span class="line">  // 数组：items，数组大小：n</span><br><span class="line">  private String[] items;</span><br><span class="line">  private int n = 0;</span><br><span class="line">  // head 表示队头下标，tail 表示队尾下标</span><br><span class="line">  private int head = 0;</span><br><span class="line">  private int tail = 0;</span><br><span class="line"></span><br><span class="line">  // 申请一个大小为 capacity 的数组</span><br><span class="line">  public CircularQueue(int capacity) &#123;</span><br><span class="line">    items = new String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 入队</span><br><span class="line">  public boolean enqueue(String item) &#123;</span><br><span class="line">    // 队列满了</span><br><span class="line">    if ((tail + 1) % n == head) return false;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + 1) % n;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 出队</span><br><span class="line">  public String dequeue() &#123;</span><br><span class="line">    // 如果 head == tail 表示队列为空</span><br><span class="line">    if (head == tail) return null;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + 1) % n;</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-阻塞队列和并发队列"><a href="#4-阻塞队列和并发队列" class="headerlink" title="4.阻塞队列和并发队列"></a>4.阻塞队列和并发队列</h4><p>队列这种数据结构很基础，平时的业务开发不大可能从0实现一个队列，甚至不会用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。<br>阻塞队列是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。<br><img src="/posts/19167/zuseduilie1.jpg"><br>上述的定义就是一个“生产者—消费者模型”。使用阻塞队列可以轻松实现一个“生产者—消费者模型”。<br><img src="/posts/19167/zuseduilie2.jpg"></p><p>那，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，如何实现一个线程安全的队列呢？<br>线程安全的队列叫做并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发操作，这也是循环队列比链式队列应用更加广泛的原因，</p><h4 id="5-线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？"><a href="#5-线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？" class="headerlink" title="5.线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？"></a>5.线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？</h4><p>一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<br>对于如何存储排队的请求，我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。基于链表和基于数组实现的队列对于排队请求有何区别？<br>基于链表的实现方式，可以实现一个支持无限排队的无界队列(unbounded queue)，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。<br>基于数组实现的有界队列(bounded queue)，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，是很有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。<br>除了队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考:"></a>思考:</h4><h4 id="1-除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？"><a href="#1-除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？" class="headerlink" title="(1)除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？"></a>(1)除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？</h4><h4 id="2-如何实现无锁并发队列？"><a href="#2-如何实现无锁并发队列？" class="headerlink" title="(2)如何实现无锁并发队列？"></a>(2)如何实现无锁并发队列？</h4><p><img src="/posts/19167/sikao.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——栈</title>
      <link href="/posts/37178.html"/>
      <url>/posts/37178.html</url>
      
        <content type="html"><![CDATA[<p><strong>思考：如何实现浏览器的前进和后退功能？</strong><br>当你依次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面b和a。当你后退到页面a，点击前进按钮，就可以重新查看页面b和c。但是，如果你后退到页面b后，点击了新的页面d，那就无法在通过前进、后退功能查看页面c了。</p><h2 id="如何理解栈？"><a href="#如何理解栈？" class="headerlink" title="如何理解栈？"></a>如何理解栈？</h2><p>关于“栈”，有一个非常贴切的例子，就是一摞叠在一起的盘子。放盘子的时候，都是从下往上一个一个放；取的时候，从上往下一个一个地依次取，不能从中间任意抽出。<br><strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong></p><p><img src="/posts/37178/zhan.jpg"></p><p>从栈的操作特性上看，<strong>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据</strong>。</p><p>特定的数据结构是对特定场景的抽象。<br>栈与数组或链表相比，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时比较不可控。<br>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</p><h2 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h2><p>栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。<br>栈既可以用数组来实现，也可以用链表来实现。<br>用数组实现的栈，叫做顺序栈；用链表实现的栈，叫做链式栈。</p><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;       <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;           <span class="comment">// 栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为 n 的数组空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组空间不够了，直接返回 false，入栈失败。</span></span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将 item 放到下标为 count 的位置，并且 count 加一</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈为空，则直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span></span><br><span class="line">    String tmp = items[count-<span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于链表实现的链式栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackBasedOnLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data, Node next)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Node top = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (top == <span class="keyword">null</span>) &#123;</span><br><span class="line">      top = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newNode.next = top;</span><br><span class="line">      top = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> value = top.data;</span><br><span class="line">    top = top.next;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node p = top;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">      System.out.print(p.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为n的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)。入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度是O(1)。<br>注意，这里存储数据需要一个大小为n的数组，并不是说空间复杂度就是O(n)。因为，这n个空间是必须的，无法省掉。所以在说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p><h3 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h3><p>刚才那个基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。<br>尽管链式栈的大小不受限，但要存储next指针，内存消耗相对较多。<br>如何基于数组实现一个可以支持动态扩容的栈呢？</p><p>基于数组实现一个可以支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，就申请一个更大的数组，将原来的数据搬移到新数组中。<br><img src="/posts/37178/dongtaikuorong.jpg"></p><p>动态扩容的顺序栈，对于出栈操作来说，不会涉及到内存的重新申请和数据搬移，所以出栈的时间复杂度是O(1)。但是对于入栈操作来说，当栈中有空闲空间时，入栈操作的时间复杂度为O(1)，当空间不够时，就需要重新申请内存和数据搬移，时间复杂度就成了O(n)。<br>入栈操作，最好情况时间复杂度是O(1)，最坏情况时间复杂度是O(n)。均摊时时间复杂度是O(1)。<br><img src="/posts/37178/juntan.jpg"></p><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h3><p>栈作为一个比较基础的数据结构，比较经典的一个应用场景是<strong>函数调用栈</strong>。<br>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   printf(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，main()函数调用了add()函数，获取计算结果，与临时变量a相加，最后打印res的值。下图可以看到这个过程对应的函数栈里出栈、入栈的操作，在执行到add()函数时，函数调用栈的情况。<br><img src="/posts/37178/hanshuzhanzhen.jpg"></p><h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h3><p>栈的另一个常见的应用场景，<strong>编译器利用栈来实现表达式求值</strong>。<br>这里将算术表达式简化为只包含加减乘除四则运算(其实更复杂的还有与或非等逻辑运算、括号等)，比如：34+13*9+44-12/3。</p><p>对于这个四则运算，人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事。</p><p>实际上，编译器就是通过两个栈来实现的。其中一个<strong>保存操作数的栈</strong>，另一个是<strong>保存运算符的栈</strong>。<br>从左向右遍历表达式，当遇到数字，直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素比较。如果比运算符栈栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><p>如下图为 3+5*8-6 这个表达式的计算过程<br><img src="/posts/37178/biaodashiqiuzhi.jpg"></p><h3 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h3><p>借助栈来检查<strong>表达式中的括号</strong>是否匹配。</p><p>假设表达式中只包含三种括号，圆括号()、方括号[]、花括号{}，并且它们可以任意嵌套。<br>比如，<code>&#123;[()]&#125;</code>或<code>[(&#123;&#125;)([])]</code>等都为合法形式，而<code>([)&#123;&#125;]</code>为不合法形式。<br>对于一个只包含括号的表达式字符串，如何检查它是否合法呢？</p><p>思路：用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，就将其压入栈中；当扫描到右括号时，将其与栈顶左括号匹配，若能够匹配，将此栈顶左括号出栈，继续扫描其余的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有左括号，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法形式；否则，说明有未匹配的左括号，为非法格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 栈中只进左括号 每当有一个括号要进栈时就看它是不是与栈顶括号相匹配 匹配就pop 不匹配就进栈</span></span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                <span class="comment">// 左括号入栈</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.size() &gt; <span class="number">0</span> &amp;&amp; map.get(stack.peek()).equals(c)) &#123;</span><br><span class="line">                    <span class="comment">// 栈不为空，并且左右括号匹配  出栈</span></span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="用两个栈来实现浏览器的前进、后退功能"><a href="#用两个栈来实现浏览器的前进、后退功能" class="headerlink" title="用两个栈来实现浏览器的前进、后退功能"></a>用两个栈来实现浏览器的前进、后退功能</h3><p>使用两个栈X和Y，把首次浏览的页面依次压入栈X。<br>当点击后退按钮时，依次从栈X中出栈，并将出栈的数据依次放入栈Y。当点击前进按钮时，依次从栈Y中取出数据，放入栈X中。<br>当栈X中没有数据时，就说明没有页面可以继续后退浏览了。当栈Y中没有数据，说明没有页面可以点击前进按钮浏览了。</p><p>举个例子，我们顺序查看了a-b-c三个页面，依次把a、b、c压入栈：<br><img src="/posts/37178/abc.jpg"><br>通过浏览器的后退按钮，从页面c后退到页面a之后，就依次把c和b从栈X中弹出，并且依次放入到栈Y中：<br><img src="/posts/37178/tuibc.jpg"><br>点击前进按钮回到b页面，将b从栈Y中弹出，放入栈X：<br><img src="/posts/37178/jinb.jpg"><br>通过页面b跳转到新的页面d，页面c就无法再通过前进、后退按钮重复查看，这时清空栈Y：<br><img src="/posts/37178/dianjixindeyemian.jpg"></p><h3 id="为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗"><a href="#为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗" class="headerlink" title="为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗?"></a>为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗?</h3><p>不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最好的选择。<br>从调用函数进入被调用函数，对于数据来说，变化的是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p><h3 id="JVM的虚拟机栈-VS-数据结构的栈"><a href="#JVM的虚拟机栈-VS-数据结构的栈" class="headerlink" title="JVM的虚拟机栈 VS 数据结构的栈"></a>JVM的虚拟机栈 VS 数据结构的栈</h3><p>JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储java中的对象。那JVM中的“栈”和这里说的“栈”是不是一回事？如果不是，那它为什么又叫做“栈”?<br>内存中的栈和数据结构的栈不是一个概念。<br>内存中的堆栈是内存中的数据区域，是一段虚拟的内存空间；数据结构中的堆栈是抽象的数据存储结构。但是它们都有“栈”的特性。</p><p>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为堆和栈。<br>代码区：存储方法体的二进制代码。高级调度(作业)、中级调度(内存)、低级调度(进程)控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——链表</title>
      <link href="/posts/62654.html"/>
      <url>/posts/62654.html</url>
      
        <content type="html"><![CDATA[<h4 id="经典链表应用场景：LRU缓存淘汰算法"><a href="#经典链表应用场景：LRU缓存淘汰算法" class="headerlink" title="经典链表应用场景：LRU缓存淘汰算法"></a>经典链表应用场景：LRU缓存淘汰算法</h4><p>缓存是一种提高数据读取性能技术，硬件设计和软件开发中都有应用：CPU缓存、数据库缓存、浏览器缓存等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留，需要缓存淘汰策略来决定，如：先进先出策略(first in first out)、最少使用策略LFU(least frequently used)、最近最少使用策略(least recently used)。<br>所以想一下，如何用链表来实现LRU缓存淘汰策略？</p><h4 id="数组-amp-链表：底层存储结构"><a href="#数组-amp-链表：底层存储结构" class="headerlink" title="数组&amp;链表：底层存储结构"></a>数组&amp;链表：底层存储结构</h4><p>数组需要一块连续的内存空间来存储，对内存的要求比较高。如果需要申请一个100MB大小的数组，当内存中没有连续的、足够大的内存空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败。<br>链表，不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。<br><img src="/posts/62654/neicunfenbu.jpg"></p><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>链表通过指针将一组零散的内存块串联在一起。我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，把这个记录下个结点地址的指针叫做后继指针next。<br><img src="/posts/62654/danlianbiao.jpg"><br>单链表中，有两个结点是比较特殊的，分别是第一个结点和最后一个结点。习惯性地把第一个结点叫做头结点，把最后一个结点叫做尾结点。头结点用来记录链表的基地址，通过它可以遍历得到整条链表。尾结点的指针不是指向下一个结点，而是指向一个空地址null，表示这是链表上最后一个结点。<br>与数组一样，链表也支持数据的查找、插入和删除操作。<br>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)。而在链表中插入或者删除一个数据，不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。<br>针对链表的插入和删除操作，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)。<br><img src="/posts/62654/charuandshanchu.jpg"><br>但是，链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据不是连续存储的，就无法像数组那样，根据首地址和下标，通过寻址公式只算计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表是一种特殊的单链表。唯一区别在于尾结点。单链表的尾结点指针指向空地址，表示这是最后的结点；而循环链表的尾结点指针指向链表的头结点。<br><img src="/posts/62654/xunhuanlianbiao.jpg"><br>循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环形结构特点时适合采用，比如著名的<a href="https://blog.csdn.net/weixin_38214171/article/details/80352921">约瑟夫问题</a>。</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。<br><img src="/posts/62654/shuangxianglianbiao.jpg"><br>双向链表需要额外的两个空间来存储后继节点和前驱结点的地址。所以如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。但它支持双向遍历。</p><h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><p><img src="/posts/62654/shuangxiangxunhuan.jpg"></p><h3 id="单链表-amp-双向链表比较"><a href="#单链表-amp-双向链表比较" class="headerlink" title="单链表&amp;双向链表比较"></a>单链表&amp;双向链表比较</h3><h4 id="1-删除结点中“值等于某个给定值”的结点"><a href="#1-删除结点中“值等于某个给定值”的结点" class="headerlink" title="1.删除结点中“值等于某个给定值”的结点"></a>1.删除结点中“值等于某个给定值”的结点</h4><h4 id="2-删除给定指针指向的结点"><a href="#2-删除给定指针指向的结点" class="headerlink" title="2.删除给定指针指向的结点"></a>2.删除给定指针指向的结点</h4><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过前面讲的指针操作将其删除。尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度是O(n)。<br>对于第二种情况，已经找到了要删除的结点，但是删除某个结点q需要知道指向它的前驱结点p，而单链表不支持直接获取前驱结点，所以为了找到前驱结点，还是要从头结点开始遍历链表，知道p-&gt;next=q，说明p是q的前驱结点。但是对于双向链表来说，因为双向链表的结点中已经保存了前驱结点的指针，就不需要像单链表那样遍历。<br>对于插入操作，在链表的指定结点前面插入一个结点，双向链表可以在O(1)时间复杂度搞定，而单向链表需要O(n)的时间复杂度。<br>除此之外，对于一个有序链表，双向链表的按值查询的效率要比单链表高一些。因为双向链表可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>Java中LinkedHashMap的实现中就用到了双向链表这种数据结构。</p><h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>当内存空间充足的时候，如果我们更加追求代码的执行速度，就可以选择空间复杂度相对较高但时间复杂度相对很低的算法或者数据结构。<br>相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，要反过来用时间换空间的设计思路。<br>实际上，缓存就是利用了空间换时间的设计思想。</p><h3 id="链表-amp-数组：性能比较"><a href="#链表-amp-数组：性能比较" class="headerlink" title="链表&amp;数组：性能比较"></a>链表&amp;数组：性能比较</h3><p><img src="/posts/62654/xingneng.jpg"><br>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高；而链表在内存中不是连续存储，所以对CPU缓存不友好，没办法有效预读。<br>引申：CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(具体大小这里不确定，跟CPU实现有关)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取，反之要去内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的矛盾。对于数组来说，存储空间是连续的，所以在加载某个下标的时候就可以把后面的几个下标元素也加载到CPU缓存，这样执行速度就快于存储空间不连续的链表存储。<br>链表本身没有大小限制，天然的支持动态扩容，插入元素只需要修改指针的指向就可以，这是我理解的链表与数组的最大区别。</p><h4 id="如何基于链表实现LRU缓存淘汰算法"><a href="#如何基于链表实现LRU缓存淘汰算法" class="headerlink" title="如何基于链表实现LRU缓存淘汰算法"></a>如何基于链表实现LRU缓存淘汰算法</h4><p>思路：维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表：<br>1.如果此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，将其从原来的位置删除，然后再插入到链表的头部。<br>2.如果此数据没有在缓存链表中：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则删除链表尾结点，再将新的数据结点插入到链表的头部。<br>这样，不管缓存有没有满，都需要遍历一遍链表，这种基于链表的实现思路，缓存访问的时间复杂度是O(n)。<br>引申：引入散列表(Hash Table)来记录每个数据的位置，可以将缓存访问的时间复杂度降到O(1)。</p><h4 id="如何基于数组实现LRU缓存淘汰策略？"><a href="#如何基于数组实现LRU缓存淘汰策略？" class="headerlink" title="如何基于数组实现LRU缓存淘汰策略？"></a>如何基于数组实现LRU缓存淘汰策略？</h4><p>思路：维护一个有序的数组，越靠近数组首位置的数据越是最早访问的，当有一个新的数据被访问时：<br>1.如果这个数据已经存在于数组中，把对应位置的数据删掉，直接把这个数据加到数组的最后一位。时间复杂度为O(n)。<br>2.如果这个数据不存在这个数组中，数组还有空间的话，就把这个数据直接添加到最后一位；没有空间的话，删除掉数组的第一个元素，然后把数据插入到数组最后一个。时间复杂度为O(n)。</p><h4 id="如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？"><a href="#如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？" class="headerlink" title="如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？"></a>如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？</h4><p>思路：使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">  public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">    if (head == null || head.next == null) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line"></span><br><span class="line">    while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">      ListNode next = slow.next;</span><br><span class="line">      slow.next = prev;</span><br><span class="line">      prev = slow;</span><br><span class="line">      slow = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fast != null) &#123;  //奇数个结点时</span><br><span class="line">      slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (slow != null) &#123;</span><br><span class="line">      if (slow.val != prev.val) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——2.4OutOfMemoryError异常</title>
      <link href="/posts/31238.html"/>
      <url>/posts/31238.html</url>
      
        <content type="html"><![CDATA[<p>在java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。</p><h3 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1. Java堆溢出"></a>1. Java堆溢出</h3><p>java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量到达最大堆的容量限制后产生内存溢出异常。</p><h3 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2. 虚拟机栈和本地方法栈溢出"></a>2. 虚拟机栈和本地方法栈溢出</h3><p>由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数(设置本地方法栈大小)虽然存在，但实际上是无效的，栈容量只由-Xss参数设定。</p><p>关于虚拟机栈和本地方法栈，在java虚拟机规范中描述了两种异常：</p><ol><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ol><p>这里把异常分成两种情况看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。</p><p>在单线程的操作中，以下两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError异常：</p><ol><li>使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的栈深度相应缩小。</li><li>定义了大量的本地变量，增加此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的栈深度相应缩小。</li></ol><h3 id="3-运行时常量池溢出"><a href="#3-运行时常量池溢出" class="headerlink" title="3.运行时常量池溢出"></a>3.运行时常量池溢出</h3><h3 id="4-方法区溢出"><a href="#4-方法区溢出" class="headerlink" title="4.方法区溢出"></a>4.方法区溢出</h3><h3 id="5-本机直接内存溢出"><a href="#5-本机直接内存溢出" class="headerlink" title="5.本机直接内存溢出"></a>5.本机直接内存溢出</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——2.3对象访问</title>
      <link href="/posts/47280.html"/>
      <url>/posts/47280.html</url>
      
        <content type="html"><![CDATA[<p>在java语言中，对象访问是如何进行的？</p><p>对象访问在java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会涉及java栈、java堆和方法区这三个最重要内存区域之间的关联关系。</p><h4 id="Object-obj-new-Object"><a href="#Object-obj-new-Object" class="headerlink" title="Object obj = new Object();"></a>Object obj = new Object();</h4><p>假设这句代码出现在方法体中，那<code>Object obj</code>这部分的语义将会反映到<code>java栈的本地变量表</code>中，作为一个reference类型数据出现。而<code>new Object()</code>这部分的语义将会反应到<code>java堆</code>中，形成一块存储了<code>Object类型所有实例数据值(Instance Data，对象中各个实例字段的数据)的结构化内存</code>，根据具体类型以及虚拟机实现的对象内存布局(Object Memory Layout)的不同，这块内存的长度是不固定的。<br>另外，在java堆中还必须包含能查找到此对象类型数据(如对象类型、父类、实现的接口、方法等)的地址信息，这些类型数据则存储在<code>方法区</code>中。</p><p>由于reference类型在java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。</p><ol><li><p>如果使用<code>句柄</code>访问方式，java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。<br><img src="/posts/47280/jubingfangwen.png" alt="通过句柄访问对象"></p></li><li><p>如果使用<code>直接指针</code>访问方式，java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。<br><img src="/posts/47280/zhijiezhizhen.png" alt="通过直接指针访问对象"></p></li></ol><p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普通的行为)时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p><p>就<code>Sun HotSpot</code>而言，它是使用<code>直接指针</code>进行对象访问的；从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——2.2运行时数据区域</title>
      <link href="/posts/30686.html"/>
      <url>/posts/30686.html</url>
      
        <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。<br><img src="/posts/30686/yunxingshishujuquyu.png"></p><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><p>程序计数器(program counter register)是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p><p>在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说一个内核)只会执行一条线程中的指令。<br>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为<code>线程私有</code>的内存。</p><p>如果线程正在执行的是一个<code>java方法</code>，这个计数器记录的是正在执行的<code>虚拟机字节码指令的地址</code>；如果正在执行的是<code>native方法</code>，这个计数器值则为<code>空(undefined)</code>。</p><p>此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="2-java虚拟机栈"><a href="#2-java虚拟机栈" class="headerlink" title="2.java虚拟机栈"></a>2.java虚拟机栈</h3><p>与程序计数器一样，java虚拟机栈(java virtual machine stacks)也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会同时创建一个<code>栈帧</code>(stack frame,栈帧是方法运行期的基础数据结构)用于存储<code>局部变量表、操作栈、动态链接、方法出口</code>等信息。<br>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>经常有人把java内存区分为堆内存(heap)和栈内存(stack)，这种分法比较粗糙，java内存区域的划分实际上远比这复杂。<br>这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。<br>其中的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。</p><p>局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、long、float、double)、对象引用(reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。<br>其中64位长度的long和double类型的数据会占用两个局部变量空间(slot)，其余的数据类型只占用1个。<br>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机栈可以动态扩展(当前大部分的java虚拟机都可动态扩展，只不过java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出<code>OutOfMemoryError</code>异常。</p><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h3><p>本地方法栈(native method stacks)与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的<code>native方法</code>服务。</p><p>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。<br>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><p>关于本地方法：一个Native Method就是一个java程序调用非java代码的接口。<br>一个本地方法是这样一个java的方法：该方法的实现由非java语言实现，比如C。<br>这个特征并非java所特有，很多其他的编程语言都有这一机制……</p><h3 id="4-java堆"><a href="#4-java堆" class="headerlink" title="4.java堆"></a>4.java堆</h3><p>对于大多数应用来说，java堆(java Heap)是java虚拟机所管理的内存中最大的一块。<br>java堆是被所有<code>线程共享</code>的一块内存区域，在虚拟机启动时创建。</p><p>此内存区域的唯一目的就是<code>存放对象实例</code>，几乎所有的对象实例都在这里分配内存。这一点在java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。<br>但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，<code>栈上分配、标量替换优化技术</code>将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作<code>GC堆(garbage collected heap)</code>。<br>如果从<code>内存回收</code>的角度看，由于现在收集器基本都是采用的<code>分代收集算法</code>，所以java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。<br>如果从<code>内存分配</code>的角度看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区(thread local allocation buffer,TLAB)。<br>不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><p>根据java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。<br>在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。<br>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h3><p>方法区中的信息：类的静态方法、静态变量、常量池、类的代码。</p><p>方法区(method area)与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”(Permanent Generation)，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。<br>对于其他虚拟机(如BEA JRockit、IBM J9等)来说是不存在永久代的概念的。<br>即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。</p><p>方法区是一个规范，它的实现取决于不同的虚拟机。</p><ul><li>Java8之前，HotSpot虚拟机使用<code>永久代</code>来实现方法区。</li><li>Java8及之后，HotSpot虚拟机使用<code>元空间</code>来实现方法区。</li></ul><p>java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。<br>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。<br>这个区域的内存回收目标主要是针对<code>常量池的回收和对类型的卸载</code>，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分的区域的回收确实是有必要的。<br>在Sub公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>根据java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6.运行时常量池"></a>6.运行时常量池</h3><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。<br>Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>Java虚拟机对Class文件的每一部分(自然也包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。<br>但对于运行时常量池，java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需求来实现这个内存区域。<br>不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。<br>Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7.直接内存"></a>7.直接内存</h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p><p>在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在java堆和native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括RAM及SWAP区或者分页文件)的大小及处理器寻址空间的限制。<br>服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.5内存分配与回收策略</title>
      <link href="/posts/16290.html"/>
      <url>/posts/16290.html</url>
      
        <content type="html"><![CDATA[<p>Java技术体系中所提倡的<code>自动内存管理</code>最终可以归结为自动化地解决了两个问题：<code>给对象分配内存</code>以及<code>回收分配给对象的内存</code>。</p><h4 id="给对象分配内存"><a href="#给对象分配内存" class="headerlink" title="给对象分配内存"></a>给对象分配内存</h4><p>对象的内存分配，往大方向上讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，讲按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。</p><p>但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配。在Java编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。<br>当你写好一个Java程序后，源语言的语句将由Java编译器编译成字节码，而不是编译成与某个特定的处理器硬件平台对应的指令代码（比如，Intel的Pentium微处理器或IBM的System/390处理器）。字节码是可以发送给任何平台并且能在那个平台上运行的独立于平台的代码。</p><h3 id="1-对象优先在Eden上分配"><a href="#1-对象优先在Eden上分配" class="headerlink" title="1. 对象优先在Eden上分配"></a>1. 对象优先在Eden上分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p><p>虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前内存各区域的分配情况。在实际应用中，内存回收日志一般是打印到文件后通过日志工具进行分析。</p><ul><li>新生代GC(Minor GC)：指发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC(但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>所谓大对象就是指，需要大量连续内存空间的java对象，最典型的大对象就是那种很长的字符串及数组。</p><p>大对象对虚拟机的内存分配来说就是一个坏消息(比遇到一个大对象更加坏的消息就是遇到一群“朝生夕死”的“短命大对象”，写程序的时候应当避免)，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><h3 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h3><p>虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，哪些对象应当放在老年代中。</p><p>为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。<br>如果对象在Eden出生并经过第一个Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。<br>对象在Survivor区中每熬过一个Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁)时，就会被晋升到老年代中。<br>对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。</p><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</p><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><p>在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。<br>如果大于，则改为直接进行一次Full GC。<br>如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。</p><p>新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况时(最极端就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。</p><p>与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p><p>取平均值进行比较是一种动态概念的手段，也就是说如果某次Minor GC存活后的对象徒增，远远高于平均值的话，依然会导致担保失败(Handle Promotion Failure)。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。<br>虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.4垃圾收集器</title>
      <link href="/posts/35696.html"/>
      <url>/posts/35696.html</url>
      
        <content type="html"><![CDATA[<p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。</p><p><img src="/posts/35696/lajishoujiqi.png"><br>图中展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。</p><p>明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。<br>因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h3><p>单线程，stop the word</p><h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2. ParNew收集器"></a>2. ParNew收集器</h3><p>Serial收集器的多线程版本</p><h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3. Parallel Scavenge收集器"></a>3. Parallel Scavenge收集器</h3><h3 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4. Serial Old收集器"></a>4. Serial Old收集器</h3><p>Serial收集器的老年代版本</p><h3 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h3><p>Parallel收集器的老年代版本</p><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h3><p>concurrent mark sweep，是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，非常符合在注重用户体验的应用上使用。<br>CMS收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让<strong>垃圾收集线程与用户线程(基本上)同时工作</strong>。</p><p>CMS收集器用<strong>标记—清除</strong>算法实现。<br>整个过程分为四个步骤：</p><ul><li>初始标记<br>  STW，耗时短，仅标记GC Roots能直接关联到的对象</li><li>并发标记<br>  不会STW，耗时长，从初识标记的对象中遍历整个对象图</li><li>重新标记<br>  STW，耗时短，修正并发标记期间用户线程导致的标记变动记录</li><li>并发清除。<br>  不会STW，产生浮动垃圾。<br>  并发失败的话，启动Serial Old，会导致停顿时间变长。</li></ul><p>优点：并发收集、低停顿。</p><ul><li>缺点：<ul><li>对CPU资源敏感</li><li>无法处理浮动垃圾</li><li>使用“标记—清除”算法会导致收集结束时会有大量空间碎片产生。</li><li>并发失败。<br>由于浮动垃圾的存在，因此CMS必须预留一部分空间来装载这些新产生的垃圾。CMS不能像Serial Old收集器那样，等到老年代区填满了再来清理。在JDK5时，CMS会在老年代使用了68%的空间时激活，预留了32%的空间来装载浮动垃圾，这是一个比较偏保守的配置。如果实际引用中，老年代增长的不是太快，可以通过-XX：CMSInitiatingOccupancyFraction参数适当调高这个值。到了JDK6，触发的阈值就被提升至92%，只预留了8%的空间来装载浮动垃圾。<br>如果CMS预留的内存无法容纳浮动垃圾，那么就会导致<strong>并发失败</strong>，这时JVM会触发预备方案，启用Serial Old收集器来回收Old区，这时停顿时间就变得更长了。</li></ul></li></ul><p><strong>GC时为什么要暂停用户线程？</strong><br>首先，如果不暂停用户线程，就意味着期间会不断有垃圾产生，永远也清理不干净。<br>其次，用户线程的运行必然会导致对象的引用关系发生改变，这就会导致两种情况：漏标和错标。</p><p><strong>为什么CMS采用“标记-清除”算法而不采用“标记-整理”算法</strong><br>因为CMS作为第一款实现用户线程和收集线程并发执行的收集器，当时的设计理念是减少停顿时间，最好是能并发执行。<br>但是问题来了，如要用户线程也在执行，那么就不能轻易的改变堆中对象的内存地址，不然会导致用户线程无法定位引用对象，从而无法正常运行。而标记整理算法和标记复制算法都会移动存活的对象，这就与上面的策略不符，因此CMS采用的是标记清理算法。</p><h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h3><p>G1(Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的及其，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。</p><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征，具备以下特点：</p><ul><li>分代收集</li><li>并行与并发。G1能充分利⽤CPU、多核环境下的硬件优势，使⽤多个CPU（CPU或者CPU核⼼）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执⾏的GC动作，G1收集器仍然可以通过并发的⽅式让java程序继续执⾏。</li><li>空间整合。与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li>可预测的停顿</li></ul><h4 id="G1回收流程"><a href="#G1回收流程" class="headerlink" title="G1回收流程"></a>G1回收流程</h4><p>运作分为四个步骤：</p><ul><li>初始标记<br>  这个阶段是STW(Stop the World )的，所有应用线程会被暂停，标记出从GC Root开始直接可达的对象。</li><li>并发标记<br>  从GC Roots开始对堆中对象进行可达性分析，找出存活对象，耗时较长。</li><li>最终标记<br>  标记那些在并发标记阶段发生变化的对象，这阶段需要停顿线程，但是可以并行执行。</li><li>筛选回收<br>  暂停用户线程，筛选阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。<br>  G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</li></ul><h4 id="G1收集器的内存模型"><a href="#G1收集器的内存模型" class="headerlink" title="G1收集器的内存模型"></a>G1收集器的内存模型</h4><p><img src="/posts/35696/g1-region.png"><br><strong>G1堆内存结构</strong><br>堆内存会被切分成为很多个固定大小区域(Region)，每个是连续范围的虚拟内存。<br>堆内存中一个区域(Region)的大小可以通过-XX:G1HeapRegionSize参数指定，大小区间最小1M、最大32M，总之是2的幂次方。<br>默认把堆内存按照2048份均分。</p><p><strong>G1堆内存分配</strong><br>每个Region被标记了E、S、O和H，这些区域在逻辑上被映射为Eden，Survivor和老年代。<br>存活的对象从一个区域转移(即复制或移动)到另一个区域。区域被设计为并行收集垃圾，可能会暂停所有应用线程。</p><p>如上图所示，区域可以分配到Eden，survivor和老年代。此外，还有第四种类型，被称为巨型区域(Humongous Region)，Humongous区域是为了那些存储超过50%标准region大小的对象而设计的，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。<br>G1收集器采用“标记-复制”和“标记-整理”。从整体上看是基于“标记-整理”，从局部看，两个region之间是“标记-复制”。</p><h4 id="G1的GC模式"><a href="#G1的GC模式" class="headerlink" title="G1的GC模式"></a>G1的GC模式</h4><ol><li>YoungGC年轻代收集<br> 在分配一般对象（非巨型对象）时，当所有eden region使用达到最大阀值并且无法申请足够内存时，会触发一次YoungGC。每次younggc会回收所有Eden以及Survivor区，并且将存活对象复制到Old区以及另一部分的Survivor区。<br> YoungGC的回收过程如下:<ul><li>根扫描,跟CMS类似，Stop the world，扫描GC Roots对象。</li><li>处理Dirty card，更新RSet.</li><li>扫描RSet，扫描RSet中所有old区对扫描到的young区或者survivor去的引用。</li><li>拷贝扫描出的存活的对象到survivor2/old区</li><li>处理引用队列，软引用，弱引用，虚引用</li></ul></li><li>mixed gc<br> 当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意:是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。<br> G1没有fullGC概念，需要fullGC时，调用serialOld GC进行全堆扫描（包括eden、survivor、o、perm）。</li></ol><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.2对象死或否</title>
      <link href="/posts/61135.html"/>
      <url>/posts/61135.html</url>
      
        <content type="html"><![CDATA[<p>堆中几乎存放着java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还<code>存活</code>着，哪些已经<code>死去</code>(即不可能再被任何途径使用的对象).</p><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1.引用计数算法"></a>1.引用计数算法</h3><p>很多教科书判断对象是否存活的算法是：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。<br>任何时刻计数器都为0的对象就是不可能再被使用的。</p><p>客观地说，引用计数算法(Reference Counting)的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案列，例如微软的COM(Component Object Model)技术、使用ActionScript3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。</p><p>但是，java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决<code>对象之间的相互循环引用</code>的问题。</p><p><img src="/posts/61135/yinyongjishu.png"><br>testGC()方法中对象objA和objB都有字节instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用。<br>实际上这两个对象已经不可能再被访问，但是它们因为互相引用这对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。</p><p><img src="/posts/61135/yinyongjishujieguo.png"><br>从运行结果可以看到GC日志中包含“4603K-&gt;210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p><h3 id="2-根搜索算法"><a href="#2-根搜索算法" class="headerlink" title="2.根搜索算法"></a>2.根搜索算法</h3><p>在主流的商用程序语言中(java和C#，甚至包括前面提到的古老的Lisp)，都是使用<code>根搜索算法(GC Roots Tracing)</code>判定对象是否存活的。</p><p>这个算法的基本思路就是通过一系列的名为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)。<br>当一个对象到GC Roots没有任何引用链相连(用图论的话来说就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。</p><p><img src="/posts/61135/gensousuo.png"><br>如图，对象object5、object6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p><p>在java语言里，可作为GC Roots的对象包括下面几种：</p><ol><li>虚拟机栈(栈帧中的本地变量表)中的引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中的常量引用的对象。</li><li>本地方法栈中JNI(即一般说的native方法)的引用的对象。</li></ol><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判断对象是否存活都与<code>引用</code>有关。</p><p>在JDK1.2之前，java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外内存的起始地址，就称这块内存代表着一个引用。<br>这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。<br>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>在JDK1.2之后，java对引用的概念进行了扩充，将引用分为强引用(strong reference)、软引用(soft reference)、弱引用(weak reference)、虚引用(phantom reference)四种。<br>这四种引用强度依次逐渐减弱。</p><ol><li><code>强引用</code>就是指在程序代码之中普遍存在的，类似“Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li><code>软引用</code>用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</li><li><code>弱引用</code>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现软引用。</li><li><code>虚引用</code>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现软引用。</li></ol><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<br>要真正宣告一个对象死亡，至少要经历两次标记过程。</p><p>如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。<br>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。<br>这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。<br>这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> * 1.对象可以在被GC时自我拯救</span></span><br><span class="line"><span class="comment"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SACE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;yes,i am still alive :)&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"> <span class="keyword">super</span>.finalize();</span><br><span class="line"> System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line"> FinalizeEscapeGC.SACE_HOOK = <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"> SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line"> SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"> System.gc();</span><br><span class="line"> <span class="comment">//因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line"> Thread.sleep(<span class="number">500</span>);</span><br><span class="line"> <span class="keyword">if</span>(SAVE_HOOK ！= <span class="keyword">null</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> SAVE_HOOK.isAlive();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;no,i am dead :(&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//下面这段代码与上面完全相同，但是这次自救却失败了</span></span><br><span class="line"> SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"> System.gc();</span><br><span class="line"> <span class="comment">//因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line"> Thread.sleep(<span class="number">500</span>);</span><br><span class="line"> <span class="keyword">if</span>(SAVE_HOOK ！= <span class="keyword">null</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> SAVE_HOOK.isAlive();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;no,i am dead :(&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">finalize method executed!</span><br><span class="line">yes,i am still alive :)</span><br><span class="line">no,i am dead :(</span><br></pre></td></tr></table></figure><p>从运行结果可以看到，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。<br>另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>很多人认为方法区(或者HotSpot虚拟机中的永久代)是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><p><code>回收废弃常量</code>与回收java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。<br>常量池中的其他类(接口)、方法、字段的符号引用也与此类似。</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。</p><p>类需要同时满足下面3个条件才能算是<code>无用的类</code>：</p><ol><li>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。<br>是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类的加载和卸载信息。-verbose:class及-XX:+TraceClassLoading可以在Product版的虚拟机中使用，但是-XX:+TraceClassLoading参数需要fastdebug版的虚拟机支持。<br>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.3垃圾回收算法</title>
      <link href="/posts/59131.html"/>
      <url>/posts/59131.html</url>
      
        <content type="html"><![CDATA[<h3 id="标记——清除算法-Mark-Sweep"><a href="#标记——清除算法-Mark-Sweep" class="headerlink" title="标记——清除算法(Mark-Sweep)"></a>标记——清除算法(Mark-Sweep)</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉被标记的对象。<br>标记过程在另一篇“深入理解JVM——对象死或否”中讲述，对象标记判定对象是不是还“存活”。</p><p>主要缺点有两个。<br>一个是效率问题，标记和清除过程的效率都不高。<br>另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="/posts/59131/marksweep.png" alt="标记——清除算法示意图"><br>举个不恰当的例子，类似于我们扔垃圾，我们把垃圾扔到垃圾桶里，扔到垃圾桶里的垃圾只是被标记为了“垃圾”，我们并不会立刻把它扔掉，当垃圾桶满了的时候，我们统一清除它们。</p><h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h3><p>为了解决效率问题，出现了这种称为“复制”的收集算法。</p><p>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。</p><p>这种算法的代价是将内存缩小为原来的一半，未免太高了，也就是说浪费一半的内存空间。</p><p><img src="/posts/59131/copying.png" alt="复制算法示意图"></p><p>现在的商业虚拟机都采用复制算法来回收新生代。<br>IBM的专门研究表名，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是<code>将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor</code>。<br>当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。</p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存是会被“浪费”的。<br>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行<code>分配担保(Handle Promotion)</code>。</p><p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。<br>内存的分配担保也一样，如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p><h3 id="标记——整理算法-Mark-Compact"><a href="#标记——整理算法-Mark-Compact" class="headerlink" title="标记——整理算法(Mark-Compact)"></a>标记——整理算法(Mark-Compact)</h3><p>复制算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据<code>老年代</code>的特点，便提出了这种<code>标记——整理算法</code>，标记过程仍然与“标记——清除算法”一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br><img src="/posts/59131/markcompact.png" alt="标记——整理算法示意图"></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。</p><p>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p>在<code>新生代</code>中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<code>复制算法</code>，只需要付出少量存活对象的复制成本就可以完成收集。<br>而<code>老年代</code>中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<code>“标记——清除”</code>或<code>“标记——整理”</code>算法来进行回收。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——数组</title>
      <link href="/posts/23822.html"/>
      <url>/posts/23822.html</url>
      
        <content type="html"><![CDATA[<h4 id="为什么数组要从0开始编号，而不是从1开始？"><a href="#为什么数组要从0开始编号，而不是从1开始？" class="headerlink" title="为什么数组要从0开始编号，而不是从1开始？"></a>为什么数组要从0开始编号，而不是从1开始？</h4><h4 id="如何实现随机访问？"><a href="#如何实现随机访问？" class="headerlink" title="如何实现随机访问？"></a>如何实现随机访问？</h4><h3 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1.什么是数组"></a>1.什么是数组</h3><p>数组(Array)是一种①线性表数据结构。它用一组②连续的内存空间，来存储一组具有相同类型的数据。</p><h4 id="①线性表"><a href="#①线性表" class="headerlink" title="①线性表"></a>①线性表</h4><p>顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。<br><img src="/posts/23822/xianxingbiao.jpg"><br>相对立的非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。<br><img src="/posts/23822/feixianxingbiao.jpg"></p><h4 id="②连续的内存空闲和相同类型的数据"><a href="#②连续的内存空闲和相同类型的数据" class="headerlink" title="②连续的内存空闲和相同类型的数据"></a>②连续的内存空闲和相同类型的数据</h4><p>相同类型保证数组元素内存地址的计算公式可以成立，从而支持随机访问。<br>优点：正因为这两个限制，数组才有了一个特性：随机访问（并不是random的随机，可能理解为任意访问更清晰一点。）。<br>缺点：但是，要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><h3 id="2-数组是如何实现根据下标随机访问数组元素的？"><a href="#2-数组是如何实现根据下标随机访问数组元素的？" class="headerlink" title="2.数组是如何实现根据下标随机访问数组元素的？"></a>2.数组是如何实现根据下标随机访问数组元素的？</h3><p><img src="/posts/23822/shuzuneicun.jpg"><br>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size(元素类型长度)</span><br></pre></td></tr></table></figure><h4 id="注意：数组和链表的区别"><a href="#注意：数组和链表的区别" class="headerlink" title="注意：数组和链表的区别"></a>注意：数组和链表的区别</h4><p>“链表适合插入、删除，时间复杂度是O(1)；数组适合查找，查找时间复杂度是O(1)。”实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为O(1)，即便是排好序的数组，二分查找的时间复杂度最好也是O(logn)。正确的表述应该是，“数组支持随机访问，根据下标随机访问的时间复杂度是O(1)。”</p><h3 id="3-低效的“插入”和“删除”"><a href="#3-低效的“插入”和“删除”" class="headerlink" title="3.低效的“插入”和“删除”"></a>3.低效的“插入”和“删除”</h3><p>数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，那，为什么会导致低效？改进方法？</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>假设现在有一个数组，长度为n，现在我们需要把一个数组插入到数组中的第k个位置。为了把第k个位置腾出来给信赖的数据，需要将第k~n这部分元素都顺序地往后挪一位。这样的话，插入操作的时间复杂度是多少？<br>最好情况：如果在数组的末尾插入元素，就不需要移动数据，这时的时间复杂度是O(1)。<br>最坏情况：如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O(n)。<br>平均情况时间复杂度为(1+2+……+n)/n=O(n)。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，要将某个数据插入到第k个位置，为了避免大规模的数据搬移，简单办法是：直接将第k为数据搬移到数组元素的最后，把新的元素直接放入第k个位置。<br><img src="/posts/23822/wuxucharu.jpg"><br>这样，在特定场景下，在第k个位置插入一个元素的时间复杂度就降为O(1)。这个处理思想在快排中会用到。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>跟插入数据类似，如果我们要删除第k个位置的数据，为了内存的连续性，也需要搬移数据，不然数组中间会出现空缺，内存就不连续了。<br>如果要删除数组末尾的数据，则最好情况时间复杂度为O(1)；删除数组开头的数据，最坏情况时间复杂度为O(n)；平均情况时间复杂度为O(n)。</p><p>在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率也许会提高很多。<br>假设数组a[10]中存储了8个元素：a,b,c,d,e,f,g,h。现在，我们要依次删除a,b,c三个元素。<br><img src="/posts/23822/jizhongshanchu.jpg"><br>为了避免d,e,f,g,h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br>而这，正是JVM垃圾回收之标记——清除算法的思想。<br>标记——清除算法：从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象设一个标记，这个过程不会回收任何对象。只有全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。所以剩下的堆空间是不连续的。标记——清除算法只有在少量垃圾产生时会很高效。</p><h3 id="4-警惕数组的访问越界问题"><a href="#4-警惕数组的访问越界问题" class="headerlink" title="4.警惕数组的访问越界问题"></a>4.警惕数组的访问越界问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int arr[3] = &#123;0&#125;;</span><br><span class="line">    for(; i&lt;=3; i++)&#123;</span><br><span class="line">        arr[i] = 0;</span><br><span class="line">        printf(&quot;hello world\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段C语言代码的运行结果并非是打印三行“hello world”，而是会无限打印“hello world”。<br>因为，数组的大小是3，a[0],a[1],a[2],而这段代码书写错误，导致for循环的结束条件错写为了i&lt;=3而不是i&lt;3，所以当i=3时，数组a[3]访问越界。<br>在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据前面提到的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么a[3]=0就相当于i=0，就导致代码无限循环。</p><h4 id="为什么a-3-的内存地址正好是变量i的内存地址"><a href="#为什么a-3-的内存地址正好是变量i的内存地址" class="headerlink" title="为什么a[3]的内存地址正好是变量i的内存地址"></a>为什么a[3]的内存地址正好是变量i的内存地址</h4><pre><code>函数体内的局部变量存在栈上，且是连续压栈。这段代码的变量压栈顺序是：i,arr[0],arr[1],arr[2]。变量i最先入栈，然后是数组元素，因为数组地址连续从小到大，实际栈中的变量顺序为：arr[0],arr[1],arr[2],i。这样arr[3]的地址刚好与i相同。另外的解释是：与编译器的实现有关。linux的gcc有一个编译选项(-fno-stack-protector)用于关闭堆栈保护功能。默认情况下启动堆栈保护，不管i声明在前还是声明在后，i都会在数组之后压栈，只会循环4次；如果关闭了堆栈保护功能，则会出现死循环。</code></pre><p>数组越界在C语言中是一种未决行为(没有定义的行为)，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质是访问一段连续内存，只要数组通过偏移计算得到的内存地址时可用的，那么程序就可能不会报任何错误。<br>Java本身就会做越界检查，数组越界会抛出java.lang.ArrayIndexOutOfBoundsException。</p><h3 id="5-容器能否完全替代数组？"><a href="#5-容器能否完全替代数组？" class="headerlink" title="5.容器能否完全替代数组？"></a>5.容器能否完全替代数组？</h3><p>针对数组类型，java提供了ArrayList容器类，C++STL中的vector。<br>拿java的ArrayList举例。ArrayList最大的优势就是可以将很多数组操作的细节封装起来，比如对数组的插入、删除操作。<br>另外就是支持动态扩容。数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间，如果申请的大小不够，就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。如果使用ArrayList，就不需要关心底层的扩容逻辑，ArrayList每次存储空间不够的时候，就会将空间自动扩容为1.5倍。需要注意的是，因为扩容操作涉及内存申请和数据搬移，是比较耗时的，所以如果事先能确定需要存储的数据大小，最好在创建ArrayList时事先指定大小。<br>1.java的ArrayList无法存储基本类型，涉及到拆装箱，会有一定性能消耗，涉及到技能或需要使用基本数据类型，选用数组。<br>2.如果数据大小事先已知，且对数据的操作简单，可以用数据。<br>3.多维数组表示时，数组更直观。Object[][] array和容器ArrayList<ArrayList> array。</ArrayList></p><h3 id="6-为什么数组要从0开始编号，而不是从1开始？"><a href="#6-为什么数组要从0开始编号，而不是从1开始？" class="headerlink" title="6.为什么数组要从0开始编号，而不是从1开始？"></a>6.为什么数组要从0开始编号，而不是从1开始？</h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”。<br>如果用a来表示数组的首地址，a[0]就是偏移为0的地址，也就是首地址，a[k]表示偏移了k个type_size的位置，所以a[k]的内存地址计算只需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure><p>如果，数组从1开始奇数，那计算a[k]的内存地址变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure><p>对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。</p><h3 id="7-二维数组元素的地址计算公式"><a href="#7-二维数组元素的地址计算公式" class="headerlink" title="7.二维数组元素的地址计算公式"></a>7.二维数组元素的地址计算公式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//行优先</span><br><span class="line">a[i][j] = a[0][0] + i * n * data_type_size + j * data_type_size</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——复杂度分析</title>
      <link href="/posts/4332.html"/>
      <url>/posts/4332.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是复杂度分析？"><a href="#什么是复杂度分析？" class="headerlink" title="什么是复杂度分析？"></a>什么是复杂度分析？</h3><p>1.数据结构和算法解决“如何让计算机更快时间、更省空间的解决问题”。<br>2.因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能。<br>3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。<br>4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</p><h3 id="为什么要进行复杂读分析？"><a href="#为什么要进行复杂读分析？" class="headerlink" title="为什么要进行复杂读分析？"></a>为什么要进行复杂读分析？</h3><p>1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。<br>2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。</p><h3 id="如何进行复杂度分析？"><a href="#如何进行复杂度分析？" class="headerlink" title="如何进行复杂度分析？"></a>如何进行复杂度分析？</h3><h4 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h4><p>1.来源<br>算法的执行时间与每行代码的执行次数成正比，用T（n）=O（f（n））表示，其中T（n）表示算法执行总时间，f（n）表示每行代码执行总次数，而n往往代表数据的规模。<br>2.特点<br>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时忽略这些项。</p><h4 id="复杂度分析法则"><a href="#复杂度分析法则" class="headerlink" title="复杂度分析法则"></a>复杂度分析法则</h4><p>1.单段代码看高频。比如循环。<br>2.多段代码取最大。比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3.嵌套代码求乘积。比如递归、多重循环等。<br>4.多个规模求加法。比如方法有两个参数（m、n）控制两个循环的次数，那么这时就取二者复杂度相加。</p><h3 id="常用的复杂度级别"><a href="#常用的复杂度级别" class="headerlink" title="常用的复杂度级别"></a>常用的复杂度级别</h3><h4 id="多项式阶"><a href="#多项式阶" class="headerlink" title="多项式阶"></a>多项式阶</h4><p>随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括：O（1）（常数阶）、O（logn）（对数阶）、O（n）（线性阶）、O（nlogn）（线性对数阶）、O（n^2）（平方阶）、O（n^3）（立方阶）。</p><h4 id="非多项式阶"><a href="#非多项式阶" class="headerlink" title="非多项式阶"></a>非多项式阶</h4><p>随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括O（2^n）（指数阶）、O（n！）（阶乘阶）。<br><img src="/posts/4332/fuzaduliangji.jpg" alt="复杂度量级"></p><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率和数据规模之间的增长关系。<br><img src="/posts/4332/on.jpg"></p><h3 id="复杂度分析的四个概念"><a href="#复杂度分析的四个概念" class="headerlink" title="复杂度分析的四个概念"></a>复杂度分析的四个概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// n 表示数组 array 的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码要实现的功能是，在一个无序的数组（array）中，查找变量x出现的位置。如果没有找到，就返回-1。这段代码的复杂度看上去的话是O（n）。</p><h4 id="最好情况时间复杂度"><a href="#最好情况时间复杂度" class="headerlink" title="最好情况时间复杂度"></a>最好情况时间复杂度</h4><p>代码在最理想情况下执行的时间复杂度。<br>在最理想的情况下，要查找的变量x正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。</p><h4 id="最坏情况时间复杂度"><a href="#最坏情况时间复杂度" class="headerlink" title="最坏情况时间复杂度"></a>最坏情况时间复杂度</h4><p>代码在最坏情况下执行的时间复杂度。<br>如果数组中没有要查找的变量x，需要把整个数组都遍历一遍。</p><h4 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h4><p>用代码在所有情况下执行的次数的加权平均值表示。<br>要查找的变量x，要么在数组中，要么就不在数组里，这两种情况对应的概率统计起来很麻烦，假设在数组中与不在数组中的概率都为1/2。另外，要查找的数据出现在0<del>n-1这n个位置的概率也是一样的，为1/n。所以根据概率乘法法则，要查找的数据出现在0</del>n-1中任意位置的概率就是1/（2n）。<br><img src="/posts/4332/pingjun.jpg"><br>这个值是概率论中的加权平均值，也叫做期望值，所以平均时间复杂度的全称应该叫做加权平均时间复杂度或者期望时间复杂度。<br>引入概率之后，前面那段代码的加权平均值为（3n+1）/4，用大O表示法来表示，去掉系数和常量，仍然为O（n）。</p><h4 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// array 表示一个长度为 n 的数组</span><br><span class="line">// 代码中的 array.length 就等于 n</span><br><span class="line">int[] array = new int[n];</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">   if (count == array.length) &#123;</span><br><span class="line">      int sum = 0;</span><br><span class="line">      for (int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[0] = sum;</span><br><span class="line">      count = 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现一个往数组中插入数据的功能。当数组满了之后，count==array.length时，我们用for循环遍历数组求和，并清空数组，将求和之后的sum值放到数组的第一个位置，然后将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。<br>时间复杂度最好为O（1），最坏为O（n），平均时间复杂度也是O（1）。<br>假设数组的长度是n，根据数据插入的位置不同，分为n种情况，每种情况的时间复杂度是O（1），另外在数组没有空闲空间时插入一个数据，这时是O（n），这n+1种情况发生的改率一样，都是1/（n+1）。<br><img src="/posts/4332/pingjun2.jpg"></p><p>对于后面这个inset（）函数来说，O（1）和O（n）出现的频率是有规律的，而且有一定的前后时序关系，一般都是一个O（n）插入之后，紧跟着n-1个O（1）的插入操作，循环往复。<br>针对这种特殊场景，引入一种更加简单的分析方法：摊还分析法，通过摊还分析得到均摊时间复杂度。<br>均摊时间复杂度是一种特殊的平均时间复杂度。<br>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这时候，可以将这一组操作放在一块儿分析，将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度等于最好情况时间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blue Butterfly</title>
      <link href="/posts/31995.html"/>
      <url>/posts/31995.html</url>
      
        <content type="html"><![CDATA[<p>我在清晨醒来的时候流泪<br>一只蓝色蝴蝶经过我深深的梦里<br>我的梦里</p><p>我闭上眼睛回想她的来过<br>她会一直都在<br>是我这单薄的一生如此真切的渴望</p><p>可我要怎么去知道，我不知道<br>也许只是偶然的造访<br>回忆才是她真实存在的地方</p><p>蝴蝶记忆很短<br>爱上一朵花后六秒就忘记<br>如果我有一万亩玫瑰和一点星光<br>就对她说：留下来吧</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—排序总结</title>
      <link href="/posts/36857.html"/>
      <url>/posts/36857.html</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>算法描述：将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序（即L.r[1].key&gt;L.r[2].key），则将两个记录交换之，然后比较第二个记录和第三个记录。依次类推，直到第n-1个记录和第n个记录的关键字进行过比较为止，此过程称为第一趟起泡排序，其结果使得关键字最大的记录被安置到最后一个记录的位置上。最坏情况，初始序列为“逆序”，需进行n-1趟排序，进行n(n-1)/2次比较，并做等数量级的记录移动，时间复杂度为O(n的平方)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSore</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j ++)&#123;</span><br><span class="line">                <span class="comment">// 前者大于后者 交换之</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 节省最后几趟过程，前面的元素可能已经有序了</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">25</span>,<span class="number">4</span>,<span class="number">999</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        bubbleSore(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是对冒泡排序的一种改进。它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br>一趟快速排序的具体做法是：附设两个指针low和high，它们的初值分别为low和high，设枢轴记录的关键字为pivotkey，则首先从high所指位置起向前搜索找到第一个关键字小于pivotkey的记录和枢轴记录互相交换，然后从low所指位置起向后搜索，找到第一个关键字大于pivotkey的记录和枢轴记录互相交换，重复这两步直至low=high为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        pivot = partition(a, low, high);</span><br><span class="line">        quickSort(a, low, pivot-<span class="number">1</span>);</span><br><span class="line">        quickSort(a, pivot+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> first, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=first;</span><br><span class="line">    <span class="keyword">int</span> j=end;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;  <span class="comment">//右侧扫描</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) &#123;  <span class="comment">//将较小记录交换到前面</span></span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">            <span class="comment">//i++;</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123; <span class="comment">//左侧扫描</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) &#123; <span class="comment">//将较大记录交换到后面</span></span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">            <span class="comment">//j--;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序——简单选择排序"><a href="#选择排序——简单选择排序" class="headerlink" title="选择排序——简单选择排序"></a>选择排序——简单选择排序</h3><p>算法描述：对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录与第一个记录的位置进行交换，接着对不包括第一个记录以外的其他记录进行第二轮比较，得到最小的记录并与第二个记录进行位置交换，重复该过程，直到进行比较的记录只有一个时为止。<br>选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 平均O(n^2),最好O(n^2),最坏O(n^2);空间复杂度O(1);不稳定;简单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="comment">// 找出最小值的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[k]) &#123;</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将最小值放到未排序记录的第一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                arr[k] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123; <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        selectionSort(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : b)</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一致有序。重复这个过程，直到未排序区间中元素为空，算法结束。<br><img src="/posts/36857/charupaixu.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a表示数组 n表示数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> value = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//查找插入的位置</span></span><br><span class="line">        <span class="keyword">for</span>(;j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; value)&#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j]; <span class="comment">//数据移动</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j+<span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序——堆排序"><a href="#选择排序——堆排序" class="headerlink" title="选择排序——堆排序"></a>选择排序——堆排序</h3><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想：要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br><img src="/posts/36857/guibingpaixu.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归并排序算法, a是数组，n表示数组大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    mergeSortInternally(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值</span></span><br><span class="line">    <span class="keyword">int</span> q = p + (r - p)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 分治递归</span></span><br><span class="line">    mergeSortInternally(a, p, q);</span><br><span class="line">    mergeSortInternally(a, q+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">    merge(a, p, q, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = p;</span><br><span class="line">    <span class="keyword">int</span> j = q+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 初始化变量i, j, k</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>]; <span class="comment">// 申请一个大小跟a[p...r]一样的临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">        tmp[k++] = a[i++]; <span class="comment">// i++等于i:=i+1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">    <span class="keyword">int</span> start = i;</span><br><span class="line">    <span class="keyword">int</span> end = q;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">      start = j;</span><br><span class="line">      end = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">      tmp[k++] = a[start++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将tmp中的数组拷贝回a[p...r]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) &#123;</span><br><span class="line">      a[p+i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h3 id="复杂度总结"><a href="#复杂度总结" class="headerlink" title="复杂度总结"></a>复杂度总结</h3><p><img src="/posts/36857/%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93.jpg" alt="复杂度总结"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情书</title>
      <link href="/posts/2505.html"/>
      <url>/posts/2505.html</url>
      
        <content type="html"><![CDATA[<p>你好哇，亲爱的我的爱人：<br>&emsp;&emsp;Hello，world：你好哇，我的爱人——我的世界。<br>&emsp;&emsp;因为程序员打出来的第一行代码是：“hello，world！”，所以写给你的第一封信这样来开头的话，好像，你就是我的世界了。<br>&emsp;&emsp;也是因为第一句话其实是极难的，无论是说的，还是写的。当一个少不经事的男孩子怀着激动的心情紧张地打下一行“嗨喽，你好哇！”发给那个极好的女孩子时，他总算向她和美好靠近了一步，然后他又焦急而慌张地等待她的回复，每一秒等待他都清晰地感觉到自己的心和身体在打颤，终于没有多久她稳重大方地回了一句“你好”，他的灵魂此刻在幸福的打颤，他们之间是要发生一些什么的。<br>&emsp;&emsp;所以在这里的话，写的第一句，可以说是我取巧了，取巧在我的专业，取巧在我隐藏起我的慌张和无措，以及故作模样的仪式感。<br>&emsp;&emsp;当我要谈一谈我们两个人的时候，我总要先说说我，再把目光投向你，这是一个自我剖析过去然后拉回你所在的现实的过程，最后让我说说关于我们——有关于未来。<br>&emsp;&emsp;98年的我都不敢信过完年我就虚岁22了，二十载荒唐，养成了一身的欲望，在所有的喜怒忧思悲恐惊中我最爱你，在所有的眼耳鼻舌身意的愿望中我最想要你。尤其静夜，我的情欲大，纷纷飘下，在我写下这些字的此刻。因为我的爱人，你还尚未到来，我实在不宜用太大的篇幅去讲我，怕你害怕，我也实在不愿向你隐瞒，等你来的那一天，我将一切都说与你，好的坏的都是关于我的。<br>&emsp;&emsp;在冬天刚到的时候，我说，“我干涸的心想要一场夏天，夏天太远，冬至已至，一场隆冬的雪亦能解渴。”<br>&emsp;&emsp;我已经渴望了太久。<br>&emsp;&emsp;这个冬天的雪没有那么大，这个冬天也快要走远了，我的孤独和花园已经枯萎了太久，在转瞬就至的春天和盼望已久的夏天里，你挑一个日子来吧，因为秋天是一个适合谈恋爱的季节，是一个浪漫的季节，我应该为你温柔；你若不来，“自古逢秋悲寂寥”，我一生都为你寂寥。<br>&emsp;&emsp;你也许不会相信，我常常想象你是多么美好，多么可爱，但实际见你面的时候，我相信，你比我想象的要美好得多，可爱得多。你不能说我这是说谎，因为如果不然的话，我当然可以仅仅靠想你就满足，而不必那样渴望着想见到你，我是如此羡慕那些与你想见面就能见面的人。<br>&emsp;&emsp;你不知道，我这颗心已经厌世嫉俗惯了，每一个惨淡晦暗的清晨都觉得快要不行了，坚持不住了，可是啊，看着你笑的照片，听听你的声音，就觉得，时事维艰也不过如此。<br>&emsp;&emsp;你知道吗，我好想看见你的笑容啊。就是在那种难捱的日子里，你会笑的眼睛里氤氲着的光，注视着我，驱散我深渊一样的心深处最顽固的黑暗。你做我的蚩梦吧，你永远年轻，永远热泪盈眶。你饱含着的热情，我靠近一分，就消散一分我长久以来攒了满身的沮丧。即便我仍是沮丧，我却有充足的气力去做事。<br>&emsp;&emsp;这封情书请你一定要收下。你要相信，先有情，才有话，才有诗，才有书。我这决不是在忽悠你。</p><p>一个不知所谓的臭男生</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Markdown</title>
      <link href="/posts/64522.html"/>
      <url>/posts/64522.html</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown是一种轻量级的「标记语言」</strong><span id="more"></span></p><p><img src="https://www.mdeditor.com/images/logos/markdown.png" alt="markdown" title="markdown"></p><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p><h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><h6 id="标题H5-1"><a href="#标题H5-1" class="headerlink" title="标题H5"></a>标题H5</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr><p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s></p><p><em>斜体字</em>      <em>斜体字</em></p><p><strong>粗体</strong>  <strong>粗体</strong></p><p><em><strong>粗斜体</strong></em> <em><strong>粗斜体</strong></em></p><p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p><p><strong>缩写(同HTML的abbr标签)</strong></p><blockquote><p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p></blockquote><p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p><h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><blockquote><p>引用文本 Blockquotes</p></blockquote><p>引用的行内混合 Blockquotes</p><blockquote><p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/">普通链接</a>。</p></blockquote><h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><p><a href="https://www.mdeditor.com/">普通链接</a><br><a href="https://www.mdeditor.com/" title="普通链接带标题">普通链接带标题</a><br>直接链接：<a href="https://www.mdeditor.com/">https://www.mdeditor.com</a><br>[锚点链接][anchor-id]<br>[anchor-id]: <a href="https://www.mdeditor.com/">https://www.mdeditor.com/</a><br><a href="mailto:test.test@gmail.com">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 <a href="mailto:&#x74;&#x65;&#x73;&#116;&#46;&#116;&#101;&#x73;&#116;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;">&#x74;&#x65;&#x73;&#116;&#46;&#116;&#101;&#x73;&#116;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;</a>  <a href="mailto:&#119;&#x77;&#x77;&#64;&#118;&#x69;&#112;&#x2e;&#113;&#113;&#x2e;&#99;&#111;&#109;">&#119;&#x77;&#x77;&#64;&#118;&#x69;&#112;&#x2e;&#113;&#113;&#x2e;&#99;&#111;&#109;</a></p><blockquote><p>@pandao</p></blockquote><h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><p>执行命令：<code>npm install marked</code></p><h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p><pre><code>&lt;?php    echo &quot;Hello world!&quot;;?&gt;</code></pre><p>预格式化文本：</p><pre><code>| First Header  | Second Header || ------------- | ------------- || Content Cell  | Content Cell  || Content Cell  | Content Cell  |</code></pre><h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HTML-代码-HTML-codes"><a href="#HTML-代码-HTML-codes" class="headerlink" title="HTML 代码 HTML codes"></a>HTML 代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Editor.md, Markdown, Editor&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#444</span>;<span class="attribute">font-family</span>: <span class="string">&quot;Microsoft Yahei&quot;</span>, Tahoma, <span class="string">&quot;Hiragino Sans GB&quot;</span>, Arial;<span class="attribute">background</span>:<span class="number">#fff</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style</span>: none;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none;<span class="attribute">vertical-align</span>: middle;&#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-xxl&quot;</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-green&quot;</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>图片加链接 (Image + Link)：</p><p><a href="https://www.mdeditor.com/images/logos/markdown.png" title="markdown"><img src="https://www.mdeditor.com/images/logos/markdown.png"></a></p><blockquote><p>Follow your heart.</p></blockquote><hr><h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul><li>列表一</li><li>列表二<ul><li>列表二-1</li><li>列表二-2</li><li>列表二-3</li></ul></li><li>列表三<ul><li>列表一</li><li>列表二</li><li>列表三</li></ul></li></ul><h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol><li>第一行</li><li>第二行</li><li>第三行</li></ol><h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul><li><input checked disabled type="checkbox"> GFM task list 1</li><li><input checked disabled type="checkbox"> GFM task list 2</li><li><input disabled type="checkbox"> GFM task list 3<ul><li><input disabled type="checkbox"> GFM task list 3-1</li><li><input disabled type="checkbox"> GFM task list 3-2</li><li><input disabled type="checkbox"> GFM task list 3-3</li></ul></li><li><input disabled type="checkbox"> GFM task list 4<ul><li><input disabled type="checkbox"> GFM task list 4-1</li><li><input disabled type="checkbox"> GFM task list 4-2</li></ul></li></ul><hr><h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table><thead><tr><th>项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>Function name</th><th>Description</th></tr></thead><tbody><tr><td><code>help()</code></td><td>Display the help window.</td></tr><tr><td><code>destroy()</code></td><td><strong>Destroy your computer!</strong></td></tr></tbody></table><table><thead><tr><th align="left">Left-Aligned</th><th align="center">Center Aligned</th><th align="right">Right Aligned</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="center">some wordy text</td><td align="right">$1600</td></tr><tr><td align="left">col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><table><thead><tr><th>Item</th><th align="right">Value</th></tr></thead><tbody><tr><td>Computer</td><td align="right">$1600</td></tr><tr><td>Phone</td><td align="right">$12</td></tr><tr><td>Pipe</td><td align="right">$1</td></tr></tbody></table><hr><h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><p>&copy; &amp;  &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p><p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p><p>18&ordm;C  &quot;  &apos;</p><p>[========]</p><h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote><p>Blockquotes :star:</p></blockquote><h4 id="GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul><li><input checked disabled type="checkbox"> :smiley: @mentions, :smiley: #refs, <a href>links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li><li><input checked disabled type="checkbox"> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li><li><input checked disabled type="checkbox"> [ ] :smiley: this is a complete item :smiley:;</li><li><input disabled type="checkbox"> []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li><li><input disabled type="checkbox"> [ ]this is an incomplete item :fa-star: :fa-gear:;<ul><li><input disabled type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li><li><input disabled type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li></ul></li></ul><h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p><p>[========]</p><h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E=mc^2$$</p><p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p><p>$$x &gt; y$$</p><p>$$(\sqrt{3x-1}+(1+x)^2)$$</p><p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p><p>多行公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) = \int_&#123;-\infty&#125;^\infty</span><br><span class="line">    \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125;</span><br><span class="line">    \,d\xi</span><br></pre></td></tr></table></figure><h3 id="分页符-Page-break"><a href="#分页符-Page-break" class="headerlink" title="分页符 Page break"></a>分页符 Page break</h3><blockquote><p>Print Test: Ctrl + P</p></blockquote><p>[========]</p><h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 用户登陆</span><br><span class="line">op=&gt;operation: 登陆操作</span><br><span class="line">cond=&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e=&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>[========]</p><h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>who on the moon</title>
      <link href="/posts/36760.html"/>
      <url>/posts/36760.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://music.163.com/#/song?id=1315718569">月球上的人</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这首歌讲的是男主角把自己置身于月球，作为一个月球上的人来重新审视自己曾经的一段感情。</span><br><span class="line">众所周知，用月球的角度是因为从月球所看到的地球上的事物都是过去的，光的传播需要时间，</span><br><span class="line">时过境迁后才后悔自己当初太不会相爱的本领，真想忘记自己正身处的未来去重新爱一次。</span><br></pre></td></tr></table></figure><p>网易云热评上，这样说。</p><p>关于明月，我还听说过</p><blockquote><p>最冷的日子<br>我把自己披在身上取暖<br>星空浩瀚<br>明月是明月的前身<br>你是虚构的<br>只能在虚构里爱你<br>世界需要燃烧也需要灰烬<br>我才长出一颗心           </p></blockquote><p>“明月是明月的前身”，月亮和地球的距离随时间而改变，大约为三十八万千米，因为人的眼睛接收到的是光，以光速约要1.28秒到达你的眼睛，所以你所看到的月亮事实上是1.28秒之前的月亮。</p><blockquote><p>你承诺过的月亮<br>还是没有出现<br>而我无眠，或者<br>我只是衣单天寒地<br>替你多爱了一夜人间</p></blockquote><p>可是，我等的月亮，还，没有出现。</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最冷一天</title>
      <link href="/posts/61379.html"/>
      <url>/posts/61379.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://music.163.com/#/song?id=187786">最冷一天</a></p><p>我想有一只小猫<br>最冷的时候<br>我把她抱在怀里取暖</p><p>每一个早晨<br>或明晰或晦暗的早晨<br>我还没睁开眼睛，就<br>睡意朦胧地伸出手臂<br>揽过睡在我右侧柔软的猫</p><p>我用力地抱着她，抱紧她<br>我心里有个声音：我什么也不要了<br>我再不要什么了<br>这荒唐的人间你们去爱吧<br>我好好儿爱她</p><p>我总要吻过她才有饱满的气力去做一天的事<br>她还睡着，她总要轻声哼一句<br>我的心简直要化了</p><p>我回家照例是要带她最爱吃的和<br>一支玫瑰花<br>夏天的话还要为她挑一件碎花裙<br>今生种花，来世漂亮<br>她无论何时都可以说得上是漂亮非常了</p><p>另外呢，春天我送她春风<br>夏天给她撑阳伞，秋天为她扫落叶<br>冬天，就给她下一场隆隆的大雪<br>风花雪月的故事里，她是我的<br>那一轮月亮，永恒的<br>月亮</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一朵百合</title>
      <link href="/posts/40789.html"/>
      <url>/posts/40789.html</url>
      
        <content type="html"><![CDATA[<p>一朵清澈的百合<br>生长在右侧隔着的银河</p><p>二十一日风来了<br>她在月光下睡着</p><p>听清她湿润的呓语<br>带我去另一个时空造爱飞行</p><p>扶风上升的她<br>撞进我比尘轻<br>比蚁微渺的生命</p><p>她一开口<br>人间就是了</p><p>滞空温柔的间隙<br>加速度停顿认真感应</p><p>她发出一声叹息<br>太古里的叹息</p><p>今夜四海八荒宁静下来<br>第二天纷纷飘下我纷纷的情欲</p><p>一朵清澈的百合<br>生长在清丽的风尘里</p><p>四月里醒来<br>一双眼睛装下一个生平</p><p>她没有说话<br>没有回答</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>想来情应尽矣</title>
      <link href="/posts/29308.html"/>
      <url>/posts/29308.html</url>
      
        <content type="html"><![CDATA[<p>2018-04-12<br>忆秦娥<br>&emsp;&emsp;清明诀，清明冰雨彻长夜。彻长夜，从此无心，任它明月。<br>&emsp;&emsp;泰安驿里东风冽，大梦归断重城阙。重城阙，前尘隔海，青山阔别。</p><p>2016-11-26<br>金缕曲<br>&emsp;&emsp;料应情尽矣。万般景、象天法地，都不如意。疑慢贪嗔痴折煞，解语参差是命。xxx、xxxx。欺山赶海践雪径，已枉然、此恨无人记。都付与，短长句。<br>&emsp;&emsp;心知此后来无计。便结了、缘浅路陌，从前知己。xxxxxxx，xxxxxx。xxx、xxxx。xxxxxxx，xxx、xxxxx。是问情，怎生起。</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我想在你的怀中失去记忆</title>
      <link href="/posts/7847.html"/>
      <url>/posts/7847.html</url>
      
        <content type="html"><![CDATA[<p>我想在你的怀中失去记忆<br>做个好梦然后留在这里/<br>你看见死掉的罗曼蒂克<br>我告诉你 那已经过去了<br>都是过去了/<br>十二月走后鸟就来了<br>来年可期<br>往事 无需问</p><p>如果明天你将我叫醒<br>我便知晓你是中意我的/<br>活进你的日子里<br>夜晚与清晨就明晰起来<br>睡梦竟变得可爱/<br>梦 是我做的<br>白鸟是你化成的</p><p>我在什么时辰唤你名字<br>你醒来就来临/<br>于是你站在高高的枝头上<br>容我看着你 远远地<br>看着你<br>一如十年后看着你 远远地/<br>等着<br>等着我 唤你名字</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你</title>
      <link href="/posts/7985.html"/>
      <url>/posts/7985.html</url>
      
        <content type="html"><![CDATA[<p>你这样你<br>入眼是你<br>囿于灵魂<br>又困于命理</p><p>你这样你<br>遗憾是你<br>一纸荒唐<br>换一个姓名</p><p>你这样你<br>你多迷离<br>游于想象<br>又脱于实际</p><p>你这样你<br>你太彻底<br>成为好梦<br>没成为具体</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
