<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MyBatis</title>
      <link href="/2022/10/27/MyBatis/"/>
      <url>/2022/10/27/MyBatis/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h2><h3 id="执行模式与执行器"><a href="#执行模式与执行器" class="headerlink" title="执行模式与执行器"></a>执行模式与执行器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExecutorType</span> </span>&#123;</span><br><span class="line">    SIMPLE,</span><br><span class="line">    REUSE,</span><br><span class="line">    BATCH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h4><h4 id="ReuseExecutor"><a href="#ReuseExecutor" class="headerlink" title="ReuseExecutor"></a>ReuseExecutor</h4><h4 id="BatchExecutor"><a href="#BatchExecutor" class="headerlink" title="BatchExecutor"></a>BatchExecutor</h4><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>批处理执行模式 <code>ExecutorType.BATCH</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认批处理长度 1000</span></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_BATCH_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.saveBatch(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.saveOrUpdateBatch(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.updateBatchById(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">        String sqlStatement = <span class="keyword">this</span>.getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            sqlSession.insert(sqlStatement, entity);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">        TableInfo tableInfo = TableInfoHelper.getTableInfo(<span class="keyword">this</span>.entityClass);</span><br><span class="line">        Assert.notNull(tableInfo, <span class="string">&quot;error: can not execute. because can not find cache of TableInfo for entity!&quot;</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        String keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">        Assert.notEmpty(keyProperty, <span class="string">&quot;error: can not execute. because can not find column for id from entity!&quot;</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.saveOrUpdateBatch(<span class="keyword">this</span>.entityClass, <span class="keyword">this</span>.mapperClass, <span class="keyword">this</span>.log, entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            Object idVal = ReflectionKit.getFieldValue(entity, keyProperty);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.checkValNull(idVal) || CollectionUtils.isEmpty(sqlSession.selectList(<span class="keyword">this</span>.getSqlStatement(SqlMethod.SELECT_BY_ID), entity));</span><br><span class="line">        &#125;, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            ParamMap&lt;T&gt; param = <span class="keyword">new</span> ParamMap();</span><br><span class="line">            param.put(<span class="string">&quot;et&quot;</span>, entity);</span><br><span class="line">            sqlSession.update(<span class="keyword">this</span>.getSqlStatement(SqlMethod.UPDATE_BY_ID), param);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">        String sqlStatement = <span class="keyword">this</span>.getSqlStatement(SqlMethod.UPDATE_BY_ID);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            ParamMap&lt;T&gt; param = <span class="keyword">new</span> ParamMap();</span><br><span class="line">            param.put(<span class="string">&quot;et&quot;</span>, entity);</span><br><span class="line">            sqlSession.update(sqlStatement, param);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Consumer&lt;SqlSession&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.executeBatch(<span class="keyword">this</span>.entityClass, <span class="keyword">this</span>.log, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Collection&lt;E&gt; list, <span class="keyword">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.executeBatch(<span class="keyword">this</span>.entityClass, <span class="keyword">this</span>.log, list, batchSize, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Collection&lt;E&gt; list, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.executeBatch(list, <span class="number">1000</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Consumer&lt;SqlSession&gt; consumer)</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactory(entityClass);</span><br><span class="line">        SqlSessionHolder sqlSessionHolder = (SqlSessionHolder)TransactionSynchronizationManager.getResource(sqlSessionFactory);</span><br><span class="line">        <span class="keyword">boolean</span> transaction = TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line">        SqlSession sqlSession;</span><br><span class="line">        <span class="keyword">if</span> (sqlSessionHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sqlSession = sqlSessionHolder.getSqlSession();</span><br><span class="line">            sqlSession.commit(!transaction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ExecutorType.BATCH</span></span><br><span class="line">        sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line">        <span class="keyword">if</span> (!transaction) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;SqlSession [&quot;</span> + sqlSession + <span class="string">&quot;] was not registered for synchronization because DataSource is not transactional&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> var7;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer.accept(sqlSession);</span><br><span class="line">            sqlSession.commit(!transaction);</span><br><span class="line">            var7 = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var13) &#123;</span><br><span class="line">            sqlSession.rollback();</span><br><span class="line">            Throwable unwrapped = ExceptionUtil.unwrapThrowable(var13);</span><br><span class="line">            <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                MyBatisExceptionTranslator myBatisExceptionTranslator = <span class="keyword">new</span> MyBatisExceptionTranslator(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> (DataAccessException)Objects.requireNonNull(myBatisExceptionTranslator.translateExceptionIfPossible((RuntimeException)unwrapped));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtils.mpe(unwrapped);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="keyword">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, (sqlSession) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Iterator var6 = list.iterator(); var6.hasNext(); ++i) &#123;</span><br><span class="line">                E element = var6.next();</span><br><span class="line">                consumer.accept(sqlSession, element);</span><br><span class="line">                <span class="keyword">if</span> (i % batchSize == <span class="number">0</span> || i == size) &#123;</span><br><span class="line">                    sqlSession.flushStatements();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-主题maupassant目录优化解决方案</title>
      <link href="/2022/09/29/hexo-%E4%B8%BB%E9%A2%98maupassant%E7%9B%AE%E5%BD%95%E4%BC%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/09/29/hexo-%E4%B8%BB%E9%A2%98maupassant%E7%9B%AE%E5%BD%95%E4%BC%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><ul><li>文章内容过多之后，查阅不方便</li><li><code>maupassant</code>主题默认的目录显示在正文</li></ul><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>以下方法来自于 <a href="https://wiki.hushhw.cn/posts/5dd904ed.html">https://wiki.hushhw.cn/posts/5dd904ed.html</a></p><h3 id="1、-config-yml"><a href="#1、-config-yml" class="headerlink" title="1、_config.yml"></a>1、_config.yml</h3><p>在主题配置文件_config.yml中添加侧栏toc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">widgets: </span><br><span class="line">  - toc</span><br><span class="line">  - info</span><br><span class="line">  - search</span><br><span class="line">  - category</span><br><span class="line">  - tag</span><br><span class="line">  - recent_posts</span><br><span class="line">  - recent_comments</span><br><span class="line">  - links</span><br></pre></td></tr></table></figure><h3 id="2、base-pug"><a href="#2、base-pug" class="headerlink" title="2、base.pug"></a>2、base.pug</h3><p><code>themes/maupassant/layout/base.pug</code><br>mac注意tab间隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#layout.pure-g</span><br><span class="line">  .pure-u-1.pure-u-md-3-4: .content_container</span><br><span class="line">    block content</span><br><span class="line">  if page.toc != true</span><br><span class="line">    .pure-u-1.pure-u-md-1-4: #sidebar</span><br><span class="line">      each item in theme.widgets</span><br><span class="line">        != partial(&#x27;_widget/&#x27; + item + &#x27;.pug&#x27;, null, &#123;cache: !config.relative_link&#125;)</span><br><span class="line">  else</span><br><span class="line">    //- if theme.toc_on_small_screens</span><br><span class="line">    if theme.widgets_on_small_screens</span><br><span class="line">      .pure-u-1.pure-u-md-1-4: #sidebar-toc</span><br><span class="line">        div(id=&quot;sidebar-stoc&quot; class=&quot;stoc-article&quot;)</span><br><span class="line">          strong(class=&quot;stoc-title&quot;)</span><br><span class="line">            i(class=&#x27;fa&#x27;)= &#x27; Contents &#x27;</span><br><span class="line">          div(id=&quot;stoc&quot; class=&#x27;toc-nav&#x27;)</span><br><span class="line">            != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br><span class="line">          script(type=&#x27;text/javascript&#x27;, src=url_for(theme.js) + &#x27;/toc.js&#x27; + &#x27;?v=&#x27; + theme.version)</span><br><span class="line">    else </span><br><span class="line">      .pure-u-1-4.hidden_mid_and_down: #sidebar-toc</span><br><span class="line">        div(id=&quot;sidebar-stoc&quot; class=&quot;stoc-article&quot;)</span><br><span class="line">          strong(class=&quot;stoc-title&quot;)</span><br><span class="line">            i(class=&#x27;fa&#x27;)= &#x27; Contents &#x27;</span><br><span class="line">          div(id=&quot;stoc&quot; class=&#x27;toc-nav&#x27;)</span><br><span class="line">            != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br><span class="line">          script(type=&#x27;text/javascript&#x27;, src=url_for(theme.js) + &#x27;/toc.js&#x27; + &#x27;?v=&#x27; + theme.version)</span><br><span class="line">  .pure-u-1.pure-u-md-3-4</span><br><span class="line">    != partial(&#x27;_partial/footer.pug&#x27;)</span><br></pre></td></tr></table></figure><h3 id="3、toc-js"><a href="#3、toc-js" class="headerlink" title="3、toc.js"></a>3、toc.js</h3><p><code>themes/maupassant/source/js/toc.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toc = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;sidebar-stoc&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> HEADER_OFFSET = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">var</span> toclink = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;toc-link&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> headerlink = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;headerlink&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (toc != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, scrollcatelogHandler);</span><br><span class="line"><span class="keyword">var</span> tocPosition = toc.offsetTop;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollcatelogHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event,</span><br><span class="line">     target = event.target || event.srcElement;</span><br><span class="line"> <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line"> <span class="keyword">if</span> (scrollTop &gt;  tocPosition -<span class="number">60</span>) &#123;</span><br><span class="line">     toc.classList.add(<span class="string">&quot;stoc-fixed&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     toc.classList.remove(<span class="string">&quot;stoc-fixed&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;toclink.length; i++)&#123;</span><br><span class="line"><span class="comment">//console.log(i);</span></span><br><span class="line"><span class="keyword">var</span> currentHeaderTop = headerlink[i].offsetTop - HEADER_OFFSET,</span><br><span class="line">nextHeaderTop = i+<span class="number">1</span> === toclink.length ? <span class="literal">Infinity</span> : headerlink[i+<span class="number">1</span>].offsetTop - HEADER_OFFSET;</span><br><span class="line"><span class="keyword">if</span>(currentHeaderTop &lt; scrollTop &amp;&amp; scrollTop &lt;= nextHeaderTop)&#123;</span><br><span class="line">toclink[i].classList.add(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">toclink[i].classList.remove(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、style-scss"><a href="#4、style-scss" class="headerlink" title="4、style.scss"></a>4、style.scss</h3><p><code>themes/maupassant/source/css/style.scss</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// toc start</span><br><span class="line"><span class="selector-id">#sidebar-toc</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-article</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">1em</span> <span class="number">0</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="built_in">rgba</span>(<span class="number">88</span>,<span class="number">88</span>,<span class="number">88</span>,<span class="number">0.1</span>) <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-title</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">150%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar-stoc</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: inherit;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.9em</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-fixed</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">81%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.toc-nav</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.7em</span> <span class="number">0.7em</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#stoc</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="selector-class">.active</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#0085a1</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#F5F5F5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.toc</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0.5em</span>;</span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">1.8em</span>;</span><br><span class="line">      <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">list-style-type</span>: none;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.toc-child</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// toc end</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-从ReentrantLock的实现看AQS的原理及应用</title>
      <link href="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/main.png"></p><p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。<br>AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="ReentrantLock特性概览"><a href="#ReentrantLock特性概览" class="headerlink" title="ReentrantLock特性概览"></a>ReentrantLock特性概览</h3><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。<br><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E5%AF%B9%E6%AF%94.png" alt="ReentrantLock VS Synchronized"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **************************Synchronized的使用方式**************************</span></span><br><span class="line"><span class="comment">// 1.用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 2.用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="comment">// 3.用于方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 4.可重入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **************************ReentrantLock的使用方式**************************</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> throw Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1.初始化选择公平锁、非公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 2.可用于代码块</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span></span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.手动释放锁</span></span><br><span class="line">lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock与AQS的关联"><a href="#ReentrantLock与AQS的关联" class="headerlink" title="ReentrantLock与AQS的关联"></a>ReentrantLock与AQS的关联</h3><p>ReentrantLock支持公平锁和非公平锁，并且ReentrantLock的底层就是由AQS来实现的。<br>那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 从这两者的加锁过程来理解一下它们与AQS之间的关系。</p><h4 id="非公平锁加锁"><a href="#非公平锁加锁" class="headerlink" title="非公平锁加锁"></a>非公平锁加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#NonfairSync</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码的含义为：</p><ol><li>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</li><li>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</li></ol><p>第二步获取锁失败后，后续的处理策略是怎么样的？</p><ul><li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：<ol><li>将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</li><li>存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</li></ol></li><li>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</li><li>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</li><li>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</li></ul><h4 id="公平锁加锁"><a href="#公平锁加锁" class="headerlink" title="公平锁加锁"></a>公平锁加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#FairSync</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  ...  </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p><p>对于上边提到的问题，其实在ReentrantLock源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。<br>下面对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p><img src="/2022/09/29/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/AQS.png"></p><ul><li>上图中有颜色的为Method，无颜色的为Attribution。</li><li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li><li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-asset-image</title>
      <link href="/2022/09/28/hexo-asset-image/"/>
      <url>/2022/09/28/hexo-asset-image/</url>
      
        <content type="html"><![CDATA[<ol><li>/node_modules/hexo-asset-image/index.js</li><li><code>post_asset_folder: true</code></li><li><code>![](/example.jpg)</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">      <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">  <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">     <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">  <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">      <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">      <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">         !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">        <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">        <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">        <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">        srcArray.shift();</span><br><span class="line">        src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-锁</title>
      <link href="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/"/>
      <url>/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/main.png"></p><h2 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p><p>对于同一个数据的并发操作，<code>悲观锁</code>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p><code>乐观锁</code>认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。<br>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/%E4%B9%90%E8%A7%82%E9%94%81vs%E6%82%B2%E8%A7%82%E9%94%81.png"></p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized 同步关键字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock 加锁</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。<br>那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？</p><h3 id="CAS技术原理"><a href="#CAS技术原理" class="headerlink" title="CAS技术原理"></a>CAS技术原理</h3><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。<br>java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁。</p><h4 id="AtomicInteger的源码"><a href="#AtomicInteger的源码" class="headerlink" title="AtomicInteger的源码"></a>AtomicInteger的源码</h4><p>jdk11</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This class intended to be implemented using VarHandles, but there</span></span><br><span class="line"><span class="comment">     * are unresolved cyclic startup dependencies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><p>AtomicInteger的自增函数incrementAndGet() -&gt; unsafe.getAndAddInt()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicInteger的自增函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>根据OpenJDK 8的源码可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><h4 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h4><ol><li><code>ABA问题。</code>CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。<ul><li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li></ul></li><li><code>循环时间长开销大。</code>CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li><code>只能保证一个共享变量的原子操作。</code>对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。<ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul></li></ol><h2 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h2><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。<br>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/%E8%87%AA%E6%97%8B%E9%94%81vs%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81.png"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适应性"><a href="#适应性" class="headerlink" title="适应性"></a>适应性</h4><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock。</p><h2 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。</p><h3 id="为什么Synchronized能实现线程同步？"><a href="#为什么Synchronized能实现线程同步？" class="headerlink" title="为什么Synchronized能实现线程同步？"></a>为什么Synchronized能实现线程同步？</h3><p>在回答这个问题之前需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？<br>以<code>Hotspot虚拟机</code>为例，Hotspot的对象头主要包括两部分数据：<code>Mark Word（标记字段）</code>、<code>Klass Pointer（类型指针）</code>。</p><ul><li><code>Mark Word</code>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</li><li><code>Klass Point</code>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。<br>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为<code>重量级锁</code>。<br>JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了<code>偏向锁</code>和<code>轻量级锁</code>。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><table><thead><tr><th align="left">锁状态</th><th align="center">Mark Word内容</th><th align="right">标志位</th></tr></thead><tbody><tr><td align="left">无锁</td><td align="center">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td align="right">01</td></tr><tr><td align="left">偏向锁</td><td align="center">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td align="right">01</td></tr><tr><td align="left">轻量级锁</td><td align="center">指向栈中锁记录的指针</td><td align="right">00</td></tr><tr><td align="left">重量级锁</td><td align="center">指向互斥量（重量级锁）的指针</td><td align="right">10</td></tr></tbody></table><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。<br>如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p><p>CAS原理及应用即是无锁的实现。<br>无锁无法全面代替有锁，但无锁在某些场合下（读多写少）的性能是非常高的。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。<br>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。<br>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，关闭之后程序默认会进入轻量级锁状态。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>升级为重量级锁时，锁标志的状态值变为<code>10</code>，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><ul><li><code>偏向锁</code>通过对比Mark Word解决加锁问题，避免执行CAS操作。</li><li><code>轻量级锁</code>是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</li><li><code>重量级锁</code>是将除了拥有锁的线程以外的线程都阻塞。</li></ul><h2 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h2><p><code>公平锁</code>是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。<br>公平锁的优点是等待锁的线程不会饿死。<br>缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p><code>非公平锁</code>是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。<br>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。<br>缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>通过ReentrantLock的源码来看看公平锁和非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">     * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">     * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">     * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。<br>它有公平锁FairSync和非公平锁NonfairSync两个子类。<br>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p>公平锁与非公平锁的加锁方法的源码:<br><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%96%B9%E6%B3%95.png" alt="公平锁和非公平锁的加锁方法"></p><p>通过上图中的源代码对比，可以看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">            <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">            <span class="comment">// thread is first in queue.</span></span><br><span class="line">            Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            Node s;</span><br><span class="line">            <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。<br>Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><p>下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。<br>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><h3 id="为什么可重入锁就可以在嵌套调用时可以自动获得锁"><a href="#为什么可重入锁就可以在嵌套调用时可以自动获得锁" class="headerlink" title="为什么可重入锁就可以在嵌套调用时可以自动获得锁"></a>为什么可重入锁就可以在嵌套调用时可以自动获得锁</h3><p><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81vs%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png"></p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。<br>非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。<br>非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><h2 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h2><p>独享锁和共享锁同样是一种概念。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。<br>JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>ReentrantReadWriteLock的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6992448646407690164L</span>;</span><br><span class="line">    <span class="comment">/** Inner class providing readlock */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** Inner class providing writelock */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">/** Performs all synchronization mechanics */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">     * default (nonfair) ordering properties.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">     * the given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructor for use by subclasses.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> lock the outer lock object</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> NullPointerException if the lock is null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructor for use by subclasses.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> lock the outer lock object</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> NullPointerException if the lock is null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。<br>ReadLock和WriteLock是靠内部类Sync实现的锁。<br>Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。<br>读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><h3 id="读锁和写锁的具体加锁方式"><a href="#读锁和写锁的具体加锁方式" class="headerlink" title="读锁和写锁的具体加锁方式"></a>读锁和写锁的具体加锁方式</h3><p>AQS中的<code>waitStatus</code>字段（int类型，32位），该字段用来描述有多少线程获持有锁。<br>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数）。<br>在共享锁中state就是持有锁的数量。<br>但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。<br><img src="/2022/09/28/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/waitStatus.png"></p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line"><span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"><span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock中公平锁和非公平锁添加的都是独享锁"><a href="#ReentrantLock中公平锁和非公平锁添加的都是独享锁" class="headerlink" title="ReentrantLock中公平锁和非公平锁添加的都是独享锁"></a>ReentrantLock中公平锁和非公平锁添加的都是独享锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。<br>所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-Synchronized关键字</title>
      <link href="/2022/09/27/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2022/09/27/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>synchronized中文意思是同步，也称之为”同步锁“。<br>Synchronized关键字解决的是多个线程之间访问资源的同步性<br>synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p><p>synchronized的3种使用方式：</p><ul><li>修饰实例方法：其作用的范围是整个方法，作用的对象是调用这个方法的对象</li><li>修饰静态方法：其作用的范围是整个静态方法，作用的对象是这个类的所有对象</li><li>修饰代码块：其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>JVM 是通过进入、退出<code>对象监视器(Monitor)</code>来实现对方法、同步块的同步的，而对象监视器的本质依赖于底层操作系统的<code>互斥锁(Mutex Lock)</code>实现。</p><p>具体实现是在编译之后在同步方法调用前加入一个<code>monitor.enter</code>指令，在退出方法和异常处插入<code>monitor.exit</code>的指令。<br>对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程<code>monitor.exit</code>之后才能尝试继续获取锁。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码-ConcurrentHashMap</title>
      <link href="/2022/09/21/Java%E6%BA%90%E7%A0%81-ConcurrentHashMap/"/>
      <url>/2022/09/21/Java%E6%BA%90%E7%A0%81-ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-线程池在业务中的实践</title>
      <link href="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。<br>通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。</p><h3 id="场景1：快速响应用户请求"><a href="#场景1：快速响应用户请求" class="headerlink" title="场景1：快速响应用户请求"></a>场景1：快速响应用户请求</h3><p><strong>描述：</strong>用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p><p><strong>分析：</strong>从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p><p><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/%E5%BF%AB%E9%80%9F%E5%93%8D%E5%BA%94%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82.png"></p><h3 id="场景2：快速处理批量任务"><a href="#场景2：快速处理批量任务" class="headerlink" title="场景2：快速处理批量任务"></a>场景2：快速处理批量任务</h3><p><strong>描述：</strong>离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p><p><strong>分析：</strong>这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p><p><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E6%89%B9%E9%87%8F%E4%BB%BB%E5%8A%A1.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-线程池ThreadPoolExecutor</title>
      <link href="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。</p><h2 id="关于线程池"><a href="#关于线程池" class="headerlink" title="关于线程池"></a>关于线程池</h2><h3 id="1-1-线程池是什么"><a href="#1-1-线程池是什么" class="headerlink" title="1.1 线程池是什么"></a>1.1 线程池是什么</h3><p>线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具。</p><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p><p>线程过多会带来额外的开销，其中包括创建/销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。</p><p>线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建/销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><p>使用线程池可以带来一系列的好处：</p><ul><li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>可拓展性</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><h3 id="1-2-线程池解决的问题是什么"><a href="#1-2-线程池解决的问题是什么" class="headerlink" title="1.2 线程池解决的问题是什么"></a>1.2 线程池解决的问题是什么</h3><p>线程池解决的核心问题是资源管理问题。</p><p>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li></ol><p>为解决资源分配这个问题，线程池采用了<code>池化（Pooling）</code>思想。池化，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p><p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。<br>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p><ul><li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li><li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li></ul><h2 id="线程池核心设计与实现"><a href="#线程池核心设计与实现" class="headerlink" title="线程池核心设计与实现"></a>线程池核心设计与实现</h2><p>在Java中的体现是<code>ThreadPoolExecutor</code>类。</p><h3 id="2-1-总体设计"><a href="#2-1-总体设计" class="headerlink" title="2.1 总体设计"></a>2.1 总体设计</h3><p>Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-UML.png" alt="ThreadPoolExecutor UML类图"></p><p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。</p><p>ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</p><p>AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</p><p>最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p><p>ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-process.png" alt="ThreadPoolExecutor运行流程"></p><p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。<br>线程池的运行主要分成两部分：任务管理、线程管理。<br>任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。<br>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p><p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p><ol><li>线程池如何维护自身状态。</li><li>线程池如何管理任务。</li><li>线程池如何管理线程。</li></ol><h3 id="2-2-生命周期管理"><a href="#2-2-生命周期管理" class="headerlink" title="2.2 生命周期管理"></a>2.2 生命周期管理</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态（runState）和线程数量（workerCount）。<br>在具体实现中，线程池将运行状态（runState）和线程数量（workerCount）两个关键参数的维护放在了一起，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p><p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">//计算当前运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;  <span class="comment">//计算当前线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;   <span class="comment">//通过状态和线程数生成ctl</span></span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的运行状态有5种，分别为：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-runState.png" alt="ThreadPoolExecutor运行状态"></p><p>其生命周期转换如下入所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-lifecycle.png" alt="线程池生命周期"></p><h3 id="2-3-任务执行机制"><a href="#2-3-任务执行机制" class="headerlink" title="2.3 任务执行机制"></a>2.3 任务执行机制</h3><h4 id="2-3-1-任务调度-分配"><a href="#2-3-1-任务调度-分配" class="headerlink" title="2.3.1 任务调度/分配"></a>2.3.1 任务调度/分配</h4><p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p><p>所有任务的调度都是由<code>execute</code>方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。<br>其执行过程如下：</p><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6.png" alt="任务调度流程"></p><h4 id="2-3-2-任务缓冲"><a href="#2-3-2-任务缓冲" class="headerlink" title="2.3.2 任务缓冲"></a>2.3.2 任务缓冲</h4><p>任务缓冲模块是线程池能够管理任务的核心部分。<br>线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解藕，不让两者直接关联，才可以做后续的分配工作。<br>线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。<br>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-blockingQueue.png" alt="阻塞队列"></p><p>使用不同的队列可以实现不一样的任务存取策略。<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-bqType.png" alt="阻塞队列类型"></p><h4 id="2-3-3-任务申请"><a href="#2-3-3-任务申请" class="headerlink" title="2.3.3 任务申请"></a>2.3.3 任务申请</h4><p>由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p><p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-task.png"></p><p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-4-任务拒绝"><a href="#2-3-4-任务拒绝" class="headerlink" title="2.3.4 任务拒绝"></a>2.3.4 任务拒绝</h4><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p><p>拒绝策略是一个接口，其设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-reject.png"></p><h3 id="2-4-Worker线程管理"><a href="#2-4-Worker线程管理" class="headerlink" title="2.4 Worker线程管理"></a>2.4 Worker线程管理</h3><h4 id="2-4-1-Worker线程"><a href="#2-4-1-Worker线程" class="headerlink" title="2.4.1 Worker线程"></a>2.4.1 Worker线程</h4><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line">    Runnable firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p><p>Worker执行任务的模型如下图所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-worker.png"></p><p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p><p>Worker是通过继承<code>AQS</code>，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p><ol><li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 </li><li>如果正在执行任务，则不应该中断线程。 </li><li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 </li><li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</li></ol><p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-%E5%9B%9E%E6%94%B6.png"></p><h4 id="2-4-2-Worker线程增加"><a href="#2-4-2-Worker线程增加" class="headerlink" title="2.4.2 Worker线程增加"></a>2.4.2 Worker线程增加</h4><p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。</p><p>addWorker方法有两个参数：firstTask、core。<code>firstTask</code>参数用于指定新增的线程执行的第一个任务，该参数可以为空；<code>core</code>参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize。其执行流程如下图所示：<br><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-addWorker.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = ctl.get();;) &#123;</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="keyword">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.getState() != Thread.State.NEW)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-Worker线程回收"><a href="#2-4-3-Worker线程回收" class="headerlink" title="2.4.3 Worker线程回收"></a>2.4.3 Worker线程回收</h4><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。<br>Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p><p>线程回收的工作是在<code>processWorkerExit</code>方法完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p><h4 id="2-4-4-Worker线程执行任务"><a href="#2-4-4-Worker线程执行任务" class="headerlink" title="2.4.4 Worker线程执行任务"></a>2.4.4 Worker线程执行任务</h4><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p><ol><li>while循环不断地通过getTask()方法获取任务。 </li><li>getTask()方法从阻塞队列中取任务。 </li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 </li><li>执行任务。 </li><li>如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</li></ol><p><img src="/2022/09/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor-runWorker.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                    afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly); <span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实际开发中遇到的问题</title>
      <link href="/2022/09/05/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/05/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="研发效能"><a href="#研发效能" class="headerlink" title="研发效能"></a>研发效能</h2><h3 id="Excel导入导出获取实时进度"><a href="#Excel导入导出获取实时进度" class="headerlink" title="Excel导入导出获取实时进度"></a>Excel导入导出获取实时进度</h3><p>背景：数据量大的excel导入，并且有较多数据校验，后台处理耗时长，体验差，需要实时展示当前导入的进度，提高使用体验。</p><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><ol><li>websocket实现长连接</li><li>短轮询</li></ol><h4 id="Mybatis在MySQL下的批处理效率"><a href="#Mybatis在MySQL下的批处理效率" class="headerlink" title="Mybatis在MySQL下的批处理效率"></a>Mybatis在MySQL下的批处理效率</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rewriteBatchedStatements=<span class="keyword">true</span> <span class="comment">//批量将数据传给mysql</span></span><br><span class="line">allowMultiQueries=<span class="keyword">true</span> <span class="comment">//允许一次性执行多条sql</span></span><br></pre></td></tr></table></figure><p>MySQL Jdbc驱动在默认情况下会无视executeBatch()语句，把我们期望批量执行的一组sql语句拆散，一条一条地发给MySQL数据库，直接造成较低的性能。<br>MySQL的JDBC连接的url中要加<code>rewriteBatchedStatements</code>参数，并保证<code>5.1.13</code>以上版本的驱动，才能实现高性能的批量插入。</p><h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><h3 id="平台部门开放给各组织、部门的数据安全性、隔离性"><a href="#平台部门开放给各组织、部门的数据安全性、隔离性" class="headerlink" title="平台部门开放给各组织、部门的数据安全性、隔离性"></a>平台部门开放给各组织、部门的数据安全性、隔离性</h3><h3 id="HDS、Hwork微前端嵌入"><a href="#HDS、Hwork微前端嵌入" class="headerlink" title="HDS、Hwork微前端嵌入"></a>HDS、Hwork微前端嵌入</h3><p>背景：Hwork要嵌入HDS中的业务需求模块，两个前端项目都是微前端-乾坤结构。</p><p>所遇问题如下：</p><ol><li>HDS打通IDM统一登录，但内部生成自己特殊的token；Hwork也打通IDM统一登录，将IDM token放在Session Storage中，并生成自己的token，放在Local Storage中。两个产品之间token不互通。</li><li>Hwork后端接口以<code>/gw/hwork</code>开发，由前端nginx统一转发到Hwork的网关服务再分发到相应的后端服务。HDS后端接口以<code>/api/v1</code>、<code>/api/v2</code>等开头，走HDS统一的网关。</li></ol><p>解决方式如下：</p><ol><li>web和应用前端以乾坤方式嵌入hwork</li><li>hwork提供标识区分前端环境是web端或应用端</li><li>hds需求平台判断hwork标识，前端没有token或者请求后端接口返回40001，跳转IAM换取token，IAM换取token后重定向到hds，hds二次重定向到hwork</li><li>hds需求平台前端判断是在Hwork环境，统一处理后端请求路径，增加/gw/hds/前缀</li><li>hwork网关对/gw/hds/前缀请求进行统一处理，转发到hds后端服务</li></ol><h3 id="任务协同项目下code绝对自增"><a href="#任务协同项目下code绝对自增" class="headerlink" title="任务协同项目下code绝对自增"></a>任务协同项目下code绝对自增</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">insert into job_issue_project(issue_id, project_id, created_at, creator, updated_at, code)</span><br><span class="line">VALUES</span><br><span class="line">&lt;foreach collection=&quot;issueIds&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">    (#&#123;item&#125;,</span><br><span class="line">    #&#123;project&#125;,</span><br><span class="line">    #&#123;now&#125;,</span><br><span class="line">    #&#123;creator&#125;,</span><br><span class="line">    #&#123;now&#125;,</span><br><span class="line">    (select ntest.mcode from (SELECT case when max(`code`) is null</span><br><span class="line">    then 1 else max(`code`)+1 end mcode from job_issue_project where project_id=#&#123;project&#125;) ntest)</span><br><span class="line">    )</span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure><p>该子查询实现project下code自增，max(code)会锁住project条件下的行记录，并发时会有死锁问题。</p><p>理想情况下应该依赖于<code>发号平台</code>来获取服务内所需要的编码。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作问题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2022/08/31/SpringBoot/"/>
      <url>/2022/08/31/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot应用中Tomcat建议配置"><a href="#SpringBoot应用中Tomcat建议配置" class="headerlink" title="SpringBoot应用中Tomcat建议配置"></a>SpringBoot应用中Tomcat建议配置</h3><p>Spring Boot 能支持的最大并发量主要看其对Tomcat的设置，可以在配置文件中对其进行更改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">最大工作线程数，默认200。</span><br><span class="line">server.tomcat.max-threads=200</span><br><span class="line"> </span><br><span class="line">最大连接数默认是10000</span><br><span class="line">server.tomcat.max-connections=10000</span><br><span class="line"> </span><br><span class="line">等待队列长度，默认100。</span><br><span class="line">server.tomcat.accept-count=100</span><br><span class="line"> </span><br><span class="line">最小工作空闲线程数，默认10。tomcat启动时的初始化的线程数</span><br><span class="line">server.tomcat.min-spare-threads=100</span><br><span class="line"></span><br><span class="line">#请求头最大长度kb</span><br><span class="line">server.tomcat.max-http-header-size: 1048576</span><br><span class="line"></span><br><span class="line">#请请求体最大长度kb</span><br><span class="line">server.tomcat.#max-http-post-size: 2097152</span><br></pre></td></tr></table></figure><p>对应application.yml配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">  tomcat:</span><br><span class="line">    uri-encoding: UTF-8</span><br><span class="line">    max-threads: 800 #最大工作线程数量</span><br><span class="line">    min-spare-threads: 20 #最小工作线程数量</span><br><span class="line">    max-connections: 10000 #一瞬间最大支持的并发的连接数</span><br><span class="line">    accept-count: 200 #等待队列长度</span><br></pre></td></tr></table></figure><ul><li><p>线程数的经验值为：1核2G内存，线程数经验值200；4核8G内存， 线程数经验值800。<br>（4核8G内存单进程调度线程数800-1000，超过这个并发数之后，将会花费巨大的时间在CPU调度上）</p></li><li><p>等待队列长度：队列做缓冲池用，但也不能无限长，消耗内存，出入队列也耗CPU。</p></li><li><p>maxThreads规定的是Tomcat线程池最多能起的线程数目，并不是实际running的CPU数量；实际上，maxThreads的大小比CPU核心数量要大得多。这是因为，处理请求的线程真正用于计算的时间可能很少，大多数时间可能在阻塞，如等待数据库返回数据、等待硬盘读写数据等。因此，在某一时刻，只有少数的线程真正的在使用物理CPU，大多数线程都在等待；因此线程数远大于物理核心数才是合理的。也就是说，Tomcat通过使用比CPU核心数量多得多的线程数，可以使CPU忙碌起来，大大提高CPU的利用率。</p></li><li><p>maxConnections则是Tomcat一瞬间最多能够处理的并发连接数。</p></li><li><p>maxConnections 和acceptCount的关系为:当连接数达到最大值maxConnections后,系统会继续接收连接,进行排队，但不会超过acceptCount的值。</p></li></ul><p>Tomcat最大连接数取决于maxConnections这个值加上acceptCount这个值,在连接数达到了maxConenctions之后,Tomcat仍会保持住连接,但是不处理，等待其它请求处理完毕之后才会处理这个请求。</p><h4 id="针对4C8G配置，可以参考建议值："><a href="#针对4C8G配置，可以参考建议值：" class="headerlink" title="针对4C8G配置，可以参考建议值："></a>针对4C8G配置，可以参考建议值：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tomcat:</span><br><span class="line">accept-count: 1000</span><br><span class="line">max-connections: 10000</span><br><span class="line">max-threads: 800</span><br><span class="line">min-spare-threads: 100</span><br></pre></td></tr></table></figure><h3 id="SpringBoot集成WebSocket"><a href="#SpringBoot集成WebSocket" class="headerlink" title="SpringBoot集成WebSocket"></a>SpringBoot集成WebSocket</h3><ol><li>添加 starter 依赖</li><li>添加 WebSocket 配置：<ul><li>实现接口<code>WebSocketConfigurer</code>，并重写相应方法</li></ul></li><li>添加处理器，作用类似 SpringMVC 的处理器映射：<ul><li>实现接口 <code>WebSocketHandler</code>，并重写相应方法</li></ul></li><li>添加拦截器（可选），可在 websocket 握手阶段做一些处理，例如校验、保存用户信息。<ul><li>实现接口：<code>HandshakeInterceptor</code>，并重写相应方法</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="/2022/08/31/Tomcat/"/>
      <url>/2022/08/31/Tomcat/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——Apache Pulsar</title>
      <link href="/2022/08/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Apache%20Pulsar/"/>
      <url>/2022/08/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Apache%20Pulsar/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——Kafka</title>
      <link href="/2022/08/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/"/>
      <url>/2022/08/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Kafka/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发和多线程-介绍</title>
      <link href="/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h3><ul><li><p>资源利用率更好</p></li><li><p>程序设计在某些情况下更简单</p></li><li><p>程序响应更快</p></li><li><p>设计更复杂</p></li><li><p>上下文切换的开销</p></li><li><p>增加资源消耗</p></li></ul><h3 id="并发编程模型"><a href="#并发编程模型" class="headerlink" title="并发编程模型"></a>并发编程模型</h3><p>并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。</p><p>并发模型与分布式系统之间的相似性？</p><ul><li>并行工作者</li><li>流水线模式</li><li>函数式并行</li></ul><h3 id="如何创建并运行java线程"><a href="#如何创建并运行java线程" class="headerlink" title="如何创建并运行java线程"></a>如何创建并运行java线程</h3><ol><li>创建Thread子类的一个实例并重写run()方法，调用start()方法</li><li>实现Runnable接口并实现run()方法，在Thread类的构造函数中传入实现Runnable接口的类的实例对象</li></ol><h3 id="竞态条件与临界区"><a href="#竞态条件与临界区" class="headerlink" title="竞态条件与临界区"></a>竞态条件与临界区</h3><p>在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源，如，同一内存区（变量，数组，或对象）、系统（数据库，web service等）。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化，多个线程读取相同的资源就是安全的。</p><ul><li>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件</li><li>导致竞态条件发生的代码区称作临界区</li></ul><p>在临界区中使用适当的同步可以避免竞态条件。</p><h3 id="线程安全与共享资源"><a href="#线程安全与共享资源" class="headerlink" title="线程安全与共享资源"></a>线程安全与共享资源</h3><p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。</p><ul><li>局部变量</li><li>局部的对象引用</li><li>对象成员</li></ul><h4 id="线程控制逃逸规则"><a href="#线程控制逃逸规则" class="headerlink" title="线程控制逃逸规则"></a>线程控制逃逸规则</h4><p>如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</p><h3 id="线程安全及不可变性"><a href="#线程安全及不可变性" class="headerlink" title="线程安全及不可变性"></a>线程安全及不可变性</h3><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型，即Java内存模型。</p><p>Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p><p>原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中使用。</p><h4 id="Java内存模型和硬件内存架构之间的桥接"><a href="#Java内存模型和硬件内存架构之间的桥接" class="headerlink" title="Java内存模型和硬件内存架构之间的桥接"></a>Java内存模型和硬件内存架构之间的桥接</h4><p>所有的线程栈和堆都分布在主存中，部分线程栈和堆可能有时候会出现在CPU缓存和CPU内部的寄存器中。<br><img src="/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/java-memory-model-5.png"></p><p>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题，主要包括如下两个方面：</p><ul><li>线程对共享变量修改的可见性</li><li>当读/写和检查共享变量时出现<code>race condition 竞态条件</code></li></ul><h4 id="共享对象可见性"><a href="#共享对象可见性" class="headerlink" title="共享对象可见性"></a>共享对象可见性</h4><p>如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不可见的。</p><p>想象一下，共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。</p><p><img src="/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/java-memory-model-6.png"></p><p>解决这个问题你可以使用Java中的volatile关键字。volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。</p><h4 id="race-condition"><a href="#race-condition" class="headerlink" title="race condition"></a>race condition</h4><p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p><p>想象一下，如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次。</p><p>如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。</p><p>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。<br><img src="/2022/08/19/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D/java-memory-model-7.png"></p><p>解决这个问题可以使用Java同步块。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p><h3 id="Java同步块"><a href="#Java同步块" class="headerlink" title="Java同步块"></a>Java同步块</h3><p>Java 同步块（synchronized block）用来标记方法或者代码块是同步的。Java同步块用来避免竞争。</p><ul><li>Java同步关键字（synchronized）</li><li>实例方法同步</li><li>静态方法同步</li><li>实例方法中同步块</li><li>静态方法中同步块</li></ul><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h3 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h3><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h3 id="非阻塞算法-vs-阻塞算法"><a href="#非阻塞算法-vs-阻塞算法" class="headerlink" title="非阻塞算法 vs 阻塞算法"></a>非阻塞算法 vs 阻塞算法</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发和多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDE插件开发-VS Code</title>
      <link href="/2022/08/05/IDE%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-vscode/"/>
      <url>/2022/08/05/IDE%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-vscode/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDE插件开发-IntelliJ平台</title>
      <link href="/2022/08/05/IDE%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-IntelliJ%E5%B9%B3%E5%8F%B0/"/>
      <url>/2022/08/05/IDE%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-IntelliJ%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h2><h2 id="plugin-xml"><a href="#plugin-xml" class="headerlink" title="plugin.xml"></a>plugin.xml</h2><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><h2 id="applicationService"><a href="#applicationService" class="headerlink" title="applicationService"></a>applicationService</h2><h2 id="applicationConfigurable"><a href="#applicationConfigurable" class="headerlink" title="applicationConfigurable"></a>applicationConfigurable</h2><h2 id="toolWindow"><a href="#toolWindow" class="headerlink" title="toolWindow"></a>toolWindow</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码-Object</title>
      <link href="/2022/06/29/Java%E6%BA%90%E7%A0%81-Object/"/>
      <url>/2022/06/29/Java%E6%BA%90%E7%A0%81-Object/</url>
      
        <content type="html"><![CDATA[<p>Object类是一切类的超类，在类继承的树形结构上，Object是所有类的根节点。所有的对象，包括数据，都继承了Object类的方法。</p><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives"></a>registerNatives</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol><li>hashCode 表示对象在 hash 表中的位置，对于同一个对象来说，多次调用，返回相同的 hashCode。</li><li>如果 Object.equal () 相等，Object.hashCode () 也必然相等。重写时也建议保证此特性。</li><li>如果 Object.equal () 相等，这并不要求 Object.hashCode () 也返回不同值。如果真出现这种情况，最好优化代码，充分利用 hash 表的性能。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">intptr_t</span> <span class="title">get_next_hash</span><span class="params">(Thread * Self, oop obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> value = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">     <span class="comment">// so it&#x27;s possible for two threads to race and generate the same RNG.</span></span><br><span class="line">     <span class="comment">// On MP system we&#x27;ll have lots of RW access to a global, so the</span></span><br><span class="line">     <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">     value = os::<span class="built_in">random</span>() ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">     <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">     <span class="comment">// synchronization schemes.</span></span><br><span class="line">     <span class="keyword">intptr_t</span> addrBits = <span class="built_in">intptr_t</span>(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">     value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">     value = <span class="number">1</span> ;            <span class="comment">// for sensitivity testing</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">     value = ++GVars.hcSequence ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">     value = <span class="built_in">intptr_t</span>(obj) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Marsaglia&#x27;s xor-shift scheme with thread-specific state</span></span><br><span class="line">     <span class="comment">// This is probably the best overall implementation -- we&#x27;ll</span></span><br><span class="line">     <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">     <span class="keyword">unsigned</span> t = Self-&gt;_hashStateX ;</span><br><span class="line">     t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">     <span class="keyword">unsigned</span> v = Self-&gt;_hashStateW ;</span><br><span class="line">     v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">     Self-&gt;_hashStateW = v ;</span><br><span class="line">     value = v ;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  value &amp;= markOopDesc::hash_mask;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="number">0</span>) value = <span class="number">0xBAD</span> ;</span><br><span class="line">  <span class="built_in">assert</span> (value != markOopDesc::no_hash, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">TEVENT</span> (hashCode: GENERATE) ;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中的 hashCode 其实就是 JVM 启动的一个参数，每一个分支对应一个生成策略。通过 -XX:hashCode，可以任意切换 hashCode 的生成策略。</p><p>首先解释一下入参 oop obj 就是对象的逻辑地址。所以与地址相关的生成策略有两条，在 hashCode 等于 1 或 4 的时候。</p><ul><li>hashCode==1：这种方式具有幂等的性质，在 STW（stop-the-world）操作中，这种策略通常用于同步方案中。利用对象地址计算，使用不经常更新的随机数参与运算。</li><li>hashCode==4：与创建对象的内存位置有关，原样输出。</li></ul><p>其他情况：</p><ul><li>hashCode==0：简单地返回随机数，与对象的内存地址没有联系。然而根据随机数生成并全局地读写在多处理器下并不占优势。</li><li>hashCode==2：始终返回完全相同的标识，即 hashCode=1。这可用于测试依赖对象标识的代码。</li><li>hashcode==3：从零开始计算哈希代码值。它看起来不是线程安全的，因此多个线程可以生成具有相同哈希代码的对象。</li><li>hashCode&gt;=5（默认）：在 jdk1.8 中，这是默认的 hashCode 生成算法，支持多线程生成。使用了 Marsaglia 的 xor-shift 算法产生伪随机数。</li></ul><h4 id="xor-shift-算法"><a href="#xor-shift-算法" class="headerlink" title="xor-shift 算法"></a>xor-shift 算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint32_t xor128(void) &#123;</span><br><span class="line"> static uint32_t x = 123456789;</span><br><span class="line"> static uint32_t y = 362436069;</span><br><span class="line"> static uint32_t z = 521288629;</span><br><span class="line"> static uint32_t w = 88675123;</span><br><span class="line"> uint32_t t;</span><br><span class="line"> </span><br><span class="line"> t = x ^ (x &lt;&lt;11);</span><br><span class="line"> x = y; y = z; z = w;</span><br><span class="line"> return w = w ^ (w&gt;&gt; 19) ^ (t ^ (t&gt;&gt; 8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String重写hashCode"><a href="#String重写hashCode" class="headerlink" title="String重写hashCode"></a>String重写hashCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相同的字符串调用hashCode()方法，得到的值是一样的，与内存地址、进程、及其无关。</p><p>为什么计算时选择<code>31</code>？</p><ol><li>31 是个奇质数，不大不小，一般质数非常适合 hash 计算，偶数相当于移位运算，容易溢出，数据信息丢失。如果太小，则产生的哈希值区间小；太大则容易溢出，数据信息丢失。</li><li>31 * i == (i &lt;&lt; 5) - i。非常易于维护，将移位代替乘除，会有性能的提升，并且 JVM 执行时能够自动优化成这个样子。</li><li>通过实验计算，选用 31 后出现 hash 冲突的概率相比于其他数字要小。</li></ol><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当重写hashCode方法的时候，通常都需要重写该方法，以便维护hashCode方法的常规约定，该方法申明相等的对象必须具有相同的hashCode。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码-HashMap</title>
      <link href="/2022/06/28/Java%E6%BA%90%E7%A0%81-HashMap/"/>
      <url>/2022/06/28/Java%E6%BA%90%E7%A0%81-HashMap/</url>
      
        <content type="html"><![CDATA[<p>HashMap 1.7及以前，底层数据结构使用 [数组+链表]，1.8 后使用 [数组+链表/红黑树] ，使用数组存储元素是因为查找快，链表是为了解决哈希冲突存在的，而红黑树是为了解决链表中查询速度慢对链表进行优化的一种数据结构。</p><p>HashMap 是非线程安全的，如果需要线程安全，使用 ConcurrentHashMap 或者 Collections.synchronizedMap() 包裹 HashMap 达到线程安全的目的。</p><p><img src="/2022/06/28/Java%E6%BA%90%E7%A0%81-HashMap/java7hashmap.png"><br><img src="/2022/06/28/Java%E6%BA%90%E7%A0%81-HashMap/java8hashmap.png"></p><h3 id="1、HashMap为什么线程不安全"><a href="#1、HashMap为什么线程不安全" class="headerlink" title="1、HashMap为什么线程不安全"></a>1、HashMap为什么线程不安全</h3><h4 id="初始化懒加载"><a href="#初始化懒加载" class="headerlink" title="初始化懒加载"></a>初始化懒加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个HashMap的时候，其实只是定义了initialCapacity和loadFactor这两个值，</span></span><br><span class="line"><span class="comment">// 并没有初始化数组，而是懒加载的思想，在第一次put时候通过resize()方法去加载。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次个线程不安全的地方</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在jdk1-8中，在多线程环境下，在并发执行put操作时会发生数据覆盖的情况。"><a href="#在jdk1-8中，在多线程环境下，在并发执行put操作时会发生数据覆盖的情况。" class="headerlink" title="在jdk1.8中，在多线程环境下，在并发执行put操作时会发生数据覆盖的情况。"></a>在jdk1.8中，在多线程环境下，在并发执行put操作时会发生数据覆盖的情况。</h4><p>JDK1.7出现的问题，在JDK1.8中已经得到了很好的解决，JDK1.8直接在resize函数中完成了数据迁移。在进行元素插入时使用的是尾插法然后在扩容。</p><p>但是在1.8中仍会有数据覆盖这样的问题，先看put源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//判断是否出现hash碰撞,如果没有hash碰撞则直接插入元素，此处线程不安全</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//++size此处线程不安全</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中代码<code>if ((p = tab[i = (n - 1) &amp; hash]) == null) </code>是判断是否出现hash碰撞：<br>比如两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</p><p>还有一种情况就是代码<code>if (++size &gt; threshold)</code>中的++size：<br>同样还是线程A、B，这两个线程同时进行put操作时，假设当前HashMap的zise大小为10，当线程A执行到此行代码时，从主内存中获得size的值为10后准备进行+1操作，但是由于时间片耗尽只好让出CPU，线程B快乐的拿到CPU还是从主内存中拿到size的值10进行+1操作，完成了put操作并将size=11写回主内存，然后线程A再次拿到CPU并继续执行(此时size的值仍为10)，当执行完put操作后，还是将size=11写回内存，此时线程A、B都执行了一次put操作，但是size的值只增加了1，所有说还是由于数据覆盖又导致了线程不安全。</p><h4 id="在jdk1-7中，在多线程环境下，当并发执行扩容时会造成死循环-环形链-或数据丢失。"><a href="#在jdk1-7中，在多线程环境下，当并发执行扩容时会造成死循环-环形链-或数据丢失。" class="headerlink" title="在jdk1.7中，在多线程环境下，当并发执行扩容时会造成死循环(环形链)或数据丢失。"></a>在jdk1.7中，在多线程环境下，当并发执行扩容时会造成死循环(环形链)或数据丢失。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>JDK1.7中HashMap的transfer函数如上，扩容操作（先扩容再头插法插入）会重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。头插法会将链表的顺序翻转，这也是造成死循环和数据丢失的关键。</p><h3 id="2、HashMap为什么选用红黑树这种数据结构优化链表"><a href="#2、HashMap为什么选用红黑树这种数据结构优化链表" class="headerlink" title="2、HashMap为什么选用红黑树这种数据结构优化链表"></a>2、HashMap为什么选用红黑树这种数据结构优化链表</h3><p>在JDK1.8之后，Java对HashMap做了改进，在链表长度大于<code>8</code>的时候，将后面的数据存到<code>红黑树</code>中，以<code>加快检索速度</code>。</p><p>红黑树也是一种平衡二叉树，每个节点有一个储存位表示节点的颜色，可以是红色或者黑色。通过对任意一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有任意一条从根到叶子的路径超过最短路径的两倍，因此红黑树是一种弱平衡二叉树。</p><p>相对于AVL树来说，红黑树的旋转次数少，对于搜索、插入、删除多的操作下用红黑树。</p><h3 id="3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲-HashMap-扰动函数？"><a href="#3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲-HashMap-扰动函数？" class="headerlink" title="3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲 HashMap 扰动函数？"></a>3、为什么默认初始容量为2次幂？不是2次幂会怎样？讲讲 HashMap 扰动函数？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 如果没有hash碰撞则直接插入元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n 为 2次幂，可以保证数据的均匀插入，降低哈希冲突的概率，毕竟冲突越大，代表数组中的链表/红黑树越大，从而降低Hashmap 的性能。</p><p>不管是规定 Hashmap 的 n 为 2次幂，还是扰动函数，都是为了一个目标，降低哈希冲突的概率，从而使 HashMap 性能得到优化。<br>规定 n 为 2次幂，是在新建 Hashmap对象初始化时，规定其容量大小的角度来优化。<br>扰动函数是插入 key 值时改变 key 的散列值，增大key的散列程度，降低哈希碰撞的概率来达到优化效果。</p><h3 id="4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）"><a href="#4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）" class="headerlink" title="4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）"></a>4、为什么HashMap使用高16位异或低16位计算Hash值（HashMap的扰动函数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算索引下标，key的hashCode的高16位与低16位异或 对数组的长度取余</span></span><br><span class="line">   tab[i = (n -<span class="number">1</span>) &amp; hash]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>hash值是一个int类型，二进制位为32位，而HashMap的table数组初始化size为16，计算索引下标的取余操作为<code>hash &amp; (length - 1) ==&gt; hash &amp; 1111</code>，这里面的问题是，1111只会与hashCode的低4位进行与操作，hashCode的高位并没有参与运算，会导致很多hashCode值不同而高位有区别的数最后算出来的索引是一样的。</p><p>举个例子，假设hashCode为1111110001，那么<code>1111110001 &amp; 1111 = 0001</code>，高位发生变化时<code>1011110001 &amp; 1111 = 0001</code>，<code>1001110001 &amp; 1111 = 0001</code>，也就是说在高位发生变化时，你最后算出来的索引都一样了，这样就会导致很多数据都被放到一个数组里面了，造成性能退化。</p><p>为了避免这种情况，HashMap将 key 的<code>高16位与低16位进行异或</code>，这样可以保证高位的数据也参与到与运算中来，以增大索引的散列程度，让数据分布得更为均匀 (个人觉得很多博客说的减小哈希碰撞是错误的说法，因为hash碰撞指的是两个hashCode相同，这里显然不是)。</p><p>主要原因是保留高16位与低16位的特性，增大散列程度。</p><p>为什么用异或，不用<code>&amp;</code>或者<code>|</code>操作。因为异或可以保证两个数值的特性，<code>&amp;</code>运算使得结果向0靠近， <code>|</code>运算使得结果向1靠近。</p><h4 id="Object类中的hashCode方法"><a href="#Object类中的hashCode方法" class="headerlink" title="Object类中的hashCode方法"></a>Object类中的hashCode方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法不是抽象方法，带有native关键字，底层调用C++程序。</p><p>hashCode()方法返回的是哈希码：实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值。所以hashCode()方法的执行结果可以等同看做一个java对象的内存地址。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>基于jdk1.8</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16, 默认初始化容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//负载系数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;   <span class="comment">// 取消树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 最小树化数组容量，转换为红黑树的最小数组长度为64</span></span><br></pre></td></tr></table></figure><h3 id="影响HashMap性能的两个因素"><a href="#影响HashMap性能的两个因素" class="headerlink" title="影响HashMap性能的两个因素"></a>影响HashMap性能的两个因素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>初始容量。创建哈希表时的容量。</li><li>负载系数。衡量哈希表在自动增加容量之前的填充程度的容量，当哈希表中的数据数量超过 (负载因子 * 当前容量) 时，哈希表将被扩容、重建。</li></ol><p>loadFactor的默认值为<code>0.75f</code> 是官方给出的一个比较好的临界值，这个值是经过多次推测得出的</p><h3 id="防蠢货能力"><a href="#防蠢货能力" class="headerlink" title="防蠢货能力"></a>防蠢货能力</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用HashMap的put方法，实际上调用了HashMap的putVal方法。<br>首先putVal()先用<code>hash(key)</code>函数计算键值对key的hash。hash(key)与数组长度做取余的位运算，得到这个键值对节点在数组中的具体下标。<br>进入putVal()方法，如果第一次插入元素，会调用resize()方法，初始化数组长度以及负载因子。<br>如果不是第一次插入：先看这个下标有没有元素，如果没有的话，直接放在这个下标。如果这个下标已经有元素了，就会发生哈希冲突，遍历这个下标的链表，如果key值相等，就替换value；如果key值不相等，就继续向下遍历，如果遍历完成仍然key不相等，就用尾插法将元素插入到链表中，然后判断链表是否要转化成红黑树。<br>插入完成后，HashMap的size++，如果size大于阈值就进行数组的扩容操作。</p><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化或增加表的大小，如果表为空，根据初始容量分配。扩容表，2次幂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 获取旧元素数组的各种信息</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧数组长度 </span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧数组临界值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 定义新数组的长度及扩容的临界值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果原 table 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组长度达到最大值,修改临界值为最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容操作(2倍)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 新数组初始容量和阈值使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;  <span class="comment">// 16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 16 * 0.75 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 临界值还为0，设置临界值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新负载因子</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 红黑树调整</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表调整</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="treeify方法"><a href="#treeify方法" class="headerlink" title="treeify方法"></a>treeify方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将链表中每个值进行红黑树插入操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">// 初始化Root</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 平衡调节</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保给定的根是根结点</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2022/05/10/Maven/"/>
      <url>/2022/05/10/Maven/</url>
      
        <content type="html"><![CDATA[<h3 id="MVN常用参数"><a href="#MVN常用参数" class="headerlink" title="MVN常用参数"></a>MVN常用参数</h3><ul><li>mvn -e 显示详细错误</li><li>mvn -U 强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖）</li><li>mvn -o 运行offline模式，不联网更新依赖</li><li>mvn -N 仅在当前项目模块执行命令，关闭reactor</li><li>mvn -pl module_name在指定模块上执行命令</li><li>mvn -ff 在递归执行命令过程中，一旦发生错误就直接退出</li><li>mvn -Dxxx=yyy 指定java全局属性</li><li>mvn -Pxxx 引用profile xxx</li><li>mvn -s setting.xml  -gs setting.xml -Dmaven.repo.local=$(pwd)/repos package -Dmaven.test.skip=true</li></ul><h3 id="Maven打包命令"><a href="#Maven打包命令" class="headerlink" title="Maven打包命令"></a>Maven打包命令</h3><h4 id="mvn-package"><a href="#mvn-package" class="headerlink" title="mvn package"></a>mvn package</h4><p>完成项目编译、单元测试、打包功能，打包到本项目，一般在项目target目录下。</p><p>打包文件未部署到本地Maven仓库和远程Maven仓库。</p><h4 id="mvn-install"><a href="#mvn-install" class="headerlink" title="mvn install"></a>mvn install</h4><p>完成项目编译、单元测试、打包功能，同时把打包文件部署到本地Maven仓库，但未部署到远程Maven仓库。</p><h4 id="mvn-deploy"><a href="#mvn-deploy" class="headerlink" title="mvn deploy"></a>mvn deploy</h4><p>完成项目编译、单元测试、打包功能，同时把打包文件部署到本地Maven仓库和远程Maven仓库。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nexus升级https过程</title>
      <link href="/2022/04/26/nexus%E5%8D%87%E7%BA%A7https%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/04/26/nexus%E5%8D%87%E7%BA%A7https%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>maven 3.8.1 版本之后，在 settings.xml 中通过配置 mirror 禁用了不安全的 http 链接，默认情况下必须使用 https 的仓库地址。</li></ul><p>10.200.17.45 测试机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8093:8081  -u root --name=nexus-lcf --privileged=true -v /data/nexus-https-lcf:/nexus-data -e INSTALL4J_ADD_VM_PARAMS=&quot;-Xms256m -Xmx512m -XX:MaxDirectMemorySize=1024m&quot; sonatype/nexus3:latest</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8443:8443 -p 8094:8081  -u root --name=nexus-lcf-https --privileged=true -v /data/nexus-https-lcf:/nexus-data -e INSTALL4J_ADD_VM_PARAMS=&quot;-Xms256m -Xmx512m -XX:MaxDirectMemorySize=1024m&quot; nexus-https:latest</span><br></pre></td></tr></table></figure><ul><li>-d</li><li>-u root –privileged=true</li><li>-p 8093:8081</li><li>–name=nexus-lcf</li><li>-v /data/nexus-https-lcf:/nexus-data</li><li>-e INSTALL4J_ADD_VM_PARAMS=”-Xms256m -Xmx512m -XX:MaxDirectMemorySize=1024m”</li></ul><p>10.163.204.79</p><h2 id="Nexus部署"><a href="#Nexus部署" class="headerlink" title="Nexus部署"></a>Nexus部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/sonatype/nexus3    // 拉取最新nexus镜像</span><br><span class="line">docker stop 7d6824229a9a &amp;&amp; docker rm 7d6824229a9a   // 停掉旧容器</span><br></pre></td></tr></table></figure><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d        </span></span><br><span class="line"> -p <span class="number">80</span>:<span class="number">8081</span>        </span><br><span class="line"> --name=nexus         </span><br><span class="line">--restart=always         </span><br><span class="line">--ulimit nofile=<span class="number">655360</span>         </span><br><span class="line">--ulimit memlock=-<span class="number">1</span>         </span><br><span class="line">--memory=<span class="number">16</span>G         </span><br><span class="line">--memory-swap=-<span class="number">1</span>         </span><br><span class="line">--cpuset-cpus=<span class="string">&#x27;0-7&#x27;</span>         </span><br><span class="line">-eINSTALL4J_ADD_VM_PARAMS=<span class="string">&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;</span>         </span><br><span class="line">-v /etc/localtime:/etc/localtime         </span><br><span class="line">-v /data/nexus:/nexus-data         </span><br><span class="line">sonatype/nexus3:latest</span><br></pre></td></tr></table></figure><h2 id="升级https"><a href="#升级https" class="headerlink" title="升级https"></a>升级https</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv _.haier.net.* ~/</span><br><span class="line">openssl pkcs12 -export -out keystore.pkcs12 -inkey _.haier.net.key -in _.haier.net.crt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM sonatype/nexus3</span><br><span class="line">USER root</span><br><span class="line">COPY keystore.pkcs12 /keystore.pkcs12</span><br><span class="line">RUN keytool -v -importkeystore -srckeystore keystore.pkcs12 -srcstoretype PKCS12 -destkeystore keystore.jks -deststoretype JKS -storepass password -srcstorepass password  &amp;&amp;\</span><br><span class="line">    cp keystore.jks /opt/sonatype/nexus/etc/ssl/</span><br><span class="line">USER nexus</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t nexus-https -f jdk_dockerfile</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d         -p 80:8081         --name=nexus         --restart=always         --ulimit nofile=655360         --ulimit memlock=-1         --memory=16G     --memory-swap=-1         --cpuset-cpus=&#x27;0-7&#x27;         -eINSTALL4J_ADD_VM_PARAMS=&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;         -v /etc/localtime:/etc/localtime         -v /data/nexus:/nexus-data         sonatype/nexus3:latest</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d         -p 80:8081     -p 443:8443    --name=nexus         --restart=always         --ulimit nofile=655360         --ulimit memlock=-1         --memory=16G         --memory-swap=-1         --cpuset-cpus=&#x27;0-7&#x27;         -eINSTALL4J_ADD_VM_PARAMS=&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;         -v /etc/localtime:/etc/localtime         -v /data/nexus:/nexus-data         nexus-https:latest</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Jetty section</span></span><br><span class="line"><span class="meta">application-port-ssl</span>=<span class="string">8443</span></span><br><span class="line"><span class="meta">application-port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">application-host</span>=<span class="string">0.0.0.0</span></span><br><span class="line"><span class="meta">nexus-args</span>=<span class="string">$&#123;jetty.etc&#125;/jetty.xml,$&#123;jetty.etc&#125;/jetty-http.xml,$&#123;jetty.etc&#125;/jetty-requestlog.xml,$&#123;jetty.etc&#125;/jetty-https.xml</span></span><br><span class="line"><span class="meta">nexus-context-path</span>=<span class="string">/$&#123;NEXUS_CONTEXT&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Nexus section</span></span><br><span class="line"><span class="meta">nexus-edition</span>=<span class="string">nexus-pro-edition</span></span><br><span class="line"><span class="meta">nexus-features</span>=<span class="string">\</span></span><br><span class="line"><span class="string"> nexus-pro-feature</span></span><br><span class="line"><span class="meta">nexus.clustered</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker run -d        </span><br><span class="line"> -p 80:8081        </span><br><span class="line"> -p 443:8443</span><br><span class="line"> --name=nexus         </span><br><span class="line">--restart=always         </span><br><span class="line">--ulimit nofile=655360         </span><br><span class="line">--ulimit memlock=-1         </span><br><span class="line">--memory=16G         </span><br><span class="line">--memory-swap=-1         </span><br><span class="line">--cpuset-cpus=&#x27;0-7&#x27;         </span><br><span class="line">-e INSTALL4J_ADD_VM_PARAMS=&quot;-Xms4g -Xmx4g -XX:MaxDirectMemorySize=6717M -Duser.timezone=Asia/Shanghai&quot;         </span><br><span class="line">-v /etc/localtime:/etc/localtime         </span><br><span class="line">-v /data/nexus:/nexus-data         </span><br><span class="line">nexus-https:latest</span><br><span class="line"></span><br><span class="line">docker参数</span><br><span class="line">–name 指定docker容器的名称 </span><br><span class="line">–net=host 使用host网络模式（和宿主机一个网络） </span><br><span class="line">–restart always docker 异常退出后自动重启 </span><br><span class="line">–volume / -v 挂载本地目录，格式 /src:/dst </span><br><span class="line">-e 指定docker启动后环境变量（env） </span><br><span class="line">–privileged 让docker可以拥有root权限 </span><br><span class="line">–ulimit nofile 系统文件句柄打开数量限制 </span><br><span class="line">–ulimit memlock 最大锁定内存地址空间，-1表示不限制 </span><br><span class="line">–memory 限制docker内存 </span><br><span class="line">–memory-swap 限制docker虚拟内存，-1 为不限制，共用宿主机swap </span><br><span class="line">–cpuset-cpus 指定docker绑定的CPU </span><br><span class="line">TERM=dumb 让docker里面可以执行top命令</span><br></pre></td></tr></table></figure><h3 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h3><p>nexus挂载目录/data<br><img src="/2022/04/26/nexus%E5%8D%87%E7%BA%A7https%E8%BF%87%E7%A8%8B/df-Th.jpg"><br><img src="/2022/04/26/nexus%E5%8D%87%E7%BA%A7https%E8%BF%87%E7%A8%8B/xfs_growfs.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nexus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID</title>
      <link href="/2022/04/11/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
      <url>/2022/04/11/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式ID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2022/02/24/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2022/02/24/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2022/02/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/02/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetCache源码探究</title>
      <link href="/2022/01/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-JetCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/"/>
      <url>/2022/01/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-JetCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="com-alicp-jetcache-anno-aop"><a href="#com-alicp-jetcache-anno-aop" class="headerlink" title="com.alicp.jetcache.anno.aop"></a>com.alicp.jetcache.anno.aop</h2><ul><li><p>CacheAdvisor<br>切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryPointcutAdvisor</span></span></span><br></pre></td></tr></table></figure></li><li><p>CachePointcut<br>切点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachePointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> <span class="keyword">implements</span> <span class="title">ClassFilter</span></span></span><br></pre></td></tr></table></figure></li><li><p>JetCacheInterceptor<br>拦截器、增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JetCacheInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">ApplicationContextAware</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="开启JetCache支持注解"><a href="#开启JetCache支持注解" class="headerlink" title="开启JetCache支持注解"></a>开启JetCache支持注解</h2><h3 id="EnableMethodCache"><a href="#EnableMethodCache" class="headerlink" title="@EnableMethodCache"></a>@EnableMethodCache</h3><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul><li><p>@Target(ElementType.TYPE)<br>@Target表示该注解可以用在什么地方。<code>TYPE</code>用于类、接口和enum声明</p></li><li><p>@Retention(RetentionPolicy.RUNTIME)<br>@Retention表示需要在什么级别保存该注解信息。<code>RUNTIME</code>时VM将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</p></li><li><p>@Documented<br>将此注解包含在Javadoc中。</p></li><li><p>@Import({CommonConfiguration.class, ConfigSelector.class})<br>@Import只能用在类上 ，@Import通过快速导入的方式实现把实例加入spring的IOC容器中</p></li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>basePackages</li></ul><h4 id="CommonConfiguration-class"><a href="#CommonConfiguration-class" class="headerlink" title="CommonConfiguration.class"></a>CommonConfiguration.class</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigMap <span class="title">jetcacheConfigMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConfigMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConfigSelector-class"><a href="#ConfigSelector-class" class="headerlink" title="ConfigSelector.class"></a>ConfigSelector.class</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableMethodCache</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROXY:</span><br><span class="line">                <span class="keyword">return</span> getProxyImports();</span><br><span class="line">            <span class="keyword">case</span> ASPECTJ:</span><br><span class="line"><span class="comment">//                return getAspectJImports();</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] getProxyImports() &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        result.add(AutoProxyRegistrar.class.getName());</span><br><span class="line">        result.add(JetCacheProxyConfiguration.class.getName());</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> String[result.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private String[] getAspectJImports() &#123;</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span></span><br><span class="line"><span class="comment">//        result.add(CACHE_ASPECT_CONFIGURATION_CLASS_NAME);</span></span><br><span class="line"><span class="comment">//        return result.toArray(new String[result.size()]);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnableCreateCacheAnnotation"><a href="#EnableCreateCacheAnnotation" class="headerlink" title="@EnableCreateCacheAnnotation"></a>@EnableCreateCacheAnnotation</h3><h4 id="元注解-1"><a href="#元注解-1" class="headerlink" title="元注解"></a>元注解</h4><ul><li>@Target(ElementType.TYPE)</li><li>@Retention(RetentionPolicy.RUNTIME)</li><li>@Documented</li><li>@Import({CommonConfiguration.class, CreateCacheAnnotationBeanPostProcessor.class})</li></ul><h4 id="CreateCacheAnnotationBeanPostProcessor-class"><a href="#CreateCacheAnnotationBeanPostProcessor-class" class="headerlink" title="CreateCacheAnnotationBeanPostProcessor.class"></a>CreateCacheAnnotationBeanPostProcessor.class</h4><h2 id="JetCache方法注解"><a href="#JetCache方法注解" class="headerlink" title="JetCache方法注解"></a>JetCache方法注解</h2><h3 id="方法注解生效的实现方式"><a href="#方法注解生效的实现方式" class="headerlink" title="方法注解生效的实现方式"></a>方法注解生效的实现方式</h3><p>使用自定义注解（切点）+ MethodInterceptor（增强Advice）构成织入（DefaultPointcutAdvisor）</p><h3 id="Cached"><a href="#Cached" class="headerlink" title="@Cached"></a>@Cached</h3><h3 id="CacheRefresh"><a href="#CacheRefresh" class="headerlink" title="@CacheRefresh"></a>@CacheRefresh</h3><h3 id="CacheUpdate"><a href="#CacheUpdate" class="headerlink" title="@CacheUpdate"></a>@CacheUpdate</h3><h3 id="CacheInvalidate"><a href="#CacheInvalidate" class="headerlink" title="@CacheInvalidate"></a>@CacheInvalidate</h3><h2 id="Cache类库实现"><a href="#Cache类库实现" class="headerlink" title="Cache类库实现"></a>Cache类库实现</h2><h3 id="Cache类库结构"><a href="#Cache类库结构" class="headerlink" title="Cache类库结构"></a>Cache类库结构</h3><p><img src="/2022/01/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-JetCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/cache%E7%B1%BB%E5%BA%93%E7%BB%93%E6%9E%84.png"></p><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><ul><li>类似于集合中的List，定义了一些缓存的基本方法，如get、put。</li><li>提供了方法的默认实现，使用了模板方法模式，小写方法有默认实现，大写方法由子类实现。</li><li>模板方法设计模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> CacheInvokeException </span>&#123;</span><br><span class="line">    CacheGetResult&lt;V&gt; result = GET(key);  <span class="comment">// 模板方法设计模式</span></span><br><span class="line">    <span class="keyword">if</span> (result.isSuccess()) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.getValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CacheGetResult&lt;V&gt; <span class="title">GET</span><span class="params">(K key)</span></span>;  <span class="comment">//接口方法，待子类实现</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="AbstractCache"><a href="#AbstractCache" class="headerlink" title="AbstractCache"></a>AbstractCache</h3><p>实现了Cache接口，类似于AbstractList。与AbstractList不同的是依旧采用了模板方法的设计模式，相当于在这一层又抽出了一些公共部分，定义接口方法在子类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> CacheGetResult&lt;V&gt; <span class="title">GET</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">    CacheGetResult&lt;V&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">new</span> CacheGetResult&lt;V&gt;(CacheResultCode.FAIL, CacheResult.MSG_ILLEGAL_ARGUMENT, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = do_GET(key);</span><br><span class="line">    &#125;</span><br><span class="line">    result.future().thenRun(() -&gt; &#123;</span><br><span class="line">        CacheGetEvent event = <span class="keyword">new</span> CacheGetEvent(<span class="keyword">this</span>, System.currentTimeMillis() - t, key, result);</span><br><span class="line">        notify(event);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> CacheGetResult&lt;V&gt; <span class="title">do_GET</span><span class="params">(K key)</span></span>;  <span class="comment">// 模板方法，由子类实现</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>此处会统计时间，根据这个方法可看出统计的是程序的执行时间，网络io时间不计算在内。</li><li>执行异步方法，新建一个缓存时间，发送通知给缓存时间的监控对象。<h4 id="异步的实现"><a href="#异步的实现" class="headerlink" title="异步的实现"></a>异步的实现</h4>在CacheResult中维护了一个私有的实例变量，用来完成异步有关操作，可以看到这个future变量是在CacheResult构造函数由参数传入，或是在构造函数中完成初始化。<br>调用future()方法即可将这个对象暴露出去，来完成异步操作。<br>上面代码中是调用了<code>CompletionStage</code>的thenRun()方法，即对上一步的计算结果不关心，执行下一个操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CompletionStage&lt;ResultData&gt; future;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheResult</span><span class="params">(CompletionStage&lt;ResultData&gt; future)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.future = future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheResult</span><span class="params">(CacheResultCode resultCode, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(CompletableFuture.completedFuture(<span class="keyword">new</span> ResultData(resultCode, message, <span class="keyword">null</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheResult</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    future = CompletableFuture.completedFuture(<span class="keyword">new</span> ResultData(ex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;ResultData&gt; <span class="title">future</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送缓存事件给监控者，监控者可对缓存事件监控</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(CacheEvent e)</span> </span>&#123;</span><br><span class="line">    List&lt;CacheMonitor&gt; monitors = config().getMonitors();</span><br><span class="line">    <span class="keyword">for</span> (CacheMonitor m : monitors) &#123;</span><br><span class="line">        m.afterOperation(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="computeIfAbsentImpl"><a href="#computeIfAbsentImpl" class="headerlink" title="computeIfAbsentImpl()"></a>computeIfAbsentImpl()</h4>缓存如果没有获取到值，就put一个值进去。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法参数使用了函数式接口来传递loader</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; <span class="function">V <span class="title">computeIfAbsentImpl</span><span class="params">(K key, Function&lt;K, V&gt; loader, <span class="keyword">boolean</span> cacheNullWhenLoaderReturnNull,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">long</span> expireAfterWrite, TimeUnit timeUnit, Cache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//强转Cache为AbstractCache类型</span></span><br><span class="line">    AbstractCache&lt;K, V&gt; abstractCache = CacheUtil.getAbstractCache(cache);</span><br><span class="line">    <span class="comment">//使用代理模式构建一个Loader，作用是对load过程计时</span></span><br><span class="line">    CacheLoader&lt;K, V&gt; newLoader = CacheUtil.createProxyLoader(cache, loader, abstractCache::notify);</span><br><span class="line">    CacheGetResult&lt;V&gt; r;</span><br><span class="line">    <span class="comment">//根据cache的类型不同制定不同的获取缓存值策略，获取CacheGetResult</span></span><br><span class="line">    <span class="keyword">if</span> (cache <span class="keyword">instanceof</span> RefreshCache) &#123;</span><br><span class="line">        RefreshCache&lt;K, V&gt; refreshCache = ((RefreshCache&lt;K, V&gt;) cache);</span><br><span class="line">        r = refreshCache.GET(key);</span><br><span class="line">        refreshCache.addOrUpdateRefreshTask(key, newLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = cache.GET(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否获取到缓存，未获取到则判断是否需要更新缓存。</span></span><br><span class="line">    <span class="keyword">if</span> (r.isSuccess()) &#123;</span><br><span class="line">        <span class="keyword">return</span> r.getValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Consumer&lt;V&gt; cacheUpdater = (loadedValue) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(needUpdate(loadedValue, cacheNullWhenLoaderReturnNull, newLoader)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (timeUnit != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cache.PUT(key, loadedValue, expireAfterWrite, timeUnit).waitForResult();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cache.PUT(key, loadedValue).waitForResult();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        V loadedValue;</span><br><span class="line">        <span class="comment">// 缓存穿透保护</span></span><br><span class="line">        <span class="keyword">if</span> (cache.config().isCachePenetrationProtect()) &#123;</span><br><span class="line">            loadedValue = synchronizedLoad(cache.config(), abstractCache, key, newLoader, cacheUpdater);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loadedValue = newLoader.apply(key);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 函数式接口，消费数据</span></span><br><span class="line">             cacheUpdater.accept(loadedValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2022/01/05/Nginx/"/>
      <url>/2022/01/05/Nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h3><p>轻量级的Web服务器、反向代理服务器。</p><h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><ul><li><p>正向代理<br><img src="/2022/01/05/Nginx/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.jpeg"><br>由于防火墙的原因，我们不能直接访问谷歌，可以借助VPN来实现，这是简单的正向代理的例子。<br>正向代理“代理”的是客户端，而且客户端是知道目标的，但是目标不知道客户端是通过VPN访问的。</p></li><li><p>反向代理<br><img src="/2022/01/05/Nginx/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.jpeg"><br>当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。</p></li></ul><h3 id="Nginx的Master-Worker模式"><a href="#Nginx的Master-Worker模式" class="headerlink" title="Nginx的Master-Worker模式"></a>Nginx的Master-Worker模式</h3><p><img src="/2022/01/05/Nginx/Nginx%E8%BF%9B%E7%A8%8B.jpeg"><br>启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</p><h4 id="Master进程"><a href="#Master进程" class="headerlink" title="Master进程"></a>Master进程</h4><ul><li>读取并验证配置文件nginx.conf</li><li>管理Worker进程</li></ul><h4 id="Worker进程"><a href="#Worker进程" class="headerlink" title="Worker进程"></a>Worker进程</h4><p>每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求。Worker进程的个数由配置文件决定，一般和CPU个数有关（利于进程切换）。</p><h3 id="Nginx如何做到热部署"><a href="#Nginx如何做到热部署" class="headerlink" title="Nginx如何做到热部署"></a>Nginx如何做到热部署</h3><h3 id="Nginx如何做到高并发下的高效处理"><a href="#Nginx如何做到高并发下的高效处理" class="headerlink" title="Nginx如何做到高并发下的高效处理"></a>Nginx如何做到高并发下的高效处理</h3><p>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。Worker进程只需要从epoll队列循环处理即可。</p><h4 id="epoll模型是什么"><a href="#epoll模型是什么" class="headerlink" title="epoll模型是什么"></a>epoll模型是什么</h4><h3 id="Nginx挂了怎么办"><a href="#Nginx挂了怎么办" class="headerlink" title="Nginx挂了怎么办"></a>Nginx挂了怎么办</h3><p>Keepalived+Nginx实现高可用。<br>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）<br>Keepalived+Nginx实现高可用的思路：</p><ol><li>请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</li><li>Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）<br><img src="/2022/01/05/Nginx/Keepalived+Nginx.jpeg"></li></ol><h3 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h3><h4 id="虚拟主机-server"><a href="#虚拟主机-server" class="headerlink" title="虚拟主机 server"></a>虚拟主机 server</h4><p><img src="/2022/01/05/Nginx/conf-server.jpeg"></p><h4 id="反向代理-proxy-pass"><a href="#反向代理-proxy-pass" class="headerlink" title="反向代理 proxy_pass"></a>反向代理 proxy_pass</h4><p>在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。</p><p>反向代理的过程是透明的，比如说request -&gt; Nginx -&gt; Tomcat，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER。</p><h4 id="负载均衡-upstream"><a href="#负载均衡-upstream" class="headerlink" title="负载均衡 upstream"></a>负载均衡 upstream</h4><p>上面的反向代理中，我们通过proxy_pass来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？</p><ol><li>通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</li><li>将proxy_pass替换成upstream指定的值即可。</li></ol><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存，是Nginx提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。</p><ol><li>定义缓存存储目录并指定共享内存空间</li><li>在location里指定共享内存空间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">user www;</span><br><span class="line">worker_processes auto;</span><br><span class="line">events &#123;</span><br><span class="line">worker_connections 4096;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">include mime.types;</span><br><span class="line">default_type application/octet-stream;</span><br><span class="line">sendfile on;</span><br><span class="line">gzip on;</span><br><span class="line">keepalive_timeout 65;</span><br><span class="line"></span><br><span class="line"># 以下是缓存相关配置</span><br><span class="line">proxy_cache_path /data/nginx/cache2 levels=1:2 keys_zone=mycache:1024m max_size=2048m inactive=1d ;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name localhost;</span><br><span class="line">#charset koi8-r;</span><br><span class="line">#access_log logs/host.access.log main;</span><br><span class="line">location /apis/test/img &#123;</span><br><span class="line">proxy_pass http://192.168.1.2/;</span><br><span class="line"></span><br><span class="line"># 以下三行是缓存相关配置</span><br><span class="line">proxy_cache mycache;</span><br><span class="line">proxy_cache_valid 200 1d;</span><br><span class="line">proxy_cache_use_stale error timeout invalid_header updating http_500 http_503 http_404;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 500 502 503 504 /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>proxy_cache_path:定义缓存目录，需要手动创建此目录；缓存数据存放至此。</li><li>/data/nginx/cache2：自定义的缓存目录，缓存中的文件名称是应用MD5的结果；另外，首先是将缓存响应写入临时文件，然后文件才被重命名；</li><li>levels=1:2：定义缓存的层次结构级别；这里表示缓存目录的第一级目录是1个字符，第二级目录是2个字符；</li><li>keys_zone=mycache:1024m：内核中建立的用于缓存数据原数据的共享内存空间；这里存放缓存数据的原数据；查找缓存的时候，先从这个内核空间中找到，缓存数据的原数据，然后再到对应目录中查找缓存；我这里定义的zone名称为‘mycache’;</li><li>max_size=2048m：设置缓存空间的最大值；</li><li>inactive=1d: 设置缓存的数据保留时间，这里自定义1天内没有被访问过就删除；</li><li>proxy_cache：在location里设置内存缓存源数据空间名字，对应我们前面的设定’mycache’;</li><li>proxy_cache_valid: 可以为不同的响应状态码设置不同的缓存时间，比如这里200状态码，设置为1天；</li><li>proxy_cache_use_stale：指定后端服务器出现状况时，nginx可以使用的过期缓存</li><li>另外可以设置proxy_cache_key：用来指定缓存所使用的key的组合字符串，然后用md5进行加密。如不指定默认使用：$scheme$proxy_host$request_uri;</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot缓存技术——Spring Cache、JetCache</title>
      <link href="/2021/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94SpringBoot%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
      <url>/2021/12/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94SpringBoot%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>Spring Cache 是 Spring 自带的缓存方案，既可以使用本地缓存，也可以使用 Redis。</p><h3 id="Cache-Type"><a href="#Cache-Type" class="headerlink" title="Cache Type"></a>Cache Type</h3><ul><li>GENERIC</li><li>JCACHE</li><li>EHCACHE</li><li>HAZELCAST</li><li>INFINISPAN</li><li>COUCHBASE</li><li>REDIS</li><li>CAFFEINE</li><li>SIMPLE</li><li>NONE</li></ul><h3 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--Redis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在配置类或者Application类上添加<code>@EnableCaching</code>注解以启动缓存功能。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/api</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">********</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>启用缓存，首先从缓存中查找数据，如果存在，则从缓存读取数据；如果不存在，则执行方法，并将方法返回值添加到缓存。</p><h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>更新缓存，如果 condition 计算结果为 true，则将方法返回值添加到缓存中</p><h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>删除缓存，根据 value 与 key 字段计算缓存地址，将缓存数据删除</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>不能实现缓存刷新。</li><li>不支持二级缓存。本地缓存和Redis远程缓存只能二选一。</li></ol><h2 id="JetCache"><a href="#JetCache" class="headerlink" title="JetCache"></a>JetCache</h2><p>JetCache是一个基于Java的缓存系统封装，提供统一的API和注解来简化缓存的使用。</p><p>当前有四个实现，RedisCache、TairCache（此部分未在github开源）、CaffeineCache(in memory)和一个简易的LinkedHashMapCache(in memory)。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>通过统一的API访问Cache系统</li><li>通过注解实现声明式的方法缓存，支持TTL和两级缓存</li><li>通过注解创建并配置Cache实例</li><li>针对所有Cache实例和方法缓存的自动统计</li><li>Key的生成策略和Value的序列化策略是可以配置的</li><li>分布式缓存自动刷新，分布式锁 (2.2+)</li><li>异步Cache API (2.2+，使用Redis的lettuce客户端时)</li><li>Spring Boot支持</li></ul><ol><li>分布式缓存和内存型缓存可以共存，当共存时，优先访问内存，保护远程缓存；也可以只用某一种，分布式 or 内存</li><li>自动刷新策略，防止某个缓存失效，访问量突然增大时，所有机器都去访问数据库，可能导致数据库挂掉</li><li>利用不严格的分布式锁，对同一key，全局只有一台机器自动刷新</li></ol><h3 id="依赖项-1"><a href="#依赖项-1" class="headerlink" title="依赖项"></a>依赖项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- springboot依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- jetcache依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jetcache-starter-redis-lettuce&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="添加启动类注解"><a href="#添加启动类注解" class="headerlink" title="添加启动类注解"></a>添加启动类注解</h4><p>在配置类或者Application类，<code>@EnableMethodCache</code>用于注解开启方法上的缓存功能，<code>@EnableCreateCacheAnnotation</code>用于注解开启<code>@CreateCache</code>来引入 Cacche Bean 的功能。</p><h4 id="依赖项说明"><a href="#依赖项说明" class="headerlink" title="依赖项说明"></a>依赖项说明</h4><ul><li><p>jetcache-anno-api<br>定义jetcache的注解和常量，不传递依赖。如果你想把Cached注解加到接口上，又不希望你的接口jar传递太多依赖，可以让接口jar依赖 jetcache-anno-api 。</p></li><li><p>jetcache-core<br>核心api，完全通过编程来配置操作Cache，不依赖Spring。两个内存中的缓存实现 LinkedHashMapCache 和 CaffeineCache 也由它提供。</p></li><li><p>jetcache-anno<br>基于Spring提供 @Cached 和 @CreateCache 注解支持。</p></li><li><p>jetcache-redis<br>使用jedis提供Redis支持。</p></li><li><p>jetcache-redis-lettuce （需要JetCache2.3以上版本）<br>使用lettuce提供Redis支持，实现了JetCache异步访问缓存的的接口。</p></li><li><p>jetcache-starter-redis<br>Spring Boot方式的Starter，基于Jedis。</p></li><li><p>jetcache-starter-redis-lettuce （需要JetCache2.3以上版本）<br>Spring Boot方式的Starter，基于Lettuce。</p></li></ul><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/api</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">statIntervalMinutes:</span> <span class="number">15</span>  <span class="comment">#指定统计间隔，以分钟为单位。0表示没有统计数据。</span></span><br><span class="line">  <span class="attr">areaInCacheName:</span> <span class="literal">false</span>   <span class="comment">#jetcache-anno使用缓存名称作为远程缓存密钥前缀，在jetcache 2.4.3 和之前的版本中，它总是在缓存名称中添加区域名称。从2.4.4开始我们有这个配置项，为兼容原因，默认值为true。然而，虚假价值对于新项目更合理。</span></span><br><span class="line">  <span class="attr">hidePackages:</span> <span class="string">com.alibaba</span> <span class="comment">#包名称以（hiddenPackages）开始的将在生成的缓存实例名称中被截断</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">caffeine</span>        <span class="comment">#后端缓存系统的类型。可以tair，redis远程缓存，或者linkedhashmap，caffeine对于本地缓存。</span></span><br><span class="line">      <span class="attr">limit:</span> <span class="number">100</span>           <span class="comment">#每个Cache实例的本地内存中的max元素的全局配置。只有本地缓存​​需要它。</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">fastjson</span></span><br><span class="line">      <span class="attr">expireAfterWriteInMillis:</span> <span class="number">100000</span>   <span class="comment">#写入的全局配置到期时间，以毫秒为单位。</span></span><br><span class="line">      <span class="attr">expireAfterAccessInMillis:</span> <span class="number">100000</span>  <span class="comment">#读取的全局配置到期时间，以毫秒为单位。需要jetcache2.2 +，只有本地缓存​​支持此功能。0表示禁用读取过期功能</span></span><br><span class="line">    <span class="attr">otherArea:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">linkedhashmap</span></span><br><span class="line">      <span class="attr">limit:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">none</span></span><br><span class="line">      <span class="attr">expireAfterWriteInMillis:</span> <span class="number">100000</span></span><br><span class="line">      <span class="attr">expireAfterAccessInMillis:</span> <span class="number">100000</span></span><br><span class="line">  <span class="attr">remote:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis.lettuce</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">fastjson</span></span><br><span class="line">      <span class="attr">valueEncoder:</span> <span class="string">java</span>    <span class="comment">#全局配置值编码器只需要远程缓存。两个内置valueEncoder是java和kryo</span></span><br><span class="line">      <span class="attr">valueDecoder:</span> <span class="string">java</span>    <span class="comment">#全局配置值解码器只需要远程缓存。两个内置valueEncoder是java和kryo</span></span><br><span class="line">      <span class="attr">poolConfig:</span></span><br><span class="line">        <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">maxIdle:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">redis://lvchengfeng@39.99.128.143:6379/1?timeout=5s</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">$&#123;redis.host&#125;</span></span><br><span class="line">      <span class="attr">port:</span> <span class="string">$&#123;redis.port&#125;</span></span><br></pre></td></tr></table></figure><h3 id="通过-CreateCache-创建-Cache-实例"><a href="#通过-CreateCache-创建-Cache-实例" class="headerlink" title="通过 @CreateCache 创建 Cache 实例"></a>通过 @CreateCache 创建 Cache 实例</h3><p><code>@CreateCache</code>是一个属性注解，用于创建一个缓存的实例对象，通过操作缓存实例对象来完成对缓存的操作。</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建缓存实例，默认使用远程缓存，过期时间为永不过期</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">  <span class="meta">@CreateCache</span></span><br><span class="line">  <span class="keyword">private</span> Cache&lt;Long, User&gt; userCache;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 手动查询缓存</span></span><br><span class="line">      User user = userCache.get(id);</span><br><span class="line">      <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">          <span class="comment">// 缓存中没有数据，查数据库</span></span><br><span class="line">          <span class="comment">// 这里新建一个user代表去查了数据库</span></span><br><span class="line">          User user1 = <span class="keyword">new</span> User(id, <span class="string">&quot;zhangsan&quot;</span>, <span class="number">0</span>, <span class="keyword">new</span> Date(), <span class="number">0</span>);</span><br><span class="line">          log.info(<span class="string">&quot;模拟查询数据库获取到的用户：&#123;&#125;&quot;</span>, user1);</span><br><span class="line">          userCache.put(user1.getId(), user1);</span><br><span class="line">          <span class="comment">// 也可以单独指定缓存失效时间</span></span><br><span class="line">          <span class="comment">// userCache.put(user1.getId(), user1, 100, TimeUnit.SECONDS);</span></span><br><span class="line">          <span class="keyword">return</span> user1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 缓存中有数据，直接返回</span></span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">deleteUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 手动操作缓存对象完成缓存的删除</span></span><br><span class="line">      userCache.remove(id);</span><br><span class="line">      <span class="comment">// 数据库删除操作...</span></span><br><span class="line">      log.info(<span class="string">&quot;模拟删除用户id：&#123;&#125;&quot;</span>, id);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 手动完成缓存的更新操作</span></span><br><span class="line">      userCache.put(user.getId(), user);</span><br><span class="line">      <span class="comment">// 数据库更新操作...</span></span><br><span class="line">      log.info(<span class="string">&quot;模拟更新用户：&#123;&#125;&quot;</span>, user);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CreateCache &#123;</span><br><span class="line">    <span class="comment">// 如果要使用多后端缓存系统，可以在配置中设置多个“缓存区”，此属性指定要使用的“缓存区域”的名称。</span></span><br><span class="line">    <span class="function">String <span class="title">area</span><span class="params">()</span> <span class="keyword">default</span> &quot;<span class="keyword">default</span>&quot;</span>;</span><br><span class="line">    <span class="comment">// 指定缓存的唯一名称，默认会使用类名+方法名，name会被用于远程缓存的key前缀</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;$$undefined$$&quot;</span>;</span><br><span class="line">    <span class="comment">// 指定时间单位，默认为秒</span></span><br><span class="line">    <span class="function">TimeUnit <span class="title">timeUnit</span><span class="params">()</span> <span class="keyword">default</span> TimeUnit.SECONDS</span>;</span><br><span class="line">    <span class="comment">// 指定远程缓存过期时间，默认无穷大</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expire</span><span class="params">()</span> <span class="keyword">default</span> -2147483648</span>;</span><br><span class="line">    <span class="comment">// 指定本地缓存过期时间，默认无穷大</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">localExpire</span><span class="params">()</span> <span class="keyword">default</span> -2147483648</span>;</span><br><span class="line">    <span class="comment">// 指定缓存类型，默认使用远程缓存</span></span><br><span class="line">    <span class="function">CacheType <span class="title">cacheType</span><span class="params">()</span> <span class="keyword">default</span> CacheType.REMOTE</span>;</span><br><span class="line">    <span class="comment">// 指定本地缓存元素限制</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">localLimit</span><span class="params">()</span> <span class="keyword">default</span> -2147483648</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">serialPolicy</span><span class="params">()</span> <span class="keyword">default</span> &quot;$$undefined$$&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">keyConvertor</span><span class="params">()</span> <span class="keyword">default</span> &quot;$$undefined$$&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过注解实现方法缓存"><a href="#通过注解实现方法缓存" class="headerlink" title="通过注解实现方法缓存"></a>通过注解实现方法缓存</h3><h4 id="Cached-缓存新增"><a href="#Cached-缓存新增" class="headerlink" title="@Cached 缓存新增"></a>@Cached 缓存新增</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cached(name = &quot;UserService.userCache.&quot;,</span></span><br><span class="line"><span class="meta">        key = &quot;#id&quot;,</span></span><br><span class="line"><span class="meta">        expire = 100,</span></span><br><span class="line"><span class="meta">        cacheType = CacheType.BOTH,</span></span><br><span class="line"><span class="meta">        localLimit = 50)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(id, <span class="string">&quot;zhangsan&quot;</span>, <span class="number">0</span>, <span class="keyword">new</span> Date(), <span class="number">0</span>);</span><br><span class="line">    log.info(<span class="string">&quot;模拟查询数据库获取到的用户：&#123;&#125;&quot;</span>, user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>area<br>如果要使用多后端缓存系统，可以在配置中设置多个“缓存区”，此属性指定要使用的“缓存区域”的名称。</p></li><li><p>cacheType<br>默认是<code>CacheType.REMOTE</code>，另支持<code>CacheType.LOCAL</code>和<code>CacheType.BOTH</code>。<code>CacheType.BOTH</code>时支持本地缓存和远程缓存，优先取本地缓存。</p></li><li><p>serialPolicy<br>value序列化策略。</p></li></ul><h4 id="CacheUpdate-缓存更新"><a href="#CacheUpdate-缓存更新" class="headerlink" title="@CacheUpdate 缓存更新"></a>@CacheUpdate 缓存更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheUpdate(</span></span><br><span class="line"><span class="meta">        name = &quot;UserService.userCache.&quot;,</span></span><br><span class="line"><span class="meta">        key = &quot;#user.id&quot;,</span></span><br><span class="line"><span class="meta">        value = &quot;#user&quot;,</span></span><br><span class="line"><span class="meta">        condition = &quot;#result&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据库操作...</span></span><br><span class="line">    log.info(<span class="string">&quot;模拟更新用户：&#123;&#125;&quot;</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>value<br>用来更新缓存的值，使用SpEL表达式指定。</p></li><li><p>condition<br>表达式脚本用于调节缓存操作，当评估结果为false时，操作被否决。在实际方法调用之后进行评估，因此我们可以在脚本中引用#result。</p></li></ul><h4 id="CacheInvalidate-缓存删除"><a href="#CacheInvalidate-缓存删除" class="headerlink" title="@CacheInvalidate 缓存删除"></a>@CacheInvalidate 缓存删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheInvalidate(</span></span><br><span class="line"><span class="meta">        name = &quot;UserService.userCache.&quot;,</span></span><br><span class="line"><span class="meta">        key = &quot;#id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">deleteUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据库操作...</span></span><br><span class="line">    log.info(<span class="string">&quot;模拟删除用户id：&#123;&#125;&quot;</span>, id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法缓存-amp-缓存实例"><a href="#方法缓存-amp-缓存实例" class="headerlink" title="方法缓存&amp;缓存实例"></a>方法缓存&amp;缓存实例</h3><p>方法缓存的使用方法简单，但是不支持自由度较高的缓存操作逻辑（比如加锁）或异步操作，如果需要用到这些功能则必须使用创建缓存实例的方式进行缓存的操作。</p><p>如果只是为了引入缓存，并且业务场景也只是对缓存进行一些简单的增删改查操作，那么可以选择使用方法缓存；但如果需要使用缓存完成更加复杂的业务逻辑或者需要异步操作缓存则需要考虑使用创建缓存实例的方式。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="缓存时间"><a href="#缓存时间" class="headerlink" title="缓存时间"></a>缓存时间</h4><ol><li>Cache.put() 等方法指定了超时时间，则以此时间为准</li><li>Cache.put() 等方法未指定超时时间，则使用创建Cache实例时指定的超时时间，Cache实例的超时时间通过在 @CreateCache 和 @Cached 上的 expire 属性指定</li><li>如果还没有指定，则使用yml中定义的全局配置，例如 @Cached(cacheType=local) 使用 jetcache.local.default.expireAfterWriteInMillis 作为全局配置，如果仍未指定则是默认的无穷大</li></ol><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="Asynchronous-异步API"><a href="#Asynchronous-异步API" class="headerlink" title="Asynchronous 异步API"></a>Asynchronous 异步API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CacheGetResult r = cache.GET(userId);</span><br><span class="line">CompletionStage&lt;ResultData&gt; future = r.future();</span><br><span class="line">future.thenRun(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(r.isSuccess())&#123;</span><br><span class="line">        System.out.println(r.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Distributed-lock-不严格的分布式锁支持"><a href="#Distributed-lock-不严格的分布式锁支持" class="headerlink" title="Distributed lock 不严格的分布式锁支持"></a>Distributed lock 不严格的分布式锁支持</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache.tryLockAndRun(<span class="string">&quot;key&quot;</span>, <span class="number">60</span>, TimeUnit.SECONDS, () -&gt; heavyDatabaseOperation());</span><br></pre></td></tr></table></figure><h4 id="Read-through-and-automatically-refreshment"><a href="#Read-through-and-automatically-refreshment" class="headerlink" title="Read through and automatically refreshment"></a>Read through and automatically refreshment</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CreateCache</span></span><br><span class="line"><span class="meta">@CacheRefresh(timeUnit = TimeUnit.MINUTES, refresh = 60, stopRefreshAfterLastAccess = 100)</span></span><br><span class="line"><span class="meta">@CachePenetrationProtect</span></span><br><span class="line"><span class="keyword">private</span> Cache&lt;String, Long&gt; orderSumCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    orderSumCache.config().setLoader(<span class="keyword">this</span>::loadOrderSumFromDatabase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于@Cached注解，刷新任务是在调用带有@Cached方法时才会生效，用于解决缓存雪崩</li><li>@CacheRefresh 自动刷新</li><li>@CachePenetrationProtect 加载保护</li></ul><h3 id="自动刷新缓存"><a href="#自动刷新缓存" class="headerlink" title="自动刷新缓存"></a>自动刷新缓存</h3><h4 id="JetCache的缓存刷新策略"><a href="#JetCache的缓存刷新策略" class="headerlink" title="JetCache的缓存刷新策略"></a>JetCache的缓存刷新策略</h4><p>对于开启了自动刷新的缓存，JetCahce在创建缓存的时候也会创建一个以一定时间间隔运行的定时任务，这个定时任务的主要工作就是判断这个缓存是否是一个活跃缓存，如果是，就执行刷新（查询数据库，更新缓存），重置缓存过期时间；否则停止刷新。</p><p>判断一个缓存是否是活跃的指标是该缓存上一次访问时间与当前时间的差值，当这个差值大于某个阈值的时候就判定为不活跃缓存，停止刷新；反之执行刷新。</p><p>特别的，如果一个不活跃的缓存在它还没有过期前被激活则又会开始执行自动刷新，也就是说停止刷新后的缓存如果在失效之前再次被访问又会重新激活自动刷新任务，而不是完全任由它自动过期。</p><h4 id="创建缓存实例时设置自动刷新"><a href="#创建缓存实例时设置自动刷新" class="headerlink" title="创建缓存实例时设置自动刷新"></a>创建缓存实例时设置自动刷新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CreateCache</span></span><br><span class="line"><span class="keyword">private</span> Cache&lt;Long, String&gt; userCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// newPolicy方法指定了定时任务的执行时间间隔</span></span><br><span class="line">    <span class="comment">// stopRefreshAfterLastAccess方法指定了停止刷新缓存的时间阈值</span></span><br><span class="line">    RefreshPolicy policy = RefreshPolicy.newPolicy(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                          .stopRefreshAfterLastAccess(<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">    userCache.config().setLoader(<span class="keyword">this</span>::loadOrderSumFromDatabase);</span><br><span class="line">    userCache.config().setRefreshPolicy(policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>newPolicy(1, TimeUnit. MINUTES) 方法指定了定时任务的执行时间间隔为【1分钟】</li><li>stopRefreshAfterLastAccess(30, TimeUnit. MINUTES) 方法指定了停止刷新缓存的时间阈值为【30分钟】，即如果这个缓存在30分钟内没有被访问过就停止刷新</li></ul><h4 id="使用-CacheRefresh-注解"><a href="#使用-CacheRefresh-注解" class="headerlink" title="使用 @CacheRefresh 注解"></a>使用 @CacheRefresh 注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cached(name = &quot;UserService.userCache.&quot;,</span></span><br><span class="line"><span class="meta">        key = &quot;#id&quot;,</span></span><br><span class="line"><span class="meta">        expire = 100,</span></span><br><span class="line"><span class="meta">        cacheType = CacheType.BOTH,</span></span><br><span class="line"><span class="meta">        localLimit = 50)</span></span><br><span class="line"><span class="comment">// refresh指定了定时任务的执行时间间隔</span></span><br><span class="line"><span class="comment">// stopRefreshAfterLastAccess方法指定了停止刷新缓存的时间阈值</span></span><br><span class="line"><span class="meta">@CacheRefresh(</span></span><br><span class="line"><span class="meta">        refresh = 1,</span></span><br><span class="line"><span class="meta">        stopRefreshAfterLastAccess = 30</span></span><br><span class="line"><span class="meta">        timeUnit = TimeUnit.MINUTES)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(id, <span class="string">&quot;zhangsan&quot;</span>, <span class="number">0</span>, <span class="keyword">new</span> Date(), <span class="number">0</span>);</span><br><span class="line">    log.info(<span class="string">&quot;模拟查询数据库获取到的用户：&#123;&#125;&quot;</span>, user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@CacheRefresh 注解的 refresh 属性指定了定时任务的执行时间间隔</li><li>@CacheRefresh 注解的 stopRefreshAfterLastAccess 属性指定了停止刷新缓存的时间阈值</li></ul><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>分布式缓存自动刷新必定有多台机器都可能有相同的任务，那么每台机器都可能在同一时间刷新缓存必然是浪费，但是jetcache是没有一个全局任务分配的功能的。这里jetcache也非常聪明，利用了一个非严格的分布式锁，只有获取了这个key的分布式锁，才可以进行这个key的缓存刷新。分布式锁是向远程缓存写入一个lockKey为name+name+key+”#URL#”，value为uuid的缓存，写入成功则获取分布式锁成功。</p><h4 id="避免滥用-CacheRefresh-注解"><a href="#避免滥用-CacheRefresh-注解" class="headerlink" title="避免滥用 @CacheRefresh 注解"></a>避免滥用 @CacheRefresh 注解</h4><p>后台刷新任务是针对单个key的，每个key对应一个Runnable，对系统的线程池是一个考验，所以不能过度依赖自动刷新。我们需要保证key是热点且数量有限的，否则每个机器都会保存一个key对应的Runnable是比较危险的事情。这里可以活用condition的选项，在哪些情况下使用自动刷新功能。比如微博热帖，我们可以根据返回的微博贴的阅读数，超过某个值之后，将这个热帖加入到自动刷新任务中。</p><h3 id="统计功能"><a href="#统计功能" class="headerlink" title="统计功能"></a>统计功能</h3><p>JetCache 提供了对缓存的监控功能，让开发者根据缓存的使用情况作出相应的调整优化措施，当遇到问题时能够通过查看统计数据快速准确地定位问题。</p><h4 id="开启统计"><a href="#开启统计" class="headerlink" title="开启统计"></a>开启统计</h4><p>当yml中的<code>jetcache.statIntervalMinutes</code>大于<code>0</code>时，通过<code>@CreateCache</code>和<code>@Cached</code>配置出来的Cache自带监控功能，JetCache会按指定的时间定期通过logger输出统计信息，默认输出信息类似如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">2017-01-12 19:00:00,001 INFO  support.StatInfoLogger - jetcache stat from 2017-01-12 18:59:00,000 to 2017-01-12 19:00:00,000</span><br><span class="line">cache                                                |       qps|   rate|           get|           hit|          fail|        expire|avgLoadTime|maxLoadTime</span><br><span class="line">-----------------------------------------------------+----------+-------+--------------+--------------+--------------+--------------+-----------+-----------</span><br><span class="line">default_AlicpAppChannelManager.getAlicpAppChannelById|      0.00|  0.00%|             0|             0|             0|             0|        0.0|          0</span><br><span class="line">default_ChannelManager.getChannelByAccessToten       |     30.02| 99.78%|         1,801|         1,797|             0|             4|        0.0|          0</span><br><span class="line">default_ChannelManager.getChannelByAppChannelId      |      8.30| 99.60%|           498|           496|             0|             1|        0.0|          0</span><br><span class="line">default_ChannelManager.getChannelById                |      6.65| 98.75%|           399|           394|             0|             4|        0.0|          0</span><br><span class="line">default_ConfigManager.getChannelConfig               |      1.97| 96.61%|           118|           114|             0|             4|        0.0|          0</span><br><span class="line">default_ConfigManager.getGameConfig                  |      0.00|  0.00%|             0|             0|             0|             0|        0.0|          0</span><br><span class="line">default_ConfigManager.getInstanceConfig              |     43.98| 99.96%|         2,639|         2,638|             0|             0|        0.0|          0</span><br><span class="line">default_ConfigManager.getInstanceConfigSettingMap    |      2.45| 70.75%|           147|           104|             0|            43|        0.0|          0</span><br><span class="line">default_GameManager.getGameById                      |      1.33|100.00%|            80|            80|             0|             0|        0.0|          0</span><br><span class="line">default_GameManager.getGameUrlByUrlKey               |      7.33|100.00%|           440|           440|             0|             0|        0.0|          0</span><br><span class="line">default_InstanceManager.getInstanceById              |     30.98| 99.52%|         1,859|         1,850|             0|             0|        0.0|          0</span><br><span class="line">default_InstanceManager.getInstanceById_local        |     30.98| 96.40%|         1,859|         1,792|             0|            67|        0.0|          0</span><br><span class="line">default_InstanceManager.getInstanceById_remote       |      1.12| 86.57%|            67|            58|             0|             6|        0.0|          0</span><br><span class="line">default_IssueDao.getIssueById                        |      7.62| 81.40%|           457|           372|             0|            63|        0.0|          0</span><br><span class="line">default_IssueDao.getRecentOnSaleIssues               |      8.00| 85.21%|           480|           409|             0|            71|        0.0|          0</span><br><span class="line">default_IssueDao.getRecentOpenAwardIssues            |      2.52| 82.78%|           151|           125|             0|            26|        0.0|          0</span><br><span class="line">default_PrizeManager.getPrizeMap                     |      0.82|100.00%|            49|            49|             0|             0|        0.0|          0</span><br><span class="line">-----------------------------------------------------+----------+-------+--------------+--------------+--------------+--------------+-----------+-----------</span><br></pre></td></tr></table></figure><p>输出的统计信息以缓存的<code>name</code>为统计单位（所以在创建缓存时需要指定合适的name），统计的数据主要有每秒钟访问次数（QPS）、总共访问次数（GET）、缓存命中次数（HIT）以及命中率（RATE）等</p><h4 id="配置统计信息输出到独立的日志文件"><a href="#配置统计信息输出到独立的日志文件" class="headerlink" title="配置统计信息输出到独立的日志文件"></a>配置统计信息输出到独立的日志文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出日志到文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;JETCACHE_LOGFILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志文件名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>jetcache.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志文件后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>jetcache.log.%d&#123;yyyy-MM-dd&#125;<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输出格式化样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 输出级别控制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.alicp.jetcache&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;JETCACHE_LOGFILE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式缓存</title>
      <link href="/2021/12/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
      <url>/2021/12/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><h3 id="客户端缓存-浏览器缓存"><a href="#客户端缓存-浏览器缓存" class="headerlink" title="客户端缓存/浏览器缓存"></a>客户端缓存/浏览器缓存</h3><p>对于B/S架构的互联网应用来说客户端缓存主要分为页面缓存和浏览器缓存两种，对于APP而言主要是自身所使用的缓存。</p><p>客户端Client/Server是建立在局域网的基础上的。浏览器Browser/Server是建立在广域网的基础上的。</p><h3 id="网络中缓存"><a href="#网络中缓存" class="headerlink" title="网络中缓存"></a>网络中缓存</h3><ul><li>CDN缓存</li><li>代理服务器缓存</li></ul><h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><ul><li>本地缓存</li><li>分布式缓存，Redis、Memcached、MongoDB等NoSql</li><li>数据库缓存</li></ul><h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><h3 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h3><p><code>Content Delivery Network</code>，内容分发网络，是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。</p><p>CDN是将源站内容（image、html、js、css等）分发至全国所有的节点，从而缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性的技术。它能够有效解决网络带宽小、用户访问量大、网点分布不均等问题。</p><h2 id="代理服务器缓存"><a href="#代理服务器缓存" class="headerlink" title="代理服务器缓存"></a>代理服务器缓存</h2><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>Proxy Server，其功能就是代理网络用户去取得网络信息。<br>形象的说：它是网络信息的中转站。在一般情况下，我们使用网络浏览器直接去连接其他Internet站点取得网络信息时，须送出Request信号来得到回答，然后对方再把信息以bit方式传送回来。代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。</p><h4 id="代理功能"><a href="#代理功能" class="headerlink" title="代理功能"></a>代理功能</h4><ol><li>突破自身IP访问限制，访问国外站点。教育网、169网等网络用户可以通过代理访问国外网站。</li><li>访问一些单位或团体内部资源。如某大学FTP(前提是该代理地址在该资源 的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</li><li>突破中国电信的IP封锁。中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国外的代理服务器试试。</li><li>提高访问速度。通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li><li>隐藏真实IP。上网者也可以通过这种方法隐藏自己的IP，免受攻击。</li></ol><h2 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h2><ol><li>定义缓存存储目录并指定共享内存空间</li><li>在location里指定共享内存空间</li></ol><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>即内存，本地缓存是一级缓存，位于服务本机的内存中，读写速度快，缺点是不能持久化，一旦项目关闭，数据就会丢失，而且不能满足分布式系统的应用场景(比如数据不一致的问题)。<br>存在的问题：</p><ol><li>本读缓存数据直接保存在JVM中，需要考虑缓存数据的大小、JVM的垃圾回收性能消耗</li><li>单服务是集群部署的时候，应该考虑是否需要做集群中本地缓存的数据同步</li><li>无法进行持久化</li><li>无法保证多实例数据一致性</li></ol><h3 id="EhCache"><a href="#EhCache" class="headerlink" title="EhCache"></a>EhCache</h3><h3 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h3><h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>利用缓存数据库，最常见的就是Redis。Redis的访问速度同样很快，可以设置过期时间、设置持久化方法，缺点是会受到网络和并发访问的影响。</p><h3 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h3><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>Jedis 是直连模式，在多个线程间共享一个 Jedis 实例是线程不安全的，每个线程都去拿自己的 Jedis 实例，当连接数量增多时，物理连接成本就较高了。</p><p>底层使用阻塞的I/O，且其方法调用都是同步的，程序流需要等到sockets处理完I/O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。</p><h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p>相比较Jedis，Lettuce基于优秀Netty NIO框架构建，支持Redis的高级功能，如Sentinel，集群，流水线，自动重新连接和Redis数据模型，线程安全，适用于分布式缓存。</p><p>如果需要集群、读写分离、异步等特性支持需要使用Lettuce客户端。</p><h4 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h4><p>让使用者对Redis的关注分离，提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列，也是基于Netty框架的事件驱动的通信层。</p><h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><p>Spring Data Redis是Spring大家族的一部分，提供了在Srping应用中通过简单的配置访问Redis服务，对Reids底层开发包(Jedis, JRedis, RJC)进行了高度封装，RedisTemplate提供了Redis各种操作、异常处理及序列化，支持发布订阅。</p><h2 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h2><h2 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="FIFO-先进先出"><a href="#FIFO-先进先出" class="headerlink" title="FIFO 先进先出"></a>FIFO 先进先出</h4><h4 id="LRU-Least-Recently-Used"><a href="#LRU-Least-Recently-Used" class="headerlink" title="LRU(Least Recently Used)"></a>LRU(Least Recently Used)</h4><p>最近最少使用。淘汰最长时间没有被使用的，以时间作为参考。</p><h4 id="LFU-Least-Frequently-Used"><a href="#LFU-Least-Frequently-Used" class="headerlink" title="LFU(Least Frequently Used)"></a>LFU(Least Frequently Used)</h4><p>最不经常使用。淘汰一段时间内，使用次数最少的，以次数作为参考。</p><h3 id="Redis缓存淘汰策略"><a href="#Redis缓存淘汰策略" class="headerlink" title="Redis缓存淘汰策略"></a>Redis缓存淘汰策略</h3><ol><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li><li>volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。</li><li>allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。</li><li>no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。</li></ol><p>总体上分为4种：</p><ul><li>lru</li><li>lfu</li><li>random</li><li>ttl</li></ul><h2 id="缓存、数据库-最终-一致性"><a href="#缓存、数据库-最终-一致性" class="headerlink" title="缓存、数据库(最终)一致性"></a>缓存、数据库(最终)一致性</h2><p>主要有两种情况，会导致缓存和DB的一致性问题：</p><ol><li>并发的场景下，导致读取老的DB数据，更新到缓存中</li><li>缓存和DB的操作，不在一个事务中，可能只有一个操作成功，而另一个操作失败，导致不一致</li><li>数据库主从结构，主从同步不及时带来的缓存、数据库数据不一致<h3 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h3>数据更新前后双删除缓存策略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line"></span><br><span class="line">redis.del(key);</span><br><span class="line"></span><br><span class="line">db.update(data);</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">redis.del(key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>先淘汰缓存</li><li>写数据库</li><li>休眠1秒，再次淘汰缓存。高并发情况下确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<h4 id="延迟双删-同步删除，吞吐量降低如何处理"><a href="#延迟双删-同步删除，吞吐量降低如何处理" class="headerlink" title="延迟双删 - 同步删除，吞吐量降低如何处理"></a>延迟双删 - 同步删除，吞吐量降低如何处理</h4>将第二次删除作为异步的，提交一个延迟的执行任务<h4 id="延迟双删-解决删除失败的方式"><a href="#延迟双删-解决删除失败的方式" class="headerlink" title="延迟双删 - 解决删除失败的方式"></a>延迟双删 - 解决删除失败的方式</h4>添加重试机制，例如：将删除失败的key，写入消息队列；但对业务耦合有些严重；</li></ol><h2 id="一二级缓存一致性"><a href="#一二级缓存一致性" class="headerlink" title="一二级缓存一致性"></a>一二级缓存一致性</h2><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p><p>这就是缓存雪崩。<br><img src="/2021/12/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li><li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。<br><img src="/2021/12/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3><p>对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。<br>黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。<br>举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。<br><img src="/2021/12/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png"></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>缓存空值，并设置过期时间。</p><p>每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p><h2 id="热数据"><a href="#热数据" class="headerlink" title="热数据"></a>热数据</h2><h2 id="数据并发竞争"><a href="#数据并发竞争" class="headerlink" title="数据并发竞争"></a>数据并发竞争</h2><h3 id="redis的并发竞争问题是什么"><a href="#redis的并发竞争问题是什么" class="headerlink" title="redis的并发竞争问题是什么"></a>redis的并发竞争问题是什么</h3><p>多客户端同时并发写一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>某个时刻，多个系统实例都去更新某个 key。可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。</p><h3 id="redis事务的CAS方案"><a href="#redis事务的CAS方案" class="headerlink" title="redis事务的CAS方案"></a>redis事务的CAS方案</h3><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><h2 id="缓存的数据结构"><a href="#缓存的数据结构" class="headerlink" title="缓存的数据结构"></a>缓存的数据结构</h2><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面经归纳</title>
      <link href="/2021/12/15/Java%E9%9D%A2%E7%BB%8F%E5%BD%92%E7%BA%B3/"/>
      <url>/2021/12/15/Java%E9%9D%A2%E7%BB%8F%E5%BD%92%E7%BA%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="重载（Overload）和重写（Override）的区别？"><a href="#重载（Overload）和重写（Override）的区别？" class="headerlink" title="重载（Overload）和重写（Override）的区别？"></a>重载（Overload）和重写（Override）的区别？</h3><p>方法的重载和重写都是实现多态的方式，区别在于重载实现的事编译时的多态性，重写实现的是运行时的多态性。<br>重载发生在一个类中，同名方法的参数列表（参数类型、参数个数、参数顺序）不同，与返回值类型无关。<br>重写发生在子类与父类之间，要求方法名、参数列表、返回类型必须相同，访问修饰符的限制要大于被重写方法，不能抛出比被重写方法更宽泛的异常。</p><h3 id="String-和-StringBuffer、StringBuilder-的区别？"><a href="#String-和-StringBuffer、StringBuilder-的区别？" class="headerlink" title="String 和 StringBuffer、StringBuilder 的区别？"></a>String 和 StringBuffer、StringBuilder 的区别？</h3><p>java.lang.String/StringBuffer/StringBuilder，三者的共同之处都是final类，不允许被继承。</p><ul><li><p>String implements java.io.Serializable, Comparable<String>, CharSequence</String></p></li><li><p>StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A cache of the last value returned by toString. </span></span><br><span class="line"><span class="comment">    * Cleared whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure><p>StringBuffer中的许多方法是用<code>synchronized</code>关键字修饰的。</p></li><li><p>StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence</p></li></ul><h3 id="String-为什么是不可变的？"><a href="#String-为什么是不可变的？" class="headerlink" title="String 为什么是不可变的？"></a>String 为什么是不可变的？</h3><p>不可变的对象：一个对象在它创建完成之后，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><p>String 用 <code>value[]</code> 来保存字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><p><code>value[]</code>是final修饰的，不能再指向其他数组对象，但是可以通过反射，反射出String对象的value属性，进而通过获得的value引用改变数组的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//创建字符串&quot;Hello World&quot;， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">&quot;Hello World&quot;</span>; </span><br><span class="line">     </span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">//Hello World</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">     </span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s);  <span class="comment">//Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动装箱与拆箱？"><a href="#自动装箱与拆箱？" class="headerlink" title="自动装箱与拆箱？"></a>自动装箱与拆箱？</h3><p>基本数据类型和其包装类型的自动转换。<br>自动装箱都是通过包装类的valueOf()方法来实现的.自动拆箱都是通过包装类对象的xxxValue()来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装箱</span></span><br><span class="line">Integer integer = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//反编译结果</span></span><br><span class="line">Integer integer = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆箱</span></span><br><span class="line"><span class="keyword">int</span> i = integer; </span><br><span class="line"><span class="comment">// 反编译结果</span></span><br><span class="line"><span class="keyword">int</span> i = integer.valueOf;</span><br></pre></td></tr></table></figure><h4 id="自动拆装箱的场景"><a href="#自动拆装箱的场景" class="headerlink" title="自动拆装箱的场景"></a>自动拆装箱的场景</h4><ol><li>将基本数据类型放入集合类。Java中的集合只能接收对象类型</li><li>包装类型和基本类型的大小比较</li><li>包装类型的运算</li><li>三目运算符的使用</li><li>函数参数与返回值</li></ol><h4 id="自动拆装箱与缓存"><a href="#自动拆装箱与缓存" class="headerlink" title="自动拆装箱与缓存"></a>自动拆装箱与缓存</h4><p>Integer的缓存机制：</p><ul><li>适用于整数值区间 -128到+127</li><li>只适用于自动装箱</li><li>使用构造函数创建对象不适用<br>当需要进行自动装箱时，如果数字在-128到+127之间，会直接使用缓存中的对象，而不是重新创建一个对象。</li></ul><h3 id="与-equals？"><a href="#与-equals？" class="headerlink" title="== 与 equals？"></a>== 与 equals？</h3><p><code>==</code>比较的是对象的引用，<code>equals</code>比较的是值。</p><h3 id="final-关键字？"><a href="#final-关键字？" class="headerlink" title="final 关键字？"></a>final 关键字？</h3><ul><li>final修饰类中的属性。该属性一旦被初始化便不可改变，对基本类型来说是其值不可变，对对象属性来说是其引用不可再变。</li><li>fianl修饰类中的方法。子类不可重写该方法。</li><li>final修饰类。该类不可被继承。</li></ul><h3 id="Object类的常见方法？"><a href="#Object类的常见方法？" class="headerlink" title="Object类的常见方法？"></a>Object类的常见方法？</h3><ul><li><p>toString()<br>获取对象信息方法。将对象的信息变为字符串返回，默认输出对象地址。</p></li><li><p>equals(Object obj)<br>对象相等判断方法。用于比较对象是否相等，而且此方法必须被重写。基本数据类型没有equals()方法。</p></li><li><p>hashCode()<br>对象签名。用来返回该对象的物理地址(哈希码值)，常会和<code>equals()</code>方法同时重写，确保两个相等的对象拥有相等的hashcode。</p></li><li><p>getClass()<br>返回此Object的运行时类。常用于<code>反射</code>中。</p></li><li><p>wait()</p></li><li><p>notify()</p></li><li><p>notifyAll()</p></li></ul><h3 id="Java-中的异常处理？"><a href="#Java-中的异常处理？" class="headerlink" title="Java 中的异常处理？"></a>Java 中的异常处理？</h3><h3 id="获取用键盘输入常用的的两种方法？"><a href="#获取用键盘输入常用的的两种方法？" class="headerlink" title="获取用键盘输入常用的的两种方法？"></a>获取用键盘输入常用的的两种方法？</h3><h3 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h3><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="描述一下-JVM-加载-Class-文件的原理机制？"><a href="#描述一下-JVM-加载-Class-文件的原理机制？" class="headerlink" title="描述一下 JVM 加载 Class 文件的原理机制？"></a>描述一下 JVM 加载 Class 文件的原理机制？</h3><h3 id="什么是tomcat类加载机制？"><a href="#什么是tomcat类加载机制？" class="headerlink" title="什么是tomcat类加载机制？"></a>什么是tomcat类加载机制？</h3><h3 id="类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？"><a href="#类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？" class="headerlink" title="类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？"></a>类加载器双亲委派模型机制？可以打破双亲委派吗？怎么打破？</h3><h3 id="垃圾回收常见问题。"><a href="#垃圾回收常见问题。" class="headerlink" title="垃圾回收常见问题。"></a>垃圾回收常见问题。</h3><h3 id="什么是GC-为什么要有-GC？"><a href="#什么是GC-为什么要有-GC？" class="headerlink" title="什么是GC? 为什么要有 GC？"></a>什么是GC? 为什么要有 GC？</h3><h3 id="简述一下Java-垃圾回收机制？"><a href="#简述一下Java-垃圾回收机制？" class="headerlink" title="简述一下Java 垃圾回收机制？"></a>简述一下Java 垃圾回收机制？</h3><h3 id="如何判断一个对象是否存活？"><a href="#如何判断一个对象是否存活？" class="headerlink" title="如何判断一个对象是否存活？"></a>如何判断一个对象是否存活？</h3><h3 id="垃圾回收的优点和原理，并考虑-2-种回收机制？"><a href="#垃圾回收的优点和原理，并考虑-2-种回收机制？" class="headerlink" title="垃圾回收的优点和原理，并考虑 2 种回收机制？"></a>垃圾回收的优点和原理，并考虑 2 种回收机制？</h3><h3 id="Java-中垃圾收集的方法有哪些？"><a href="#Java-中垃圾收集的方法有哪些？" class="headerlink" title="Java 中垃圾收集的方法有哪些？"></a>Java 中垃圾收集的方法有哪些？</h3><h3 id="讲讲你理解的性能评价及测试指标？"><a href="#讲讲你理解的性能评价及测试指标？" class="headerlink" title="讲讲你理解的性能评价及测试指标？"></a>讲讲你理解的性能评价及测试指标？</h3><h3 id="常用的性能优化方式有哪些？"><a href="#常用的性能优化方式有哪些？" class="headerlink" title="常用的性能优化方式有哪些？"></a>常用的性能优化方式有哪些？</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Arraylist-与-LinkedList-异同。"><a href="#Arraylist-与-LinkedList-异同。" class="headerlink" title="Arraylist 与 LinkedList 异同。"></a>Arraylist 与 LinkedList 异同。</h3><h3 id="ArrayList-与-Vector-区别。"><a href="#ArrayList-与-Vector-区别。" class="headerlink" title="ArrayList 与 Vector 区别。"></a>ArrayList 与 Vector 区别。</h3><h3 id="HashMap的底层实现。"><a href="#HashMap的底层实现。" class="headerlink" title="HashMap的底层实现。"></a>HashMap的底层实现。</h3><h3 id="HashMap-和-Hashtable-的区别。"><a href="#HashMap-和-Hashtable-的区别。" class="headerlink" title="HashMap 和 Hashtable 的区别。"></a>HashMap 和 Hashtable 的区别。</h3><h3 id="HashMap-的长度为什么是2的幂次方。"><a href="#HashMap-的长度为什么是2的幂次方。" class="headerlink" title="HashMap 的长度为什么是2的幂次方。"></a>HashMap 的长度为什么是2的幂次方。</h3><h3 id="HashMap-多线程操作导致死循环问题。"><a href="#HashMap-多线程操作导致死循环问题。" class="headerlink" title="HashMap 多线程操作导致死循环问题。"></a>HashMap 多线程操作导致死循环问题。</h3><h3 id="HashSet-和-HashMap-区别。"><a href="#HashSet-和-HashMap-区别。" class="headerlink" title="HashSet 和 HashMap 区别。"></a>HashSet 和 HashMap 区别。</h3><h3 id="ConcurrentHashMap-和-Hashtable-的区别。"><a href="#ConcurrentHashMap-和-Hashtable-的区别。" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别。"></a>ConcurrentHashMap 和 Hashtable 的区别。</h3><h3 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现。"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现。" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现。"></a>ConcurrentHashMap线程安全的具体实现方式/底层具体实现。</h3><h2 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发</h2><h3 id="AQS-原理。"><a href="#AQS-原理。" class="headerlink" title="AQS 原理。"></a>AQS 原理。</h3><h3 id="AQS-对资源的共享方式。"><a href="#AQS-对资源的共享方式。" class="headerlink" title="AQS 对资源的共享方式。"></a>AQS 对资源的共享方式。</h3><h3 id="AQS底层使用了模板方法模式。"><a href="#AQS底层使用了模板方法模式。" class="headerlink" title="AQS底层使用了模板方法模式。"></a>AQS底层使用了模板方法模式。</h3><h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><h3 id="synchronized关键字。"><a href="#synchronized关键字。" class="headerlink" title="synchronized关键字。"></a>synchronized关键字。</h3><h3 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗？"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗？" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？</h3><h3 id="讲一下-synchronized-关键字的底层原理。"><a href="#讲一下-synchronized-关键字的底层原理。" class="headerlink" title="讲一下 synchronized 关键字的底层原理。"></a>讲一下 synchronized 关键字的底层原理。</h3><h3 id="说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"><a href="#说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？" class="headerlink" title="说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"></a>说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</h3><h3 id="谈谈-synchronized和ReenTrantLock-的区别。"><a href="#谈谈-synchronized和ReenTrantLock-的区别。" class="headerlink" title="谈谈 synchronized和ReenTrantLock 的区别。"></a>谈谈 synchronized和ReenTrantLock 的区别。</h3><h3 id="说说-synchronized-关键字和-volatile-关键字的区别。"><a href="#说说-synchronized-关键字和-volatile-关键字的区别。" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别。"></a>说说 synchronized 关键字和 volatile 关键字的区别。</h3><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><h3 id="实现Runnable接口和Callable接口的区别。"><a href="#实现Runnable接口和Callable接口的区别。" class="headerlink" title="实现Runnable接口和Callable接口的区别。"></a>实现Runnable接口和Callable接口的区别。</h3><h3 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a>执行execute()方法和submit()方法的区别是什么呢？</h3><h3 id="如何创建线程池。"><a href="#如何创建线程池。" class="headerlink" title="如何创建线程池。"></a>如何创建线程池。</h3><h3 id="介绍一下Atomic-原子类。"><a href="#介绍一下Atomic-原子类。" class="headerlink" title="介绍一下Atomic 原子类。"></a>介绍一下Atomic 原子类。</h3><h3 id="JUC-包中的原子类是哪4类？"><a href="#JUC-包中的原子类是哪4类？" class="headerlink" title="JUC 包中的原子类是哪4类？"></a>JUC 包中的原子类是哪4类？</h3><h3 id="讲讲-AtomicInteger-的使用。"><a href="#讲讲-AtomicInteger-的使用。" class="headerlink" title="讲讲 AtomicInteger 的使用。"></a>讲讲 AtomicInteger 的使用。</h3><h3 id="能不能给我简单介绍一下-AtomicInteger-类的原理？"><a href="#能不能给我简单介绍一下-AtomicInteger-类的原理？" class="headerlink" title="能不能给我简单介绍一下 AtomicInteger 类的原理？"></a>能不能给我简单介绍一下 AtomicInteger 类的原理？</h3><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><h2 id="网络-TCP"><a href="#网络-TCP" class="headerlink" title="网络-TCP"></a>网络-TCP</h2><h2 id="网络-HTTP"><a href="#网络-HTTP" class="headerlink" title="网络-HTTP"></a>网络-HTTP</h2><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愛彌留</title>
      <link href="/2021/11/25/%E6%B8%AF%E4%B9%90-%E6%84%9B%E5%BD%8C%E7%95%99/"/>
      <url>/2021/11/25/%E6%B8%AF%E4%B9%90-%E6%84%9B%E5%BD%8C%E7%95%99/</url>
      
        <content type="html"><![CDATA[<p>爱弥留 - 达明一派<br>词：周耀辉<br>曲：刘以达</p><p>请收起你的温柔<br>浮在水仙中的杀手<br>请收起你的风流<br>垂在钟摆间的借口<br>明白我始终必须远走<br>但请不要为我忧愁<br>蝴蝶总比沙丘永久<br>但请相信我的荒谬<br>纵使真的不想远走<br>明白我始终必须远走<br>象我这永没法解释的苍白<br>象永远盖着扑克<br>象永远在转圈圈的笔画<br>一生不过揣测<br>象我这永没法青春的生命<br>象永远转换布景<br>象永远在转圈圈的花瓶<br>一生不过一声<br>没一刻可以安静</p><p>请不要问我今后<br>藏在死水中的缺口<br>请相信我的恳求<br>忘掉总比思忆永久<br>明白我始终必须远走<br>象我这永没法解释的苍白<br>象永远盖着扑克<br>象永远在转圈圈的笔画<br>一生不过揣测<br>象我这永没法青春的生命<br>象永远转换布景<br>象永远在转圈圈的花瓶<br>一生不过一声<br>没一刻可以安静</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 港乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天起的每晚 你要珍惜岁月</title>
      <link href="/2021/11/21/%E9%9A%8F%E7%AC%94-%E4%BB%8A%E5%A4%A9%E8%B5%B7%E7%9A%84%E6%AF%8F%E6%99%9A-%E4%BD%A0%E8%A6%81%E7%8F%8D%E6%83%9C%E5%B2%81%E6%9C%88/"/>
      <url>/2021/11/21/%E9%9A%8F%E7%AC%94-%E4%BB%8A%E5%A4%A9%E8%B5%B7%E7%9A%84%E6%AF%8F%E6%99%9A-%E4%BD%A0%E8%A6%81%E7%8F%8D%E6%83%9C%E5%B2%81%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<p>今天花了几个小时的时间把hexo从windows迁到mac上。<br>上一次的记录时间是<code>2019-11-24</code>，今天是<code>2021-11-21</code>。<br>两年了，重新出发吧。</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2020/10/27/Spring/"/>
      <url>/2020/10/27/Spring/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发记录—爱河</title>
      <link href="/2019/11/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/11/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>2019-11-24<br>6-3 盐与密码加密的小知识_batch<br>6-4 模型的set操作_batch<br>6-5 Success操作成功处理_batch<br>6-6 isOptional校验_batch<br>6-7 模拟枚举_batch<br>6-8 验证用户账号密码_batch<br>7-1 jsonwebtoken_batch<br>7-2 HttpBasicAuth传递令牌_batch<br>7-3 验证JWT令牌_batch<br>7-4 API权限分级控制_batch</p><p>2019-11-22<br>前端完成了二分之一，墜入-fall、耽于-down两个模块进行完毕，我的-mine模块后期可能会调整，最重要的模块沉沦-sink还无从下手。<br>后面会先设计沉沦-sink模块的布局，或者继续服务端的开发。</p><p>2019-09-26<br>6-3盐与加密</p><p>2019-09-23<br>全局异常处理 监听任何异常<br>捕捉异常是需要告诉用户或者告诉自己用来排查错误<br>5-2Lin-validator获取http参数</p><p>2019-08-07<br>netty相关知识<br>netty的线程模型：单线程模型、多线程模型、主从线程模型。<br>单线程模型：所有的IO操作都有同一个NIO线程处理。<br>多线程模型：由一组NIO线程处理IO操作。<br>主从线程模型：一组线程池接受请求，一组线程池处理IO。</p><p>2019-08-06<br>仿七月《旧岛》完成“墜入”模块的开发。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-索引</title>
      <link href="/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL为什么使用B-TRee"><a href="#MySQL为什么使用B-TRee" class="headerlink" title="MySQL为什么使用B+TRee"></a>MySQL为什么使用B+TRee</h2><p>文件系统及数据库系统普通采用<code>B-/+Tree</code>作为索引结构。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/P操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li></ol><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ol><li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)。B+树只有叶子节点保存了data，时间复杂度固定为 O(log n)。</li><li>为所有叶子结点增加了一个链指针</li></ol><h3 id="MySQL-InnoDB存储引擎中B-树一个节点有多大？一千万条数据，B-树多高？"><a href="#MySQL-InnoDB存储引擎中B-树一个节点有多大？一千万条数据，B-树多高？" class="headerlink" title="MySQL InnoDB存储引擎中B+树一个节点有多大？一千万条数据，B+树多高？"></a>MySQL InnoDB存储引擎中B+树一个节点有多大？一千万条数据，B+树多高？</h3><h4 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h4><ol><li>数据持久化存储磁盘里，磁盘的最小单元是扇区，一个扇区的大小是 512个字节</li><li>文件系统的最小单元是块，一个块的大小是 4K</li><li>InnoDB存储引擎，有自己的最小单元，称之为页，一个页的大小是 16K</li></ol><h4 id="InnoDB引擎的页大小"><a href="#InnoDB引擎的页大小" class="headerlink" title="InnoDB引擎的页大小"></a>InnoDB引擎的页大小</h4><p>InnoDB存储引擎的最小存储单位是页，页的大小为<code>16K = 16384Byte</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_page_size&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/innodb-pagesize.jpg"></p><h5 id="B-树的存储结构"><a href="#B-树的存储结构" class="headerlink" title="B+树的存储结构"></a>B+树的存储结构</h5><p>B+树的叶子节点和非叶子节点的大小为一页，16K。</p><ul><li>叶子节点存放<code>数据</code>，非叶子节点存放<code>指针和键值</code></li><li>主键索引：叶子节点存放真正的数据</li><li>二级索引：叶子节点存放主键索引的值</li></ul><p><img src="/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/innodb-b+.jpg"></p><h5 id="B-树如何检索记录"><a href="#B-树如何检索记录" class="headerlink" title="B+树如何检索记录"></a>B+树如何检索记录</h5><ul><li>首先找到根页，你怎么知道一张表的根页在哪呢？</li><li>其实每张表的根页位置在表空间文件中是固定的，即page number=3的页</li><li>找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中</li><li>然后再去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录</li></ul><p>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据。</p><h4 id="叶子节点可以存放多少行数据"><a href="#叶子节点可以存放多少行数据" class="headerlink" title="叶子节点可以存放多少行数据"></a>叶子节点可以存放多少行数据</h4><p>单个叶子节点（也就是一页）的大小为16K。<br>一行记录的数据大小为数据表各字段的大小的和，假设为1K。</p><h4 id="非叶子节点可以存放多少指针"><a href="#非叶子节点可以存放多少指针" class="headerlink" title="非叶子节点可以存放多少指针"></a>非叶子节点可以存放多少指针</h4><p>单个非叶子节点的大小也为一页，16K。<br>非叶子节点存储<code>指针和键值</code>，假设主键为bigint类型，长度为8字节，指针大小在InnoDB中的大小为6字节，指针+键值一共14字节。<br>一个页中能够存放<code>16384 / 14 = 1170</code>个单元，这也是指针的个数。</p><h4 id="一颗B-树可以存放多少行记录"><a href="#一颗B-树可以存放多少行记录" class="headerlink" title="一颗B+树可以存放多少行记录"></a>一颗B+树可以存放多少行记录</h4><p>假设树高为k，B+树可存储的记录行数 = （非叶子节点的指针个数）的k-1次方 * 叶子节点的记录行数。</p><h2 id="索引相关概念"><a href="#索引相关概念" class="headerlink" title="索引相关概念"></a>索引相关概念</h2><h3 id="1-索引基础"><a href="#1-索引基础" class="headerlink" title="1.索引基础"></a>1.索引基础</h3><p>索引对查询的速度有着至关重要的的影响，理解索引也是进行数据库性能调优的起点。<br>索引就是提高数据查询的效率的一种数据结构。索引可以包含一个或多个列的值，如果索引包含多个列的值，则列的顺序也很重要，因为mysql只能高效的使用索引的最左前缀列。</p><h3 id="2-索引类型"><a href="#2-索引类型" class="headerlink" title="2.索引类型"></a>2.索引类型</h3><ol><li><p>哈希表<br>哈希表是一种以键-值(key-value)的方式存储数据的结构，我们只要输入待查找的值(key)，就可以找到对应的值(value)。<br>哈希的思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后value放在数组的这个位置，即idx=hash(key)。如果出现哈希冲突，采用拉链法解决。<br>因为哈希表中存放的数据不是有序的，因此不适合做区间查询，适用于只有等值查询的场景。</p></li><li><p>有序数组<br>有序数组在等值查询和范围查询场景中的性能都非常优秀。用二分法就可以快速找到(时间复杂度为O(logN))。但是如果要往中间插入一条数据，则必须挪动后面的所有记录，成本较高。因此，有序数组只适用于静态存储引擎，即数据表一旦建立后不再会修改。</p></li><li><p>搜索树— B+树索引(InnoDB)<br>使用B+树存储数据可以让一个查询尽量少的读磁盘，从而减少查询时磁盘I/O的时间。<br>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。<br>InnoDB使用了B+树索引模型，数据都是存储在B+树中的。每一个索引在InnoDB里面对应一颗B+树。<br>假设，有这样一张表：该表主键为ID，且还有一个字段k，并在k上有索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE T(</span><br><span class="line">    id int primary key,</span><br><span class="line">    k int not null,</span><br><span class="line">    index (k)</span><br><span class="line">)engine=InnoDB;</span><br></pre></td></tr></table></figure><p>表中有5条记录，分别为R1~R5，(100,1)、(200,2)、(300,3)、(500,5)和(600,6)。则在InnoDB中的索引组织结构是这样的：<br><img src="/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/IDandIndex-k.png"><br>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p></li></ol><ul><li>主键索引的叶子节点存的是整条记录，主键索引也被称为聚簇索引(clustered index)。</li><li>非主键索引的叶子节点存的是主键的值，非主键索引也被称为二级索引(secondary index)/普通索引/辅助索引。</li></ul><p>那么，<strong>基于主键索引和非主键索引的查询有什么区别？</strong></p><ul><li>如果语句是select * from T where ID=500，即主键查询，则只需要搜索ID这棵树。</li><li>如果语句是select * from T where k=5，即非主键索引查询，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。从非主键索引回到主键索引的过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。而从存储空间的角度讲，因为非主键索引树的叶结点存放的是主键的值，那么，应该考虑让主键的字段尽量短，这样非主键索引的叶子结点就越小，非主键索引占用的空间也就越小。一般情况下，建议创建一个自增主键，这样非主键索引占用的空间最小。</p><h3 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3.联合索引"></a>3.联合索引</h3><p>联合索引是指对表上的多个列进行索引。<br>假设有下面这样一张表，有这样一个需求，我们需要查询某个用户的购物情况，并按照时间进行排序，取出某用户近几次的购物情况。（注：例子来源于《MySQL技术内幕》）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 表</span><br><span class="line">CREATE TABLE buylog(</span><br><span class="line">    userid int not null,</span><br><span class="line">    buy_date DATE</span><br><span class="line">)ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">// 插入数据</span><br><span class="line">insert into buylog values(1, &#x27;2019-08-13&#x27;);</span><br><span class="line">insert into buylog values(2, &#x27;2019-08-14&#x27;);</span><br><span class="line">insert into buylog values(3, &#x27;2019-08-15&#x27;);</span><br><span class="line">insert into buylog values(1, &#x27;2019-08-11&#x27;);</span><br><span class="line">insert into buylog values(3, &#x27;2019-08-10&#x27;);</span><br><span class="line">insert into buylog values(1, &#x27;2019-08-12&#x27;);</span><br><span class="line"></span><br><span class="line">// 添加索引</span><br><span class="line">alter table buylog add index(userid);</span><br><span class="line">alter table buylog add index(userid, buy_date);</span><br><span class="line">// （或用key关键字也一样的）</span><br><span class="line">alter table buylog add key(userid);</span><br><span class="line">alter table buylog add key(userid, buy_date);</span><br></pre></td></tr></table></figure><p>上面的代码建立了两个索引，两个索引都包含了userid字段。</p><p>如果只对于userid进行查询，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from buylog where userid=2;</span><br></pre></td></tr></table></figure><p>通过<strong>explain</strong>查看该语句的执行情况，如下：<br><img src="/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/explain1.png"><br>可以看到，possible_keys在这里有两个索引可供使用，分别是userid索引和(userid,buy_date)联合索引。优化器最终选择的索引（即key）是userid，因为该索引的叶子节点只包含单个键值，所以理论上一页能存放的记录会更多（意味着可以减少查询的次数）。</p><p>接着假定要查询userid为1的最近两次的购买记录，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from buylog where userid=1 order by buy_date desc limit 2;</span><br></pre></td></tr></table></figure><p>同样的，我们看一下它的执行过程是怎样的，如下：<br><img src="/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/explain2.png"><br>可以看到，这一次查询优化器选择的索引是userid_2（也就是(userid, buy_date)联合索引）。为什么呢？因为在这个联合索引中，记录已经分别根据userid和buy_date排好序了，利用这个索引则可以直接取出相应的数据而无需再对buy_date额外做一次排序操作了。如果强制使用userid索引，则它的执行计划如下：<br><img src="/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/explain3.png"><br>从Extra字段可以看出，该语句的执行需要使用fliesort，也就是需要一次额外的排序操作才能完成查询。显然，这个排序就是对buy_date字段的排序，因为这里仅使用了userid索引，该索引未对buy_date进行排序。</p><p>总结：<br>联合索引(a, b)是根据a, b进行排序（先根据a排序，如果a相同则根据b排序）。<br>因此，下列语句可以直接使用联合索引得到结果（事实上，也就是用到了最左前缀原则）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ... from xxx where a=xxx; </span><br><span class="line">select ... from xxx where a=xxx order by b;</span><br></pre></td></tr></table></figure><p>而下列语句则不能使用联合查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... from xxx where b=xxx;</span><br></pre></td></tr></table></figure><p>对于联合索引(a, b, c)，下列语句同样可以直接通过联合索引得到结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ... from xxx where a=xxx order by b;</span><br><span class="line">select ... from xxx where a=xxx and b=xxx order by c;</span><br></pre></td></tr></table></figure><p>而下列语句则不行，需要执行一次filesort排序操作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... from xxx where a=xxx order by c;</span><br></pre></td></tr></table></figure><h3 id="4-最左前缀匹配原则"><a href="#4-最左前缀匹配原则" class="headerlink" title="4.最左前缀匹配原则"></a>4.最左前缀匹配原则</h3><p>对于有很多字段的一张表，查询的方式是多样的，难道要为了每一种可能的查询都定义索引吗？这样岂不是很浪费空间，毕竟建索引也是需要一些空间的。事实上，B+ 树这种索引结构，可以利用索引的“最左前缀”原则来定位记录，避免重复定义索引。</p><p>以下面的例子进行说明什么是“最左前缀原则”：<br><img src="/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/zuizuoqianzhui.jpg"></p><p>假设建立了一个联合索引(name,age)，可以看到，索引项是按照索引定义里面出现的字段顺序排序的，先根据名字排序，名字相同的就根据年龄排序。</p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p><p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p><p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><p>因此，基于最左前缀原则，我们在定义联合索引的时候，考虑如何安排索引内的字段顺序就至关重要了！评估的标准就是索引的复用能力，比如，当已经有了(a,b)字段的索引，一般就不需要再单独在a上建立索引了。</p><h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5.覆盖索引"></a>5.覆盖索引</h3><p>还是利用“2.3 B+树索引”提到过的表，如果执行的语句是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where k between 3 and 5;</span><br></pre></td></tr></table></figure><p>则这条SQL语句的执行流程如下：</p><ol><li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li><li>再到 ID 索引树查到 ID=300 对应的 R3；</li><li>在 k 索引树取下一个值 k=5，取得 ID=500；</li><li>再回到 ID 索引树查到 ID=500 对应的 R4；</li><li>在 k 索引树取下一个值k=6，不满足条件，循环结束。</li></ol><p>在这个过程中，回到主键索引树的过程，称为回表。在这个例子中，由于查询的结果是所有字段，所需要的数据只有主键上才有，所以不得不回表。<br>但如果执行的语句是下面这样的，注意！这里查询的结果只是“ID”（恰好是主键），而不是所有字段了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ID from T where k between 3 and 5;</span><br></pre></td></tr></table></figure><p>由于查询的值是ID，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里，索引k已经“覆盖了”我们的查询需求，故称为覆盖索引。</p><p>除了上面这种情况，针对某些统计问题时，覆盖索引也能发挥用处。还是以上面的例子，执行如下语句来统计表的记录总数（在此我们假设这张表数据量特别特别大，需要多次磁盘IO）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from T;</span><br></pre></td></tr></table></figure><p>如果没有对字段k设置索引，那么只能是通过聚簇索引来计算；如果对字段k设置了索引，那么，由于聚簇索引的叶结点存放的是整行记录的所有信息，而辅助索引的叶结点只存放主键，两者相比，对于一页内存，显然辅助索引能够存放的节点更多，意味着辅助索引可以减少IO次数，从而更快的计算出count()的值。</p><p>验证如下：<br>没有对字段k设置索引时，优化器会选择聚簇索引进行操作（即key为PRIMARY）:<br><img src="/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/explain4.png"></p><p>对字段k设置了索引时，优化器会选择辅助索引进行操作（即key为k）:<br><img src="/2019/11/22/MySQL-%E7%B4%A2%E5%BC%95/explain5.png"></p><p>可见，如果建立了辅助索引，在有些场景下，优化器会自动使用辅助索引从而提升查询效率。</p><p>总结：覆盖索引就是从辅助索引中就能直接得到查询结果，而不需要回表到聚簇索引中进行再次查询，所以可以减少搜索次数（不需要从辅助索引树回表到聚簇索引树），或者说减少IO操作（通过辅助索引树可以一次性从磁盘载入更多节点），从而提升性能。</p><h3 id="6-索引下推"><a href="#6-索引下推" class="headerlink" title="6.索引下推"></a>6.索引下推</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8—接口中的静态方法和默认方法</title>
      <link href="/2019/11/08/java8%E2%80%94%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
      <url>/2019/11/08/java8%E2%80%94%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、默认方法-default修饰"><a href="#一、默认方法-default修饰" class="headerlink" title="一、默认方法(default修饰)"></a>一、默认方法(default修饰)</h3><p>在java8中因为存在函数式接口，一个函数式接口中只能存在一个普通方法，但是可以写多个默认方法，来为实现类提供方法实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    default String getName () &#123;</span><br><span class="line">        return &quot;张三&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    default String getAge () &#123;</span><br><span class="line">        return &quot;13&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 普通方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String getHome ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然接口中可以写方法的实现，那么就会出现与父类之间冲突的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public String getName () &#123;</span><br><span class="line">        return &quot;李四&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的类中同样存在一个方法getName()，如果有一个类既实现MyInterface接口，又继承MyClass类，那么这个类的getName方法到底使用接口中的还是父类中的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class My_JAVA8_Test extends MyClass implements MyInterface&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        My_JAVA8_Test test = new My_JAVA8_Test();</span><br><span class="line">        System.out.println(test.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String getHome() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是“李四”，这里有一个类优先的原则：若一个接口中定义了一个默认方法，而另一个父类中又定义了一个同名方法时，选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。</p><p>如果，此时，再定义一个接口，里面也有一个方法叫做getName，而一个类去同时实现这两个接口。那么这个类的getName方法到底会执行哪一个？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface MyFun &#123;</span><br><span class="line"></span><br><span class="line">    default String getName () &#123;</span><br><span class="line">        return &quot;王五&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class My_JAVA8_Test implements MyInterface, MyFun&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        My_JAVA8_Test test = new My_JAVA8_Test();</span><br><span class="line">        System.out.println(test.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String getHome() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 此时，类会让我们自己去重写，也可以自己选择使用上面2个接口中的方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return MyFun.super.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若一个接口中定义了一个默认方法，而另外一个接口中又定义了一个同名方法时，接口冲突。不管是否是默认方法，必须覆盖该方法来解决冲突。</p><h3 id="二、静态方法"><a href="#二、静态方法" class="headerlink" title="二、静态方法"></a>二、静态方法</h3><p>java8中的静态方法，使用方式： 接口名.方法名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface MyFun &#123;</span><br><span class="line"></span><br><span class="line">    default String getName () &#123;</span><br><span class="line">        return &quot;王五&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static void test () &#123;</span><br><span class="line">        System.out.println(&quot;测试接口中静态方法！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyFun.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8—Stream API</title>
      <link href="/2019/11/07/java8%E2%80%94Stream-API/"/>
      <url>/2019/11/07/java8%E2%80%94Stream-API/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是Stream"><a href="#一、什么是Stream" class="headerlink" title="一、什么是Stream"></a>一、什么是Stream</h3><p>Stream是java8中处理集合的关键抽象概念，它可以指定我们希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API对集合数据进行操作，就类似使用SQL执行的数据库查询。也可以使用Stream API来并行执行操作。简而言之，Stream API提供了一种高效且易于使用的处理数据的方式。<br>在Stream操作过程中，可以对数据流做过滤、排序、切片等操作，但是操作之后会产生一个新的流，而数据源则不会发生改变。<br>Stream是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列，而集合讲的是数据，流讲的是计算。<br>注意：</p><ol><li>Stream自己不会存储元素。</li><li>Stream不会改变元对象，相反，它会返回一个持有结果的新Stream。</li><li>Stream操作时延迟执行，这意味着它们会等到需要结果时才执行。(延迟加载)</li></ol><h3 id="二、Stream操作的三个步骤"><a href="#二、Stream操作的三个步骤" class="headerlink" title="二、Stream操作的三个步骤"></a>二、Stream操作的三个步骤</h3><ol><li>创建Stream：一个数据源(集合、数组)，获取一个流。</li><li>中间操作：一个中间操作链，对数据源的数据进行处理。</li><li>终止操作：一个终止操作，执行中间操作链，并产生结果。</li></ol><h3 id="三、创建Stream的四种方式"><a href="#三、创建Stream的四种方式" class="headerlink" title="三、创建Stream的四种方式"></a>三、创建Stream的四种方式</h3><h4 id="1-通过Collection的stream-方法—串行流或者parallelStream-方法—并行流创建Stream"><a href="#1-通过Collection的stream-方法—串行流或者parallelStream-方法—并行流创建Stream" class="headerlink" title="1.通过Collection的stream()方法—串行流或者parallelStream()方法—并行流创建Stream"></a>1.通过Collection的stream()方法—串行流或者parallelStream()方法—并行流创建Stream</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 创建 Stream的四种方式</span><br><span class="line">    * 1.通过Collection得Stream（）方法（串行流）</span><br><span class="line">           或者 parallelStream（）方法（并行流）创建Stream</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test1 () &#123;</span><br><span class="line">       // 1. 通过Collection的Stream()方法（串行流）</span><br><span class="line">       // 或者 parallelStream()方法（并行流）创建Stream</span><br><span class="line">       List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">       Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line">       Stream&lt;String&gt; stream2 = list.parallelStream();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2-通过Arrays中的静态方法stream-获取数组流"><a href="#2-通过Arrays中的静态方法stream-获取数组流" class="headerlink" title="2.通过Arrays中的静态方法stream()获取数组流"></a>2.通过Arrays中的静态方法stream()获取数组流</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 创建 Stream的四种方式</span><br><span class="line">    * 2. 通过Arrays中得静态方法stream()获取数组流</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test2 () &#123;</span><br><span class="line">       // 2. 通过Arrays中得静态方法stream()获取数组流</span><br><span class="line">       IntStream stream = Arrays.stream(new int[]&#123;3,5&#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-通过Stream类中的of-静态方法获取流"><a href="#3-通过Stream类中的of-静态方法获取流" class="headerlink" title="3.通过Stream类中的of()静态方法获取流"></a>3.通过Stream类中的of()静态方法获取流</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 创建 Stream的四种方式</span><br><span class="line">    * 3. 通过Stream类中得 of（）静态方法获取流</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test3 () &#123;</span><br><span class="line">       // 3. 通过Stream类中得of()静态方法获取流</span><br><span class="line">       Stream&lt;String&gt; stream = Stream.of(&quot;4645&quot;, &quot;huinnj&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="4-创建无限流-迭代、生成"><a href="#4-创建无限流-迭代、生成" class="headerlink" title="4.创建无限流(迭代、生成)"></a>4.创建无限流(迭代、生成)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 创建 Stream的四种方式</span><br><span class="line">    * 4. 创建无限流(迭代、生成)</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test4 () &#123;</span><br><span class="line">       // 4. 创建无限流</span><br><span class="line">       // 迭代（需要传入一个种子，也就是起始值，然后传入一个一元操作）</span><br><span class="line">       Stream&lt;Integer&gt; stream1 = Stream.iterate(2, (x) -&gt; x * 2);</span><br><span class="line">       </span><br><span class="line">       // 生成(无限产生对象)</span><br><span class="line">       Stream&lt;Double&gt; stream2 = Stream.generate(() -&gt; Math.random());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="四、Stream中间操作"><a href="#四、Stream中间操作" class="headerlink" title="四、Stream中间操作"></a>四、Stream中间操作</h3><p>多个中间操作可以连接起来形成一个流程线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理，而终止操作时一次性全部处理，称为“延迟加载”。</p><h4 id="1-筛选与切片"><a href="#1-筛选与切片" class="headerlink" title="1.筛选与切片"></a>1.筛选与切片</h4><ol><li>filter ——接收lambda，从流中排除某些元素<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 筛选与切片</span><br><span class="line">    *  filter —— 接收Lambda ，从流中排除某些元素。</span><br><span class="line">    *  </span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test5 () &#123;</span><br><span class="line">       //内部迭代：在此过程中没有进行过迭代，由Stream api进行迭代</span><br><span class="line">       //中间操作：不会执行任何操作</span><br><span class="line">       Stream&lt;Person&gt; stream = list.stream().filter((e) -&gt; &#123;</span><br><span class="line">           System.out.println(&quot;Stream API 中间操作&quot;);</span><br><span class="line">           return e.getAge() &gt; 30;</span><br><span class="line">       &#125;);</span><br><span class="line">       </span><br><span class="line">       //终止操作：只有执行终止操作才会执行全部。即：延迟加载 </span><br><span class="line">       stream.forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>在执行终止语句之后，一边迭代，一边打印，而并没有去迭代上面集合，这是内部迭代，由Stream API完成。<br>以下是外部迭代，人为的迭代。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void test6 () &#123;</span><br><span class="line">       //外部迭代</span><br><span class="line">       Iterator&lt;Person&gt; it = list.iterator();</span><br><span class="line">       while (it.hasNext()) &#123;</span><br><span class="line">           System.out.println(it.next());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>limit ——截断流，使其元素不超过给定数量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * limit —— 截断流，使其元素不超过给定数量。</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test7 () &#123;</span><br><span class="line">       //过滤之后取2个值</span><br><span class="line">       list.stream().filter((e) -&gt; e.getAge() &gt;30 ).</span><br><span class="line">       limit(2).forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>在这里，可以配合其他的中间操作，并截断流，使得可以取得相应个数的元素。<br>在上面的计算中，只要发现有2条符合条件的元素，则不会继续往下迭代数据，可以提高效率。</li></ol><h4 id="2-跳过元素"><a href="#2-跳过元素" class="headerlink" title="2.跳过元素"></a>2.跳过元素</h4><p>skip(n)，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空，与limit(n)互补。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * skip（n）—— 跳过元素，返回一个扔掉了前n个元素的流。</span><br><span class="line">    * 若流中元素不足n个，则返回一个空，与limit（n）互补。</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test8 () &#123;</span><br><span class="line">       //跳过前2个值</span><br><span class="line">       list.stream().skip(2).forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-筛选"><a href="#3-筛选" class="headerlink" title="3.筛选"></a>3.筛选</h4><p>distinct()，通过流所生成元素的hashCode()和equals()去除重复元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * distinct —— 筛选，通过流所生成元素的hashCode（）和equals（）去除重复元素</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test9 () &#123;</span><br><span class="line">       list.stream().distinct().forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注意：distinct()需要实体中重写hashCode()和equals()方法才可以使用。</p><h4 id="4-映射"><a href="#4-映射" class="headerlink" title="4.映射"></a>4.映射</h4><ol><li><p>map()，将元素转换成其他形式或者提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * map —— 映射 ，将元素转换成其他形式或者提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test10 () &#123;</span><br><span class="line">       //将流中每一个元素都映射到map的函数中，每个元素执行这个函数，再返回</span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;);</span><br><span class="line">       list.stream().map((e) -&gt; e.toUpperCase()).forEach(System.out::printf);</span><br><span class="line">   </span><br><span class="line">       //获取Person中的每一个人得名字name，再返回一个集合</span><br><span class="line">       List&lt;String&gt; names = this.list.stream().map(Person :: getName).collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>flatMap，接收一个函数作为参数，将流中的每个值都换成一个流，然后把所有流连接成一个流。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * flatMap —— 接收一个函数作为参数，将流中的每个值都换成一个流，然后把所有流连接成一个流</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test11 () &#123;</span><br><span class="line">       StreamAPI_Test s = new StreamAPI_Test();</span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;);</span><br><span class="line">       list.stream().flatMap((e) -&gt; s.filterCharacter(e)).forEach(System.out::println);</span><br><span class="line">       </span><br><span class="line">       //如果使用map则需要这样写</span><br><span class="line">       list.stream().map((e) -&gt; s.filterCharacter(e)).forEach((e) -&gt; &#123;</span><br><span class="line">           e.forEach(System.out::println);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">    * 将一个字符串转换为流</span><br><span class="line">    * @param str</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public Stream&lt;Character&gt; filterCharacter(String str)&#123;</span><br><span class="line">       List&lt;Character&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">       for (Character ch : str.toCharArray()) &#123;</span><br><span class="line">           list.add(ch);</span><br><span class="line">       &#125;</span><br><span class="line">       return list.stream();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其实map()方法就相当于Collection的add()方法，如果add的是一个集合的话就会变成二维数组，而flatMap的话就相当于Collection的addAll()方法，参数如果是集合的话，只是将2个集合合并，而不是变成二维数组。</p></li></ol><h4 id="5-排序"><a href="#5-排序" class="headerlink" title="5.排序"></a>5.排序</h4><p>sorted()有两种方法，一种是不传任何参数，叫自然排序，还有一种需要传Comparator接口参数，叫做定制排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * sorted有两种方法，一种是不传任何参数，叫自然排序，还有一种需要传Comparator接口参数，叫做定制排序。</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test12 () &#123;</span><br><span class="line">       // 自然排序</span><br><span class="line">       List&lt;Person&gt; persons = list.stream().sorted().collect(Collectors.toList());</span><br><span class="line">       </span><br><span class="line">       //定制排序</span><br><span class="line">       List&lt;Person&gt; persons1 = list.stream().sorted((e1, e2) -&gt; &#123;</span><br><span class="line">           if (e1.getAge() == e2.getAge()) &#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125; else if (e1.getAge() &gt; e2.getAge()) &#123;</span><br><span class="line">               return 1;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return -1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="五、Stream终止操作"><a href="#五、Stream终止操作" class="headerlink" title="五、Stream终止操作"></a>五、Stream终止操作</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8—方法引用与构造器引用</title>
      <link href="/2019/11/07/java8%E2%80%94%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8/"/>
      <url>/2019/11/07/java8%E2%80%94%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>若lambda体中的内容已经有方法实现了，我们可以使用方法引用。可以理解为方法引用为lambda表达式的另一种表现形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void test1() &#123;</span><br><span class="line">       Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);</span><br><span class="line">       </span><br><span class="line">       //下面这种写法与上面写法效果一致</span><br><span class="line">       PrintStream pr = System.out;</span><br><span class="line">       Consumer&lt;String&gt; con1 = pr :: println;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>要想使用方法引用，就必须要实现的方法的返回值和参数与函数式接口中的返回值和参数一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void test2() &#123;</span><br><span class="line">       Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">       int b = com.compare(5, 6);</span><br><span class="line">       </span><br><span class="line">       Comparator&lt;Integer&gt; com1 = Integer :: compare;</span><br><span class="line">       int c = com1.compare(7, 8);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void test3() &#123;</span><br><span class="line">       BiPredicate&lt;String, String&gt; bi = (x, y) -&gt; x.equals(y);</span><br><span class="line">        </span><br><span class="line">       BiPredicate&lt;String, String&gt; bi1 = String :: equals;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><p>格式：  ClassName::new</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 无参构造函数</span><br><span class="line">   @Test</span><br><span class="line">   public void test4() &#123;</span><br><span class="line">       Supplier&lt;Encoder&gt; su = () -&gt; new Encoder();</span><br><span class="line">       Supplier&lt;Encoder&gt; su1 = Encoder :: new;</span><br><span class="line"></span><br><span class="line">// supplier.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 有参构造函数</span><br><span class="line">   @Test</span><br><span class="line">   public void test5() &#123;</span><br><span class="line">       Function&lt;Integer, Integer&gt; fun = (x) -&gt; new Integer(x);</span><br><span class="line">       Function&lt;Integer, Integer&gt; fun1 = Integer :: new;</span><br><span class="line"></span><br><span class="line">       // function.apply(x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h2><p>格式： Type::new</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test6() &#123;</span><br><span class="line">    Function&lt;Integer, String[]&gt; fun = (x) -&gt; new String[x];</span><br><span class="line">    </span><br><span class="line">    Function&lt;Integer, String[]&gt; fun1 = String[] :: new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8—四大内置核心函数式接口详解</title>
      <link href="/2019/11/07/java8-%E5%9B%9B%E5%A4%A7%E5%86%85%E7%BD%AE%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/11/07/java8-%E5%9B%9B%E5%A4%A7%E5%86%85%E7%BD%AE%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer<T></T></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void accept(T t);</span><br><span class="line"></span><br><span class="line">    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收一个泛型的参数T，然后调用accept，对这个参数做一系列的操作，没有返回值。<br>在stream里，主要是用于forEach，内部迭代的时候，对传入的参数，做一系列的业务操作，没有返回值。</p><h2 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier<T></T></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Supplier&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Gets a result.</span><br><span class="line">     *</span><br><span class="line">     * @return a result</span><br><span class="line">     */</span><br><span class="line">    T get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有参数，返回一个泛型T。</p><h2 id="Function-lt-T-R-gt"><a href="#Function-lt-T-R-gt" class="headerlink" title="Function&lt;T, R&gt;"></a>Function&lt;T, R&gt;</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Applies this function to the given argument.</span><br><span class="line">     *</span><br><span class="line">     * @param t the function argument</span><br><span class="line">     * @return the function result</span><br><span class="line">     */</span><br><span class="line">    R apply(T t);</span><br><span class="line"></span><br><span class="line">    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        return (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        return (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;T&gt; Function&lt;T, T&gt; identity() &#123;</span><br><span class="line">        return t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Function接口，定义了一个apply的抽象方法，接收一个泛型T对象，并且返回泛型R对象。</p><h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate<T></T></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Evaluates this predicate on the given argument.</span><br><span class="line">     *</span><br><span class="line">     * @param t the input argument</span><br><span class="line">     * @return &#123;@code true&#125; if the input argument matches the predicate,</span><br><span class="line">     * otherwise &#123;@code false&#125;</span><br><span class="line">     */</span><br><span class="line">    boolean test(T t);</span><br><span class="line"></span><br><span class="line">    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        return (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default Predicate&lt;T&gt; negate() &#123;</span><br><span class="line">        return (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        return (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123;</span><br><span class="line">        return (null == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8—Lambda表达式</title>
      <link href="/2019/11/07/java8%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/11/07/java8%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="java8新特性"><a href="#java8新特性" class="headerlink" title="java8新特性"></a>java8新特性</h3><ol><li>Lambda表达式（重要）</li><li>函数式接口</li><li>方法引用与构造器引用</li><li>stream API（重要）</li><li>接口中的默认方法和静态方法</li><li>新时间日期</li></ol><h2 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h2><h3 id="1-为什么要使用Lambda表达式"><a href="#1-为什么要使用Lambda表达式" class="headerlink" title="1.为什么要使用Lambda表达式"></a>1.为什么要使用Lambda表达式</h3><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)，可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使得java的语言表达能力得到提升。<br>Lambda表达式需要函数式接口的支持，接口中只有一个抽象方法的接口叫做函数式接口，使用@FunctionalInterface修饰，来检查是否是函数式接口。</p><h3 id="2-Lambda表达式基础语法"><a href="#2-Lambda表达式基础语法" class="headerlink" title="2.Lambda表达式基础语法"></a>2.Lambda表达式基础语法</h3><p>java8中新增了一个操作符，“-&gt;”箭头表达式，也叫Lambda操作符。<br>Lambda表达式左侧为Lambda表达式的参数列表，右侧为操作步骤与逻辑，也叫Lambda体。</p><ol><li>无参数，无返回值（ () -&gt; 接口的功能 ）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 语法一：无参数，无返回值（（）-&gt; 执行的代码 ）</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">    //java8实现Runnable方法</span><br><span class="line">    Runnable run = () -&gt; System.out.println(&quot;Hello Lambda&quot;);</span><br><span class="line">    run.run();</span><br><span class="line">    </span><br><span class="line">    //java8以前得写法</span><br><span class="line">    Runnable run1 = new Runnable() &#123;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Hello World&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    run1.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一个参数，无返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 语法二：一个参数，无返回值</span><br><span class="line">   */</span><br><span class="line">  @Test</span><br><span class="line">  public void test2() &#123;</span><br><span class="line">      Consumer&lt;String&gt; t1 = (x) -&gt; System.out.println(x);</span><br><span class="line">      t1.accept(&quot;Hello Lambda&quot;);</span><br><span class="line"></span><br><span class="line">//只有一个参数，小括号可以不写</span><br><span class="line">      Consumer&lt;String&gt; t2 = x -&gt; System.out.println(x);</span><br><span class="line">      t2.accept(&quot;Hello Lambda&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>多个参数，多条语句，有返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 语法三：多个参数，多条语句，有返回值。</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(y);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(com.compare(1, 3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多个参数，一条语句，有返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 语法四：多个参数，一条语句，有返回值</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test4() &#123;</span><br><span class="line">    //只有一条语句与返回值时，大括号和return都可以省略</span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; 0;</span><br><span class="line">    </span><br><span class="line">    System.out.println(com.compare(1, 3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Lambda表达式的参数列表可以不用写，因为JVM编译器可以通过上下文推断出类型，即“类型推断”。</li></ol><h3 id="3-Lambda表达式需要“函数式接口”的支持"><a href="#3-Lambda表达式需要“函数式接口”的支持" class="headerlink" title="3.Lambda表达式需要“函数式接口”的支持"></a>3.Lambda表达式需要“函数式接口”的支持</h3><p>函数式接口：接口中只有一个抽象方法时，那么这个接口叫做函数式接口。函数式接口可以使用@FunctionalInterface修饰，jvm会自动检查该接口是否为函数式接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> @FunctionalInterface</span><br><span class="line"> public interface myLambdaModle&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">     public int test(T t1, T t2);</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">public int myTest(int o1, int o2, myLambdaModle&lt;Integer&gt; m) &#123;</span><br><span class="line">       return m.test(o1, o2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 对两个数进行运算</span><br><span class="line">   public void test5() &#123;</span><br><span class="line">       int sum1 = myTest(3, 6, (x, y) -&gt; x*y);</span><br><span class="line">       int sum2 = myTest(3, 6, (x, y) -&gt; x-y);</span><br><span class="line">       int sum3 = myTest(3, 6, (x, y) -&gt; x+y);</span><br><span class="line">       int sum4 = myTest(3, 6, (x, y) -&gt; x/y);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="二、四大内置核心函数式接口"><a href="#二、四大内置核心函数式接口" class="headerlink" title="二、四大内置核心函数式接口"></a>二、四大内置核心函数式接口</h2><h3 id="1-Consumer：消费型接口-void-accept-T-t"><a href="#1-Consumer：消费型接口-void-accept-T-t" class="headerlink" title="1.Consumer：消费型接口( void accept(T t) )"></a>1.Consumer<T>：消费型接口( void accept(T t) )</T></h3><p>消费型接口，有参数，无返回值类型的接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消费型接口Consumer&lt;T&gt;</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test1 () &#123;</span><br><span class="line">    consumo(500, (x) -&gt; System.out.println(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void consumo (double money, Consumer&lt;Double&gt; c) &#123;</span><br><span class="line">    c.accept(money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Supplier：供给型接口-T-get"><a href="#2-Supplier：供给型接口-T-get" class="headerlink" title="2.Supplier：供给型接口( T get() )"></a>2.Supplier<T>：供给型接口( T get() )</T></h3><p>供给类型的接口，只有产出，没有输入(只有返回值，没有入参)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 供给型接口，Supplier&lt;T&gt;</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test2 () &#123;</span><br><span class="line">    Random ran = new Random();</span><br><span class="line">    List&lt;Integer&gt; list = supplier(10, () -&gt; ran.nextInt(10));</span><br><span class="line">    </span><br><span class="line">    for (Integer i : list) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 随机产生sum个数量得集合</span><br><span class="line"> * @param sum 集合内元素个数</span><br><span class="line"> * @param sup</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;Integer&gt; supplier(int sum, Supplier&lt;Integer&gt; sup)&#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    for (int i = 0; i &lt; sum; i++) &#123;</span><br><span class="line">        list.add(sup.get());</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Function-lt-T-R-gt-：函数型接口-R-apply-T-t"><a href="#3-Function-lt-T-R-gt-：函数型接口-R-apply-T-t" class="headerlink" title="3.Function&lt;T, R&gt;：函数型接口( R apply(T t) )"></a>3.Function&lt;T, R&gt;：函数型接口( R apply(T t) )</h3><p>函数型接口，输入一个类型的参数，输出一个类型的参数，两种类型可以一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 函数型接口：Function&lt;R, T&gt;</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test3 () &#123;</span><br><span class="line">    String s = strOperar(&quot; asdf &quot;, x -&gt; x.substring(0, 2));</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    String s1 = strOperar(&quot; asdf &quot;, x -&gt; x.trim());</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 字符串操作</span><br><span class="line"> * @param str 需要处理得字符串</span><br><span class="line"> * @param fun Function接口</span><br><span class="line"> * @return 处理之后得字符传</span><br><span class="line"> */</span><br><span class="line">public String strOperar(String str, Function&lt;String, String&gt; fun) &#123;</span><br><span class="line">    return fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Predicate：断言型接口-boolean-test-T-t"><a href="#4-Predicate：断言型接口-boolean-test-T-t" class="headerlink" title="4.Predicate：断言型接口( boolean test(T t) )"></a>4.Predicate<T>：断言型接口( boolean test(T t) )</T></h3><p>断言型接口，输入一个参数，输出一个boolean类型的返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 断言型接口：Predicate&lt;T&gt;</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test4 () &#123;</span><br><span class="line">    List&lt;Integer&gt; l = new ArrayList&lt;&gt;();</span><br><span class="line">    l.add(102);</span><br><span class="line">    l.add(172);</span><br><span class="line">    l.add(13);</span><br><span class="line">    l.add(82);</span><br><span class="line">    l.add(109);</span><br><span class="line">    List&lt;Integer&gt; list = filterInt(l, x -&gt; (x &gt; 100));</span><br><span class="line">    for (Integer integer : list) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 过滤集合</span><br><span class="line"> * @param list</span><br><span class="line"> * @param pre</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;Integer&gt; filterInt(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pre)&#123;</span><br><span class="line">    List&lt;Integer&gt; l = new ArrayList&lt;&gt;();</span><br><span class="line">    for (Integer integer : list) &#123;</span><br><span class="line">        if (pre.test(integer))</span><br><span class="line">            l.add(integer);</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2019/09/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/09/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="进程间的五种通讯方式"><a href="#进程间的五种通讯方式" class="headerlink" title="进程间的五种通讯方式"></a>进程间的五种通讯方式</h3><ol><li>管道pipe</li><li>FIFO(有名管道)</li><li>消息队列</li><li>信号量</li><li>共享内存</li><li>套接字socket</li><li>文件和记录锁定(UNIX中)</li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列——RabbitMQ</title>
      <link href="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/"/>
      <url>/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RabbitMQ简介"><a href="#一、RabbitMQ简介" class="headerlink" title="一、RabbitMQ简介"></a>一、RabbitMQ简介</h2><p>MQ全称是Message Queue，可以理解为消息队列的意思，简单来说就是消息以<strong>管道</strong>的方式进行传递。</p><h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><p>我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ，我们后面会一一对比这些消息队列。<br>另外，我们知道队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者发送消息1,2,3…对于消费者就会按照1,2,3…的顺序来消费。但是偶尔也会出现消息被消费的顺序不对的情况，比如某个消息消费失败又或者一个 queue 多个consumer 也会导致消息被消费的顺序不对，我们一定要保证消息被消费的顺序正确。<br>除了上面说的消息消费顺序的问题，使用消息队列，我们还要考虑如何保证消息不被重复消费？如何保证消息的可靠性传输（如何处理消息丢失的问题）？……等等问题。所以说使用消息队列也不是十全十美的，使用它也会让系统可用性降低、复杂度提高，另外需要我们保障一致性等问题。</p><p>RabbitMQ是一个实现了AMQP(Advanced Message Queuing Protocol)高级消息队列协议的消息队列服务，用Erlang语言实现的。</p><h2 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h2><p>在我们秒杀抢购商品的时候，系统会提醒我们稍等排队中，而不是页面卡死或报错给用户。<br>像这种排队结算就用到了消息队列机制，放入通道里面一个一个结算处理，而不是某个时间段突然涌入大批量的查询新增把数据库给搞宕机，所以RabbitMQ本质上起到的作用就是削峰，为业务保驾护航。<br>在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。</p><h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><ul><li><p>通过异步处理提高系统性能（削峰、减少响应所需时间）<br>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。<br>消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。<br>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，</strong>以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p></li><li><p>降低系统耦合性<br>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。<br>我们最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。<br>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<br>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。<br>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。<br>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p></li><li><p>不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。 另外，这两种消息模型是JMS提供的，AMQP协议还提供了5种消息模型。</p></li></ul><h3 id="使用消息队列带来的一些问题"><a href="#使用消息队列带来的一些问题" class="headerlink" title="使用消息队列带来的一些问题"></a>使用消息队列带来的一些问题</h3><ul><li>系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！</li><li>系统复杂性提高： 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li>一致性问题： 上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><h2 id="三、JMS对比AMQP"><a href="#三、JMS对比AMQP" class="headerlink" title="三、JMS对比AMQP"></a>三、JMS对比AMQP</h2><h3 id="3-1-JMS"><a href="#3-1-JMS" class="headerlink" title="3.1 JMS"></a>3.1 JMS</h3><h4 id="3-1-1-JMS简介"><a href="#3-1-1-JMS简介" class="headerlink" title="3.1.1 JMS简介"></a>3.1.1 JMS简介</h4><p>JMS（JAVA Message Service,java消息服务）是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。JMS（JAVA Message Service，Java消息服务）API是一个消息服务的标准或者说是规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。<br>ActiveMQ 就是基于 JMS 规范实现的。</p><h4 id="3-1-2-JMS两种消息模型"><a href="#3-1-2-JMS两种消息模型" class="headerlink" title="3.1.2 JMS两种消息模型"></a>3.1.2 JMS两种消息模型</h4><ol><li>点到点模型(P2P)<br>使用队列（Queue）作为消息通信载体；满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</li><li>发布/订阅模型(Pub/Sub)<br>发布订阅模型（Pub/Sub） 使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。</li></ol><h4 id="3-1-3-JMS五种不同的消息正文格式"><a href="#3-1-3-JMS五种不同的消息正文格式" class="headerlink" title="3.1.3 JMS五种不同的消息正文格式"></a>3.1.3 JMS五种不同的消息正文格式</h4><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p><ul><li>StreamMessage – Java原始值的数据流</li><li>MapMessage–一套名称-值对</li><li>TextMessage–一个字符串对象</li><li>ObjectMessage–一个序列化的 Java对象</li><li>BytesMessage–一个字节的数据流</li></ul><h3 id="3-2-AMQP"><a href="#3-2-AMQP" class="headerlink" title="3.2 AMQP"></a>3.2 AMQP</h3><h4 id="3-2-1-AMQP简介"><a href="#3-2-1-AMQP简介" class="headerlink" title="3.2.1 AMQP简介"></a>3.2.1 AMQP简介</h4><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。<br>RabbitMQ 就是基于 AMQP 协议实现的。</p><h4 id="3-2-2-五种消息模型"><a href="#3-2-2-五种消息模型" class="headerlink" title="3.2.2 五种消息模型"></a>3.2.2 五种消息模型</h4><ol><li>direct exchange</li><li>fanout exchange</li><li>topic exchange</li><li>headers exchange</li><li>system exchange</li></ol><h3 id="3-3-JMS对比AMQP"><a href="#3-3-JMS对比AMQP" class="headerlink" title="3.3 JMS对比AMQP"></a>3.3 JMS对比AMQP</h3><ul><li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。</li><li>JMS支持TextMessage、MapMessage等复杂的消息类型；而AMQP仅支持byte[]消息类型（复杂的类型可序列化后发送）。</li><li>由于Exchange提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而JMS仅支持队列和主题/订阅方式两种。</li></ul><h2 id="四、常见的消息队列对比"><a href="#四、常见的消息队列对比" class="headerlink" title="四、常见的消息队列对比"></a>四、常见的消息队列对比</h2><ol><li><strong>吞吐量：</strong>万级的ActiveMQ和RabbitMQ的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的RocketMQ和Kafka低一个数量级。</li><li><strong>可用性：</strong>都可以实现高可用。ActiveMQ和RabbitMQ都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。kafka也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用。</li><li><strong>时效性：</strong>RabbitMQ基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是ms级。</li><li><strong>功能支持：</strong>支持    除了Kafka，其他三个功能都较为完备。Kafka功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准。</li><li><strong>消息丢失：</strong>ActiveMQ和RabbitMQ丢失的可能性非常低，RocketMQ和Kafka理论上不会丢失。<br>总结：</li></ol><ul><li>ActiveMQ的社区算是比较成熟，但是较目前来说，ActiveMQ的性能比较差，而且版本迭代很慢，不推荐使用。</li><li>RabbitMQ在吞吐量方面虽然稍逊于Kafka和RocketMQ，但是由于它基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为RabbitMQ基于erlang开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li><li>RocketMQ阿里出品，Java系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且RocketMQ有阿里巴巴的实际业务场景的实战考验。RocketMQ社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的。</li><li>kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量。kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li></ul><p>参考：《Java工程师面试突击第1季-中华石杉老师》</p><h2 id="RabbitMQ核心概念"><a href="#RabbitMQ核心概念" class="headerlink" title="RabbitMQ核心概念"></a>RabbitMQ核心概念</h2><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。<br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/rabbitmq.jpg" alt="RabbitMQ整体模型架构"></p><h3 id="1-Producer-生产者-和Consumer-消费者"><a href="#1-Producer-生产者-和Consumer-消费者" class="headerlink" title="1. Producer(生产者)和Consumer(消费者)"></a>1. Producer(生产者)和Consumer(消费者)</h3><ul><li>Producer(生产者) :生产消息的一方（邮件投递者）</li><li>Consumer(消费者) :消费消息的一方（邮件收件人）<br>消息一般由 2 部分组成：消息头（或者说是标签 Label）和 消息体。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</li></ul><h3 id="2-Exchange-交换器"><a href="#2-Exchange-交换器" class="headerlink" title="2. Exchange(交换器)"></a>2. Exchange(交换器)</h3><p>在 RabbitMQ 中，消息并不是直接被投递到 Queue(消息队列) 中的，中间还必须经过 Exchange(交换器) 这一层，Exchange(交换器) 会把我们的消息分配到对应的 Queue(消息队列) 中。<br>Exchange(交换器) 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 Producer(生产者) ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。<br>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略：direct(默认)，fanout, topic, 和 headers，不同类型的Exchange转发消息的策略有所区别。<br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/exchange.jpg"><br>生产者将消息发给交换器的时候，一般会指定一个 RoutingKey(路由键)，用来指定这个消息的路由规则，而这个 RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。<br>RabbitMQ 中通过 Binding(绑定) 将 Exchange(交换器) 与 Queue(消息队列) 关联起来，在绑定的时候一般会指定一个 BindingKey(绑定建) ,这样 RabbitMQ 就知道如何正确将消息路由到队列了。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。<br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/bind.jpg"><br>生产者将消息发送给交换器时，需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p><h3 id="3-Queue-消息队列"><a href="#3-Queue-消息队列" class="headerlink" title="3. Queue(消息队列)"></a>3. Queue(消息队列)</h3><p>Queue(消息队列) 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。<br>RabbitMQ 中消息只能存储在 队列 中，这一点和 Kafka 这种消息中间件相反。Kafka 将消息存储在 topic（主题） 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。<br>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。<br>RabbitMQ 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p><h3 id="4-Broker-消息中间件的服务节点"><a href="#4-Broker-消息中间件的服务节点" class="headerlink" title="4. Broker(消息中间件的服务节点)"></a>4. Broker(消息中间件的服务节点)</h3><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。<br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/liucheng.jpg"></p><h3 id="5-Exchange-Types-交换器类型"><a href="#5-Exchange-Types-交换器类型" class="headerlink" title="5. Exchange Types(交换器类型)"></a>5. Exchange Types(交换器类型)</h3><ol><li>fanout：fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</li><li>direct：direct 类型的Exchange路由规则也很简单，一对一的匹配，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。<br><img src="/2019/09/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94RabbitMQ/direct.jpg"><br>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为”Info”或者”debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。<br>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</li><li>topic：direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：<ul><li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li><li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li><li>BindingKey 中可以存在两种特殊字符串“”和“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li></ul></li><li>headers：headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)’对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</li></ol><h3 id="6-RoutingKey-路由键-和BindingKey-绑定键"><a href="#6-RoutingKey-路由键-和BindingKey-绑定键" class="headerlink" title="6. RoutingKey(路由键)和BindingKey(绑定键)"></a>6. RoutingKey(路由键)和BindingKey(绑定键)</h3><p>RoutingKey（路由键）：用于把生成者的数据分配到交换器上；<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上；</p><h2 id="消息发送原理"><a href="#消息发送原理" class="headerlink" title="消息发送原理"></a>消息发送原理</h2><p>首先你必须连接到Rabbit才能发布和消费消息，那怎么连接和发送消息的呢？<br>你的应用程序和Rabbit Server之间会创建一个TCP连接，一旦TCP打开，并通过了认证，认证就是你试图连接Rabbit之前发送的Rabbit服务器连接信息和用户名和密码，有点像程序连接数据库，使用Java有两种连接认证的方式，后面代码会详细介绍，一旦认证通过你的应用程序和Rabbit就创建了一条AMQP信道（Channel）。<br>信道是创建在“真实”TCP上的虚拟连接，AMQP命令都是通过信道发送出去的，每个信道都会有一个唯一的ID，不论是发布消息，订阅队列或者介绍消息都是通过信道完成的。</p><h4 id="为什么不通过TCP直接发送命令？"><a href="#为什么不通过TCP直接发送命令？" class="headerlink" title="为什么不通过TCP直接发送命令？"></a>为什么不通过TCP直接发送命令？</h4><p>对于操作系统来说创建和销毁TCP会话是非常昂贵的开销，假设高峰期每秒有成千上万条连接，每个连接都要创建一条TCP会话，这就造成了TCP连接的巨大浪费，而且操作系统每秒能创建的TCP也是有限的，因此很快就会遇到系统瓶颈。<br>如果我们每个请求都使用一条TCP连接，既满足了性能的需要，又能确保每个连接的私密性，这就是引入信道概念的原因。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2019/09/16/Redis/"/>
      <url>/2019/09/16/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><p>简单来说，redis就是一个数据库，不过与传统数据库不同的是，redis的数据是存在内存中的，所以读写速度非常快，因此redis被广泛应用于缓存方向。<br>另外，redis也经常用来做分布式锁。<br>redis提供了多种数据类型来支持不同的业务场景。<br>除此之外，redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><h2 id="为什么要用redis-为什么要用缓存？"><a href="#为什么要用redis-为什么要用缓存？" class="headerlink" title="为什么要用redis/为什么要用缓存？"></a>为什么要用redis/为什么要用缓存？</h2><p>主要从“高性能”和“高并发”这两点来看待这个问题。<br><strong>高性能：</strong><br>假如用户第一次访问网页，需要从数据库中访问某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存储在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。<br>操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变之后，同步改变缓存中相应的数据即可。<br><img src="/2019/09/16/Redis/gaoxingneng.jpg"><br><strong>高并发：</strong><br>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据存到缓存中去，这样用户的一部分请求会直接到缓存这里请求数据而不用经过数据库。<br><img src="/2019/09/16/Redis/gaobingfa.jpg"></p><h2 id="为什么要用redis为不用map-guava做缓存？"><a href="#为什么要用redis为不用map-guava做缓存？" class="headerlink" title="为什么要用redis为不用map/guava做缓存？"></a>为什么要用redis为不用map/guava做缓存？</h2><p>缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。<br>使用redis或者memcached之类的称为分布式缓存，在多实例的情况下，各实例公用一份缓存数据，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。</p><h2 id="redis的线程模型"><a href="#redis的线程模型" class="headerlink" title="redis的线程模型"></a>redis的线程模型</h2><p>redis内部使用文件事件处理器file event handler，这个文件事件处理器是单线程的，所以redis才叫做单线程的模型。它采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。<br>文件事件处理器的结构包含4个部分：</p><ul><li>多个socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)<br>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</li></ul><h2 id="redis和memcached的区别"><a href="#redis和memcached的区别" class="headerlink" title="redis和memcached的区别"></a>redis和memcached的区别</h2><ol><li>**redis支持更丰富的数据类型(支持更复杂的应用场景)**：redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset(sorted set)，hash等数据结构的存储。memcached支持简单的数据类型，string。</li><li><strong>redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用，而memcached把数据全部存在内存之中。</strong></li><li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是redis目前是原生支持cluster模式的。</li><li>memcached是多线程，非阻塞IO复用的网络模型；redis使用单线程的多路IO复用模型。<br><img src="/2019/09/16/Redis/redis-memcached.jpg"></li></ol><h2 id="redis常见数据结构以及使用场景分析"><a href="#redis常见数据结构以及使用场景分析" class="headerlink" title="redis常见数据结构以及使用场景分析"></a>redis常见数据结构以及使用场景分析</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h3><blockquote><p><strong>常用命令</strong>：set,get,decr,incr,mget等。<br>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。</p></blockquote><h3 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h3><blockquote><p><strong>常用命令</strong>：hget,hset,hgetall等。<br>hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">  “id”: 1,</span><br><span class="line">  “name”: “frozenwind”,</span><br><span class="line">  “age”: 21,</span><br><span class="line">  “location”: “ShanDong, QingDao”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h3><blockquote><p><strong>常用命令</strong>：lpush,rpush,lpop,rpop,lrange等<br>list就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的list结构来实现。<br>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。<br>另外可以通过lrange命令，就是从某个元素开始读取多少个元素，可以基于list实现分页查询，这个很棒的一个功能，基于redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p></blockquote><h3 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h3><blockquote><p><strong>常用命令</strong>：sadd,spop,smembers,sunion等<br>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。<br>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。<br>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinterstore key1 key2 key3     将交集存在key1内</span><br></pre></td></tr></table></figure><h3 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h3><blockquote><p><strong>常用命令</strong>：zadd,zrange,zrem,zcard等<br>和set相比，sortedset增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。<br>举例：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用Redis中的Sorted Set结构进行存储。</p></blockquote><h2 id="redis设置过期时间"><a href="#redis设置过期时间" class="headerlink" title="redis设置过期时间"></a>redis设置过期时间</h2><p>redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。<br>我们set key的时候，都可以给一个expire time，就是过期时间，通过过期时间我们可以指定这个key可以存活的时间。</p><p>假设你设置了一批key只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？<br><strong>定期删除+惰性删除</strong></p><ul><li><strong>定期删除：</strong>redis默认是每隔100ms就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如redis存了几十万个key，每隔100ms就遍历所有的设置过期时间的key的话，会给CPU带了很大的负载。</li><li><strong>惰性删除：</strong>定期删除可能会导致很多过期key到了时间并没有被删除掉，所以就有了惰性删除。假如你的过期key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个key，才会被redis给删除掉，这就是惰性删除。<br>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，怎么解决这个问题？<strong>redis内存淘汰机制</strong>。</li></ul><h2 id="redis内存淘汰机制-mysql里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"><a href="#redis内存淘汰机制-mysql里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？" class="headerlink" title="redis内存淘汰机制(mysql里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？)"></a>redis内存淘汰机制(mysql里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？)</h2><p><strong>redis提供6中数据淘汰策略：</strong></p><ol><li>volatile-lru：从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key(这个是最常用的)。</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。</li><li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li><li>0版本后增加以下两种：</li><li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰。</li><li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。</li></ol><h2 id="redis持久化机制-怎么保证redis挂掉之后再重启数据可以进行恢复"><a href="#redis持久化机制-怎么保证redis挂掉之后再重启数据可以进行恢复" class="headerlink" title="redis持久化机制(怎么保证redis挂掉之后再重启数据可以进行恢复)"></a>redis持久化机制(怎么保证redis挂掉之后再重启数据可以进行恢复)</h2><p>很多时候我们需要持久化数据，也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了防止系统故障而将数据备份到一个远程位置。<br>redis不同于memcached的很重要的一点是，redis支持持久化，而且支持两种不同的持久化操作。redis的一种持久化方式叫快照(snapshotting，RDB)，另一种方式是只追加文件(append-only file，AOF)。</p><h4 id="快照-snapshotting-持久化-RDB"><a href="#快照-snapshotting-持久化-RDB" class="headerlink" title="快照(snapshotting)持久化(RDB)"></a>快照(snapshotting)持久化(RDB)</h4><p>redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本(redis主从结构，主要用来提高redis性能)，还可以将快照留在原地以便重启服务器的时候使用。<br>快照持久化是redis默认采用的持久化方式，在redis.conf配置文件中默认有以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure><h4 id="AOF-append-only-file-持久化"><a href="#AOF-append-only-file-持久化" class="headerlink" title="AOF(append-only file)持久化"></a>AOF(append-only file)持久化</h4><p>与快照持久化相比，AOF持久化的实时性更好，因此已成为主流的持久化方案。默认情况下redis没有开启AOF方式的持久化，可以通过appendonly参数开启。<br>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。<br>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><h4 id="Redis4-0对于持久化机制的优化"><a href="#Redis4-0对于持久化机制的优化" class="headerlink" title="Redis4.0对于持久化机制的优化"></a>Redis4.0对于持久化机制的优化</h4><p>Redis4.0开始支持RDB和AOF的混合持久化(默认关闭，可以通过配置项<code>aof-use-rdb-preamble</code>开启）。<br>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。<br>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。<br>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</p><h2 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。<br>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当Redis运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。</p><h2 id="缓存穿透和缓存雪崩问题解决方案"><a href="#缓存穿透和缓存雪崩问题解决方案" class="headerlink" title="缓存穿透和缓存雪崩问题解决方案"></a>缓存穿透和缓存雪崩问题解决方案</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>是什么：缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。<br>解决办法：</p><ul><li>事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li><li>事中：本地ehcache+hystrix限流&amp;降级，避免mysql崩掉</li><li>事后：利用redis持久化机制保存的数据尽快恢复缓存<br><img src="/2019/09/16/Redis/huancunxuebeng.jpg"></li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>是什么：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。<br>解决办法：</p><ul><li>采用布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li><li>缓存空结果：如果一个查询返回的数据为空(不管是数据不存在，还是系统故障)，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿，是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这是由于并发用户特别多，同时读缓存没读到数据(并发查询同一条数据)，又同时去数据库去数据，引起数据库压力瞬间增大，造成过大压力。<br>解决方案：</p><ul><li>设置热点数据，永远不过期</li><li>加互斥锁。</li></ul><h2 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h2><p>所谓redis的并发竞争key的问题也就是多个系统同时对一个key进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。<br>解决方案：分布式锁(zookeeper和redis都可以实现分布式锁)。如果不存在redis的并发竞争key问题，不要使用分布式锁，这样会影响性能。<br>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务器宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><h2 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h2><p>只要使用缓存，就可能会涉及到缓存与数据库双存储双写，只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？<br>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话(缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案)，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。<br>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令总结</title>
      <link href="/2019/08/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器ip、端口连通情况"><a href="#服务器ip、端口连通情况" class="headerlink" title="服务器ip、端口连通情况"></a>服务器ip、端口连通情况</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>ping出域名对应的服务器ip</p><h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><p>telnet ip port</p><h4 id="nc-vz-w2-ip-port"><a href="#nc-vz-w2-ip-port" class="headerlink" title="nc -vz -w2 ip port"></a>nc -vz -w2 ip port</h4><p>mac测试远程端口是否正常，netcat</p><h2 id="linux性能监控命令"><a href="#linux性能监控命令" class="headerlink" title="linux性能监控命令"></a>linux性能监控命令</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>可以实时显示系统中各个进程的占用情况。<br><img src="/2019/08/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/top.png"><br>上部分列出了系统整体的统计信息：任务、CPU、内存、交换区等信息。<br>下部分列出进程的详细情况。</p><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>可以查看系统负载。显示的和top命令第一行一样。<br><img src="/2019/08/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/uptime.png"></p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看所有进程<br><img src="/2019/08/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/ps.png"></p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>全局正则表达式文本</p><h4 id="ps-ef"><a href="#ps-ef" class="headerlink" title="ps -ef"></a>ps -ef</h4><p>用标准格式显示进程</p><h4 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps aux"></a>ps aux</h4><p>用BSD格式来显示进程</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>这个命令用来查看当前建立的网络连接(深刻理解netstat每一项代表的含义)。最经典的案例就是查看本地系统打开了哪些端口：<br><img src="/2019/08/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/netstat.png"></p><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>可以用来监控虚拟内存。可对操作系统的虚拟内存、IO、CPU等多个指标的整体情况进行监视。<br><img src="/2019/08/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/vmstat.png"></p><h4 id="内存方面："><a href="#内存方面：" class="headerlink" title="内存方面："></a>内存方面：</h4><p>swpd：已经使用的交换内存（kb）<br>free：空闲的物理内存（kb）<br>buff：用作缓冲区的内存数（kb）<br>cache：用作高速缓存的内存数（kb）<br>si、so 两列，表示磁盘和内存之间交换的频繁程度。<br>分析思路：<br>如果 si、so 数值长期很大并且free长期很小，表示物理内存不能满足需要，也就是内存不足。由于磁盘的性能比内存是慢很多的，所以如果存在大量的页面交换，那么系统的性能必然会受到很大影响。</p><h4 id="CPU方面："><a href="#CPU方面：" class="headerlink" title="CPU方面："></a>CPU方面：</h4><p>r：展示了正在执行和等待cpu资源的任务个数。当这个值超过了cpu个数，就会出现cpu瓶颈。<br>us：用户CPU时间。<br>sy：系统CPU时间。<br>id：空闲CPU时间。<br>wa：等等I/O CPU时间。<br>us+sy+id+wa=100%<br>分析思路：<br>如果 r 经常大于4，且id经常小于40，表面CPU的负荷很重。</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>可以用来观察内存使用情况。<br><img src="/2019/08/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/free.png"><br>total= used + free<br>分析思路：<br>当 –/+ buffers/cache中的free长时间接近0，且 swap used长时间比较大时，说明物理内存已经不够用了，需要升级内存或降低内存的使用量。</p><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>可以用来监控磁盘I/O的情况。<br><img src="/2019/08/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/iostat.png"></p><h3 id="磁盘命令"><a href="#磁盘命令" class="headerlink" title="磁盘命令"></a>磁盘命令</h3><h4 id="df-（disk-free）"><a href="#df-（disk-free）" class="headerlink" title="df （disk free）"></a>df （disk free）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-a：全部文件系统列表，包含虚拟文件系统</span><br><span class="line">-B：指定显示scale size，比如以M，G为单位显示</span><br><span class="line">-h：方便人阅读方式显示。</span><br><span class="line">-H：和-h相似，不过其中1k = 1000byte， 1M=1000k</span><br><span class="line">-i：列出inode的信息</span><br><span class="line">-k ：区块为1024字节</span><br><span class="line">-l ：显示本地文件系统</span><br><span class="line">-p：使用POSIX规范输出</span><br><span class="line">-t：打印指定的文件系统类型</span><br><span class="line">-T：显示文件系统类型</span><br><span class="line">-x：不打印指定的文件系统类型</span><br></pre></td></tr></table></figure><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-l 列出素所有分区表</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀系统的设计</title>
      <link href="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="秒杀系统常见问题"><a href="#秒杀系统常见问题" class="headerlink" title="秒杀系统常见问题"></a>秒杀系统常见问题</h3><ol><li>简单说一下秒杀系统的设计思路?</li><li>你怎么实现秒杀业务的？</li><li>你怎么保证秒杀成功的？</li><li>秒杀操作的策略是什么？</li><li>你使用的Redis有什么用？</li><li>你为什么使用Redis中间件？</li><li>你测试过你这个系统的抗压能力么？</li><li>你使用过什么方法来测试你的系统并发量？</li><li>你觉得你这个系统还可以再优化么？</li><li>你觉得你这个系统的瓶颈在哪里？还可以在哪些方向做进一步优化?</li><li>最后一件商品，多个用户同时抢购怎么处理？（超卖问题）</li></ol><h3 id="秒杀系统特点"><a href="#秒杀系统特点" class="headerlink" title="秒杀系统特点"></a>秒杀系统特点</h3><ol><li>秒杀业务简单，买家查询，买家下订单，减库存。</li><li>秒杀时网站访问流量激增，出现峰值；</li><li>访问请求数量远大于实际需求量。</li></ol><h3 id="整体设计思路"><a href="#整体设计思路" class="headerlink" title="整体设计思路"></a>整体设计思路</h3><ul><li>限流：屏蔽掉无用的流量，允许少部分流量流向后端。</li><li>削峰：瞬时大流量峰值容易压垮系统，解决这个问题是重中之重。常用的消峰方法有异步处理、缓存和消息中间件等技术。</li><li>异步处理：秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式。</li><li>内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。</li><li>可拓展：当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。</li><li>消息队列：消息队列可以削峰，将拦截大量并发请求，这也是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。</li><li>充分利用缓存：利用缓存可极大提高系统读写速度。<br><img src="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/fangan.png"></li></ul><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h3 id="1-集成redis"><a href="#1-集成redis" class="headerlink" title="1.集成redis"></a>1.集成redis</h3><p>通用缓存key封装<br>接口：定义一些规范<br>抽象类：定义一些通用的实现<br>实现类：特定类的具体实现。</p><h3 id="2-两次MD5"><a href="#2-两次MD5" class="headerlink" title="2.两次MD5"></a>2.两次MD5</h3><p>1）用户端：PASS=MD5(明文+固定salt)，第一次MD5防止用户的密码明文在网络上传输。<br>2）服务端：PASS=MD5(用户输入+随机salt)，服务端的MD5是防止数据库中的密码被反查，双重保险。</p><h3 id="3-数据表的主键"><a href="#3-数据表的主键" class="headerlink" title="3.数据表的主键"></a>3.数据表的主键</h3><p>Twitter的分布式雪花算法SnowFlake每秒自增生成26个万个可排序的ID </p><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h3 id="JSR303参数检验"><a href="#JSR303参数检验" class="headerlink" title="JSR303参数检验"></a>JSR303参数检验</h3><h3 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h3><h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><h4 id="session和cookie的区别和联系"><a href="#session和cookie的区别和联系" class="headerlink" title="session和cookie的区别和联系"></a>session和cookie的区别和联系</h4><p>1.session保存在服务器，客户端不知道其中的信息；cookie保存在客户端，服务器能够知道其中的信息。<br>2.session中保存的是对象，cookie中保存的是字符串。<br>3.session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到。而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的。<br>4.session需要借助cookie才能正常工作，如果客户端完全禁止cookie，session将失效。<br>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于在服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上还有其他选择。<br>Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p><p>如何利用实现自动登录：当用户在某个网站注册后，就会收到一个惟一用户ID的cookie。客户后来重新连接时，这个用户ID会自动返回，服务器对它进行检查，确定它是否为注册用户且选择了自动登录，从而使用户无需给出明确的用户名和密码，就可以访问服务器上的资源。<br>如何根据用户的爱好定制站点：网站可以使用cookie记录用户的意愿。对于简单的设置，网站可以直接将页面的设置存储在cookie中完成定制。然而对于更复杂的定制，网站只需仅将一个惟一的标识符发送给用户，由服务器端的数据库存储每个标识符对应的页面设置。</p><h4 id="分布式Session的集中实现方式"><a href="#分布式Session的集中实现方式" class="headerlink" title="分布式Session的集中实现方式"></a>分布式Session的集中实现方式</h4><p>1.基于数据库的Session共享<br>2.基于NFS共享文件系统<br>3.基于memcached的session，如何保证memcached本身的高可用性？<br>4.基于resin/tomcat web容器本身的session复制机制<br>5.基Redis缓存数据库进行session共享。<br>6.基于cookie进行session共享<br>分布式session是为了使web能适应大规模的访问。</p><h4 id="项目怎么实现的分布式session"><a href="#项目怎么实现的分布式session" class="headerlink" title="项目怎么实现的分布式session"></a>项目怎么实现的分布式session</h4><p>基于token/cookie的分布式会话（分布式session）实现<br>通过服务端把一个token写到cookie当中，然后客户端在随后的访问中携带这个cookie，服务端通过这个token就能找到相对应的用户。<br>登陆成功之后，给这个用户生成一个类似于session id的东西，比方说就叫token来标识这个用户然后写到cookie中，传递给客户端，客户端在随后的访问中，都在cookie中上传这个token服务端拿到这个token之后，用这个token来取用户对应的用户信息。</p><p>客户端禁用cookie时？<br>URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。</p><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><h3 id="秒杀逻辑的实现"><a href="#秒杀逻辑的实现" class="headerlink" title="秒杀逻辑的实现"></a>秒杀逻辑的实现</h3><p>秒杀——减库存、下订单、生成秒杀订单(一个全部的order，一个用于秒杀的miaosha_order)，三个操作一个事务</p><h4 id="超卖问题—在数据库层面解决"><a href="#超卖问题—在数据库层面解决" class="headerlink" title="超卖问题—在数据库层面解决"></a>超卖问题—在数据库层面解决</h4><p>1.秒杀商品的库存不允许为负数，sql语句中加一个where条件进行库存数量判断；<br>2.为miaosha_order建立一个唯一索引(userId，goodsId)，即一个用户只能秒杀一种商品的一个，防止用户重复购买。</p><h4 id="最后一件商品，多个用户同时抢购"><a href="#最后一件商品，多个用户同时抢购" class="headerlink" title="最后一件商品，多个用户同时抢购"></a>最后一件商品，多个用户同时抢购</h4><p>redis缓存中stock标识还剩1时，多个用户同时抢购，都拿到可以秒杀的标识，这些秒杀请求都放入消息队列中，但消息队列先进先出的顺序，第一个被消费者拿到的秒杀请求可以被处理成功，其后的秒杀请求在数据库层面都是<code>sql:where stock &lt; 0</code>，无法创建订单，秒杀失败。<br>redis预减库存是为了减少到达数据库层面的请求，实际到达数据库层面的请求也许会多于库存数量，但库存数量为零时的秒杀请求就返回失败。</p><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><h3 id="JMeter压测"><a href="#JMeter压测" class="headerlink" title="JMeter压测"></a>JMeter压测</h3><p>JMeter入门—自定义变量模拟多用户—JMeter命令行使用<br>Redis压测工具redis-benchmark</p><p>网站承载的并发：每秒查询率QPS<br>QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。<br>QPS = 并发量 / 平均响应时间，通常QPS用来表达和衡量当前系统的负载，也可以用RPS来表示。<br>TPS是LoadRunner中重要的性能参数指标。TPS每秒十五处理量。</p><p>压测时报这个错误org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation<br>经过面向google编程，发现可能出发这种异常情况的原因：<br>第一：请求contenttype=application/json;charset=UTF-8,而这里的produces=text/html原来代码：@RequestMapping(value = “/upload”, method = RequestMethod.POST, produces = “text/html; charset=UTF-8”)解决方法：去掉produces = “text/html; charset=UTF-8”这段代码或者设置produces=application/json;charset=UTF-8<br>第二：方法名重复例子：① html的名字   showArticle.html② js的名字   showArticle.js③ajax传到后台来执行的方法名   ajax的url:”showArticle”④后台拦截方法名@ResponseBody@RequestMapping(value = “/showArticle”, method = RequestMethod.POST)解决方案防止静态文件名跟控制器请求路由冲突。如本例中，将login.html更名为signin.html。将静态文件URI与动态请求URI分离。如，把提供REST接口的URI都改成以/api/XXX开头，把静态文件改为以/static/XXX开头。这样当请求/static/login.html时，spring会直接使用内置的处理静态资源的控制器返回静态文件而不再去查找用户定义的控制器。</p><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>缓存逻辑<br>1.失效：应用程序先从缓存取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。<br>2.命中：应用程序从缓存中取数据，取到后返回。<br>3.更新：先把数据存到数据库中，成功后，再让缓存失效，更新缓存。不能先删除缓存，再更新数据库，会导致缓存数据不一致。<br>4.缓存处理流程：前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。</p><h3 id="缓存穿透和缓存雪崩"><a href="#缓存穿透和缓存雪崩" class="headerlink" title="缓存穿透和缓存雪崩"></a>缓存穿透和缓存雪崩</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透(缓存和数据库中都没有的数据)是指查询一个缓存中一定不存在数据，由于缓存不命中，接着查询数据库也无法查询出结果，因此也不会写入到缓存中，这将会导致每个查询都会去请求数据库。<br>解决方案：<br>1.布隆过滤。<br>对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免对底层存储系统的查询压力。<br>比如，接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；<br>2.缓存空对象。<br>当存储层中没有结果后，即使返回的空对象也将其存储起来(key：null)，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。（问题是，一、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；二、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响）。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿，是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这是由于并发用户特别多，同时读缓存没读到数据(并发查询同一条数据)，又同时去数据库去数据，引起数据库压力瞬间增大，造成过大压力。<br>解决方案：<br>1.设置热点数据，永远不过期<br>2.加互斥锁。</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指，由于缓存层承载着大量的请求，有效地保护了存储层，但是如果缓存层由于某些原因整体不能提供服务，于是所有的请求都会到达存储层，存储层的调用量会暴增，造成存储层数据库会挂掉。<br>解决方案：<br>1.依赖隔离组件为后端限流并降级。在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某一个key只允许一个线程查询数据和写缓存，其他线程等待。<br>2.数据预热。可以通过缓存reload机制，预先去更新缓存，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。<br>3.设置热点数据，不过期。</p><h4 id="缓存并发"><a href="#缓存并发" class="headerlink" title="缓存并发"></a>缓存并发</h4><p>缓存并发是指，高并发场景下同时大量查询过期的key值，最后查询数据库将缓存结果回写到缓存，造成数据库压力过大。<br>解决方案：<br>分布式锁。在缓存更新或者过期的情况下，先获取锁，在进行更新或者从数据库中获取数据后，再释放锁，需要一定的时间等待，就可以从缓存中继续获取数据。</p><h3 id="页面优化"><a href="#页面优化" class="headerlink" title="页面优化"></a>页面优化</h3><h4 id="1-页面缓存-URL缓存-对象缓存"><a href="#1-页面缓存-URL缓存-对象缓存" class="headerlink" title="1.页面缓存(+URL缓存)+对象缓存"></a>1.页面缓存(+URL缓存)+对象缓存</h4><p>页面缓存：访问一个页面时，首先不是让我们的系统去渲染页面(页面的html和css)，而是先从缓存中取，如果找到了就直接返回给客户端，如果没有就手动渲染再将结果返回给客户端，同时把结果存储到缓存，下次可以直接使用。<br>URL缓存与页面缓存实际上一样，url中多了一个id参数，根据id去取相应的事物的缓存内容。<br>对象缓存：设置token，返回一个对象。</p><h4 id="2-页面静态化，前后端分离。"><a href="#2-页面静态化，前后端分离。" class="headerlink" title="2.页面静态化，前后端分离。"></a>2.页面静态化，前后端分离。</h4><p> 页面静态化，不用JSP，用html写页面，用js和ajax获取/提交数据、渲染页面，实现前后端分离。<br> 页面静态化将页面缓存到用户的浏览器，用户访问页面时，不需要与服务端交互，从本地缓存拿到页面，节省流量。<br> 应用：将活动页面上(秒杀商品页面和商品列表)的所有可以静态的元素全部静态化，尽量减少动态元素，将静态页面缓存到redis中，访问秒杀商品页面时首先不是让系统去渲染页面而是先从缓存中取。</p><h4 id="3-静态资源优化"><a href="#3-静态资源优化" class="headerlink" title="3.静态资源优化"></a>3.静态资源优化</h4><p>1.JS/CSS压缩，自动去除空白字符和注释减小页面的体积，减少流量<br>2.多个JS/CSS的访问请求组合到一个请求中，减少连接数</p><h4 id="4-CDN优化"><a href="#4-CDN优化" class="headerlink" title="4.CDN优化"></a>4.CDN优化</h4><p>CDN内容分发网络Content Delivery Network。<br>CDN就近访问。</p><h4 id="高并发问题的解决"><a href="#高并发问题的解决" class="headerlink" title="高并发问题的解决"></a>高并发问题的解决</h4><p>瓶颈在数据库，加缓存来解决。从用户发起请求的时候，从浏览器开始，做页面的静态化将页面缓存到用户的浏览器端，在请求到达网站之前，部署一些CDN请求结点，让请求先访问CDN，（中间还可以有一层Nginx缓存），再做应用程序的页面缓存(将页面代码缓存到redis)，下一层对象缓存(将java对象缓存到redis)，最后访问数据库。一层一层的缓存来削减最后到达数据库的请求数量，保证网站在高并发情况下抗住压力。<br>采用缓存不可避免会导致数据的不一致。</p><h3 id="第六章接口优化"><a href="#第六章接口优化" class="headerlink" title="第六章接口优化"></a>第六章接口优化</h3><p>1.Redis预减库存减少数据库访问<br>思路：减少数据库访问<br>1）系统初始化，把商品库存数量加载到redis<br>2）收到用户秒杀请求，redis预减库存，库存不足的时候，直接返回秒杀失败，这样后面的请求对数据库的压力就没有了，否则进入3<br>3）将秒杀请求放入消息队列，返回用户一个响应“排队中”，此时还没有立即对数据库进行操作，而是进行异步下单<br>4）这时客户端会询问是否秒杀成功；服务端的队列将请求出队，生成订单，减少库存，给客户端秒杀成功的响应。<br>2.内存标记减少Redis访问<br>3.请求先入队(队列RabbitMQ)缓冲，异步下单，增强用户体验<br>4.<strong>Nginx水平/横向扩展</strong><br>用Nginx做一个反向代理，将本机80端口收到的请求反向代理，交给服务器集群(server_pool)，让这些服务器的权重weight相同，均分请求，负载均衡。<br><img src="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/nginx.png"><br><img src="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/jiagou.png"><br>5.数据库分库分表 中间件mycat</p><h4 id="思路：减少数据库访问"><a href="#思路：减少数据库访问" class="headerlink" title="思路：减少数据库访问"></a>思路：减少数据库访问</h4><p>1.系统初始化，把商品库存数量加载到Redis<br>2.收到请求，Redis预减库存，库存不足，直接返回秒杀失败，否则进入3<br>3.请求入队，立即返回排队中<br>4.请求出队，生成订单，减少库存<br>5.客户端轮询，是否秒杀成功</p><h4 id="轮询的实现"><a href="#轮询的实现" class="headerlink" title="轮询的实现"></a>轮询的实现</h4><p>setTimeout(getMiaoshaResult(), 200); 延时执行函数</p><h4 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h4><p>5000个线程 访问10次 50000个请求 QPS：2114</p><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>1.秒杀接口地址隐藏<br>思路：秒杀开始之前不知道秒杀的地址，不是写死的，要从服务端获取，动态拼成。<br>秒杀开始之前，先去秒杀请求接口获取秒杀地址。<br>1）接口改造，带上PathVariable参数<br>2）添加生成地址的接口<br>3）秒杀收到请求，先验证PathVariable参数</p><p>2.数学公式验证码—通过验证码来保证获取秒杀接口的地址的安全<br>思路：点击秒杀之前，先输入验证码，分散用户的请求。<br>作用：1）防止机器人盗刷；2）让用户填写验证码，让请求不会非常集中，将瞬间的并发量分散开，减轻数据库的压力。<br>实现：1）添加生成验证码的接口；2）在获取秒杀路径的时候，验证验证码；3）ScriptEngine使用。</p><p>3.接口限流防刷<br>限制同一UserID访问频率。<br>第一种：限制用户访问在一段时间之内只能访问有限的次数，超过这个次数就认为它是非法的。<br>做计时器，在用户访问的时候，记录他的访问次数。这个是在缓存中实现，比如说限定时间是一分钟可以允许用户访问接口100次，用户拿到秒杀地址后就开始计数，1分钟内访问次数就加一，超过有效期并且用户访问次数没有超过限制就重置，归零重新计数。<br>第二种：禁止重复提交，用户提交之后按钮置灰。IP限流。</p><p>get和post有什么区别？<br>GET是幂等的,从服务端获取数据,不会使服务端的数据产生变化<br>POST向服务端提交数据,要使得服务端的数据发生变化</p><h3 id="起竖机构态势信息高效表示及识别的研究"><a href="#起竖机构态势信息高效表示及识别的研究" class="headerlink" title="起竖机构态势信息高效表示及识别的研究"></a>起竖机构态势信息高效表示及识别的研究</h3><p>1.研究背景<br>在起竖控制系统中，执行终端误差表示属于一类技术矛盾：一个系统中两种需求之间的矛盾，即控制精度需求(要求误差等级划分尽量详细)与计算代价(要求误差等级划分尽量少)之间的矛盾，为其中之一而优化参数将导致另一项指标的恶化。<br>采用二值逻辑真或假来表示某一等级当前是或不是有效信息，控制器可以同时接收系统误差的所有可能状态，就是一组0、1组成的数串，该数串中至多有一位为1，即至多有一个误差等级是有效的。<br>当提高系统对误差的灵敏度、细化误差等级划分时，误差等级数目增加，误差等级数串的位数也将随之呈线性增加趋势，势必增加传输和暂存代价。控制系统进行决策计算时，误差等级数串最终要落实到硬件计算单元被处理。当误差等级数目增加进而导致数串的位数增加时，必然要相应改变误差等级信息的传输及计算的硬件单元数据线宽度，这将为改进系统控制性能带来不便。<br>2.选用Hamming编码<br>因此，将起竖机构执行终端误差表示中的矛盾依据TRIZ理论(发明问题解决理论)归纳的通用工程参数概括为信息数量与信息损失。<br>基于发明原理15“动态化“原理解决改善信息数量的同时造成信息损失的问题，将固定的信息表示方式改为可变的表示方式，即对执行终端误差信息进行编码，并选择Hamming规则进行编码。<br>应用Hamming编码方法对态势信息进行编码<br>Hamming码由美国数学家Richard Wesley Hamming提出，通过在传输的消息流中插入验证码的方法，侦测并更正单一bit错误，hamming码只能检测到一位错误。<br>在数据校验与纠错应用中，传输的对象是Hamming码的全部码位，确定错误码位后需要直接纠错该码位。在本次研究的起竖机构控制系统的误差表示应用中，误差信息数串中的码位必须是系统实时误差等级的真实反应，不能通过数值计算直接修改，而是由协同核心启用决策状态转移函数进行输出模式的计算，而且误差状态字已经能够反应误差等级数串的信息，因此，在检测误差时只需要传输误差状态字即可，不需传输Hamming码的全部码位。</p><h4 id="应用Hamming编码规则表示输出回路的角度跟踪误差"><a href="#应用Hamming编码规则表示输出回路的角度跟踪误差" class="headerlink" title="应用Hamming编码规则表示输出回路的角度跟踪误差"></a>应用Hamming编码规则表示输出回路的角度跟踪误差</h4><p>应用已有的文献，依托前人推导的Hamming规则的依据，建立的二叉树结构的Hamming树，使基于繁琐逻辑运算的Hamming校验过程可以被从根节点按路径权值访问叶节点的方式取代，这样来确定出错码位。</p><p>计算海明码的位数：假设用N表示加入了校验码位后整个传输信息的二进制位数。用K代表当中有效信息位数，r表示加入的校验码位数，它们之间的关系应满足：N=K＋r≤2r－1（是为了确保r位校验码能校验所有的数据位，由于r位校验码所能表示的最大十进制数为2r-1，同一时候也确保各位码本身不被其它校验码校验）<br>|  信息码位数  | 1 | 2-4 | 5-11 | 12-26 | 27-57 | 57-120 | 121-247 |<br>| ————|—|—–|——|——-|——-|——–|———|<br>|  校验码位数  | 2 | 3   |   4  |   5   |   6   |    7   |    8    |</p><p>根据数据的码位和海明码以某种规则进行运算，异或再相加，得到的结果判断该码位是否出错。</p><p>1.海明码检错/纠错基本思想<br>（1）将有效信息按某种规律分成若干组，每组安排一个校验位通过异或运算进行校验，得出具体的校验码<br>（2）在接收端同样通过异或运算看各组校验结果是否正确，并观察出错的校校组，或者多个出错的校验组的共同校验位，得出具体的出错比特位<br>（3）对错误位取反来将其纠正</p><p>2.海明码计算<br>(1) 计算校验码位数<br>(2) 确定校验码位置<br>(3) 确定校验码<br> 校验位置选择原则：第i位校验码从当前校验码位开始，每次连续校验i位后再跳过i位，然后再连续校验i位，再跳过i位，以此类推。确定每个校验码所校验的比特位：<br>P1校验码位校验的码字位为：第1位（也就是P1本身）、第3位、第5位、第7位、第9位、第11位、第13位、第15位，……。<br>P2校验码位校验的码字位为：第2位（也就是P2本身）、第3位，第6位、第7位，第10位、第11位，第14位、第15位，……。<br>P3校验码位校验的码字位为：第4位（也就是P4本身）、第5位、第6位、第7位，第12位、第13位、第14位、第15位，第20位、第21位、第22位、第23位，……。<br>Pn校验码位校验的码字位为：第2n-1位（也就是Pn本身）、第2n-1+1位、第2n-1+2位、第2n-1+3位、……、第2n-1位，第3×2n-1位、第3×2n-1+1、……、第2×2n-1位，第5×2n-1位、第5×2n-1+1位、第3×2n-1位，……、第7×2n-1位、第7×2n-1+1位、……、第4×2n-1位，……，第(2m-1) 2n-1位、……第m×2n-1位<br>    最后每组通过异或逻辑运算（与偶校验原理一样），使每组的运算结果为0(偶校验)，即可得出第i位校验码的值。<br>(4)实现检错<br>码字中的信息码位同时被多个校验码进行校验，然后通过这些码位对不同校验码的联动影响最终可以找出是哪一位出错了。<br>所有校验码所在的位是只由对应的校验码进行校验，如第1位（只由p1校验）、第2位（只由p2校验）、第4位（只由p3校验）、第8位（只由p4校验）、第16位（只由p5校验），……。也就是这些位如果发生了差错，影响的只是对应的校验码的校验结果，不会影响其它校验码的校验结果。这点很重要，如果最终发现只是一个校验组中的校验结果不符，则直接可以知道是对应校验组中的校验码在传输过程中出现了差错。<br>所有信息码位均被至少两个校验码进行了校验，也就是至少校验了两次。查看对应的是哪两组校验结果不符，确定是哪位信息码在传输过程中出了差错。<br>海明码校验的方式就是各校验码对它所校验的位组进行“异或运算”.<br>校验位组如下图示：<br><img src="/2019/08/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/haimingmajiaoyanweizu.png"><br>正常情况下（也就是整个码字不发生差错的情况下），在采用偶校验时，各校验组通过异或运算后的校验结果均应该是为0，也就是前面所说的G1、G2、G3、G4，……均为0，因为此时1为偶数个，进行异或运算后就是0；而采用奇校验时，各组校验结果均应是为1。<br>(5)纠错<br>检测出了是哪位差错还不够，因为海明码具有纠正一位错误的能力，所以还需要完成纠错过程。这个过程的原理比较简单，就是直接对错误的位进行取反，或者加“1”操作，使它的值由原来的“1”变成“0”，由原来的“0”变成“1”（因为二进制中每一位只能是这二者之一）。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2019/07/24/MySQL/"/>
      <url>/2019/07/24/MySQL/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/07/24/MySQL/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%80%83%E7%82%B9.png"><br>mysql是关系型数据库。<br>关系型数据库采用二维表结构组织和管理数据，并规定了表内和表间数据的依赖关系。<br>关系数据库是指一些相关的表和其他数据库对象的集合。对于关系数据库来说，关系就是表的同义词。关系型数据库管理系统以表、字段和记录等结构来组织数据，表用来保存数据，每个表由一组字段来定义其结构，记录是表中的一条数据。</p><h3 id="如何设计一个关系型数据库"><a href="#如何设计一个关系型数据库" class="headerlink" title="如何设计一个关系型数据库"></a>如何设计一个关系型数据库</h3><p><img src="/2019/07/24/MySQL/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1.png"></p><h3 id="MySQl中基于UTF-8字符集编码，VARCHAR字符长度与字节长度的理解"><a href="#MySQl中基于UTF-8字符集编码，VARCHAR字符长度与字节长度的理解" class="headerlink" title="MySQl中基于UTF-8字符集编码，VARCHAR字符长度与字节长度的理解"></a>MySQl中基于UTF-8字符集编码，VARCHAR字符长度与字节长度的理解</h3><p>在 <code>mysql 4.1</code> 及之前早期版本中，如果是字符集为UTF-8 ， varchar 以<code>字节</code>为单位存储，一个汉字占 3 个字节，则 varchar(100) 类型字段只能存放约 33 个汉字。</p><p>而在<code>往后的版本中，如 5.x </code>，一个汉字占多少长度与编码有关 。<br>在 UTF-8 字符集下，varchar 以<code>字符</code>为单位存储。所以 varchar(100) 类型字段可存放约 100 个汉字。</p><h2 id="一、MySQL执行引擎"><a href="#一、MySQL执行引擎" class="headerlink" title="一、MySQL执行引擎"></a>一、MySQL执行引擎</h2><p>一个库中可以有多个不同存储引擎的表。</p><h3 id="InnoDB-VS-MyISAM"><a href="#InnoDB-VS-MyISAM" class="headerlink" title="InnoDB VS MyISAM"></a>InnoDB VS MyISAM</h3><p>InnoDB采用聚集索引，数据和索引存储在一起。<br>若一个主键被定义，该主键则作为密集索引；若没有主键被定义，该表的第一个唯一非空索引则作为密集索引；若不满足以上条件，innoDB内部会生成一个隐藏主键(rowid，密集索引，该主键是一个六字节的列，该列的值随着记录的插入而自增)。<br>即innoDB必须得有一个主键作为密集索引存在，innodb引擎里的主键一般都是聚集索引；非主键索引都是非聚集索引，非主键索引存储相关键位和其对应的主键值，要进行两次查找(先通过非主键索引去查找主键索引，再通过主键索引去查找数据的物理地址)。<br>InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如updatetable set num=1 where name like “a%”，就是说在不确定的范围时，InnoDB还是会锁表的。InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的</p><p>MyIsam采用稀疏索引(非聚簇索引)。MyISAM中索引一个文件，数据一个文件，主键索引和辅助索引是平等的，不需要像innoDB的辅助索引一样要进行两次查找。</p><p>InnoDB和MyISAM数据库的表的结构定义信息都存储在frm文件中。<br>InnoDB的数据和索引存储在ibd文件中（聚集），MyISAM索引存在MYI文件中，数据存储在MYD文件中（非聚集）。  </p><p>InnoDB引擎的索引结构：也是B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p>MyISAM索引结构: MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。<br>B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。</p><h3 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h3><p>主键的索引:密集索引,聚簇索引/聚集索引,<br>非主键索引:稀疏索引,非聚集索引/辅助索引,二级索引<br>innodb使用B+树索引模型，而且是多叉树。innodb索引中分为主键索引(聚簇索引)和非主键索引(二级索引)。主键索引保存了该行数据的全部信息，二级索引保存了该行数据的主键；所以使用二级索引的时候会先查出主键值，然后回表查询出数据，而使用主键索引则不需要回表。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>主键索引和其他索引没有任何区别, 都是稀疏索引, 表数据存储在独立的地方MYD, 表数据MYD和索引MYI的分开的, 索引用地址指向表数据。</p><p>两者的对比：</p><ol><li>是否支持行级锁；</li><li>是否支持事务和崩溃后的安全恢复：MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB提供事务支持、外部键等高级数据库功能。</li><li>是否支持外键；</li><li>是否支持MVCC：仅InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效；MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作；MVCC可以使用乐观锁和悲观锁来实现；各数据库中MVCC实现并不统一。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、InnoDB"><a href="#二、InnoDB" class="headerlink" title="二、InnoDB"></a>二、InnoDB</h2><h3 id="表锁-行锁"><a href="#表锁-行锁" class="headerlink" title="表锁/行锁"></a>表锁/行锁</h3><p>有索引，则使用行锁；没有索引，则使用表锁。</p><p>表级锁还是行级锁说的是锁的粒度，共享锁和排他锁说的是锁的性质，不管是表锁还是行锁，都有共享锁和排他锁的区分。</p><h3 id="InnoDB的锁类型"><a href="#InnoDB的锁类型" class="headerlink" title="InnoDB的锁类型"></a>InnoDB的锁类型</h3><h4 id="1-基本锁"><a href="#1-基本锁" class="headerlink" title="1. 基本锁"></a>1. 基本锁</h4><p>在一个高并发系统中，会出现多会话同时访问同一资源的情况，此时即产生了竞争。为了保证数据的一致性，必须要用锁机制来控制资源的并发访问。</p><p>InnoDB采用的行锁的设计（MyISAM只支持表锁），行锁带来更高的并发性，但管理复杂度也要比表锁更高。InnoDB共实现了2种标准的行级锁：</p><ul><li>共享锁（S Lock），允许持有锁的事务读取数据。</li><li>排它锁（X Lock），允许持有锁的事务修改和删除数据。</li></ul><h4 id="2-意向锁-Intention-locks"><a href="#2-意向锁-Intention-locks" class="headerlink" title="2. 意向锁 Intention locks"></a>2. 意向锁 Intention locks</h4><p>InnoDB存储引擎支持多粒度的锁定，即允许行级锁和表级锁同时存在。</p><ul><li>意向共享锁（IS lock），表示事务想要获得表中某几行的共享锁。</li><li>意向排它锁（IX lock），表示事务想要获得表中某几行的排它锁。</li></ul><p>意向锁是一种表级锁，表示事务稍后希望在更细的粒度上（行级别）加锁。</p><ul><li>select … lock in share mode; 会对表施加IS锁</li><li>select … for update; 会对表施加IX锁</li></ul><table><thead><tr><th align="center"></th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">冲突</td></tr><tr><td align="center">IX</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">冲突</td><td align="center">兼容</td></tr><tr><td align="center">S</td><td align="center">冲突</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center">IS</td><td align="center">冲突</td><td align="center">兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><p>例如，如果请求在记录r上加X锁，则需要先在表级别上加意向排他锁（IX），如果此时表上存在其他锁，则意向锁需要等待表级别锁的释放，待表级意向锁(IX)获得成功后，才可以对行级别加X锁。</p><p>意向锁只会阻塞表级别的请求（如全表扫描、lock tables … write），除此之外不会阻塞任何操作。</p><h4 id="3-行锁-记录锁-Record-locks"><a href="#3-行锁-记录锁-Record-locks" class="headerlink" title="3. 行锁/记录锁 Record locks"></a>3. 行锁/记录锁 Record locks</h4><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，而不是给表的行记录加锁实现的，这就意味着只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。</p><p>由于InnoDB的行锁实现是针对索引字段添加的锁，不是针对行记录加的锁，因此虽然访问的是InnoDB引擎下表的不同行，但如果使用相同的索引字段作为过滤条件，依然会发生锁冲突，只能串行进行，不能并发进行。</p><p>即使SQL中使用了索引，但是经过MySQL的优化器后，如果认为全表扫描比使用索引效率高，此时会放弃使用索引，因此也不会使用行锁，而是使用表锁。</p><p>例如：<code>select col from t where col=1 for update;</code> 即对col为1的记录添加记录锁，阻止其他事务对此记录的操作。</p><h4 id="4-间隙锁-Gap-locks"><a href="#4-间隙锁-Gap-locks" class="headerlink" title="4. 间隙锁 Gap locks"></a>4. 间隙锁 Gap locks</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</p><p>例如：<code>select col from t where col between 1 and 10 for update;</code>会锁住1~10之间的间隙，而不管这段间隙内是否存在记录，因此间隙锁可能只锁住了一段空气。此时如果想插入为col为5的记录会被阻塞，即使5的记录不存在。</p><p>间隙锁的唯一目的即是阻止其他的事务往间隙中插入记录，因此不同的事务可以对同样的间隙重复加锁，没有共享和排他类型之分。</p><h5 id="InnoDB自动使用间隙锁的条件"><a href="#InnoDB自动使用间隙锁的条件" class="headerlink" title="InnoDB自动使用间隙锁的条件"></a>InnoDB自动使用间隙锁的条件</h5><ol><li><code>可重复读 Repeatable Read</code>级别下才会有间隙锁。必须在RR级别下。</li><li>检索条件必须有索引。（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打开间隙锁设置</span><br><span class="line">innodb_locks_unsafe_for_binlog：默认值为OFF，即启用间隙锁</span><br></pre></td></tr></table></figure><h4 id="5-临键锁-Next-Key-locks"><a href="#5-临键锁-Next-Key-locks" class="headerlink" title="5. 临键锁 Next-Key locks"></a>5. 临键锁 Next-Key locks</h4><p>行锁与间隙锁组合起来用就叫做Next-Key Lock。InnoDB默认加锁方式是<code>next-key</code>锁。</p><p><code>next-key lock</code>会对记录本身和记录之前的区间加锁。</p><blockquote><p>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.</p></blockquote><p>如果一个会话占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。</p><blockquote><p>If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order.</p></blockquote><p>例如：假设表中存在索引记录1,10。则next-key lock可能锁住的范围是：(-∞,1]、(1,10]、(10,+∞），对于最后一个区间，next-key lock也会锁住最大记录之后的间隙。</p><p><code>Next-key lock</code>只在<code>MySQL</code>的<code>repeatable read</code>隔离级别下使用，主要是用来解决<code>幻读(phantom read)</code>的问题。</p><p>当对唯一键值进行锁定时，next-key lock将会降级为record lock，即仅锁住唯一记录。而如果唯一键由多个列组成，而查询仅使用其中一列，则其实是range查询，InnoDB会依然使用next-key lock进行锁定。</p><h4 id="6-插入意向锁-Insert-intention-locks"><a href="#6-插入意向锁-Insert-intention-locks" class="headerlink" title="6. 插入意向锁 Insert intention locks"></a>6. 插入意向锁 Insert intention locks</h4><p>插入意向锁是间隙锁的一种，其由insert语句在插入记录前获取，代表将在间隙中插入记录的意向。</p><p>多个事务可以对同一个间隙重复加insert intention lock，只要插入的记录值不同，事务就不会冲突。</p><p>例如表中已存在记录1和10,两个事务分别想插入5和6。两个事务都会对1和10记录之间的间隙(2,9)加insert intention lock，但由于插入的记录值不同，因此后续对要插入的记录获取X锁的时候并不会冲突。</p><h4 id="7-自增锁-auto-inc-locks"><a href="#7-自增锁-auto-inc-locks" class="headerlink" title="7. 自增锁 auto-inc locks"></a>7. 自增锁 auto-inc locks</h4><p>自增锁是一种特殊类型的表锁，只要在事务对auto_increment类型的列插入数据时，才会施加auto-inc lock,此时其他想插入的事务都需要等待该锁的释放，而持有该锁的事务可以获得连续的primary key值。</p><h2 id="三、MySQL中B-树的落地"><a href="#三、MySQL中B-树的落地" class="headerlink" title="三、MySQL中B+树的落地"></a>三、MySQL中B+树的落地</h2><p><img src="/2019/07/24/MySQL/myisam.png"><br><img src="/2019/07/24/MySQL/innodb.png"><br><img src="/2019/07/24/MySQL/innodb%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.png"><br><img src="/2019/07/24/MySQL/%E5%AF%B9%E6%AF%94.png"></p><h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong>和<strong>哈希索引</strong>。<br>对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。<br>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p><ul><li>InnoDB：其数据文件本身就是索引文件。其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong></li><li>MyISAM：B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存放，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”，索引文件和数据文件分开存储。</li></ul><p>为什么mysql中给某一个字段添加一个唯一性约束，会自动生成一个索引？<br>唯一性约束是为了做到表中数据不能有重复值，但是数据库是如何保证数据没有重复值呢？<br>要在存储数据的时候查询一遍看是否重复。<br>那怎样查询最快呢？mysql中创建索引查询最快，所以在创建唯一性约束时就创建了索引。<br>为什么索引查询最快？<br>索引的底层数据结构决定。</p><h2 id="五、数据库事务"><a href="#五、数据库事务" class="headerlink" title="五、数据库事务"></a>五、数据库事务</h2><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>读未提交read-uncommitted：允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>不可重复读(读已提交)read-committed：允许读取并发事务已经提交过的数据，可以防止脏读，但是幻读或不可重复读仍有可能发生。</li><li>可重复读repeatable-read：对同一字段的多次读取结果都是一致的，除非是被本身事务自己所修改，可以防止脏读和不可重复读，但幻读仍有可能发生。这是InnoDB默认支持的隔离级别。</li><li>串行化serializable：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。</li></ul><p>mysql默认的事务隔离级别是可重复读repeatable-read。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>RU，读未提交</li><li>RC，读已提交。Oracle/SQLserver的默认隔离级别是read committed。是允许幻读和不可重复读存在的</li><li>RR，可重复读。MySQL默认隔离级别是RR，在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。</li><li>Serializable，串行化</li></ul><h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h3><h4 id="脏读-dirty-read"><a href="#脏读-dirty-read" class="headerlink" title="脏读 dirty read"></a>脏读 dirty read</h4><p>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”。</p><h4 id="不可重复读-unrepeatable-read"><a href="#不可重复读-unrepeatable-read" class="headerlink" title="不可重复读 unrepeatable read"></a>不可重复读 unrepeatable read</h4><p>一个事务对同一数据的读取结果前后不一致。与脏读的区别在于，脏读的是另一事务未提交的数据，不可重复读的是另一事务已经提交的数据，只不过数据被其他事务修改过。<br>事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p><h4 id="幻读-phantom-read"><a href="#幻读-phantom-read" class="headerlink" title="幻读 phantom read"></a>幻读 phantom read</h4><p>事务读取某个范围的数据时，因为其他事务的操作导致前后两次读取的结果不一致。幻读和不可重复读的区别在于，不可重复读是针对确定的某一行数据而言，而幻读是针对不确定的多行数据，因此幻读通常出现在带有查询条件的范围查询中。<br>一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询未看到的行。<br>系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p><p>乐观并发控制:对于并发执行可能冲突的操作,假定其不会真的冲突,允许并发执行,直到真正发生冲突时才去解决冲突,比如让事务回滚。<br>悲观并发控制:对于并发执行可能冲突的操作,假定其必定发生冲突,通过让事务等待(锁)或者中止(时间戳排序)的方式使并行的操作串行执行。</p><h2 id="六、数据库锁"><a href="#六、数据库锁" class="headerlink" title="六、数据库锁"></a>六、数据库锁</h2><h4 id="加锁的目的"><a href="#加锁的目的" class="headerlink" title="加锁的目的"></a>加锁的目的</h4><p>数据库的锁是为了解决事务的隔离性问题，为了让事务之间相互不影响，每个事务进行操作的时候都会对数据加上一把特有的锁，防止其他事务同时操作数据。</p><h4 id="锁是基于什么实现的"><a href="#锁是基于什么实现的" class="headerlink" title="锁是基于什么实现的"></a>锁是基于什么实现的</h4><p>在Innodb中，锁是作用在索引上面的，当我们的SQL命中索引时，那么锁住的就是命中条件内的索引节点(行锁)，如果没有命中索引的话，那我们锁的就是整个索引树（表锁）</p><h3 id="并发事务访问相同记录"><a href="#并发事务访问相同记录" class="headerlink" title="并发事务访问相同记录"></a>并发事务访问相同记录</h3><h4 id="读读情况"><a href="#读读情况" class="headerlink" title="读读情况"></a>读读情况</h4><p>并发事务相继读取相同记录，允许发生。</p><h4 id="写写情况"><a href="#写写情况" class="headerlink" title="写写情况"></a>写写情况</h4><p>这种情况会出现脏写的问题，任何一种隔离级别都不允许这种问题的发生，是通过加锁来实现的。这个所谓的锁其实是一个内存中的结构。<br>当一个事务想对一条记录作出修改时，首先会看看内存中有没有与这条记录相关的锁结构，当没有的时候就会在内存中生成一个锁结构与之相关联。</p><p>比如，事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：<br><img src="/2019/07/24/MySQL/%E7%94%9F%E6%88%90%E9%94%81%E7%BB%93%E6%9E%84.png"></p><p>锁结构两个比较重要的属性：</p><ul><li>trx信息：表示锁结构与哪个事务有关</li><li>is_waiting：表示当前事务是否在等待</li></ul><p>锁获取的状态：</p><ul><li>获取锁成功：内存中生成了对应的锁结构，而且is_waiting的值为false。（除了隐式锁）</li><li>获取锁失败：内存中生成了对应的锁结构，而且is_waiting的值为true，事务需要等待</li><li>不加锁：内存中没有生成锁结构，可以直接操作。（不包括隐式锁）</li><li>释放锁：释放锁，发现还有事务等待锁，修改对应锁结构is_waiting的值为true</li></ul><h4 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a>读-写或写-读情况</h4><p>读-写或写-读，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。</p><h4 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h4><p>怎么解决脏读、不可重复读、幻读的问题，有两种解决方案。</p><ul><li>方案一：读操作利用多版本并发控制(MVCC),写操作进行加锁</li><li>方案二：读写操作都采用加锁的方法</li></ul><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><ul><li>基于锁的属性分类：共享锁、排他锁。</li><li>基于锁的粒度分类：行级锁（innodb)、表级锁（innodb、myisam)、页级锁（innodb引擎)、记录锁、间隙锁、临键锁、自增锁。</li><li>基于锁的状态分类：意向共享锁、意向排它锁。</li><li>基于加锁的态度分类：悲观锁、乐观锁。</li></ul><p>MyISAM和InnoDB存储引擎使用的锁：</p><ul><li>MyISAM采用表级锁(table-level locking)</li><li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁<br>表级锁和行级锁对比：</li><li>表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li><li>行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。<br>InnoDB存储引擎的锁的算法有三种：</li><li>Record lock：单个行记录上的锁。</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身。</li><li>Next-key lock：record+gap锁定一个范围，包含记录本身。</li></ul><p>相关知识点：</p><ol><li>innodb对于行的查询使用next-key lock</li><li>Next-locking keying为了解决Phantom Problem幻读问题</li><li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ol><h2 id="七、MySQL执行计划"><a href="#七、MySQL执行计划" class="headerlink" title="七、MySQL执行计划"></a>七、MySQL执行计划</h2><p>如何查看执行计划<br>如何根据执行计划进行SQL优化</p><h2 id="八、SQL优化"><a href="#八、SQL优化" class="headerlink" title="八、SQL优化"></a>八、SQL优化</h2><h3 id="1-如何定位并优化慢查询sql"><a href="#1-如何定位并优化慢查询sql" class="headerlink" title="1)如何定位并优化慢查询sql"></a>1)如何定位并优化慢查询sql</h3><ol><li>第一步根据慢日志定位慢查询sql。慢日志是用来记录执行比较慢的sql。</li><li>第二步使用explain等工具分析sql。<br>explain关键字段：type；extra</li><li>第三步修改sql或者尽量让sql走索引。</li></ol><p>Ⅰ.MySql中的日志包括错误日志、二进制日志、通用查询日志、慢查询日志等。</p><ul><li><strong>通用查询日志</strong>：记录建立的客户端连接和执行语句。</li><li><strong>慢查询日志</strong>：记录所有执行时间超过long_query_time秒的所有查询或者不适用索引的查询。</li><li><strong>错误日志</strong>：记录启动、运行或停止mysqld时出现的问题。</li><li><strong>二进制日志</strong>：记录所有更改数据的语句，还用于复制。</li></ul><p>Ⅱ.<strong>mysql slow log</strong>是用来记录执行时间较长(超过long_query_time秒)的sql的一种日志工具。</p><ul><li>启用slow log<ul><li>在my.cnf里通过log-slow-queries[=file_name]</li><li>在mysqld进程启动时,指定–log-slow-queries[=file_name]选项</li></ul></li><li>慢日志查询监控工具<ul><li>explain</li></ul></li></ul><h3 id="2-联合索引的最左匹配原则的成因"><a href="#2-联合索引的最左匹配原则的成因" class="headerlink" title="2)联合索引的最左匹配原则的成因"></a>2)联合索引的最左匹配原则的成因</h3><h3 id="3-索引是建立得越多越好吗"><a href="#3-索引是建立得越多越好吗" class="headerlink" title="3)索引是建立得越多越好吗"></a>3)索引是建立得越多越好吗</h3><h2 id="九、数据库主备搭建"><a href="#九、数据库主备搭建" class="headerlink" title="九、数据库主备搭建"></a>九、数据库主备搭建</h2><h3 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h3><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><h4 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h4><h2 id="十、分库分表"><a href="#十、分库分表" class="headerlink" title="十、分库分表"></a>十、分库分表</h2><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——树</title>
      <link href="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/"/>
      <url>/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/tree.png"></p><ul><li>二叉树</li><li>动态查找树<ol><li>二叉查找树 BST</li><li>平衡二叉树 AVL</li><li>红黑树 RBT</li><li>哈夫曼树</li></ol></li><li>多路查找树<ol><li>B树</li><li>B+树</li><li>R树</li></ol></li></ul><h3 id="1-二分搜索树（BST）"><a href="#1-二分搜索树（BST）" class="headerlink" title="1.二分搜索树（BST）"></a>1.二分搜索树（BST）</h3><p>二叉树——&gt;完全二叉树——&gt;满二叉树<br>二叉树具有天然递归结构：每个节点的左子树也是二叉树，每个节点的右子树也是二叉树。</p><h4 id="二分搜索树的每个节点的值"><a href="#二分搜索树的每个节点的值" class="headerlink" title="二分搜索树的每个节点的值"></a>二分搜索树的每个节点的值</h4><p>大于其左子树的所有节点的值，小于其右子树的所有节点的值。<br>二分搜索树中存储的元素必须有可比较性。</p><h4 id="二分搜索树的前中后序遍历"><a href="#二分搜索树的前中后序遍历" class="headerlink" title="二分搜索树的前中后序遍历"></a>二分搜索树的前中后序遍历</h4><h3 id="2-平衡二叉树-AVL"><a href="#2-平衡二叉树-AVL" class="headerlink" title="2.平衡二叉树(AVL)"></a>2.平衡二叉树(AVL)</h3><p>基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。</p><p>AVL树的应用场景：</p><ul><li>windows对进程地址空间的管理</li></ul><h3 id="3-红黑树（R-B-Tree）"><a href="#3-红黑树（R-B-Tree）" class="headerlink" title="3.红黑树（R-B Tree）"></a>3.红黑树（R-B Tree）</h3><ol><li>任何一个节点都有颜色，黑色或者红色。</li><li>根节点是黑色的。</li><li>父子节点之间不能出现两个连续的红节点。</li><li>任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等。</li><li>空节点被认为是黑色的。</li></ol><p>红黑树的应用场景：</p><ol><li>epoll在内核中的实现，用红黑树管理事件块（文件描述符）</li><li>Java的TreeMap实现</li><li>nginx中，用红黑树管理timer</li><li>linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块</li></ol><h3 id="4-B-树"><a href="#4-B-树" class="headerlink" title="4.B-树"></a>4.B-树</h3><p>B-树是一种多路平衡查找树，在文件系统中很有用。<br>一颗m阶的B-树，或为空树，或为满足下列特性的m叉树：<br>1)树中每个节点至多有m棵子树；<br>2)若根节点不是叶子节点，则至少有两棵子树；<br>3)除根之外的所有非终端节点至少有m/2上限棵子树；<br>4)所有的非终端节点中包含下列信息数据：(n，A0，K1，A1，K2，A2，……，Kn，An)。其中，n(m/2-1&lt;=n&lt;=m-1)为关键字的个数(或n+1为该节点子树的个数)；Ki(1&lt;=i&lt;=n)为关键字，且Ki&lt; Ki+1；Ai(0&lt;=i&lt;=n)为指向该节点子树根节点的指针，且指针Ai-1所指子树中所有节点的关键字均小于Ki，An所指子树中所有的节点的关键字均大于Kn。<br>5)所有叶子结点位于同一层。保证平衡。<br><img src="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/B%E6%A0%91.jpg"></p><h4 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h4><p>在B-树上进行查找的过程是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程。<br>由于B-树用作文件的索引，因此它的查找涉及外存的存取。<br>在B-树上进行查找包含两种操作：(1)在B-树中找节点；(2)在节点中找关键字。由于B-树通常存储在磁盘上，则前一查找操作是在磁盘上进行的，而后一查找操作实在内存中进行的，即在磁盘上找到指针p所指节点后，先将节点中的信息读入内存，然后再利用顺序查找或折半查找查询等于K的关键字。</p><h4 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h4><p>插入和分裂<br>m阶的B树，每个结点最多m-1个关键字，保证最多有m棵子树。</p><h4 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h4><h4 id="B树怎么保证绝对平衡的？"><a href="#B树怎么保证绝对平衡的？" class="headerlink" title="B树怎么保证绝对平衡的？"></a>B树怎么保证绝对平衡的？</h4><h3 id="5-B-树"><a href="#5-B-树" class="headerlink" title="5.B+树"></a>5.B+树</h3><p>B+树是应文件系统所需而出的一种B-树的变型树(严格来说，它已不是此前定义的树了)。<br>一棵m阶的B+树和m阶的B-树的差异在于：<br>1)有n棵子树的节点中含有n个关键字；<br>2)所有的叶子节点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接；<br>3)所有的非终端节点可以看成是索引部分，节点中仅含有其子树(根节点)中的最大(或最小)关键字。<br><img src="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/B+%E6%A0%91.jpg"></p><h4 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B+树的查找"></a>B+树的查找</h4><h4 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h4><p>B+树的插入仅在叶子节点上进行，当节点中的关键字个数大于m时要分裂成两个节点，它们所含关键字的个数分别为(m+1)/2的上界，并且它们的双亲结点中应同时包含这两个结点中的最大关键字。</p><h4 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h4><p>B+树的删除也仅在叶子节点进行，当叶子结点中的最大关键字被删除时，其在非终端结点中的值可以作为一个“分界关键字”存在。若因删除而使节点中关键字的个数少于m/2时，其和兄弟节点的合并过程和B-树类似。</p><h3 id="6-线段树-区间树"><a href="#6-线段树-区间树" class="headerlink" title="6.线段树(区间树)"></a>6.线段树(区间树)</h3><p>线段树不是完全二叉树，是平衡二叉树。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假如我是一个诗人</title>
      <link href="/2019/05/28/%E9%9A%8F%E7%AC%94-%E8%90%BD%E5%AF%9E%E8%AF%97%E4%BA%BA/"/>
      <url>/2019/05/28/%E9%9A%8F%E7%AC%94-%E8%90%BD%E5%AF%9E%E8%AF%97%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>6<br>有一天<br>我和晚风做了一个约定<br>天色将暗时<br>我们互换身体<br>我有一个额外的条件<br>我要带走关于你的记忆</p><p>于是<br>那一晚我变成了风<br>我只做了一件事<br>三月中旬<br>满月当空<br>我吹来一大团水汽<br>然后云雾笼罩<br>月色朦胧</p><p>月亮是存在于十四行诗里的光辉<br>你是白日梦尽头的天光大放<br>当我看见你的那一刻<br>我对你说，“我看见了月亮”<br>今夜<br>我不要地球上的人观赏<br>我妄图独享</p><p>那个与晚风交换的“我”呢<br>他呆坐在荒野的尽头<br>不知道在凝望着什么<br>一如往常的许许多多个夜晚<br>他什么也做不了<br>除了凝望</p><p>第二天天色将暗时<br>我又坐在荒野的尽头<br>晚风袭来，带着显然的怒气<br>他再也不会与我交换<br>除非我什么也不带走，尤其关于你的记忆<br>他没有想到：<br>我所带走的，已经是我的全部</p><p>晚风再次提议<br>他想知道那种感觉<br>那种我装着你的时候的感觉<br>我拒绝了<br>晚风不解<br>他在我身边想了一整个晚上</p><p>于是那个夜晚<br>我又呆坐在荒野的尽头<br>不知道在凝望些什么<br>一如往常的许许多多个夜晚<br>我什么也做不了<br>除了凝望<br>我只觉得冷</p><p>5<br>假如我是一个诗人<br>一个乐观的诗人<br>我就会留意到我和你在一起时<br>天气很好，阳光温柔，风也善良<br>我们一起走在路上，想到什么便说什么<br>要是不说话，也十分美好<br>好像我们就该这样，从清晨到日暮<br>吃过饭后看月亮爬上来<br>听你说，“今晚的月亮好圆啊”</p><p>可我总在和你见面时便想到将要分别<br>想到这些我就难过到说不出话来<br>可是你明明什么也没有问我<br>美好的时光很短，短到让人看不见<br>美好不再<br>若是悲观者寿<br>我将长久且寂寥地等待下去</p><p>4<br>假如我是一个诗人<br>一个多情的诗人<br>我想象自己也许会为很多人动情<br>生活有时很长，还夹杂着苦难<br>我需要不断地去爱人方不至于难过</p><p>我遇到一些人像十八岁的云<br>一些人像十二月初冬的雪<br>像三四月的蝴蝶从蓝色里飞来<br>像鲜红的玫瑰、在夜晚醒来的星星<br>和睡不着的白日梦</p><p>我在同一段时间只钟情一个人<br>我不知道怎么会忽然不再了<br>有时候怪我，而有时不怪我<br>当我无法再把她写进字里行间<br>我知道，这已经不对了<br>喜欢一个人，才会为她写诗</p><p>从此朝也不思，夜也不想<br>诗和好梦都追随她而去<br>我只是在偶尔看到那些美好事物时恍然：<br>她是美好本身<br>而我呢，什么也不是</p><p>3<br>假如我是一个诗人<br>一个历经沧桑的诗人<br>我踏碎了一场冬天慕名而来<br>站在你的花园外目睹这久违的春色<br>九千里长风在我身后回旋、吟唱<br>送给你我肩上最后消融的雪花<br>借着夕阳的余晖袒露爱意</p><p>我自深深处走来，向你走来<br>轻声唤你：我的爱人</p><p>2<br>假如我是一个诗人<br>一个不羁的诗人<br>我在和你有关的事物中迸发灵感<br>譬如初见你时，我写“星光颤抖”<br>沉沦之后，写“夜色零落”<br>大可以在你忽远忽近时抽身离去<br>为什么我却越来越虚弱了</p><p>我想你<br>而有时你也想到我</p><p>1<br>如果我是一个落魄诗人<br>我会拿出比我还落魄的诗句<br>和比我富有的人交换<br>只换一分动容</p><p>诗里不会有山川河流<br>没存在草木生灵<br>只会写：我在上帝之上爱你<br>在时间之外想你<br>看客动容，我就可以继续爱你<br>声势浩大的爱意<br>是我唯一可以给你的东西</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="在浏览器中输入一个网址，按下回车后，发生了什么？"><a href="#在浏览器中输入一个网址，按下回车后，发生了什么？" class="headerlink" title="在浏览器中输入一个网址，按下回车后，发生了什么？"></a>在浏览器中输入一个网址，按下回车后，发生了什么？</h3><p><img src="httpqingqiu.png"></p><ol><li><strong>域名解析</strong><br> 浏览器通过浏览器缓存、系统缓存、路由器缓存、域名服务器搜索该域名的ip地址。</li><li><strong>发起TCP3次握手，建立TCP连接</strong><br> 拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序的80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。<br>为什么HTTP协议要基于TCP来实现？<br>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</li><li><strong>建立TCP连接后发起HTTP请求</strong><br><img src="httpqingqiubaowen.jpg"></li><li><strong>服务器端响应http请求，浏览器得到html代码</strong><br> 服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件。</li><li><strong>浏览器解析html代码，并请求html代码中的资源</strong><br> 浏览器拿到html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以请求成功显示的顺序并不一定是代码里面的顺序。<br>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</li><li><strong>浏览器对页面进行渲染呈现给用户</strong><br> 浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</li></ol><h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h3><p><img src="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png"></p><h2 id="物理层和数据链路层"><a href="#物理层和数据链路层" class="headerlink" title="物理层和数据链路层"></a>物理层和数据链路层</h2><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>IP ICMP ARP RARP AKP UUCP</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>TCP和UDP Socket</p><h3 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP 传输控制协议"></a>TCP 传输控制协议</h3><ol><li>TCP是面向连接的。面向连接，三次握手建立连接，四次挥手释放连接；</li><li>TCP提供可靠交付的服务。通过TCP连接传送的数据无差错、不丢失、不重复，并且按序到达。TCP的报文段是交给IP层(网络层)传送的，而IP层只能提供最大努力服务，网络提供的是不可靠的传输。</li><li>基于字节流。应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成是一连串的无结构的字节流。在TCP连接中传送的字节流的每一个字节都按顺序编号。</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。TCP连接的端点叫套接字(socket)。根据RFC793的定义，端口号拼接到IP地址即构成了套接字(IP地址：端口号)。每一条TCP连接唯一的被通信两端的两个套接字确定。</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li><li>TCP首部20个字节。源端口、目的端口，序号seq，确认号ack，同步位SYN，终止位FIN，确认位ACK，检验和，窗口，……</li><li>因为TCP下面的网络提供的是不可靠的传输，所以TCP必须采用适当的措施使得两个运输层之间的通信变得可靠：传输信道不产生差错；不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li></ol><h3 id="UDP-用户数据报协议"><a href="#UDP-用户数据报协议" class="headerlink" title="UDP 用户数据报协议"></a>UDP 用户数据报协议</h3><ol><li>UDP是无连接的，发送数据之前不需要建立连接。</li><li>UDP使用尽最大努力交付，不保证可靠交付。因此主机不需要维持复杂的连接状态表。</li><li>UDP是面向报文的。发送方的UDP(传输层)对应用层的应用程序交下来的报文，在添加UDP数据报首部后就向下交付给IP层，UDP对应用层交下来的报文既不合并也不拆分，而是保留这些报文的边界；在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。</li><li>UDP没有拥塞控制。网络出现的拥塞不会使源主机的发送速率降低，吞吐量只受限于数据生成速率、传输速率以及机器性能。</li><li>UDP支持一对一、一对多、多对一、多对多的交互通信。</li><li>UDP的首部开销小。UDP的首部：源端口，目的端口，长度(UDP用户数据报的长度)，检验和，每个字段两个字节，一共只有8个字节。</li></ol><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>ACK：确认序号标志<br>SYN：同步序号，用于建立连接过程<br>FIN：finish标志，用于释放连接(只有连接释放请求报文中置1)<br><img src="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>第一次握手，建立连接时，客户端发送SYN包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手，服务器收到SYN包，必须确认客户的SYN(ack=x+1)，同时自己也发送一个SYN包(syn=y)，即SYN+ACK包，此时服务器进入SYN_RCVD状态；<br>第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"><br>第一次挥手：客户端发送连接释放报文，FIN=1，seq=u，客户端进入终止等待1状态。<br>第二次挥手：服务器对连接释放的确认，ACK=1，ack=u+1，seq=v，至此客户端进入终止等待2状态，但是服务器进入关闭等待状态，还能向客户端发送数据。<br>第三次挥手：服务器发送连接释放报文，FIN=1，ACK=1，ack=u+1，seq=w，因为服务器在关闭等待状态可能向客户端发送了数据，所以seq不是v，服务器进入最终确认状态。<br>第四次挥手：客户端对服务器发来的连接释放进行确认，ACK=1，ack=w+1，seq=u+1。服务器收到这个确认报文进入CLOSED状态，而客户端还没有关闭连接，客户端此时进入TIME_WAIT状态，需等待2MSL时间。</p><p>为什么会有TIME_WAIT状态？<br>TCP连接必须经过时间2MSL后才真正释放掉。1)确保A发送的最后一个确认报文段ACK能够到达B，这个报文段有可能丢失，使得LAST_ACK状态的B收不到对已发送的FIN+ACK的确认，B就会重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器。如果A不等待2MSL时间，而是马上进入CLOSED状态，那么B很有可能无法正常进入CLOSED状态；2)防止已失效的连接请求报文段出现在本连接中，避免新旧连接混淆。</p><p>为什么需要四次握手才能断开连接？<br>因为TCP连接是全双工的，发送方和接收方都需要FIN报文和ACK报文。</p><h3 id="流量控制、拥塞控制"><a href="#流量控制、拥塞控制" class="headerlink" title="流量控制、拥塞控制"></a>流量控制、拥塞控制</h3><h4 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h4><ol><li>以字节为单位的<strong>滑动窗口</strong>。TCP使用滑动窗口做流量控制和乱序重排。</li><li>超时重传时间的选择。报文段往返时间RTT(发送一个数据包到收到相对应的ACK所花费的时间)；超时重传时间RTO(超市计时器设置的重传时间间隔)。</li><li>选择确认(select ACK)。<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以在TCP连接上实现对发送方的流量控制。发送方的发送窗口不能超过接收方给出的接收窗口的数值。TCP的窗口单位是字节，不是报文段。<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4>计算机网络中的链路容量(即带宽)、交换节点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫做拥塞。拥塞：对资源的需求超过了可用资源。<br>拥塞控制防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。</li></ol><p>TCP的拥塞控制算法：慢开始、拥塞避免、快重传、快恢复。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>HTTP和HTTPS WebSocket</p><h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><ul><li>HTTPS是具有安全性的SSL加密协议，是密文传输的，HTTP明文传输</li><li>连接方式不同，HTTPS默认使用<code>443</code>端口，HTTP使用<code>80</code>端口</li><li>HTTPS=HTTP+加密+认证+完整性保护</li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>SSL(Security Sockets Layer，安全套接层)是为网络通信提供安全及数据完整性的一种安全协议，是操作系统对外的API。<br>SSL3.0后更名为TLS，采用身份验证和数据加密保证网络通信的安全和数据的完整性。<br><img src="httpyuhttps.png"></p><h3 id="HTTP超文本传输协议"><a href="#HTTP超文本传输协议" class="headerlink" title="HTTP超文本传输协议"></a>HTTP超文本传输协议</h3><p>客户/服务器模式。<br>http协议本身是无连接的，虽然http使用了TCP作为运输层协议，但通信的双方在交换http报文之前不需要先建立http连接。<br>http协议是无状态的。同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。</p><h4 id="HTTP协议与TCP-IP协议的关系"><a href="#HTTP协议与TCP-IP协议的关系" class="headerlink" title="HTTP协议与TCP/IP协议的关系"></a>HTTP协议与TCP/IP协议的关系</h4><p>HTTP的长连接和短连接本质上是TCP的长连接和短连接。<br>HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。<br>IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。</p><h4 id="如何理解HTTP协议是无状态的"><a href="#如何理解HTTP协议是无状态的" class="headerlink" title="如何理解HTTP协议是无状态的"></a>如何理解HTTP协议是无状态的</h4><p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。<br>也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。<br>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议。</p><h4 id="http长连接和短连接"><a href="#http长连接和短连接" class="headerlink" title="http长连接和短连接"></a>http长连接和短连接</h4><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。<br>当客户端浏览器访问的某个HTML或其他类型的web页中包含有其他的web资源(如javaScript文件、图像文件、CSS文件等)，每遇到这样一个web资源，浏览器就会重新建立一个http会话。</p><p>从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。<br>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件(如apache)中设定这个时间。<br>实现长连接需要客户端和服务端都支持长连接。</p><h4 id="http-1-0、http-1-1、http-2-0、http-3-0"><a href="#http-1-0、http-1-1、http-2-0、http-3-0" class="headerlink" title="http/1.0、http/1.1、http/2.0、http/3.0"></a>http/1.0、http/1.1、http/2.0、http/3.0</h4><ul><li>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，HTTP1.1默认支持长连接</li><li>HTTP 1.1支持只发送header信息(不带任何body信息)。还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可</li><li>HTTP1.0是没有host域的，HTTP1.1才支持这个参数</li><li>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求</li><li>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快</li><li>HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取</li></ul><h4 id="http-中-get-和-post-区别"><a href="#http-中-get-和-post-区别" class="headerlink" title="http 中 get 和 post 区别"></a>http 中 get 和 post 区别</h4><p>http报文层面：GET将请求信息放在URL中，POST放在报文体中。<br>数据库层面：GET请求符合幂等性和安全性，POST不符合。<br>其他：GET请求可以被缓存、被存储，而POST不行。</p><h4 id="常见的-web-请求返回的状态码"><a href="#常见的-web-请求返回的状态码" class="headerlink" title="常见的 web 请求返回的状态码"></a>常见的 web 请求返回的状态码</h4><p>1xx表示通知信息，如请求收到了或正在进行处理<br>2xx表示成功，如202接受或知道了，200正常返回信息<br>3xx表示重定向，如要完成请求还必须采取进一步的行动<br>4xx表示客户端错误，如请求中有错误的语法或不能完成<br>5xx表示服务器的差错，如服务器失效无法完成请求<br>400错误的请求；404找不到，请求的资源不存在；401请求未经授权；403服务器收到请求，但是拒绝提供服务<br>302临时移动；301资源永久性地转移到其他URL；<br>500内部服务器错误；503服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p><h3 id="HTTP是无状态协议，如何保存用户状态"><a href="#HTTP是无状态协议，如何保存用户状态" class="headerlink" title="HTTP是无状态协议，如何保存用户状态"></a>HTTP是无状态协议，如何保存用户状态</h3><p>HTTP是一种不保存状态，即无状态(stateless)协议。也就是说HTTP协议自身不对请求和响应之间的通信状态进行保存。<br>那么我们如何保存用户状态呢？<br>Session机制的存在就是为了解决这个问题，session的主要作用就是通过服务端记录用户的状态。<br>典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为HTTP协议是无状态的，服务端给特定的用户创建特定的session之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个session，过了时间限制，就会销毁这个session)。</p><ul><li>在服务端保存session的方法很多，最常用的就是内存和数据库(使用内存数据库redis保存)。</li><li>既然session存放的服务器端，那么我们如何实现seesion跟踪呢？大部分情况下，我们都是通过在Cookie中附加一个Session ID的方式来跟踪。</li></ul><h3 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h3><p>Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><ol><li><strong>Cookie一般用来保存用户信息。</strong>比如①我们在Cookie中保存已经登录过的用户信息，下次访问网站的时候页面可以自动把你登录的一些基本信息给填了；②一般的网站都会有保持登录，也就是说下次再访问网站的时候就不需要重新登录了，这是因为用户登陆的时候我们可以存放一个Token在Cookie中，下次登录的时候只需要根据Token值来查找用户即可(为了安全考虑，重新登陆一般要将Token重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session的主要作用是通过服务端记录用户的状态。</strong>比如购物车场景。</li><li>Cookie数据存放在客户端(浏览器端)，Session数据保存在服务器端；</li><li>Session相对于Cookie更安全，因为Session是存储在服务器的。如果使用Cookie，一些敏感信息不要写入Cookie中，最好能将Cookie信息加密然后使用到的时候再去服务端解密。</li><li>服务器访问增多，Session会增加服务器负担，若考虑减轻服务器负担，应使用Cookie。<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4>在RFC6265中对Cookie进行了定义，规定万维网站点可以使用Cookie来跟踪用户。<br>Cookie表示在HTTP服务器和客户之间传递的状态信息。<br>cookie是由服务器发给客户端的特殊信息，以文本的形式存放在客户端；客户端再次请求的时候，会把cookie回发；服务器接收到后，会解析cookie生成与客户端相对应的内容。<br><img src="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E8%AE%BE%E7%BD%AE%E5%8F%8A%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B.png"><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4>session机制是服务器端的机制，是在服务器上保存的信息。<br>服务器解析客户端请求并操作session-id，按需保存状态信息。<br>Session是指使用HttpSession对象实现会话跟踪的技术，是一种在服务器端保持会话跟踪的解决方案。</li></ol><p>服务器在创建会话对象时，会为其分配一个唯一的会话标识——SessionID，以“JSESSIONID”的属性名保存在客户端Cookie中，在用户随后的请求中，服务器通过读取Cookie中的JSESSIONID属性值来识别不同的用户，从而实现对每个用户的会话跟踪。</p><p>session的实现方式：1.使用cookie来实现；2.使用URL回写来实现。</p><h4 id="cookie被禁用，如何实现session"><a href="#cookie被禁用，如何实现session" class="headerlink" title="cookie被禁用，如何实现session"></a>cookie被禁用，如何实现session</h4><p>最常用的就是利用URL重写，把SessionID直接附加在URL路径的后面。<br>URL重写通过HttpServletResponse的encodeURL()方法和encodeRedirectURL()方法实现。</p><ul><li>encodeURL()方法可以对任意请求的URL进行重写。</li><li>encodeRedirectURL()方法主要对使用sendRedirect()方法的URL进行重写。</li><li>URL重写方法根据请求信息中是否包含“Set-Cookie”请求头来决定是否进行URL重写，若包含该请求头，会将URL原样输出；若不包含，则会将会话标识重写到URL中。</li></ul><h3 id="Socket和WebSocket"><a href="#Socket和WebSocket" class="headerlink" title="Socket和WebSocket"></a>Socket和WebSocket</h3><p>WebSocket 是一种网络通信协议，类似 http 协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># http</span><br><span class="line">http://example.com:80/some/path</span><br><span class="line"># websocket</span><br><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等<br>域名解析、根域名服务器<br>DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>正向代理、反向代理<br>反向代理服务器</p><h3 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h3><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>阻塞与非阻塞是线程访问某一资源时候，该资源没有准备就绪的一种处理方式。<br>阻塞是指当前线程会处于阻塞状态，等待该资源处理完毕，直到它响应，返回一个结果；非阻塞指这个线程直接返回一个结果，不会等待这个资源处理完毕才去响应，而是去请求其他资源。</p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>同步和异步是指访问数据的一种机制。</p><h4 id="BIO-Block-IO"><a href="#BIO-Block-IO" class="headerlink" title="BIO(Block IO)"></a>BIO(Block IO)</h4><p>BIO同步阻塞IO</p><h4 id="NIO-Non-Block-IO"><a href="#NIO-Non-Block-IO" class="headerlink" title="NIO(Non-Block IO)"></a>NIO(Non-Block IO)</h4><p>NIO同步非阻塞IO</p><h4 id="AIO-Asynchronize-IO"><a href="#AIO-Asynchronize-IO" class="headerlink" title="AIO(Asynchronize IO)"></a>AIO(Asynchronize IO)</h4><p>AIO异步非阻塞IO<br><img src="/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/B-N-AIO.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——12.4java与线程</title>
      <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94java%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94java%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——12.3java内存模型</title>
      <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="计算机内存模型、缓存一致性、MESI-协议"><a href="#计算机内存模型、缓存一致性、MESI-协议" class="headerlink" title="计算机内存模型、缓存一致性、MESI 协议"></a>计算机内存模型、缓存一致性、MESI 协议</h3><h4 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h4><p>由于计算机的存储设备与运算器的运算速度之间有着几个数量级的差距，所以现代计算机系统不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(cache)来作为内存与处理器之间的缓冲：将运算需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。</p><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性(Cache Coherence)。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/neicunmoxing.png"></p><p>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？</p><h4 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h4><p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI、Synapse、Firefly及DragonProtocol等等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的。</p><p>MESI是指4种状态的首字母，每个Cache line有4个状态，可用两个bit表示。</p><ul><li>M 修改(Modify)，缓存块已经被改动，必须被写回主存，其他处理器不能再缓存这个块。</li><li>E 独享、互斥(Exclusive)，缓存块还没有被改动，且其他处理器不能装入这个缓存块。</li><li>S 共享(Shared)，缓存块未被改动，且其他处理器能够装入这个缓存块。</li><li>I 无效(Invalid)，缓存块中的数据无效。</li></ul><p>可见性、原子性、有序性、happens-before、内存屏障、synchronized、volatile、final、锁</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h4><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。<br>此处的变量(Variable)与java编程中所说的变量略有区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为后者是线程私有的，不会被共享，自然就不存在竞争问题。<br>为了获得较好的执行效能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存在和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权力。</p><p>Java内存模型规定了所有的变量都存储在主内存(MainMemory)中(可以类比物理机的主内存，此处仅是虚拟机内存的一部分)。每条线程还有自己的工作内存(WorkingMemeory，可与处理器高速缓存类比)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/javaneicunmoxing.png"></p><h4 id="12-3-2-内存间交互操作"><a href="#12-3-2-内存间交互操作" class="headerlink" title="12.3.2 内存间交互操作"></a>12.3.2 内存间交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8中操作(虚拟机实现时必须保证每一种操作都是原子的、不可再分的)来完成：</p><ul><li>lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write(写入)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><h4 id="12-3-4-对于volatile型变量的特殊规则"><a href="#12-3-4-对于volatile型变量的特殊规则" class="headerlink" title="12.3.4 对于volatile型变量的特殊规则"></a>12.3.4 对于volatile型变量的特殊规则</h4><p>关键字volatile可以说是java虚拟机提供的最轻量级的同步机制，但是它并不容易被正确地、完整地理解，以至于许多程序员都不去使用它，遇到需要处理多线程数据竞争的问题时一律使用synchronized来进行同步。</p><p>Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些规则定义之前，先介绍一下这个关键字的作用。<br>当一个变量被定义成volatile之后，它将具备两种特性，第一是<code>保证此变量对所有线程的可见性</code>；第二是<code>禁止指令重排序优化</code>。</p><p>两种特性产生的原因是Java内存模型对volatile变量的三条特殊规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">规则1：只有当线程T对变量V执行的前一个操作为load时，线程T才可以对变量V执行use操作;</span><br><span class="line">并且只有当线程T对变量V执行的后一个操作为use时，线程T才可以对变量V执行load操作。</span><br></pre></td></tr></table></figure><p>该规则令read - load - use形成整体性的原子操作，使得volatile变量在被使用前会从主内存中读取最新值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">规则2：只有当线程T对变量V执行的前一个操作为assign时，线程T才可以对变量V执行store动作;</span><br><span class="line">并且只有当线程T对变量V执行的后一个操作为store时，线程T才可以对变量V执行assign动作。</span><br></pre></td></tr></table></figure><p>该规则令assign - store - write形成整体性的原子操作，使得volatile变量在被赋值后会立即同步回主内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">规则3：假定操作A是线程T对变量V实施的use或assign操作，操作F是和操作A关联的load或store操作，操作P是和操作F相关联的read或write操作；</span><br><span class="line">假定操作B是线程T对变量W实施的use或assign操作，操作G是和操作B关联的load或store操作，操作Q是和操作G相关联的read或write操作；</span><br><span class="line">如果A先于B，则P先于Q。</span><br></pre></td></tr></table></figure><p>这里的<code>可见性</code>是指<code>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</code>。而普通变量不能做到这一点，变量值在线程间传递均需要通过主内存来完成，如：线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量的值才会对线程B可见。<br>关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。volatile变量在各个线程的工作内存中不存在一致性问题(在各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题)，但是<code>java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的</code>。<br>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用synchronized或java.util.concurrent中的原子类)来保证原子性：1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；2.变量不需要与其他的状态变量共同参与不变约束。</p><p>使用volatile变量的第二个语义是<code>禁止指令重排序优化</code>，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”(Within-Thread-As-If-Serial Semantics)。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/volatile-zhilingchongpaixu.png"></p><h5 id="volatile与内存屏障"><a href="#volatile与内存屏障" class="headerlink" title="volatile与内存屏障"></a>volatile与内存屏障</h5><ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障</li></ul><p>解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？确实在某些情况下，volatile同步机制的性能要优于锁(使用synchronized关键字或java.util.concurrent包里面的锁)，但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地说volatile就会比synchronized快上多少。如果让volatile自己与自己比较，则可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会满上一些，因为它需要在本地代码中插入许多内存屏障(Memory Barrier或Memory Fence)指令来保证处理器不发生乱序执行。不过即便如此，大多数情况下volatile的总开销仍然要比锁来得低，我们在volatile与锁中选择的唯一判断依据仅仅是volatile的语义能否满足使用场景的需求。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/volatile-dingyiguize.png"></p><h4 id="12-3-4-对于long和double型变量的特殊规则"><a href="#12-3-4-对于long和double型变量的特殊规则" class="headerlink" title="12.3.4 对于long和double型变量的特殊规则"></a>12.3.4 对于long和double型变量的特殊规则</h4><p>Java内存模型只保证32位数据类型操作的原子性，对于64位数据类型（long和double）操作则由两个32位原子操作组成。</p><p>java内存模型要求lock、unlock、read、load、assign、use、store和write这八个操作都具有原子性，但是对于64位的数据类型(long和double)，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的long和double的非原子性协定。</p><p>如果有多个进程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。<br>不过这种读取到“半个变量”的情况非常罕见，因为java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要将用到的long和double变量专门声明为volatile。</p><h4 id="12-3-5-原子性、可见性与有序性"><a href="#12-3-5-原子性、可见性与有序性" class="headerlink" title="12.3.5 原子性、可见性与有序性"></a>12.3.5 原子性、可见性与有序性</h4><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。<br>想要线程安全，必须保证原子性、可见行、有序性。</p><p><code>原子性(Atomicity)</code> ：由Java内存模型来直接保证原子性变量操作包括read、load、assign、use、store和write这六个，大致可以认为基本数据类型的访问读写是具备原子性的(long和double的非原子性协定例外)。<br>如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p><p><code>可见性(Visibility)</code>：可见性就是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新，因此可以说volatile保证了多线程操作时变量的可见性，而普通变量不能保证这一点。<br>除了volatile之外，java还有两个关键字能实现可见性，它们是synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)”这条规则获得的；而final关键字的可见性是指被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去(this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那么在其他线程中就能看见final字段的值。</p><p><code>有序性(Ordering)</code>：Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的含义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p><h4 id="12-3-6-先行发生规则（happens-before）"><a href="#12-3-6-先行发生规则（happens-before）" class="headerlink" title="12.3.6 先行发生规则（happens-before）"></a>12.3.6 先行发生规则（happens-before）</h4><p>先行发生原则（happens - before）：如果操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——8虚拟机字节码执行引擎</title>
      <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——7虚拟机类加载机制</title>
      <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="7-1概述"><a href="#7-1概述" class="headerlink" title="7.1概述"></a>7.1概述</h3><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。<br>在java语言里面，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为java应用程序提供高度的灵活性，java中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><h3 id="7-2类加载的时机"><a href="#7-2类加载的时机" class="headerlink" title="7.2类加载的时机"></a>7.2类加载的时机</h3><p>类加载机制：jvm把class文件加载到内存，并对数据进行校验、分配、解析和初始化，最终形成jvm可以直接使用的java类型的过程。</p><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F.png"><br>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了以上七个阶段，其中验证、准备和解析三个部分统称为连接。<br>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持java语言的运行时绑定。按部就班地“开始”，而不是按部就班地“进行”或“完成”，因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。<br>什么情况下需要开始类加载过程的第一个阶段：加载。虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有些只有四种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之前开始)：<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E6%9C%89%E4%B8%94%E5%8F%AA%E6%9C%89.png"><br>对于这四种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语“有且只有”，这四种场景中的行为称为对一个类进行主动引用。除此之外所有引用类的方式，都不会触发初始化，称为被动引用（通过子类引用父类的静态字段，不会导致子类初始化；通过数组定义来引用类，不会触发此类的初始化；常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化）。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A0%E8%BD%BD.png"></p><h3 id="7-3类加载的过程"><a href="#7-3类加载的过程" class="headerlink" title="7.3类加载的过程"></a>7.3类加载的过程</h3><h4 id="7-3-1加载"><a href="#7-3-1加载" class="headerlink" title="7.3.1加载"></a>7.3.1加载</h4><p>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。</p><p>“加载”阶段是“类加载”过程的一个阶段，这两个名词看起来很相似。<br>在加载阶段，虚拟机需要完成以下三件事情：<br>1)通过一个类的全限定名来获取定义此类的二进制字节流；<br>2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；<br>3)在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E8%8E%B7%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81.png"><br>相对于类加载过程的其他阶段，加载阶段(准确地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员们可以通过定义自己的类加载器去控制字节流的获取方式。<br>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后再java堆中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持这固定的先后顺序。</p><h4 id="7-3-2验证"><a href="#7-3-2验证" class="headerlink" title="7.3.2验证"></a>7.3.2验证</h4><p>确保加载的类信息符合jvm规范，没有安全方面的问题。</p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>Java语言本身是相对安全的语言(依然是相对于C/C++来说)，使用纯粹的java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但前面已经说过，Class文件并不一定要求用java源码编译而来，可以使用任何途径，包括用十六进制编辑器直接编写来产生Class文件。在字节码的语言层面上，上述java代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。<br>尽管验证阶段是非常重要的，并且验证阶段的工作量在虚拟机的类加载子系统中占了很大一部分，但虚拟机规范对这个阶段的限制和指导显得非常笼统，仅仅说了一句如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个java.lang.VerifyError异常或其子类异常，具体应当检查哪些方面，如果检查，何时检查，都没有强制要求或明确说明，所以不同的虚拟机对类验证的实现可能会有所不同，但大致上都会完成下面四个阶段的检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。<br>1)文件格式验证<br>第一阶段是要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。验证点包括：是否以魔数0xCAFEBABE开头；主、次版本号是否在当前虚拟机处理范围之内；常量池的常量中是否有不被支持的常量类型(检查常量tag标志)；指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据；Class文件中各个部分及文件本身是否有被删除的或附加的其他信息；……<br>实际上第一阶段的验证点远不止这些，上面这些只是从HotSpot虚拟机源码中摘抄的一小部分，该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个java类型信息的要求。这阶段得到验证是基于字节流进行的，进行了这个阶段的验证之后，字节流才会进入内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构进行的。<br>2）元数据验证<br>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求，这个阶段可能包括的验证点如下：这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)；这个类的父类是否继承了不允许被继承的类(被final修饰的类)；如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；类中的字段、方法是否与父类产生了矛盾(例如覆盖了父类的final字段，或者出现不符合规则的方法重写)；……<br>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合java语言规范的元数据信息。<br>3)字节码验证<br>第三阶段是整个验证过程中最复杂的一个阶段，主要工作是进行数据流和控制流分析。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析。这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况——在操作栈中放置了一个int类型的数据，使用时却按long类型来加载如本地变量表中；保证跳转指令不会跳转到方法体以外的字节码指令上；保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型则是危险和不合法的；……<br>如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说名其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。这里涉及了离散数学中一个很著名的问题“Halting Problem”：通俗一点的说法就是，通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%AD%97%E8%8A%82%E7%A0%81%E9%AA%8C%E8%AF%81.png"><br>4)符号引用验证<br>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外(常量池中的各种符号引用)的信息进行匹配性的校验，通常需要校验以下内容：符号引用中通过字符串描述的全限定名是否能找到对应的类；在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段；符号引用中的类、字段和方法的访问性(private、protected、public、default)是否可被当前类访问；……<br>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p><h4 id="7-3-3准备"><a href="#7-3-3准备" class="headerlink" title="7.3.3准备"></a>7.3.3准备</h4><p>正式为类变量(static)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。两个容易混淆的概念：这时候进行内存分配的仅包括类变量(static修饰的变量)，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在java堆中；这里所说的初始值“通常情况”下是数据类型的零值。<br>假设一个类变量的定义为：public static int value = 123; 那么变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会被执行。<br>“通常情况”下初始值是零值，相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，public static final int value = 123; 编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png"></clinit></p><h4 id="7-3-4解析"><a href="#7-3-4解析" class="headerlink" title="7.3.4解析"></a>7.3.4解析</h4><p>虚拟机常量池内的符号引用替换为直接引用的过程。</p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？<br>符号引用(Symbolic Reference)：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。<br>直接引用(Direct Reference)：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E8%A7%A3%E6%9E%90.png"><br>解析动作主要针对类或接口、字段、类方法、接口访问四类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。<br>1)类或接口的解析<br>2)字段解析<br>3)类方法解析<br>4)接口方法解析</p><h4 id="7-3-5初始化"><a href="#7-3-5初始化" class="headerlink" title="7.3.5初始化"></a>7.3.5初始化</h4><p>初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的。<br>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<br>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。<br>当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。</clinit></clinit></clinit></p><p>类的主动引用(一定会发生类的初始化)：new一个类的对象；调用类的静态成员(除了final常量)和静态方法；使用java.lang.reflect包的方法对类进行反射调用；当虚拟机启动java Hello，则一定会初始化Hello类，说白了就是先启动mian方法所在的类；当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类。<br>类的被动引用(不会发生类的初始化)：当访问一个静态域时，只有真正声明这个域的类才会被初始化(通过子类引用父类的静态变量，不会导致子类初始化)；通过数组定义类引用，不会触发此类的初始化；引用常量不会触发此类的初始化(常量在编译阶段就存入调用类的常量池中了)。</p><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码(或者说是字节码)。<br>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/clinit.png"><br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/clinit2.png"></clinit></p><h3 id="7-4类加载器"><a href="#7-4类加载器" class="headerlink" title="7.4类加载器"></a>7.4类加载器</h3><p>类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。<br>类缓存：标准的javaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间，不过jvm垃圾收集器可以回收这些Class对象。</p><p>1.启动类加载器(Bootstrap Classloader)：用来加载java的核心库(JAVA_HOME/jre/lib/rt.jar，或sun.boot.class.path路径下的内容)，是用原生代码来实现的，并不继承自java.lang.ClassLoader。加载扩展类和应用程序类加载器，并指定他们的父类加载器。<br>2.扩展类加载器(Extension Classloader)：用来加载java的扩展库(JAVA_HOME/jre/ext/.jer，或java.ext.dirs路径下的内容)。java虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载java类。由sun.misc.Launcher$ExtClassLoader实现。<br>3.应用程序类加载器(Application Classloader)：它根据java应用的类路径(classpath，java.class.path路径)来加载类，一般来说，java应用的类都是由它来完成加载的。由sun.misc.Launcher$AppClassLoader实现。<br>4.自定义类加载器：开发人员可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。</p><p>java.class.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个java类，即java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载java应用所需的资源，如图像文件和配置文件等。</p><p><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"><br>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，这里类加载器之间的父子关系一般不会以继承(Inheritance)的关系来实现，而是都使用组合(Composition)关系来复用父加载器的代码。<br>类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的java程序中，但它并不是一个强制性的约束模型，而是java设计者们推荐给开发者们的一种类加载器实现方法。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。<br>双亲委托机制是为了保证java核心库的类型安全，这种机制保证不会出现用户自己能定义java.lang.Object类的情况。<br><img src="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png"><br>类加载器的代理模式：交给其他加载器来加载指定的类。<br>双亲委派机制是代理模式的一种，并不是所有的类加载器都采用双亲委派机制；tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器，这与一般类加载器的顺序是相反的。</p><p>自定义类加载器的流程：继承java.lang.ClassLoader；首先检查请求的类型是否已经被这个类加载器加载到命名空间中了，如果已经加载，直接返回；委派类加载请求给父类加载器，如果父类加载器能够完成，则返回父类加载器加载的Class实例；调用本类加载类的findClass(……)方法，试图获取对应的字节码，如果获取的到，则调用defineClass(……)导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass(……)，loadClass(……)转抛异常，终止加载过程。<br>实现双亲委派模型的代码都集中来java.lang.ClassLoader的loadClass()方法之：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，则再抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。<br>注意，被两个类加载器加载的同一个类，jvm不认为是相同的类。</p><p>思考：<br>1.假如我们自己写了一个java.lang.String的类，我们是否可以替换调JDK本身的类？<br>答案是否定的。我们不能实现。为什么呢？我看很多网上解释是说双亲委托机制解决这个问题，其实不是非常的准确。因为双亲委托机制是可以打破的，你完全可以自己写一个classLoader来加载自己写的java.lang.String类，但是你会发现也不会加载成功，具体就是因为针对java.※开头的类，jvm的实现中已经保证了必须由bootstrp来加载。<br>因为String已经在启动时被加载，所以用户自定义类ClassLoader是无法加载一个自定义的String。</p><p>2.既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？<br>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。<br>定义自已的类加载器分为两步：<br>1、继承java.lang.ClassLoader<br>2、重写父类的findClass方法</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——6类文件结构</title>
      <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2019/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——排序</title>
      <link href="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/zonghebijiao.jpg"></p><h3 id="一、排序-上-：为什么插入排序比冒泡排序更受欢迎？"><a href="#一、排序-上-：为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="一、排序(上)：为什么插入排序比冒泡排序更受欢迎？"></a>一、排序(上)：为什么插入排序比冒泡排序更受欢迎？</h3><p>分析一个排序算法，从哪几方面入手：</p><h4 id="1-排序算法的执行效率"><a href="#1-排序算法的执行效率" class="headerlink" title="1.排序算法的执行效率"></a>1.排序算法的执行效率</h4><p>1）最好情况、最坏情况、平均情况时间复杂度。<br>2）时间复杂度的系数、常数、低阶。<br>3）比较次数和交换(或移动)次数。基于比较的排序算法会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。</p><h4 id="2-排序算法的内存消耗"><a href="#2-排序算法的内存消耗" class="headerlink" title="2.排序算法的内存消耗"></a>2.排序算法的内存消耗</h4><p>算法的内存消耗可以通过空间复杂度来衡量，针对排序算法的空间复杂度，引入了一个概念——原地排序(Sorted in place)。原地排序算法就是特指空间复杂度为O(1)的排序算法，包括冒泡排序、插入排序、选择排序。</p><h4 id="3-排序算法的稳定性"><a href="#3-排序算法的稳定性" class="headerlink" title="3.排序算法的稳定性"></a>3.排序算法的稳定性</h4><p>除了执行效率和内存消耗，针对排序算法还有一个重要的度量指标——稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。<br>假如现在有一组数据：2，9，3，4，8，3，按照大小排序之后是2，3，3，4，8，9。这组数据里有两个3，经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那这种排序算法就是稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就是不稳定的。<br>数据结构和算法在讲排序的时候，都是用整数来举例，在真正软件开发中，要排序的往往不是单纯的整数，而是一组对象，需要按照对象的某个key来排序。<br>比如，现在要给电商交易系统中的“订单”排序，订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有10万条订单数据，希望按照金额从小到大对订单数据排序。对于金额相同的订单，希望按照下单时间从早到晚有序。<br>对于这样一个排序需求，借助稳定排序算法，先按照下单时间给订单排序，然后用稳定排序算法，按照订单金额重新排序。这样两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间排序。稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</p><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><h4 id="1-1冒泡排序是原地排序算法吗？"><a href="#1-1冒泡排序是原地排序算法吗？" class="headerlink" title="1.1冒泡排序是原地排序算法吗？"></a>1.1冒泡排序是原地排序算法吗？</h4><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是一个原地排序算法。</p><h4 id="1-2冒泡排序是稳定的排序算法吗？"><a href="#1-2冒泡排序是稳定的排序算法吗？" class="headerlink" title="1.2冒泡排序是稳定的排序算法吗？"></a>1.2冒泡排序是稳定的排序算法吗？</h4><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的。</p><h4 id="1-3冒泡排序的时间复杂度"><a href="#1-3冒泡排序的时间复杂度" class="headerlink" title="1.3冒泡排序的时间复杂度"></a>1.3冒泡排序的时间复杂度</h4><p>最好情况下要排序的数据是有序的，只需要进行一次比较操作，是O(n)。而最坏情况下，要排序的数据刚好是倒序排列的，要进行n次冒泡操作，为O(n2)。<br>对于包含n个数据的数组，这n个数据有n!中排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的，如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算很复杂。<br>这里，通过“有序度”和“逆序度”这两个概念来进行分析。<br>有序度是数组中具有有序关系的元素对的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure><p><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/youxudu.jpg"><br>对于一个倒序排列的数组，比如654321，有序度为0；对于一个完全有序的数组，比如123456，有序度就是n×(n-1)/2，就是15。我们把这种完全有序的数组的有序度叫做满有序度。<br>逆序度的定义正好跟有序度相反(默认从小到大为有序)。</p><h4 id="逆序度-满有序度-有序度"><a href="#逆序度-满有序度-有序度" class="headerlink" title="逆序度 = 满有序度 - 有序度"></a>逆序度 = 满有序度 - 有序度</h4><p>排序的过程就是增加有序度，减少逆序度的过程，最后达到满有序度。</p><p>对于包含n个数据的数组进行冒泡排序，平均交换次数在最坏情况下，初始状态有序度为0，要进行n×(n-1)/2次交换；最好情况下，初始状态的有序度是n×(n-1)/2，就不需要进行交换。取中间值n×(n-1)/4来表示平均情况。定性分析下平均情况的时间复杂度为O(n2)。</p><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h3><h4 id="2-1插入排序是原地排序算法吗？"><a href="#2-1插入排序是原地排序算法吗？" class="headerlink" title="2.1插入排序是原地排序算法吗？"></a>2.1插入排序是原地排序算法吗？</h4><p>插入排序算法不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。</p><h4 id="2-2插入排序是稳定的排序算法吗？"><a href="#2-2插入排序是稳定的排序算法吗？" class="headerlink" title="2.2插入排序是稳定的排序算法吗？"></a>2.2插入排序是稳定的排序算法吗？</h4><p>在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p><h4 id="2-3插入排序的时间复杂度"><a href="#2-3插入排序的时间复杂度" class="headerlink" title="2.3插入排序的时间复杂度"></a>2.3插入排序的时间复杂度</h4><p>最好情况下从头遍历已经有序的元素O(n)；最坏情况下数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，为O(n2)。平均时间复杂度为O(n2)。</p><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><p>选择排序算法的实现思路有点类似插入排序，也区分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><h4 id="3-1选择排序是原地排序算法吗？"><a href="#3-1选择排序是原地排序算法吗？" class="headerlink" title="3.1选择排序是原地排序算法吗？"></a>3.1选择排序是原地排序算法吗？</h4><p>空间复杂度为O(1)，是一种原地排序算法。</p><h4 id="3-2选择排序是稳定的排序算法吗？"><a href="#3-2选择排序是稳定的排序算法吗？" class="headerlink" title="3.2选择排序是稳定的排序算法吗？"></a>3.2选择排序是稳定的排序算法吗？</h4><p>选择排序是一种不稳定的排序算法。</p><h4 id="3-3选择排序的时间复杂度"><a href="#3-3选择排序的时间复杂度" class="headerlink" title="3.3选择排序的时间复杂度"></a>3.3选择排序的时间复杂度</h4><p>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为O(n2)。</p><h3 id="为什么插入排序要比冒泡排序更受欢迎？"><a href="#为什么插入排序要比冒泡排序更受欢迎？" class="headerlink" title="为什么插入排序要比冒泡排序更受欢迎？"></a>为什么插入排序要比冒泡排序更受欢迎？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line">if (a[j] &gt; a[j+1]) &#123; // 交换</span><br><span class="line">   int tmp = a[j];</span><br><span class="line">   a[j] = a[j+1];</span><br><span class="line">   a[j+1] = tmp;</span><br><span class="line">   flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line">if (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+1] = a[j];  // 数据移动</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码实现上看，冒泡排序的数据交换要比插入排序的数据移动操作要多，cpu处理时间就长。虽然两者时间复杂度一样，但是插入排序优化空间要大，例如其中的希尔排序。</p><h3 id="二、排序-下-：如何用快排思想在O-n-内查找无序数组中第k大元素？"><a href="#二、排序-下-：如何用快排思想在O-n-内查找无序数组中第k大元素？" class="headerlink" title="二、排序(下)：如何用快排思想在O(n)内查找无序数组中第k大元素？"></a>二、排序(下)：如何用快排思想在O(n)内查找无序数组中第k大元素？</h3><p>时间复杂度为O(nlogn)的归并排序和快速排序，都用到了分治思想。</p><h3 id="4-归并排序-Merge-Sort"><a href="#4-归并排序-Merge-Sort" class="headerlink" title="4.归并排序(Merge Sort)"></a>4.归并排序(Merge Sort)</h3><p>思想：要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br>归并排序使用的是分治思想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//归并排序的递推公式</span><br><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure><p>给下标从p到r的数组排序，将这个排序问题转化为两个子问题，p到q和q+1到r，下标q等于p和r的中间位置(p+r)/2。当两个子数组都排好序之后，合并在一起，p到r也就排好序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序算法, A 是数组，n 表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  // 递归终止条件</span><br><span class="line">  if p &gt;= r  then return</span><br><span class="line"></span><br><span class="line">  // 取 p 到 r 之间的中间位置 q</span><br><span class="line">  q = (p+r) / 2</span><br><span class="line">  // 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+1, r)</span><br><span class="line">  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+1...r])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merge(A[p...r], A[p...q], A[q+1...r]) &#123;</span><br><span class="line">  var i := p，j := q+1，k := 0 // 初始化变量 i, j, k</span><br><span class="line">  var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组</span><br><span class="line">  while i&lt;=q AND j&lt;=r do &#123;</span><br><span class="line">    if A[i] &lt;= A[j] &#123;</span><br><span class="line">      tmp[k++] = A[i++] // i++ 等于 i:=i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] = A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 判断哪个子数组中有剩余的数据</span><br><span class="line">  var start := i，end := q</span><br><span class="line">  if j&lt;=r then start := j, end:=r</span><br><span class="line">  </span><br><span class="line">  // 将剩余的数据拷贝到临时数组 tmp</span><br><span class="line">  while start &lt;= end do &#123;</span><br><span class="line">    tmp[k++] = A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 将 tmp 中的数组拷贝回 A[p...r]</span><br><span class="line">  for i:=0 to r-p do &#123;</span><br><span class="line">    A[p+i] = tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1归并排序是稳定的排序算法吗？"><a href="#4-1归并排序是稳定的排序算法吗？" class="headerlink" title="4.1归并排序是稳定的排序算法吗？"></a>4.1归并排序是稳定的排序算法吗？</h4><p>归并排序的稳定性要看merge()合并函数。另外，稳定性是由方法本身决定的，对不稳定的排序方法而言，不管其描述形式如何，总能举出一个说明不稳定的实例来；反之，对稳定的排序方法，总能找到一种不引起不稳定的描述形式。<br>合并前后的前后顺序不变，就是稳定的。</p><h4 id="4-2归并排序的时间复杂度"><a href="#4-2归并排序的时间复杂度" class="headerlink" title="4.2归并排序的时间复杂度"></a>4.2归并排序的时间复杂度</h4><p>归并排序可以递归实现，递归代码的时间复杂度也可以写成递推公式。<br>我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br><span class="line"></span><br><span class="line">T(n) = 2*T(n/2) + n</span><br><span class="line">     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</span><br><span class="line">     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span><br><span class="line">     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     = 2^k * T(n/2^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure><p>当T(n/2^k)=T(1)时，也就是n/2^k=1，得到k=log2n。代入得到T(n)=Cn+nlog2n。大O标记法表示就是T(n)=O(nlogn)。</p><h4 id="4-3归并排序的空间复杂度"><a href="#4-3归并排序的空间复杂度" class="headerlink" title="4.3归并排序的空间复杂度"></a>4.3归并排序的空间复杂度</h4><p>归并排序的时间复杂度任何情况下都是O(nlogn)，但是归并排序并没有像快排那样应用广泛，原因在于它不是原地排序算法。因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。<br>空间复杂度为O(n)。</p><h3 id="5-快速排序-Quick-Sort"><a href="#5-快速排序-Quick-Sort" class="headerlink" title="5.快速排序(Quick Sort)"></a>5.快速排序(Quick Sort)</h3><p>快排利用的也是分治。不稳定。<br>思想：假设要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点)。遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。经过这一步骤之后，数组p到r之间的数据就被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。<br>根据分治、递推的处理思想，递归排序下标从p到<br>q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，说明所有的数据都有序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r</span><br><span class="line"></span><br><span class="line">// 快速排序，A 是数组，n 表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">// 快速排序递归函数，p,r 为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  if p &gt;= r then return</span><br><span class="line">  </span><br><span class="line">  q = partition(A, p, r) // 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-1)</span><br><span class="line">  quick_sort_c(A, q+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的处理过程是从下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程由上到下，先分区，然后再处理子问题。快排通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>现在有10个接口访问日志文件，每个日志文件大小约为300MB，每个文件里的日志都是按照时间戳从小到大排序的。希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB，如何能“快速”地将这10个日志文件合并？</p><h3 id="三、线性排序：如何根据年龄给100万用户数据排序？"><a href="#三、线性排序：如何根据年龄给100万用户数据排序？" class="headerlink" title="三、线性排序：如何根据年龄给100万用户数据排序？"></a>三、线性排序：如何根据年龄给100万用户数据排序？</h3><p>桶排序、计数排序、基数排序，这三种排序算法的时间复杂度是线性的，所以叫做线性排序(Linear Sort)。之所以能做到线性的时间复杂度，是因为这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p><h3 id="6-桶排序"><a href="#6-桶排序" class="headerlink" title="6.桶排序"></a>6.桶排序</h3><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><h4 id="6-1桶排序的时间复杂度"><a href="#6-1桶排序的时间复杂度" class="headerlink" title="6.1桶排序的时间复杂度"></a>6.1桶排序的时间复杂度</h4><p>如果要排序的数据有n个，我们把它们均匀地划分到m个桶内，每个桶内就有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为O(klogk)。m个桶排序的时间复杂度就是O(mklogk)，因为k=n/m，所以整个桶排序的时间复杂度就是O(nlog(n/m))。当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。</p><h4 id="6-2桶排序的应用场景"><a href="#6-2桶排序的应用场景" class="headerlink" title="6.2桶排序的应用场景"></a>6.2桶排序的应用场景</h4><p>桶排序对要排序数据的要求非常苛刻。首先，要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据排序完之后，桶与桶之间的数据不需要在进行排序。其次，数据在各个桶之间的分布是比较均匀的，如果数据经过桶的划分，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了，在极端情况下，如果数据都被分到一个桶里，那就退化为O(nlogn)了。<br>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。<br>比如说我们有10GB的订单数据，希望按订单金额(假设金额都是正整数)进行排序，但是我们内存有限，只有几百MB，没办法一次性把10GB的数据都加载到内存中。这个时候可以借助桶排序的思想来解决这个问题。<br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/tongpaixuyingxu.png"></p><h3 id="7-计数排序-Counting-Sort"><a href="#7-计数排序-Counting-Sort" class="headerlink" title="7.计数排序(Counting Sort)"></a>7.计数排序(Counting Sort)</h3><p>计数排序可以说是桶排序的一种特殊情况。<br>当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。<br>我们都经历过高考，高考查分系统，我们查分数的时候，系统会显示我们的成绩以及所在省的排名。2016年山东省有70万考生，如何通过成绩快速排序得出名次呢？<br>考生的满分是750分，最小是0分，这个数据的范围不算大，所以我们可以分成751个桶，对应分数从0到750分。根据考生的成绩，将这70万考生划分到751个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了70万考生的排序，因为只涉及扫描遍历操作，所以时间复杂度是O(n)。<br>计数排序的算法思想与桶排序类似，只是桶的大小粒度不一样，为什么叫“计数”，“计数”的含义来自哪里？<br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu1.png"><br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu2.png"><br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu3.png"><br><img src="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/jishu4.jpg"></p><h3 id="8-基数排序-Radix-Sort"><a href="#8-基数排序-Radix-Sort" class="headerlink" title="8.基数排序(Radix Sort)"></a>8.基数排序(Radix Sort)</h3><p>再来看这样一个排序问题，假设我们有10万个手机号码，希望将这10万个手机号码从小到大排序，有什么比较快速的排序方法？<br>快排可以做到O(nlogn)，手机号码有11位，范围太大，不适合用桶排序、计数排序。<br>可以用基数排序。<br>假设要比较两个手机号码a和b的大小，如果在前面几位中，a手机号码已经比b的大了，那后面的几位就不用看了。<br>基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="关于模式"><a href="#关于模式" class="headerlink" title="关于模式"></a>关于模式</h3><p>在讨论模式之前，必须对“模式”这个词加以界定，以规范后面的讨论和研究。<br>简而言之，人们在自己的环境中不断发现问题和寻找问题的解决方案的时候，发现有一些问题及其解决方案不断变换面孔反复出现，但在这些不同的面孔后面有着共同的本质，这些共同的本质就是模式。<br>一个围棋下得好的人知道，好的“形”对于围棋非常重要。形是棋子在棋盘上的几何形状的抽象化。形就是模式(pattern)，也是人脑把握和认识外界的关键。模式化的过程是把问题抽象化，在忽略掉不重要的细节后，发现问题的一般性本质，并找到普遍使用的解决方案的过程。</p><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><h4 id="创建模式-5种"><a href="#创建模式-5种" class="headerlink" title="创建模式(5种)"></a>创建模式(5种)</h4><h4 id="结构模式-7种"><a href="#结构模式-7种" class="headerlink" title="结构模式(7种)"></a>结构模式(7种)</h4><h4 id="行为模式-11种"><a href="#行为模式-11种" class="headerlink" title="行为模式(11种)"></a>行为模式(11种)</h4><h3 id="设计模式的7个原则"><a href="#设计模式的7个原则" class="headerlink" title="设计模式的7个原则"></a>设计模式的7个原则</h3><h4 id="开—闭原则-Open-Closed-Principle-OCP"><a href="#开—闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开—闭原则(Open-Closed Principle,OCP)"></a>开—闭原则(Open-Closed Principle,OCP)</h4><p>一个软件实体应当对扩展开放，对修改关闭。<br>在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。换言之，应当可以在不必修改源代码的前提下改变这个模块的行为。</p><h4 id="里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle,LSP)"></a>里氏代换原则(Liskov Substitution Principle,LSP)</h4><p>一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。<br>反过来的代换不成立，即如果一个软件实体使用的是一个子类，那么它不一定适用于基类。<br>里氏代换要求凡是基类型使用的地方，子类型一定适用，因此子类必须具备基类型的全部接口。</p><h4 id="依赖倒转原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒转原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle,DIP)"></a>依赖倒转原则(Dependence Inversion Principle,DIP)</h4><p>依赖于抽象，而不依赖于具体。<br>针对接口编程。<br>传统的过程性系统的设计办法倾向于使高层次的模块依赖于低层次的模块；抽象层次依赖于具体层次。依赖倒转原则是要把这个错误的依赖关系倒转过来。<br>里氏代换原则是依赖倒转原则的基础，依赖倒转原则是开-闭原则的基础。</p><h4 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle,ISP)"></a>接口隔离原则(Interface Segregation Principle,ISP)</h4><p>使用多个专门的接口比使用单一的总接口要好。<br>从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小的接口上的。<br>将“接口”理解为一个类所提供的所有方法的特征集合，也就是一种在逻辑上才存在的概念，这样的话，接口的划分就直接带来类型的划分。角色的合理划分。<br>将接口理解为狭义的java接口，这样一来，接口隔离原则讲的就是为同一个角色提供宽、窄不同的接口，以对付不同的客户端。定制服务。</p><h4 id="合成-聚合复用原则-Composite-Aggregate-Reuse-Principle-CARP"><a href="#合成-聚合复用原则-Composite-Aggregate-Reuse-Principle-CARP" class="headerlink" title="合成/聚合复用原则(Composite/Aggregate Reuse Principle,CARP)"></a>合成/聚合复用原则(Composite/Aggregate Reuse Principle,CARP)</h4><p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。<br>尽量使用合成/聚合，尽量不要使用继承。</p><h4 id="迪米特法则-Demeter-Principle"><a href="#迪米特法则-Demeter-Principle" class="headerlink" title="迪米特法则(Demeter Principle)"></a>迪米特法则(Demeter Principle)</h4><p>又叫做最少知识原则(Least Knowledge Principle，LKP)<br>一个对象应当对其他对象有尽可能少的了解。<br>只与你直接的朋友们通信；<br>不要跟“陌生人”说话；<br>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p><h4 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle, SRP)"></a>单一职责原则(Single Responsibility Principle, SRP)</h4><p>一个类只负责一个功能领域中的相应职责。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——递归</title>
      <link href="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/"/>
      <url>/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>推荐注册返佣金——现在很多App都有这个功能。用户A推荐用户B来注册，用户B又推荐了用户C来注册。可以说，用户C的“最终推荐人”为用户A，用户B的“最终推荐人”也为用户A，用户A没有“最终推荐人”。<br>一般来说，会通过数据库来记录这种推荐关系。在数据库表中，可以记录两行数据，其中actor_id表示用户id，referrer_id表示推荐人id。<br><img src="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/acre.jpg"><br>基于这个背景，给定一个用户ID，如何查找这个用户的“最终推荐人”？</p><h3 id="1-关于递归"><a href="#1-关于递归" class="headerlink" title="1.关于递归"></a>1.关于递归</h3><p>数据结构与算法，有两个最难理解的知识点，一个是动态规划，一个是递归。<br>递归是一中应用非常广泛的算法(或者编程技巧)，有很多数据结构与算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等。<br>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</p><h3 id="2-递归需要满足的三个条件"><a href="#2-递归需要满足的三个条件" class="headerlink" title="2.递归需要满足的三个条件"></a>2.递归需要满足的三个条件</h3><h4 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1)一个问题的解可以分解为几个子问题的解"></a>1)一个问题的解可以分解为几个子问题的解</h4><p>子问题就是数据规模更小的问题。</p><h4 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2)这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2)这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h4><h4 id="3-存在递归终止条件"><a href="#3-存在递归终止条件" class="headerlink" title="3)存在递归终止条件"></a>3)存在递归终止条件</h4><p>把问题分解为子问题，子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，需要有终止条件。</p><h3 id="3-如何编写递归代码"><a href="#3-如何编写递归代码" class="headerlink" title="3.如何编写递归代码"></a>3.如何编写递归代码</h3><p>写递归代码最关键的是写出递推公式，找到终止条件，将递推公式转化为代码。<br>假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问这n个台阶有多少中走法？<br>如果有7个台阶，可以2，2，2，1这样上去，也可以1，2，1，1，2这样，走法很多，如何用编程求得总共有多少中走法？<br>想一下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法加上先走2阶后，n-2个台阶的走法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure><p>再来看终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法，所以f(1)=1。然而，只有这一个是不够的。<br>n=2时，f(2)=f(1)+f(0)，如果递归终止条件只有一个f(1)=1，那f(2)就无法求解了，而f(0)是客观不可行的，所以要把f(2)=2作为一个终止条件，表示走两个台阶，有两种走法，一步走完或者分两步来走。<br>把递归终止条件和递推公式放到一起就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(1)=1</span><br><span class="line">f(2)=2</span><br><span class="line">f(n)=f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><p>转化为递归代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int f(int n)</span><br><span class="line">&#123;</span><br><span class="line">if(n == 1) return 1;</span><br><span class="line">if(n == 2) return 2;</span><br><span class="line">return f(n-1) + f(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。"><a href="#写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。" class="headerlink" title="写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。"></a>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译为代码。</h4><p>当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解。像刚刚这个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归坪铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。<br>对于递归代码，这种试图想搞清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。<br>如果一个问题A可以分解为若干子问题B、C、D，可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。而且，只需要思考问题A和子问题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题和子子问题，子子问题和子子子问题之间的关系，屏蔽掉递归细节。</p><h4 id="编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。"><a href="#编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。" class="headerlink" title="编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。"></a>编写递归代码的又一关键，只要找到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。</h4><h3 id="4-递归代码要警惕堆栈溢出"><a href="#4-递归代码要警惕堆栈溢出" class="headerlink" title="4.递归代码要警惕堆栈溢出"></a>4.递归代码要警惕堆栈溢出</h3><p>为什么递归代码容易造成堆栈溢出？如何预防堆栈溢出？<br>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br>上面的例子，如果将系统栈或者JVM堆栈大小设置为1KB，在求解f(1999)时便会出现如下堆栈报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>如何避免出现堆栈溢出？<br>声明一个全局变量，可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度(比如1000)之后，就不继续往下再递归了，直接返回报错。<br>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，会影响代码的可读性。所以，如果最大深度比较小，比如10、50，可以用这种方法，否则这种方法并不是很实用。</p><h3 id="5-递归代码要警惕重复计算"><a href="#5-递归代码要警惕重复计算" class="headerlink" title="5.递归代码要警惕重复计算"></a>5.递归代码要警惕重复计算</h3><p><img src="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/fchongfujisuan.jpg"><br>从图中，可以看到，想要计算f(5),需要先计算f(4)和 f(3)，而计算f(4) 还需要计算f(3)，因此f(3) 就被计算了很多次，这就是重复计算问题。<br>为了避免重复计算，可以通过一个数据结构(比如散列表)来保存已经求解过的f(k)。当递归调用到f(k)时，先从中看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">  if (n == 1) return 1;</span><br><span class="line">  if (n == 2) return 2;</span><br><span class="line">  </span><br><span class="line">  // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)</span><br><span class="line">  if (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    return hasSovledList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int ret = f(n-1) + f(n-2);</span><br><span class="line">  hasSovledList.put(n, ret);</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。</p><h3 id="6-递归代码改写为非递归代码"><a href="#6-递归代码改写为非递归代码" class="headerlink" title="6.递归代码改写为非递归代码"></a>6.递归代码改写为非递归代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int f(n)</span><br><span class="line">&#123;</span><br><span class="line">if(n == 1) return 1;</span><br><span class="line">if(n == 2) return 2;</span><br><span class="line"></span><br><span class="line">int ret = 0;</span><br><span class="line">int pre = 2;</span><br><span class="line">int prepre = 1;</span><br><span class="line">for(int i = 3; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = pre + prepre;</span><br><span class="line">prepre = pre;</span><br><span class="line">pre = ret;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">//刚好这个走台阶的问题类似斐波那契数列</span><br></pre></td></tr></table></figure><p>抽象出递推公式、初始值和边界条件，用迭代循环实现改写。<br>是不是所有的递归代码都可以改写为这种迭代循环的非递归写法？<br>笼统地讲，是的。因为递归本身就是借助栈来实现的，因不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。<br>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也没有解决前面讲到的某些问题，徒增了实现的复杂度。</p><h3 id="如何找到“最终推荐人”"><a href="#如何找到“最终推荐人”" class="headerlink" title="如何找到“最终推荐人”"></a>如何找到“最终推荐人”</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long findRootReferrerId(long actorId)</span><br><span class="line">&#123;</span><br><span class="line">Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">if(referrerId == null) return actorId;</span><br><span class="line">return findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际项目中，这三行代码并不能工作，为啥？这里面有两个问题。<br>一，如果递归很深，可能会有堆栈溢出的问题。<br>二，如果数据库里存在脏数据，还需要处理由此产生的无限递归问题。比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果A的推荐人是B，B的推荐人是C，C 的推荐人是A，这样就会发生死循环。<br>第一个问题，可以用限制递归深度来解决。<br>第二个问题，自动检测A-B-C-A这种“环”的存在。如何来检测环的存在？</p><h3 id="思考：对于递归代码，有什么好的调试方法？"><a href="#思考：对于递归代码，有什么好的调试方法？" class="headerlink" title="思考：对于递归代码，有什么好的调试方法？"></a>思考：对于递归代码，有什么好的调试方法？</h3><p>1.打印日志发现，递归值。<br>2.结合条件断点进行调试。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL技术内幕——MySQL体系结构和存储引擎1</title>
      <link href="/2019/05/06/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E2%80%94%E2%80%94MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1/"/>
      <url>/2019/05/06/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E2%80%94%E2%80%94MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-数据库和实例"><a href="#1-1-数据库和实例" class="headerlink" title="1.1 数据库和实例"></a>1.1 数据库和实例</h3><p>数据库：物理操作系统文件或其他形式文件类型的集合。在MySQL数据库中，数据库文件可以是frm、MYD、MYI、ibd结尾的文件。当使用NDB引擎时，数据库的文件可能不是操作系统上的文件，而是存放于内存之中的文件，但是定义仍然不变。<br>实例：MySQL数据库由后台线程以及一个共享内存区组成。共享内存可以被运行的后台线程所共享。数据库实例才是真正用于操作数据库文件的。<br>在MySQL数据库中，实例与数据库的关系通常是一一对应的，即一个实例对应一个数据库，一个数据库对应一个实例。但事，在集群情况下可能存在一个数据库被多个数据库实例使用的事情。<br>MySQL被设计为一个单进程多线程架构的数据库，这点与SQL Server类似，但与Oracle多进程的架构有所不同(Oracle的Windows版本也是单进程多线程架构的)。这也就是说，MySQL数据库实例在系统上的表现就是一个进程。</p><h3 id="1-2-MySQL体系结构"><a href="#1-2-MySQL体系结构" class="headerlink" title="1.2 MySQL体系结构"></a>1.2 MySQL体系结构</h3><p>从概念上来说，数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合；数据库实例是程序，是位于用户和操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。<br>更直白的方式：数据库是由一个个文件组成(一般来说都是二进制的文件)的，要对这些文件执行诸如select、insert、update、delete之类的数据库操作是不能通过简单的操作文件来更改数据库的内容，需要通过数据库实例来完成对数据库的操作。<br><img src="/2019/05/06/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E2%80%94%E2%80%94MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1/mysqltixijiegou.png"><br>连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲(cache)组件、插件式存储引擎、物理文件。<br>MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者可以按照自己的意愿来进行开发。<br>需要注意的是，存储引擎是基于表的，而不是数据库。</p><h3 id="1-3-MySQL存储引擎"><a href="#1-3-MySQL存储引擎" class="headerlink" title="1.3 MySQL存储引擎"></a>1.3 MySQL存储引擎</h3><p>存储引擎是MySQL区别于其他数据库的一个最重要特性。存储引擎的好处是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。对于开发人员来说，存储引擎对其是透明的；对于DBA来说，应该深刻地认识到MySQL数据库的核心在于存储引擎。<br>由于MySQL数据库的开源特性，用户可以根据MySQL预定义的存储引擎接口编写自己的存储引擎。</p><h4 id="1-3-1-InnoDB存储引擎"><a href="#1-3-1-InnoDB存储引擎" class="headerlink" title="1.3.1 InnoDB存储引擎"></a>1.3.1 InnoDB存储引擎</h4><p>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理(OLTP，on-line transaction processing)的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。从MySQL数据库5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。<br>InnoDB支持行级锁和表级锁，默认是行级锁。<br>InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB存储引擎自身进行管理。从MySQL4.1(包括4.1)版本开始，它可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中。此外，InnoDB存储引擎支持用裸设备(row disk)用来建立其表空间。<br>InnoDB通过使用多版本并发控制(MVCC)来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同时，使用一种被称为next-key locking的策略来避免幻读(phantom)现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能。<br>对于表中数据的存储，InnoDB存储引擎采用了聚集(clustered)的方式，因此每张表的存储都是按主键的顺序进行存放。如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。</p><h4 id="1-3-2-MyISAM存储引擎"><a href="#1-3-2-MyISAM存储引擎" class="headerlink" title="1.3.2 MyISAM存储引擎"></a>1.3.2 MyISAM存储引擎</h4><p>MyISAM存储引擎不支持事务，表锁设计，支持全文索引，主要面向一些OLAP(联机分析处理，On-Line Analytical Processing)数据库应用。在MySQL5.5.8版本之前MyISAM存储引擎是默认的存储引擎(除Windows版本外)。数据库系统与文件系统很大的一个不同之处在于对事务的支持，然而MyISAM存储引擎是不支持事务的。究其根本，试想用户是否在所有的应用中都需要事务呢？在数据仓库中，如果没有ETL(抽取extract、转换transform、加载load)这些操作，只是简单的报表查询是否还需要事务的支持呢？此外，MyISAM存储引擎的另一个与众不同的地方是它的缓冲池只缓存(cache)索引文件，而不缓冲数据文件，这点和大多数的数据库都非常不同。<br>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用myisampack工具来进一步压缩数据文件，因为myisampack工具使用赫夫曼(Huffman)编码静态算法来压缩数据，因此使用myisampack工具压缩后的表是只读的，当然用户也可以通过myisampack来解压数据文件。<br><img src="/2019/05/06/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E2%80%94%E2%80%94MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1/2.png"><br><img src="/2019/05/06/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E2%80%94%E2%80%94MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1/1.png"></p><h4 id="1-3-3-NDB存储引擎"><a href="#1-3-3-NDB存储引擎" class="headerlink" title="1.3.3 NDB存储引擎"></a>1.3.3 NDB存储引擎</h4><p>2003年，MySQL AB公司从Sony Ericsson公司收购了NDB集群引擎。<br>NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群，不过与Oracle RAC share everything架构不同的是，其结构是share nothing的集群架构，因此能提供更高的可用性。NDB的特点是数据全部放在内存中(从MySQL5.1版本开始，可以将非索引数据放在磁盘上)，因此主键查找(primary key lookups)的速度极快，并且通过添加NDB数据存储结点(data node)可以线性地提高数据库性能，是高可用、高性能的集群系统。<br>关于NDB存储引擎，有一个问题值得注意，就是NDB存储引擎的连接操作(JOIN)是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的。<br><img src="/2019/05/06/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E2%80%94%E2%80%94MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1/3.png"></p><h4 id="1-3-4-Mymory存储引擎"><a href="#1-3-4-Mymory存储引擎" class="headerlink" title="1.3.4 Mymory存储引擎"></a>1.3.4 Mymory存储引擎</h4><p>Mymory存储引擎(之前称HEAP存储引擎)将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的维度表。Mymory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引。<br>虽然Mymory存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段(varchar)时是按照定长字段(char)的方式进行的，因此会浪费内存(这个问题之前已经提到，eBay的工程Igor Chernyshev已经给出了patch解决方案)。<br>此外有一点容易被忽视，MySQL数据库使用Mymory存储引擎作为临时表在存放查询的中间结果集(intermediate result)。如果中间结果集大于Mymory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘中。之前提到M有ISAM不缓存数据文件，因此这是产生的临时表的性能对于查询会有损失。</p><h4 id="1-3-5-Archive存储引擎"><a href="#1-3-5-Archive存储引擎" class="headerlink" title="1.3.5 Archive存储引擎"></a>1.3.5 Archive存储引擎</h4><p>Archive存储引擎只支持INSERT和SELECT操作，从MySQL5.1开始支持索引。Archive存储引擎使用zlib算法将数据行(row)进行压缩后存储，压缩比一般可达1：10.正如其名字所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能。</p><h4 id="1-3-6-Federated存储引擎"><a href="#1-3-6-Federated存储引擎" class="headerlink" title="1.3.6 Federated存储引擎"></a>1.3.6 Federated存储引擎</h4><p>Federated存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server的链接服务器和Oracle的透明网关，不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。</p><h4 id="1-3-7-Maria存储引擎"><a href="#1-3-7-Maria存储引擎" class="headerlink" title="1.3.7 Maria存储引擎"></a>1.3.7 Maria存储引擎</h4><p>Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储一你请。Maria存储引擎的开发者是MySQL的创始人之一的Michael Widenius。因此，它可以看作是MyISAM的后续版本。Maria存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能。</p><h4 id="1-3-8-其他"><a href="#1-3-8-其他" class="headerlink" title="1.3.8 其他"></a>1.3.8 其他</h4><p>Merge、CSV、Sphinx和Infobright。</p><p><img src="/2019/05/06/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E2%80%94%E2%80%94MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1/wenti.png"><br>1）MySQL支持全文索引，MyISAM、InnoDB(从5.6版本开始)和Sphinx存储引擎都支持全文索引。<br>2）虽然MySQL的MyISAM存储引擎不支持事务，但是InnoDB支持事务。“快”是相对于不同应用来说的，对于ETL这种操作，MyISAM会有其优势，但在OLTP环境中，InnoDB存储引擎的效率更好。<br>3）当表的数据量大于1000万时——MySQL是数据库，不是文件，随着数据行数的增加，性能当然会有所下降，但是这些下降不是线性的，如果用户选择了正确的存储引擎，以及正确的配置，再多的数据量MySQL也能承受。</p><h3 id="1-4-各存储引擎之间的比较"><a href="#1-4-各存储引擎之间的比较" class="headerlink" title="1.4 各存储引擎之间的比较"></a>1.4 各存储引擎之间的比较</h3><p><img src="/2019/05/06/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E2%80%94%E2%80%94MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E1/bijiao.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——队列</title>
      <link href="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/"/>
      <url>/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>我们知道，CPU资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致CPU频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><h4 id="当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？"><a href="#当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？" class="headerlink" title="当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？"></a>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</h4><h4 id="1-如何理解“队列”"><a href="#1-如何理解“队列”" class="headerlink" title="1.如何理解“队列”"></a>1.如何理解“队列”</h4><p>队列这个概念可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。<br>队列跟栈相似，支持的操作也有限，最基本的操作也是两个：入队enqueue()，放一个数据到队列尾部；出队dequeue()，从队列头部取一个元素。<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/duiliehezhan.jpg"><br>队列和栈一样，也是一种操作受限的线性表数据结构。<br>作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；java concurrent并发包利用ArrayBlockingQueue来实现公平锁等。</p><h4 id="2-顺序队列和链式队列"><a href="#2-顺序队列和链式队列" class="headerlink" title="2.顺序队列和链式队列"></a>2.顺序队列和链式队列</h4><p>用数组实现的队列叫做顺序队列，用链表实现的队列叫做链式队列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//用数组实现的队列</span><br><span class="line">public class ArrayQueue</span><br><span class="line">&#123;</span><br><span class="line">//数组:items 数组大小:n</span><br><span class="line">private String[] items;</span><br><span class="line">private int n=0;</span><br><span class="line">//head表示队头下标 tail表示队尾下标</span><br><span class="line">private int head=0;</span><br><span class="line">private int tail=0;</span><br><span class="line"></span><br><span class="line">//申请一个大小为capacity的数组</span><br><span class="line">public ArrayQueue(int capacity)</span><br><span class="line">&#123;</span><br><span class="line">items = new String[capacity];</span><br><span class="line">n = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入队</span><br><span class="line">public boolean enqueue(String item)</span><br><span class="line">&#123;</span><br><span class="line">//如果tail==n 表示队列已满</span><br><span class="line">if(tail == n) return false;</span><br><span class="line">items[tail] = item;</span><br><span class="line">tail++;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//出队</span><br><span class="line">public String dequeue()</span><br><span class="line">&#123;</span><br><span class="line">//如果head==tail 表示队列为空</span><br><span class="line">if(head == tail) return null;</span><br><span class="line">String ret = item[head];</span><br><span class="line">head++;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于栈来说，只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/queue1.jpg"><br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/queue2.jpg"><br>随着不停的入队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题如何解决？<br>在数组中，数组的删除操作会导致数组中的数据不连续，解决方法是用数据搬移。但是，每次进行出队操作删除队列头的元素(相当于删除数组下标为0的数据)，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的O(1)变为O(n)。如何优化呢？<br>实际上，在出队时可以不用搬移数据。如果没有空闲空间了，只需要在入队时，集中触发一次数据的搬移操作。借助这个思想，出队函数dequeue()保持不变，改动一下入队函数enqueue():</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//入队操作，将item放入队尾</span><br><span class="line">public boolean enqueue(String item)</span><br><span class="line">&#123;</span><br><span class="line">//tail==n表示队列末尾没有空间了</span><br><span class="line">if(tail == n)</span><br><span class="line">&#123;</span><br><span class="line">//如果tail==n并且head==0表示整个队列都占满了，无法在添加元素</span><br><span class="line">if(head == 0) return false;</span><br><span class="line">//数据搬移</span><br><span class="line">for(int i=head;i&lt;tail;i++)</span><br><span class="line">&#123;</span><br><span class="line">item[i-head] = items[i];</span><br><span class="line">&#125;</span><br><span class="line">//搬移完之后更新head和tail</span><br><span class="line">tail -= head;</span><br><span class="line">head = 0;</span><br><span class="line">&#125;</span><br><span class="line">items[tail] = item;</span><br><span class="line">tail++;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于链表的实现，同样需要两个指针：head指针和tail指针。它们分别指向链表的第一个结点和最后一个结点。入队时，tail-&gt;next=new_node,tail=tail-&gt;next;出队时，head=head-&gt;next。<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/lianbiaoduilie.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//基于链表的实现</span><br><span class="line">public class QueueBasedOnLinkedList &#123;</span><br><span class="line">private static class Node &#123;</span><br><span class="line">    private String data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(String data, Node next) &#123;</span><br><span class="line">      this.data = data;</span><br><span class="line">      this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getData() &#123;</span><br><span class="line">      return data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private Node head = null;</span><br><span class="line">  private Node tail = null;</span><br><span class="line"></span><br><span class="line">  public void enqueue(String value) &#123;</span><br><span class="line">    if (tail == null) &#123;</span><br><span class="line">      Node newNode = new Node(value, null);</span><br><span class="line">      head = newNode;</span><br><span class="line">      tail = newNode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tail.next = new Node(value, null);</span><br><span class="line">      tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String dequeue() &#123;</span><br><span class="line">    if (head == null) return null;</span><br><span class="line"></span><br><span class="line">    String value = head.data;</span><br><span class="line">    head = head.next;</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">      tail = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void printAll() &#123;</span><br><span class="line">    Node p = head;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">      System.out.print(p.data + &quot; &quot;);</span><br><span class="line">      p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3.循环队列"></a>3.循环队列</h4><p><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/jiayichu.JPG"><br>循环队列，顾名思义，它长得像一个环。原本队列是有首有尾的，是一条直线，现在把它首尾相连，扳成了一个环。</p><p><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/xunhuanduilie.jpg"><br>图中这个队列的大小为8，当前head=4，tail=7.当有一个新的元素a入队时，放入下标为7的位置。但这个时候，并不把tail更新为8，而是将其在环中后移一位，到下标为0的位置。当再有一个元素b入队时，将b放入下标为0的位置，然后tail+1更新为1。所以，a、b依次入队之后：<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/xunhuan-ab.jpg"><br>循环队列的代码实现难度要比非循环队列难一些，关键在于，确定好队空和队满的判定条件。<br>用数组实现的非循环队列中，队满的判定条件是tail==n，队空的判定条件是head==tail。<br>循环队列为空的判断条件仍然是head==tail。队满的判断条件稍有不同：<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/xunhuan-duiman.jpg"></p><h4 id="当队满时，-tail-1-n-head。"><a href="#当队满时，-tail-1-n-head。" class="headerlink" title="当队满时，(tail+1)%n=head。"></a>当队满时，(tail+1)%n=head。</h4><p>当队列满时，图中tail指向的位置实际上是没有存储数据的，这种方法是少用一个元素空间，约定以“队列头指针在队列尾指针的下一位置上”作为队列“满”的标志。<br>另一种方法是另设一个标志位以区别队列是“空”还是“满”。另外占用一个内存空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CircularQueue &#123;</span><br><span class="line">  // 数组：items，数组大小：n</span><br><span class="line">  private String[] items;</span><br><span class="line">  private int n = 0;</span><br><span class="line">  // head 表示队头下标，tail 表示队尾下标</span><br><span class="line">  private int head = 0;</span><br><span class="line">  private int tail = 0;</span><br><span class="line"></span><br><span class="line">  // 申请一个大小为 capacity 的数组</span><br><span class="line">  public CircularQueue(int capacity) &#123;</span><br><span class="line">    items = new String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 入队</span><br><span class="line">  public boolean enqueue(String item) &#123;</span><br><span class="line">    // 队列满了</span><br><span class="line">    if ((tail + 1) % n == head) return false;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + 1) % n;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 出队</span><br><span class="line">  public String dequeue() &#123;</span><br><span class="line">    // 如果 head == tail 表示队列为空</span><br><span class="line">    if (head == tail) return null;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + 1) % n;</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-阻塞队列和并发队列"><a href="#4-阻塞队列和并发队列" class="headerlink" title="4.阻塞队列和并发队列"></a>4.阻塞队列和并发队列</h4><p>队列这种数据结构很基础，平时的业务开发不大可能从0实现一个队列，甚至不会用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。<br>阻塞队列是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/zuseduilie1.jpg"><br>上述的定义就是一个“生产者—消费者模型”。使用阻塞队列可以轻松实现一个“生产者—消费者模型”。<br><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/zuseduilie2.jpg"></p><p>那，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，如何实现一个线程安全的队列呢？<br>线程安全的队列叫做并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发操作，这也是循环队列比链式队列应用更加广泛的原因，</p><h4 id="5-线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？"><a href="#5-线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？" class="headerlink" title="5.线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？"></a>5.线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略是如何实现的？</h4><p>一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<br>对于如何存储排队的请求，我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。基于链表和基于数组实现的队列对于排队请求有何区别？<br>基于链表的实现方式，可以实现一个支持无限排队的无界队列(unbounded queue)，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。<br>基于数组实现的有界队列(bounded queue)，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，是很有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。<br>除了队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考:"></a>思考:</h4><h4 id="1-除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？"><a href="#1-除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？" class="headerlink" title="(1)除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？"></a>(1)除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求？</h4><h4 id="2-如何实现无锁并发队列？"><a href="#2-如何实现无锁并发队列？" class="headerlink" title="(2)如何实现无锁并发队列？"></a>(2)如何实现无锁并发队列？</h4><p><img src="/2019/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/sikao.png"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——栈</title>
      <link href="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/"/>
      <url>/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h4 id="如何实现浏览器的前进和后退功能？"><a href="#如何实现浏览器的前进和后退功能？" class="headerlink" title="如何实现浏览器的前进和后退功能？"></a>如何实现浏览器的前进和后退功能？</h4><p>当你依次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面b和a。当你后退到页面a，点击前进按钮，就可以重新查看页面b和c。但是，如果你后退到页面b后，点击了新的页面d，那就无法在通过前进、后退功能查看页面c了。</p><h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><p>方法调用！</p><h4 id="如何理解栈？"><a href="#如何理解栈？" class="headerlink" title="如何理解栈？"></a>如何理解栈？</h4><p>关于“栈”，有一个非常贴切的例子，就是一摞叠在一起的盘子。放盘子的时候，都是从下往上一个一个放；取的时候，从上往下一个一个地依次取，不能从中间任意抽出。后进者先出，先进者后出，这就是典型的“栈”结构。<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/zhan.jpg"><br>从栈的操作特性上看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。<br>特定的数据结构是对特定场景的抽象，数据或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时比较不可控。<br>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</p><h4 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h4><p>栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，叫做顺序栈；用链表实现的栈，叫做链式栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 基于数组实现的顺序栈</span><br><span class="line">public class ArrayStack &#123;</span><br><span class="line">  private String[] items;  // 数组</span><br><span class="line">  private int count;       // 栈中元素个数</span><br><span class="line">  private int n;           // 栈的大小</span><br><span class="line"></span><br><span class="line">  // 初始化数组，申请一个大小为 n 的数组空间</span><br><span class="line">  public ArrayStack(int n) &#123;</span><br><span class="line">    this.items = new String[n];</span><br><span class="line">    this.n = n;</span><br><span class="line">    this.count = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 入栈操作</span><br><span class="line">  public boolean push(String item) &#123;</span><br><span class="line">    // 数组空间不够了，直接返回 false，入栈失败。</span><br><span class="line">    if (count == n) return false;</span><br><span class="line">    // 将 item 放到下标为 count 的位置，并且 count 加一</span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 出栈操作</span><br><span class="line">  public String pop() &#123;</span><br><span class="line">    // 栈为空，则直接返回 null</span><br><span class="line">    if (count == 0) return null;</span><br><span class="line">    // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span><br><span class="line">    String tmp = items[count-1];</span><br><span class="line">    --count;</span><br><span class="line">    return tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//基于链表实现的链式栈</span><br><span class="line">public class StackBasedOnLinkedList &#123;</span><br><span class="line"></span><br><span class="line">private static class Node &#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(int data, Node next) &#123;</span><br><span class="line">      this.data = data;</span><br><span class="line">      this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getData() &#123;</span><br><span class="line">      return data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private Node top = null;</span><br><span class="line"></span><br><span class="line">  public void push(int value) &#123;</span><br><span class="line">    Node newNode = new Node(value, null);</span><br><span class="line"></span><br><span class="line">    if (top == null) &#123;</span><br><span class="line">      top = newNode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      newNode.next = top;</span><br><span class="line">      top = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int pop() &#123;</span><br><span class="line">    if (top == null) return -1;</span><br><span class="line">    int value = top.data;</span><br><span class="line">    top = top.next;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void printAll() &#123;</span><br><span class="line">    Node p = top;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">      System.out.print(p.data + &quot; &quot;);</span><br><span class="line">      p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为n的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)。入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度是O(1)。<br>注意，这里存储数据需要一个大小为n的数组，并不是说空间复杂度就是O(n)。因为，这n个空间是必须的，无法省掉。所以在说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p><h4 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h4><p>刚才那个基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储next指针，内存消耗相对较多。<br>基于数组实现一个可以支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，就申请一个更大的数组，将原来的数据搬移到新数组中。<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/dongtaikuorong.jpg"><br>动态扩容的顺序栈，对于出栈操作来说，不会涉及到内存的重新申请和数据搬移，所以出栈的时间复杂度是O(1)。但是对于入栈操作来说，当栈中有空闲空间时，入栈操作的时间复杂度为O(1)，当空间不够时，就需要重新申请内存和数据搬移，时间复杂度就成了O(n)。<br>入栈操作，最好情况时间复杂度是O(1)，最坏情况时间复杂度是O(n)。均摊时吉安复杂度是O(1)。<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/juntan.jpg"></p><h4 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h4><p>栈作为一个比较基础的数据结构，比较经典的一个应用场景是函数调用栈。<br>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   int a = 1; </span><br><span class="line">   int ret = 0;</span><br><span class="line">   int res = 0;</span><br><span class="line">   ret = add(3, 5);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   printf(&quot;%d&quot;, res);</span><br><span class="line">   reuturn 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int add(int x, int y) &#123;</span><br><span class="line">   int sum = 0;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，main()函数调用了add()函数，获取计算结果，与临时变量a相加，最后打印res的值。下图可以看到这个过程对应的函数栈里出栈、入栈的操作，在执行到add()函数时，函数调用栈的情况。<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/hanshuzhanzhen.jpg"></p><h4 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h4><p>栈的另一个常见的应用场景，编译器利用栈来实现表达式求值。<br>这里将算术表达式简化为只包含加减乘除四则运算(其实更复杂的还有与或非等逻辑运算、括号等)，比如：34+13*9+44-12/3。</p><p>对于这个四则运算，人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事。<br>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素比较。如果比运算符栈栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/biaodashiqiuzhi.jpg"></p><h4 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h4><p>借助栈来检查表达式中的括号是否匹配。<br>假设表达式中只包含三种括号，圆括号()、方括号[]、花括号{}，并且它们可以任意嵌套。比如，{[()]}或[({})([])]等都为合法形式，而([){}]为不合法形式。对于一个只包含括号的表达式字符串，如何检查它是否合法呢？<br>思路：用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，就将其压入栈中；当扫描到右括号时，将其与栈顶左括号匹配，若能够匹配，将此栈顶左括号出栈，继续扫描其余的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有左括号，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法形式；否则，说明有未匹配的左括号，为非法格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        //栈中只进左括号 每当有一个括号要进栈时就看它是不是与栈顶括号相匹配 匹配就pop 不匹配就进栈</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        char[] chars=s.toCharArray();</span><br><span class="line">        for(char theChar:chars)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stack.size()==0)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(theChar);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(isCompact(stack.peek(),theChar))</span><br><span class="line">            &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(theChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.size()==0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean isCompact(char a,char b)</span><br><span class="line">    &#123;</span><br><span class="line">        return ( (a==&#x27;(&#x27; &amp;&amp; b==&#x27;)&#x27;) || (a==&#x27;&#123;&#x27; &amp;&amp; b==&#x27;&#125;&#x27;) || (a==&#x27;[&#x27; &amp;&amp; b==&#x27;]&#x27;) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用两个栈来实现浏览器的前进、后退功能"><a href="#用两个栈来实现浏览器的前进、后退功能" class="headerlink" title="用两个栈来实现浏览器的前进、后退功能"></a>用两个栈来实现浏览器的前进、后退功能</h4><p>使用两个栈X和Y，把首次浏览的页面依次压入栈X，当点击后退按钮时，依次从栈X中出现，并将出栈的数据依次放入栈Y。当点击前进按钮时，依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，就说明没有页面可以继续后退浏览了。当栈Y中没有数据，说明没有页面可以点击前进按钮浏览了。</p><p>举个例子，我们顺序查看了a-b-c三个页面，依次把a、b、c压入栈：<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/abc.jpg"><br>通过浏览器的后退按钮，从页面c后退到页面a之后，就依次把c和b从栈X中弹出，并且依次放入到栈Y中：<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/tuibc.jpg"><br>点击前进按钮回到b页面，将b从栈Y中弹出，放入栈X：<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/jinb.jpg"><br>通过页面b跳转到新的页面d，页面c就无法再通过前进、后退按钮重复查看，这是清空栈Y：<br><img src="/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%88/dianjixindeyemian.jpg"></p><h4 id="为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗"><a href="#为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗" class="headerlink" title="为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗?"></a>为什么函数调用要用“栈”来保存临时变量？用其他数据结构不行吗?</h4><p>不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最好的选择。<br>从调用函数进入被调用函数，对于数据来说，变化的是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p><h4 id="JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储java中的对象。那JVM中的“栈”和这里说的“栈”是不是一回事？如果不是，那它为什么又叫做“栈”"><a href="#JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储java中的对象。那JVM中的“栈”和这里说的“栈”是不是一回事？如果不是，那它为什么又叫做“栈”" class="headerlink" title="JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储java中的对象。那JVM中的“栈”和这里说的“栈”是不是一回事？如果不是，那它为什么又叫做“栈”?"></a>JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储java中的对象。那JVM中的“栈”和这里说的“栈”是不是一回事？如果不是，那它为什么又叫做“栈”?</h4><p>我以为内存中的栈和数据结构的栈不是一个概念。内存中的堆栈是内存中的数据区域，是一段虚拟的内存空间，数据结构中的堆栈是抽象的数据存储结构。但是它们都有“栈”的特性。<br>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为堆和栈。<br>代码区：存储方法体的二进制代码。高级调度(作业)、中级调度(内存)、低级调度(进程)控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——链表</title>
      <link href="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="经典链表应用场景：LRU缓存淘汰算法"><a href="#经典链表应用场景：LRU缓存淘汰算法" class="headerlink" title="经典链表应用场景：LRU缓存淘汰算法"></a>经典链表应用场景：LRU缓存淘汰算法</h4><p>缓存是一种提高数据读取性能技术，硬件设计和软件开发中都有应用：CPU缓存、数据库缓存、浏览器缓存等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留，需要缓存淘汰策略来决定，如：先进先出策略(first in first out)、最少使用策略LFU(least frequently used)、最近最少使用策略(least recently used)。<br>所以想一下，如何用链表来实现LRU缓存淘汰策略？</p><h4 id="数组-amp-链表：底层存储结构"><a href="#数组-amp-链表：底层存储结构" class="headerlink" title="数组&amp;链表：底层存储结构"></a>数组&amp;链表：底层存储结构</h4><p>数组需要一块连续的内存空间来存储，对内存的要求比较高。如果需要申请一个100MB大小的数组，当内存中没有连续的、足够大的内存空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败。<br>链表，不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。<br><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/neicunfenbu.jpg"></p><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>链表通过指针将一组零散的内存块串联在一起。我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，把这个记录下个结点地址的指针叫做后继指针next。<br><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/danlianbiao.jpg"><br>单链表中，有两个结点是比较特殊的，分别是第一个结点和最后一个结点。习惯性地把第一个结点叫做头结点，把最后一个结点叫做尾结点。头结点用来记录链表的基地址，通过它可以遍历得到整条链表。尾结点的指针不是指向下一个结点，而是指向一个空地址null，表示这是链表上最后一个结点。<br>与数组一样，链表也支持数据的查找、插入和删除操作。<br>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)。而在链表中插入或者删除一个数据，不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。<br>针对链表的插入和删除操作，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)。<br><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/charuandshanchu.jpg"><br>但是，链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据不是连续存储的，就无法像数组那样，根据首地址和下标，通过寻址公式只算计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表是一种特殊的单链表。唯一区别在于尾结点。单链表的尾结点指针指向空地址，表示这是最后的结点；而循环链表的尾结点指针指向链表的头结点。<br><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/xunhuanlianbiao.jpg"><br>循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环形结构特点时适合采用，比如著名的<a href="https://blog.csdn.net/weixin_38214171/article/details/80352921">约瑟夫问题</a>。</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。<br><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/shuangxianglianbiao.jpg"><br>双向链表需要额外的两个空间来存储后继节点和前驱结点的地址。所以如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。但它支持双向遍历。</p><h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><p><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/shuangxiangxunhuan.jpg"></p><h3 id="单链表-amp-双向链表比较"><a href="#单链表-amp-双向链表比较" class="headerlink" title="单链表&amp;双向链表比较"></a>单链表&amp;双向链表比较</h3><h4 id="1-删除结点中“值等于某个给定值”的结点"><a href="#1-删除结点中“值等于某个给定值”的结点" class="headerlink" title="1.删除结点中“值等于某个给定值”的结点"></a>1.删除结点中“值等于某个给定值”的结点</h4><h4 id="2-删除给定指针指向的结点"><a href="#2-删除给定指针指向的结点" class="headerlink" title="2.删除给定指针指向的结点"></a>2.删除给定指针指向的结点</h4><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过前面讲的指针操作将其删除。尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度是O(n)。<br>对于第二种情况，已经找到了要删除的结点，但是删除某个结点q需要知道指向它的前驱结点p，而单链表不支持直接获取前驱结点，所以为了找到前驱结点，还是要从头结点开始遍历链表，知道p-&gt;next=q，说明p是q的前驱结点。但是对于双向链表来说，因为双向链表的结点中已经保存了前驱结点的指针，就不需要像单链表那样遍历。<br>对于插入操作，在链表的指定结点前面插入一个结点，双向链表可以在O(1)时间复杂度搞定，而单向链表需要O(n)的时间复杂度。<br>除此之外，对于一个有序链表，双向链表的按值查询的效率要比单链表高一些。因为双向链表可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>Java中LinkedHashMap的实现中就用到了双向链表这种数据结构。</p><h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>当内存空间充足的时候，如果我们更加追求代码的执行速度，就可以选择空间复杂度相对较高但时间复杂度相对很低的算法或者数据结构。<br>相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，要反过来用时间换空间的设计思路。<br>实际上，缓存就是利用了空间换时间的设计思想。</p><h3 id="链表-amp-数组：性能比较"><a href="#链表-amp-数组：性能比较" class="headerlink" title="链表&amp;数组：性能比较"></a>链表&amp;数组：性能比较</h3><p><img src="/2019/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/xingneng.jpg"><br>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高；而链表在内存中不是连续存储，所以对CPU缓存不友好，没办法有效预读。<br>引申：CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(具体大小这里不确定，跟CPU实现有关)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取，反之要去内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的矛盾。对于数组来说，存储空间是连续的，所以在加载某个下标的时候就可以把后面的几个下标元素也加载到CPU缓存，这样执行速度就快于存储空间不连续的链表存储。<br>链表本身没有大小限制，天然的支持动态扩容，插入元素只需要修改指针的指向就可以，这是我理解的链表与数组的最大区别。</p><h4 id="如何基于链表实现LRU缓存淘汰算法"><a href="#如何基于链表实现LRU缓存淘汰算法" class="headerlink" title="如何基于链表实现LRU缓存淘汰算法"></a>如何基于链表实现LRU缓存淘汰算法</h4><p>思路：维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表：<br>1.如果此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，将其从原来的位置删除，然后再插入到链表的头部。<br>2.如果此数据没有在缓存链表中：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则删除链表尾结点，再将新的数据结点插入到链表的头部。<br>这样，不管缓存有没有满，都需要遍历一遍链表，这种基于链表的实现思路，缓存访问的时间复杂度是O(n)。<br>引申：引入散列表(Hash Table)来记录每个数据的位置，可以将缓存访问的时间复杂度降到O(1)。</p><h4 id="如何基于数组实现LRU缓存淘汰策略？"><a href="#如何基于数组实现LRU缓存淘汰策略？" class="headerlink" title="如何基于数组实现LRU缓存淘汰策略？"></a>如何基于数组实现LRU缓存淘汰策略？</h4><p>思路：维护一个有序的数组，越靠近数组首位置的数据越是最早访问的，当有一个新的数据被访问时：<br>1.如果这个数据已经存在于数组中，把对应位置的数据删掉，直接把这个数据加到数组的最后一位。时间复杂度为O(n)。<br>2.如果这个数据不存在这个数组中，数组还有空间的话，就把这个数据直接添加到最后一位；没有空间的话，删除掉数组的第一个元素，然后把数据插入到数组最后一个。时间复杂度为O(n)。</p><h4 id="如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？"><a href="#如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？" class="headerlink" title="如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？"></a>如果判断一个用单链表存储的字符串是回文字符串？相应的时间空间复杂度？</h4><p>思路：使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">  public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">    if (head == null || head.next == null) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line"></span><br><span class="line">    while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">      ListNode next = slow.next;</span><br><span class="line">      slow.next = prev;</span><br><span class="line">      prev = slow;</span><br><span class="line">      slow = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fast != null) &#123;  //奇数个结点时</span><br><span class="line">      slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (slow != null) &#123;</span><br><span class="line">      if (slow.val != prev.val) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——2.4OutOfMemoryError异常</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94OutOfMemoryError%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94OutOfMemoryError%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>在java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。</p><h3 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1. Java堆溢出"></a>1. Java堆溢出</h3><p>java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量到达最大堆的容量限制后产生内存溢出异常。</p><h3 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2. 虚拟机栈和本地方法栈溢出"></a>2. 虚拟机栈和本地方法栈溢出</h3><p>由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数(设置本地方法栈大小)虽然存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在java虚拟机规范中描述了两种异常：<br>1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。<br>2）如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。<br>这里把异常分成两种情况看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。<br>在单线程的操作中，以下两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError异常：</p><pre><code>使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的栈深度相应缩小。定义了大量的本地变量，增加此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的栈深度相应缩小。</code></pre><h3 id="3-运行时常量池溢出"><a href="#3-运行时常量池溢出" class="headerlink" title="3.运行时常量池溢出"></a>3.运行时常量池溢出</h3><h3 id="4-方法区溢出"><a href="#4-方法区溢出" class="headerlink" title="4.方法区溢出"></a>4.方法区溢出</h3><h3 id="5-本机直接内存溢出"><a href="#5-本机直接内存溢出" class="headerlink" title="5.本机直接内存溢出"></a>5.本机直接内存溢出</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——2.3对象访问</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>在java语言中，对象访问是如何进行的？<br>对象访问在java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会涉及java栈、java堆和方法区这三个最重要内存区域之间的关联关系。</p><h4 id="Object-obj-new-Object"><a href="#Object-obj-new-Object" class="headerlink" title="Object obj = new Object();"></a>Object obj = new Object();</h4><p>假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反正到java堆中，形成一块存储了Object类型所有实例数据值(Instance Data，对象中各个实例字段的数据)的结构化内存，根据具体类型以及虚拟机实现的对象内存布局(Object Memory Layout)的不同，这块内存的长度是不固定的。另外，在java堆中还必须包含能查找到此对象类型数据(如对象类型、父类、实现的接口、方法等)的地址信息，这些类型数据则存储在方法区中。<br>由于reference类型在java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。<br>1）如果使用句柄访问方式，java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/jubingfangwen.png" alt="通过句柄访问对象"></p><p>2）如果使用直接指针访问方式，java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/zhijiezhizhen.png" alt="通过直接指针访问对象"></p><p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普通的行为)时只会改变句柄中的实例数据指针，而reference本身不需要被修改。<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。<br>就Sun HotSpot而言，它是使用第二种方式进行对象访问的；从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——2.2运行时数据区域</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><p>Java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/yunxingshishujuquyu.png"></p><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><p>程序计数器(program counter register)是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说一个内核)只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。<br>如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这个计数器值则为空(undefined)。此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="2-java虚拟机栈"><a href="#2-java虚拟机栈" class="headerlink" title="2.java虚拟机栈"></a>2.java虚拟机栈</h3><p>与程序计数器一样，java虚拟机栈(java virtual machine stacks)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧(stack frame,栈帧是方法运行期的基础数据结构)用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>经常有人把java内存区分为堆内存(heap)和栈内存(stack)，这种分法比较粗糙，java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。<br>局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、long、float、double)、对象引用(reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。<br>其中64位长度的long和double类型的数据会占用两个局部变量空间(slot)，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。<br>在java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展(当前大部分的java虚拟机都可动态扩展，只不过java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h3><p>本地方法栈(native method stacks)与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的native方法服务。<br>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><p>关于本地方法：一个Native Method就是一个java程序调用非java代码的接口。一个本地方法是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其他的编程语言都有这一机制……</p><h3 id="4-java堆"><a href="#4-java堆" class="headerlink" title="4.java堆"></a>4.java堆</h3><p>对于大多数应用来说，java堆(java Heap)是java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。<br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”(garbage collected heap)。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区(thread local allocation buffer,TLAB)。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。<br>根据java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h3><p>方法区中的信息：类的静态方法、静态变量、常量池、类的代码。</p><p>方法区(method area)与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与java堆区分开来。<br>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”(Permanent Generation)，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机(如BEA JRockit、IBM J9等)来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。<br>java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分的区域的回收确实是有必要的。在Sub公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。<br>根据java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6.运行时常量池"></a>6.运行时常量池</h3><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。<br>Java虚拟机对Class文件的每一部分(自然也包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需求来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7.直接内存"></a>7.直接内存</h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。<br>在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在java堆和native堆中来回复制数据。<br>显然，本机直接内存的分配不会受到java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括RAM及SWAP区或者分页文件)的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.5内存分配与回收策略</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。</p><h4 id="给对象分配内存"><a href="#给对象分配内存" class="headerlink" title="给对象分配内存"></a>给对象分配内存</h4><p>对象的内存分配，往大方向上讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配——在Java编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。当你写好一个Java程序后，源语言的语句将由Java编译器编译成字节码，而不是编译成与某个特定的处理器硬件平台对应的指令代码（比如，Intel的Pentium微处理器或IBM的System/390处理器）。字节码是可以发送给任何平台并且能在那个平台上运行的独立于平台的代码。))，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，讲按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。</p><h3 id="1-对象优先在Eden上分配"><a href="#1-对象优先在Eden上分配" class="headerlink" title="1. 对象优先在Eden上分配"></a>1. 对象优先在Eden上分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。<br>虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前内存各区域的分配情况。在实际应用中，内存回收日志一般是打印到文件后通过日志工具进行分析。<br>▲新生代GC(Minor GC)：指发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。<br>▲老年代GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC(但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</p><h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>所谓大对象就是指，需要大量连续内存空间的java对象，最典型的大对象就是那种很长的字符串及数组。大对象对虚拟机的内存分配来说就是一个坏消息(比遇到一个大对象更加坏的消息就是遇到一群“朝生夕死”的“短命大对象”，写程序的时候应当避免)，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><h3 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h3><p>虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，哪些对象应当放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一个Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一个Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁)时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。</p><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</p><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><p>在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。<br>新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况时(最极端就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。<br>取平均值进行比较是一种动态概念的手段，也就是说如果某次Minor GC存活后的对象徒增，远远高于平均值的话，依然会导致担保失败(Handle Promotion Failure)。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.4垃圾收集器</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/lajishoujiqi.png"><br>图中展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。<br>明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。</p><h4 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h4><p>单线程，stop the word</p><h4 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2. ParNew收集器"></a>2. ParNew收集器</h4><p>Serial收集器的多线程版本</p><h4 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3. Parallel Scavenge收集器"></a>3. Parallel Scavenge收集器</h4><h4 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4. Serial Old收集器"></a>4. Serial Old收集器</h4><p>Serial收集器的老年代版本</p><h4 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h4><p>Parallel收集器的老年代版本</p><h4 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h4><p>concurrent mark sweep，是一种以获取最短回收停顿时间为目标的收集器，非常符合在注重用户体验的应用上使用。CMS收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。<br>CMS收集器用“标记—清除”算法实现。整个过程分为四个步骤：初始标记—并发标记—重新标记—并发清除。<br>优点：并发收集、低停顿。<br>缺点：对CPU资源敏感，无法处理浮动垃圾，使用“标记—清除”算法会导致收集结束时会有大量空间碎片产生。</p><h4 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h4><p>G1(Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的及其，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。<br>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征，具备以下特点：并行与并发，分代收集，空间整合，可预测的停顿。<br>运作分为四个步骤：初始标记—并发标记—最终标记—筛选回收。<br>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h4 id="8-垃圾收集器参数总结"><a href="#8-垃圾收集器参数总结" class="headerlink" title="8. 垃圾收集器参数总结"></a>8. 垃圾收集器参数总结</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.2对象死或否</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%AD%BB%E6%88%96%E5%90%A6/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%AD%BB%E6%88%96%E5%90%A6/</url>
      
        <content type="html"><![CDATA[<p>堆中几乎存放着java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”(即不可能再被任何途径使用的对象).</p><h4 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1.引用计数算法"></a>1.引用计数算法</h4><p>很多教科书判断对象是否存活的算法是：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。<br>客观地说，引用计数算法(Reference Counting)的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案列，例如微软的COM(Component Object Model)技术、使用ActionScript3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。<br>但是，java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%AD%BB%E6%88%96%E5%90%A6/yinyongjishu.png"><br>testGC()方法中对象objA和objB都有字节instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用这对方，导致它们的引用计数都不为0.于是引用计数算法无法通知GC收集器回收它们。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%AD%BB%E6%88%96%E5%90%A6/yinyongjishujieguo.png"><br>从运行结果可以看到GC日志中包含“4603K-&gt;210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p><h4 id="2-根搜索算法"><a href="#2-根搜索算法" class="headerlink" title="2.根搜索算法"></a>2.根搜索算法</h4><p>在主流的商用程序语言中(java和C#，甚至包括前面提到的古老的Lisp)，都是使用根搜索算法(GC Roots Tracing)判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连(用图论的话来说就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%AD%BB%E6%88%96%E5%90%A6/gensousuo.png"><br>如图，对象object5、object6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。<br>在java语言里，可作为GC Roots的对象包括下面几种：<br>1)虚拟机栈(栈帧中的本地变量表)中的引用的对象。<br>2)方法区中的类静态属性引用的对象。<br>3)方法区中的常量引用的对象。<br>4)本地方法栈中JNI(即一般说的native方法)的引用的对象。</p><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判断对象是否存活都与“引用”有关。<br>在JDK1.2之前，java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。<br>在JDK1.2之后，java对引用的概念进行了扩充，将引用分为强引用(strong reference)、软引用(soft reference)、弱引用(weak reference)、虚引用(phantom reference)四种，这四种引用强度依次逐渐减弱。<br>1)强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。<br>2)软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。<br>3)弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现软引用。<br>4)虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现软引用。</p><h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。<br>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 此代码演示了两点：</span><br><span class="line"> * 1.对象可以在被GC时自我拯救</span><br><span class="line"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span><br><span class="line"> */</span><br><span class="line"> public class FinalizeEscapeGC&#123;</span><br><span class="line"></span><br><span class="line"> public static FinalizeEscapeGC SACE_HOOK = null;</span><br><span class="line"></span><br><span class="line"> public void isAlive()&#123;</span><br><span class="line"> System.out.println(&quot;yes,i am still alive :)&quot;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void finalize() throws Throwable&#123;</span><br><span class="line"> super.finalize();</span><br><span class="line"> System.out.println(&quot;finalize method executed!&quot;);</span><br><span class="line"> FinalizeEscapeGC.SACE_HOOK = this;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args)throws Throwable&#123;</span><br><span class="line"> SAVE_HOOK = new FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line"> //对象第一次成功拯救自己</span><br><span class="line"> SAVE_HOOK = null;</span><br><span class="line"> System.gc();</span><br><span class="line"> //因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span><br><span class="line"> Thread.sleep(500);</span><br><span class="line"> if(SAVE_HOOK ！= null)</span><br><span class="line"> &#123;</span><br><span class="line"> SAVE_HOOK.isAlive();</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(&quot;no,i am dead :(&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //下面这段代码与上面完全相同，但是这次自救却失败了</span><br><span class="line"> SAVE_HOOK = null;</span><br><span class="line"> System.gc();</span><br><span class="line"> //因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span><br><span class="line"> Thread.sleep(500);</span><br><span class="line"> if(SAVE_HOOK ！= null)</span><br><span class="line"> &#123;</span><br><span class="line"> SAVE_HOOK.isAlive();</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> System.out.println(&quot;no,i am dead :(&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//运行结果</span><br><span class="line">finalize method executed!</span><br><span class="line">yes,i am still alive :)</span><br><span class="line">no,i am dead :(</span><br></pre></td></tr></table></figure><p>从运行结果可以看到，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。<br>另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>很多人认为方法区(或者HotSpot虚拟机中的永久代)是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。<br>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。<br>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：<br>1.该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。<br>2.加载该类的ClassLoader已经被回收。<br>3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类的加载和卸载信息。-verbose:class及-XX:+TraceClassLoading可以在Product版的虚拟机中使用，但是-XX:+TraceClassLoading参数需要fastdebug版的虚拟机支持。<br>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM——3.3垃圾回收算法</title>
      <link href="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="标记——清除算法-Mark-Sweep"><a href="#标记——清除算法-Mark-Sweep" class="headerlink" title="标记——清除算法(Mark-Sweep)"></a>标记——清除算法(Mark-Sweep)</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉被标记的对象。标记过程在另一篇“深入理解JVM——对象死或否”中讲述，对象标记判定对象是不是还“存活”。<br>主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/marksweep.png" alt="标记——清除算法示意图"><br>举个不恰当的例子，类似于我们扔垃圾，我们把垃圾扔到垃圾桶里，扔到垃圾桶里的垃圾只是被标记为了“垃圾”，我们并不会立刻把它扔掉，当垃圾桶满了的时候，我们统一清除它们。</p><h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h3><p>为了解决效率问题，出现了这种称为“复制”的收集算法。<br>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。<br>这种算法的代价是将内存缩小为原来的一半，未免太高了，也就是说浪费一半的内存空间。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/copying.png" alt="复制算法示意图"><br>现在的商业虚拟机都采用复制算法来回收新生代。<br>IBM的专门研究表名，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)。<br>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p><h3 id="标记——整理算法-Mark-Compact"><a href="#标记——整理算法-Mark-Compact" class="headerlink" title="标记——整理算法(Mark-Compact)"></a>标记——整理算法(Mark-Compact)</h3><p>复制算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>根据老年代的特点，便提出了这种标记——整理算法，标记过程仍然与“标记——清除算法”一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br><img src="/2019/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/markcompact.png" alt="标记——整理算法示意图"></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。<br>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记——清除”或“标记——整理”算法来进行回收。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——数组</title>
      <link href="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
      <url>/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么数组要从0开始编号，而不是从1开始？"><a href="#为什么数组要从0开始编号，而不是从1开始？" class="headerlink" title="为什么数组要从0开始编号，而不是从1开始？"></a>为什么数组要从0开始编号，而不是从1开始？</h4><h4 id="如何实现随机访问？"><a href="#如何实现随机访问？" class="headerlink" title="如何实现随机访问？"></a>如何实现随机访问？</h4><h3 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1.什么是数组"></a>1.什么是数组</h3><p>数组(Array)是一种①线性表数据结构。它用一组②连续的内存空间，来存储一组具有相同类型的数据。</p><h4 id="①线性表"><a href="#①线性表" class="headerlink" title="①线性表"></a>①线性表</h4><p>顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。<br><img src="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/xianxingbiao.jpg"><br>相对立的非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。<br><img src="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/feixianxingbiao.jpg"></p><h4 id="②连续的内存空闲和相同类型的数据"><a href="#②连续的内存空闲和相同类型的数据" class="headerlink" title="②连续的内存空闲和相同类型的数据"></a>②连续的内存空闲和相同类型的数据</h4><p>相同类型保证数组元素内存地址的计算公式可以成立，从而支持随机访问。<br>优点：正因为这两个限制，数组才有了一个特性：随机访问（并不是random的随机，可能理解为任意访问更清晰一点。）。<br>缺点：但是，要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><h3 id="2-数组是如何实现根据下标随机访问数组元素的？"><a href="#2-数组是如何实现根据下标随机访问数组元素的？" class="headerlink" title="2.数组是如何实现根据下标随机访问数组元素的？"></a>2.数组是如何实现根据下标随机访问数组元素的？</h3><p><img src="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/shuzuneicun.jpg"><br>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size(元素类型长度)</span><br></pre></td></tr></table></figure><h4 id="注意：数组和链表的区别"><a href="#注意：数组和链表的区别" class="headerlink" title="注意：数组和链表的区别"></a>注意：数组和链表的区别</h4><p>“链表适合插入、删除，时间复杂度是O(1)；数组适合查找，查找时间复杂度是O(1)。”实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为O(1)，即便是排好序的数组，二分查找的时间复杂度最好也是O(logn)。正确的表述应该是，“数组支持随机访问，根据下标随机访问的时间复杂度是O(1)。”</p><h3 id="3-低效的“插入”和“删除”"><a href="#3-低效的“插入”和“删除”" class="headerlink" title="3.低效的“插入”和“删除”"></a>3.低效的“插入”和“删除”</h3><p>数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，那，为什么会导致低效？改进方法？</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>假设现在有一个数组，长度为n，现在我们需要把一个数组插入到数组中的第k个位置。为了把第k个位置腾出来给信赖的数据，需要将第k~n这部分元素都顺序地往后挪一位。这样的话，插入操作的时间复杂度是多少？<br>最好情况：如果在数组的末尾插入元素，就不需要移动数据，这时的时间复杂度是O(1)。<br>最坏情况：如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O(n)。<br>平均情况时间复杂度为(1+2+……+n)/n=O(n)。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，要将某个数据插入到第k个位置，为了避免大规模的数据搬移，简单办法是：直接将第k为数据搬移到数组元素的最后，把新的元素直接放入第k个位置。<br><img src="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/wuxucharu.jpg"><br>这样，在特定场景下，在第k个位置插入一个元素的时间复杂度就降为O(1)。这个处理思想在快排中会用到。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>跟插入数据类似，如果我们要删除第k个位置的数据，为了内存的连续性，也需要搬移数据，不然数组中间会出现空缺，内存就不连续了。<br>如果要删除数组末尾的数据，则最好情况时间复杂度为O(1)；删除数组开头的数据，最坏情况时间复杂度为O(n)；平均情况时间复杂度为O(n)。</p><p>在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率也许会提高很多。<br>假设数组a[10]中存储了8个元素：a,b,c,d,e,f,g,h。现在，我们要依次删除a,b,c三个元素。<br><img src="/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/jizhongshanchu.jpg"><br>为了避免d,e,f,g,h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br>而这，正是JVM垃圾回收之标记——清除算法的思想。<br>标记——清除算法：从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象设一个标记，这个过程不会回收任何对象。只有全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。所以剩下的堆空间是不连续的。标记——清除算法只有在少量垃圾产生时会很高效。</p><h3 id="4-警惕数组的访问越界问题"><a href="#4-警惕数组的访问越界问题" class="headerlink" title="4.警惕数组的访问越界问题"></a>4.警惕数组的访问越界问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int arr[3] = &#123;0&#125;;</span><br><span class="line">    for(; i&lt;=3; i++)&#123;</span><br><span class="line">        arr[i] = 0;</span><br><span class="line">        printf(&quot;hello world\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段C语言代码的运行结果并非是打印三行“hello world”，而是会无限打印“hello world”。<br>因为，数组的大小是3，a[0],a[1],a[2],而这段代码书写错误，导致for循环的结束条件错写为了i&lt;=3而不是i&lt;3，所以当i=3时，数组a[3]访问越界。<br>在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据前面提到的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么a[3]=0就相当于i=0，就导致代码无限循环。</p><h4 id="为什么a-3-的内存地址正好是变量i的内存地址"><a href="#为什么a-3-的内存地址正好是变量i的内存地址" class="headerlink" title="为什么a[3]的内存地址正好是变量i的内存地址"></a>为什么a[3]的内存地址正好是变量i的内存地址</h4><pre><code>函数体内的局部变量存在栈上，且是连续压栈。这段代码的变量压栈顺序是：i,arr[0],arr[1],arr[2]。变量i最先入栈，然后是数组元素，因为数组地址连续从小到大，实际栈中的变量顺序为：arr[0],arr[1],arr[2],i。这样arr[3]的地址刚好与i相同。另外的解释是：与编译器的实现有关。linux的gcc有一个编译选项(-fno-stack-protector)用于关闭堆栈保护功能。默认情况下启动堆栈保护，不管i声明在前还是声明在后，i都会在数组之后压栈，只会循环4次；如果关闭了堆栈保护功能，则会出现死循环。</code></pre><p>数组越界在C语言中是一种未决行为(没有定义的行为)，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质是访问一段连续内存，只要数组通过偏移计算得到的内存地址时可用的，那么程序就可能不会报任何错误。<br>Java本身就会做越界检查，数组越界会抛出java.lang.ArrayIndexOutOfBoundsException。</p><h3 id="5-容器能否完全替代数组？"><a href="#5-容器能否完全替代数组？" class="headerlink" title="5.容器能否完全替代数组？"></a>5.容器能否完全替代数组？</h3><p>针对数组类型，java提供了ArrayList容器类，C++STL中的vector。<br>拿java的ArrayList举例。ArrayList最大的优势就是可以将很多数组操作的细节封装起来，比如对数组的插入、删除操作。<br>另外就是支持动态扩容。数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间，如果申请的大小不够，就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。如果使用ArrayList，就不需要关心底层的扩容逻辑，ArrayList每次存储空间不够的时候，就会将空间自动扩容为1.5倍。需要注意的是，因为扩容操作涉及内存申请和数据搬移，是比较耗时的，所以如果事先能确定需要存储的数据大小，最好在创建ArrayList时事先指定大小。<br>1.java的ArrayList无法存储基本类型，涉及到拆装箱，会有一定性能消耗，涉及到技能或需要使用基本数据类型，选用数组。<br>2.如果数据大小事先已知，且对数据的操作简单，可以用数据。<br>3.多维数组表示时，数组更直观。Object[][] array和容器ArrayList<ArrayList> array。</ArrayList></p><h3 id="6-为什么数组要从0开始编号，而不是从1开始？"><a href="#6-为什么数组要从0开始编号，而不是从1开始？" class="headerlink" title="6.为什么数组要从0开始编号，而不是从1开始？"></a>6.为什么数组要从0开始编号，而不是从1开始？</h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”。<br>如果用a来表示数组的首地址，a[0]就是偏移为0的地址，也就是首地址，a[k]表示偏移了k个type_size的位置，所以a[k]的内存地址计算只需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure><p>如果，数组从1开始奇数，那计算a[k]的内存地址变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure><p>对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。</p><h3 id="7-二维数组元素的地址计算公式"><a href="#7-二维数组元素的地址计算公式" class="headerlink" title="7.二维数组元素的地址计算公式"></a>7.二维数组元素的地址计算公式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//行优先</span><br><span class="line">a[i][j] = a[0][0] + i * n * data_type_size + j * data_type_size</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——复杂度分析</title>
      <link href="/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是复杂度分析？"><a href="#什么是复杂度分析？" class="headerlink" title="什么是复杂度分析？"></a>什么是复杂度分析？</h3><p>1.数据结构和算法解决“如何让计算机更快时间、更省空间的解决问题”。<br>2.因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能。<br>3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。<br>4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</p><h3 id="为什么要进行复杂读分析？"><a href="#为什么要进行复杂读分析？" class="headerlink" title="为什么要进行复杂读分析？"></a>为什么要进行复杂读分析？</h3><p>1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。<br>2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。</p><h3 id="如何进行复杂度分析？"><a href="#如何进行复杂度分析？" class="headerlink" title="如何进行复杂度分析？"></a>如何进行复杂度分析？</h3><h4 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h4><p>1.来源<br>算法的执行时间与每行代码的执行次数成正比，用T（n）=O（f（n））表示，其中T（n）表示算法执行总时间，f（n）表示每行代码执行总次数，而n往往代表数据的规模。<br>2.特点<br>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时忽略这些项。</p><h4 id="复杂度分析法则"><a href="#复杂度分析法则" class="headerlink" title="复杂度分析法则"></a>复杂度分析法则</h4><p>1.单段代码看高频。比如循环。<br>2.多段代码取最大。比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3.嵌套代码求乘积。比如递归、多重循环等。<br>4.多个规模求加法。比如方法有两个参数（m、n）控制两个循环的次数，那么这时就取二者复杂度相加。</p><h3 id="常用的复杂度级别"><a href="#常用的复杂度级别" class="headerlink" title="常用的复杂度级别"></a>常用的复杂度级别</h3><h4 id="多项式阶"><a href="#多项式阶" class="headerlink" title="多项式阶"></a>多项式阶</h4><p>随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括：O（1）（常数阶）、O（logn）（对数阶）、O（n）（线性阶）、O（nlogn）（线性对数阶）、O（n^2）（平方阶）、O（n^3）（立方阶）。</p><h4 id="非多项式阶"><a href="#非多项式阶" class="headerlink" title="非多项式阶"></a>非多项式阶</h4><p>随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括O（2^n）（指数阶）、O（n！）（阶乘阶）。<br><img src="/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/fuzaduliangji.jpg" alt="复杂度量级"></p><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率和数据规模之间的增长关系。<br><img src="/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/on.jpg"></p><h3 id="复杂度分析的四个概念"><a href="#复杂度分析的四个概念" class="headerlink" title="复杂度分析的四个概念"></a>复杂度分析的四个概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// n 表示数组 array 的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码要实现的功能是，在一个无序的数组（array）中，查找变量x出现的位置。如果没有找到，就返回-1。这段代码的复杂度看上去的话是O（n）。</p><h4 id="最好情况时间复杂度"><a href="#最好情况时间复杂度" class="headerlink" title="最好情况时间复杂度"></a>最好情况时间复杂度</h4><p>代码在最理想情况下执行的时间复杂度。<br>在最理想的情况下，要查找的变量x正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。</p><h4 id="最坏情况时间复杂度"><a href="#最坏情况时间复杂度" class="headerlink" title="最坏情况时间复杂度"></a>最坏情况时间复杂度</h4><p>代码在最坏情况下执行的时间复杂度。<br>如果数组中没有要查找的变量x，需要把整个数组都遍历一遍。</p><h4 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h4><p>用代码在所有情况下执行的次数的加权平均值表示。<br>要查找的变量x，要么在数组中，要么就不在数组里，这两种情况对应的概率统计起来很麻烦，假设在数组中与不在数组中的概率都为1/2。另外，要查找的数据出现在0<del>n-1这n个位置的概率也是一样的，为1/n。所以根据概率乘法法则，要查找的数据出现在0</del>n-1中任意位置的概率就是1/（2n）。<br><img src="/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/pingjun.jpg"><br>这个值是概率论中的加权平均值，也叫做期望值，所以平均时间复杂度的全称应该叫做加权平均时间复杂度或者期望时间复杂度。<br>引入概率之后，前面那段代码的加权平均值为（3n+1）/4，用大O表示法来表示，去掉系数和常量，仍然为O（n）。</p><h4 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// array 表示一个长度为 n 的数组</span><br><span class="line">// 代码中的 array.length 就等于 n</span><br><span class="line">int[] array = new int[n];</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">   if (count == array.length) &#123;</span><br><span class="line">      int sum = 0;</span><br><span class="line">      for (int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[0] = sum;</span><br><span class="line">      count = 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现一个往数组中插入数据的功能。当数组满了之后，count==array.length时，我们用for循环遍历数组求和，并清空数组，将求和之后的sum值放到数组的第一个位置，然后将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。<br>时间复杂度最好为O（1），最坏为O（n），平均时间复杂度也是O（1）。<br>假设数组的长度是n，根据数据插入的位置不同，分为n种情况，每种情况的时间复杂度是O（1），另外在数组没有空闲空间时插入一个数据，这时是O（n），这n+1种情况发生的改率一样，都是1/（n+1）。<br><img src="/2019/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/pingjun2.jpg"></p><p>对于后面这个inset（）函数来说，O（1）和O（n）出现的频率是有规律的，而且有一定的前后时序关系，一般都是一个O（n）插入之后，紧跟着n-1个O（1）的插入操作，循环往复。<br>针对这种特殊场景，引入一种更加简单的分析方法：摊还分析法，通过摊还分析得到均摊时间复杂度。<br>均摊时间复杂度是一种特殊的平均时间复杂度。<br>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这时候，可以将这一组操作放在一块儿分析，将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度等于最好情况时间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑将在一分钟后重启</title>
      <link href="/2019/04/13/windows-%E7%94%B5%E8%84%91%E5%B0%86%E5%9C%A8%E4%B8%80%E5%88%86%E9%92%9F%E5%90%8E%E9%87%8D%E5%90%AF/"/>
      <url>/2019/04/13/windows-%E7%94%B5%E8%84%91%E5%B0%86%E5%9C%A8%E4%B8%80%E5%88%86%E9%92%9F%E5%90%8E%E9%87%8D%E5%90%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>针对win10 联想电脑，重启之后，在登录界面按SHIFT+重启</p><p>选择疑难解答</p><p>选择高级选项</p><p>选择启动设置</p><p>点击重启</p><p>F4进入安全模式</p><p>WIN+R进入CMD命令行</p><p>输入“netsh winsock reset”，成功后提示重启</p><p>重启电脑，就好了</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下迁移指定MySQL数据库至Linux</title>
      <link href="/2019/04/12/linux-Windows%E4%B8%8B%E8%BF%81%E7%A7%BB%E6%8C%87%E5%AE%9AMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%B3Linux/"/>
      <url>/2019/04/12/linux-Windows%E4%B8%8B%E8%BF%81%E7%A7%BB%E6%8C%87%E5%AE%9AMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%B3Linux/</url>
      
        <content type="html"><![CDATA[<p>在配置好阿里云服务器的javaweb环境后，发现mysql里面没有数据，才想到要把部署在Windows下的mysql数据库迁移到linux服务器中，且只迁移该项目的数据库。</p><p>本步骤基于cent os 7，使用的文件传输工具为FileZilla,数据库管理工具为Navicat for MySQL。迁移之前请确保两台主机已安装配置好MySQL数据库。</p><h3 id="使用sql脚本文件迁移"><a href="#使用sql脚本文件迁移" class="headerlink" title="使用sql脚本文件迁移"></a>使用sql脚本文件迁移</h3><h4 id="Windows（迁出数据库主机）"><a href="#Windows（迁出数据库主机）" class="headerlink" title="Windows（迁出数据库主机）"></a>Windows（迁出数据库主机）</h4><p>  1.打开Navicat，在项目所在数据库处，右键-&gt;转储SQL文件 </p><p>  2.导出sql文件成功 </p><h4 id="Linux（迁入数据库主机）"><a href="#Linux（迁入数据库主机）" class="headerlink" title="Linux（迁入数据库主机）"></a>Linux（迁入数据库主机）</h4><p>  1.打开FileZilla，登录，将导出的.sql文件上传到服务器指定的路径下（我是放在了/usr/java/mysql下）<br>  2.执行sql脚本文件<br>    mysql -u root -p 输入密码后进入mysql命令行<br>    create database 项目数据库名;<br>    use 项目数据库名;<br>    source 路径/XXX.sql<br>    执行成功，show tables;可以看到已经导入的表</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地Windows操作系统连接Linux实例（阿里云ECS）</title>
      <link href="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/"/>
      <url>/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>第一步：在本机上的java web首先要设计的差不多，localhost:8080可以访问</p><p>第二步：注册阿里云账号，租用阿里云服务器。由于我还是学生，花了9.9买了一个月的最低配云服务器ECS，服务器系统Linux CentOS7.3。</p><p>第三步：文件准备 jdk+tomcat+mysql（+redis）<br>提供链接：<a href="https://pan.baidu.com/s/1yrRfv17fq72OJsl2r94IjQ">https://pan.baidu.com/s/1yrRfv17fq72OJsl2r94IjQ</a><br>提取码：3bd8<br>文件上传工具：FileZilla<br>服务器连接工具：putty（可有可不有，相当于服务器实例的远程连接）</p><p>cd usr –&gt; mkdir java<br>为了便于文件的管理和区分，可以在/usr目录下新建/java文件夹，并创建/jdk、/tomcat、/mysql、/redis，将对应的压缩包上传到对应的文件夹下。<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.png"></p><p>第四步：安装JDK环境<br>cd /usr/java/jdk    ————进入jdk目录</p><p>tar -zxvf jdk-8u144-linux-x64.tar.gz  ————解压<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%AE%89%E8%A3%85jdk.png"></p><p>解压成功后，需要配置环境变量，在命令行输入 vi /etc/profile 然后回车，会有下图显示<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E9%85%8D%E7%BD%AEjava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8A.png"></p><p>这时，按键盘上的i键，此时可以编辑（命令框下方会有INSERT），这是vim编辑格式，在空白处插入一下字句，如下图<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E9%85%8D%E7%BD%AEjava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png"></p><p>输入完后，按ESC键退出编辑，输入：wq回车保存。</p><p>输入指令source /etc/profile，然后java -version 验证是否配置成功，验证是否配置成功。<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E9%AA%8C%E8%AF%81java%E7%89%88%E6%9C%AC.png"></p><p>出现 java version “1.8.0_144”便配置成功了。</p><p>第五步：安装tomcat<br>cd /usr/java/tomcat   ————进入tomcat目录</p><p>tar -zxvf apache-tomcat-版本号.tar.gz   ————解压</p><p>cd /usr/java/tomcat/apache-tomcat-版本号/bin  ————进入解压后tomcat文件夹</p><p>./startup.sh  ————开启tomcat，这样tomcat会自动配置环境变量，无需自己vim去添加环境变量<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%BC%80%E5%90%AFtomcat.png"></p><p>tomcat成功启动之后，打开浏览器输入公网IP:8080应该就可以访问到tomcat主页。如果出现无法访问、响应时间过长这样的信息，跟端口开放有关，我们在第八步之后处理。</p><p>第六步：安装mysql<br>cd /usr/java/mysql  ————进入mysql目录</p><p>rpm -Uvh mysql80-community-release-el7-2.noarch.rpm  ————安装rpm 回车之后 出现两个100%，如下图，成功安装<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%AE%89%E8%A3%85mysqlrpm.png"></p><p>yum install mysql-community-server  ————安装mysql服务<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%AE%89%E8%A3%85mysql.png"></p><p>service mysqld start  ————启动mysql服务<br>ps -ef | grep mysqld  ————查看mysql服务<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/mysql%E6%88%90%E5%8A%9F%E5%90%AF%E5%8A%A8.png"></p><p>grep ‘temporary password’ /var/log/mysqld.log  ————获取初始密码<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/msql%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81.png"></p><p>cd /usr/java/mysql  ————进入mysql目录<br>mysql -uroot -p     ————以root用户登录mysql，出现passowrd后输入上面的初始密码，密码输入不会显示<br>登录成功之后，输入ALTER语句更改密码，密码是大小写字母+数字+符号的组合才能通过<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E4%BF%AE%E6%94%B9mysql%E5%AF%86%E7%A0%81.png"></p><p>在root用户登录状态下，创建work用户并授权增删改查，因为root用户远程登录会有诸多问题，所以在这里创建一个work用户方便以后的操作，创建方法如下图，创建用户和授权操作要分开。<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%88%9B%E5%BB%BAwork%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E6%9D%83.png"></p><p>flush privileges;  —————刷新权限 配置生效</p><p>mysql -uwork -P3306 -h你的IP -p  ————通过work用户访问服务器，输入修改后的密码后就可以了<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E9%80%9A%E8%BF%87work%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p><p>第七步：安装redis<br>cd /usr/java/redis  ————进入redis目录<br>tar -zvxf redis-5.0.4.tar.gz  ————解压</p><p>cd /usr/java/redis/redis-5.0.4 ————进入解压后的redis目录<br>vi redis.conf  ————配置redis的一些属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#监听所有的IP地址（<span class="number">61</span>行）</span><br><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>注释掉为#bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">#设置为守护进程（<span class="number">128</span>行）</span><br><span class="line">daemonize no 改为 daemonize yes</span><br></pre></td></tr></table></figure><p>ESC :wq保存之后，输入make并回车，安装redis<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%AE%89%E8%A3%85redis.png"></p><p>输入下图指令，启动redis服务并连接测试<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%90%AF%E5%8A%A8redis%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95.png"></p><p>第八步：项目上传<br>将自己的javaweb项目export出一个.war文件，将这个.war文件上传至服务器的tomcat的webapps下<br>在tomcat启动情况下 ./startup.sh，会自动将（项目.war）解析成（项目）<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0.png"></p><p>全部部署成功，打开浏览器，输入公网IP<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%85%AC%E7%BD%91IP.png"></p><p>输入公网IP/项目路径<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%85%AC%E7%BD%91IP2.png"></p><p>会出现的问题：<br>tomcat默认端口为8080，http支持的端口是80，如果要跟微信测试号连接的话，微信测试号支持的端口是80，所以要将tomcat下的server.xml中的port：8080改成port：80<br>在阿里云服务器的实例中，需要配置安全组，添加端口信息，表示开放这些端口。<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/%E5%AE%89%E5%85%A8%E7%BB%84.png"></p><p>我遇到的问题是：安全组开放了80端口和8080端口，结果在浏览器访问IP：80和IP：8080都是无法访问的情况；在将安全组中的端口改成上图情况，也就是取消了8080端口后，都可以成功访问，也就是第八步图中的样子，只是这是都不需要输入端口号了。<br>如果碰到访问不了的情况，多半是安全组问题，以及去tomcat下的server.xml文件中的配置信息。<br>至于firewall和iptables，防火墙与端口的问题，应该不是很重要，因为我都配置过，结果并没有什么卵用…</p><p>附一个本地命令行测试连接成功与否的方法 win+R ——&gt; telnet 公网ip 80<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/telnet%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5.png" alt="如图为连接失败，端口80未开放"></p><p>成功的话，会进入下图这样的命令框<br><img src="/2019/04/08/linux-%E6%9C%AC%E5%9C%B0Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5Linux%E5%AE%9E%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91ECS%EF%BC%89/telnet%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.png"></p><p>另外一个问题：如果页面能够访问了，也就是tomcat连接没有问题了，但是数据库mysql中的数据显示不出来，只有html或者jsp中的标签布局可以显示，这时要注意两个问题————<br>  一：本地mysql中的项目所用到的数据库没有上传到服务器mysql中，导致服务器中mysql里没有所创建的那些表，也就查不到数据。<br>  详见另一篇博文：windows下迁移指定mysql数据库至linux</p><p>  二：服务器mysql版本与JDBC连接所需要的mysql-connection-java jar版本是不是一致，一致才能够连接到。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blue Butterfly</title>
      <link href="/2019/04/04/%E9%9A%8F%E7%AC%94-Blue-Butterfly/"/>
      <url>/2019/04/04/%E9%9A%8F%E7%AC%94-Blue-Butterfly/</url>
      
        <content type="html"><![CDATA[<p>我在清晨醒来的时候流泪<br>一只蓝色蝴蝶经过我深深的梦里<br>我的梦里</p><p>我闭上眼睛回想她的来过<br>她会一直都在<br>是我这单薄的一生如此真切的渴望</p><p>可我要怎么去知道，我不知道<br>也许只是偶然的造访<br>回忆才是她真实存在的地方</p><p>蝴蝶记忆很短<br>爱上一朵花后六秒就忘记<br>如果我有一万亩玫瑰和一点星光<br>就对她说：留下来吧</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—排序总结</title>
      <link href="/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>1.冒泡排序<br>算法描述：将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序（即L.r[1].key&gt;L.r[2].key），则将两个记录交换之，然后比较第二个记录和第三个记录。依次类推，直到第n-1个记录和第n个记录的关键字进行过比较为止，此过程称为第一趟起泡排序，其结果使得关键字最大的记录被安置到最后一个记录的位置上。最坏情况，初始序列为“逆序”，需进行n-1趟排序，进行n(n-1)/2次比较，并做等数量级的记录移动，时间复杂度为O(n的平方)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)  <span class="comment">//外层循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;length-i;j++) <span class="comment">//内层循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j-<span class="number">1</span>]&gt;a[j]) <span class="comment">//前者大于后者 交换之</span></span><br><span class="line">&#123;</span><br><span class="line">temp=a[j];</span><br><span class="line">a[j]=a[j-<span class="number">1</span>];</span><br><span class="line">a[j-<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> length)</span>  <span class="comment">//优化的冒泡排序</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果有500个数值的数组，前100个无序，后400个有序，该方法对于后400个数据只需要比较一次，</span></span></span><br><span class="line"><span class="function"><span class="comment">//便记录下这个标识然后设置尾边界，以后的99次不会与后面400个数据比较 节省时间。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j,k;</span><br><span class="line"><span class="keyword">int</span> flag=length; <span class="comment">//flag来记录最后交换的位置 也就是排序的尾边界</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(flag&gt;<span class="number">0</span>) <span class="comment">//flag&gt;0的话说明排序未结束</span></span><br><span class="line">&#123;</span><br><span class="line">k=flag;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j-<span class="number">1</span>]&gt;a[j])  <span class="comment">//交换</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp=a[j];</span><br><span class="line">a[j]=a[j-<span class="number">1</span>];</span><br><span class="line">a[j-<span class="number">1</span>]=temp;</span><br><span class="line"></span><br><span class="line">flag=j; <span class="comment">//表示交换过数据 记录尾边界</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.快速排序<br>快速排序是对冒泡排序的一种改进。它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br>一趟快速排序的具体做法是：附设两个指针low和high，它们的初值分别为low和high，设枢轴记录的关键字为pivotkey，则首先从high所指位置起向前搜索找到第一个关键字小于pivotkey的记录和枢轴记录互相交换，然后从low所指位置起向后搜索，找到第一个关键字大于pivotkey的记录和枢轴记录互相交换，重复这两步直至low=high为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> first, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i=first;</span><br><span class="line">         <span class="keyword">int</span> j=end;</span><br><span class="line">         <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">             <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;  <span class="comment">//右侧扫描</span></span><br><span class="line">                 j--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(i &lt; j) &#123;  <span class="comment">//将较小记录交换到前面</span></span><br><span class="line">                 <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                 a[i] = a[j];</span><br><span class="line">                 a[j] = temp;</span><br><span class="line">                 <span class="comment">//i++;</span></span><br><span class="line">             &#125; </span><br><span class="line">             <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123; <span class="comment">//左侧扫描</span></span><br><span class="line">                 i++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(i &lt; j) &#123; <span class="comment">//将较大记录交换到后面</span></span><br><span class="line">                 <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                 a[i] = a[j];</span><br><span class="line">                 a[j] = temp;</span><br><span class="line">                 <span class="comment">//j--;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> pivot;</span><br><span class="line">         <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">             pivot = partition(a, low, high);</span><br><span class="line">             quickSort(a, low, pivot-<span class="number">1</span>);</span><br><span class="line">             quickSort(a, pivot+<span class="number">1</span>, high);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>3.选择排序——简单选择排序<br>算法描述：对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录与第一个记录的位置进行交换，接着对不包括第一个记录以外的其他记录进行第二轮比较，得到最小的记录并与第二个记录进行位置交换，重复该过程，直到进行比较的记录只有一个时为止。<br>选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 平均O(n^2),最好O(n^2),最坏O(n^2);空间复杂度O(1);不稳定;简单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="comment">// 找出最小值的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[k]) &#123;</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将最小值放到未排序记录的第一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                arr[k] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123; <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        selectionSort(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : b)</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.插入排序<br>将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一致有序。重复这个过程，直到未排序区间中元素为空，算法结束。<br><img src="/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/charupaixu.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a表示数组 n表示数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> value = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//查找插入的位置</span></span><br><span class="line">        <span class="keyword">for</span>(;j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; value)&#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j]; <span class="comment">//数据移动</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j+<span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.选择排序——堆排序</p><p>6.希尔排序</p><p>7.归并排序<br>思想：要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br><img src="/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/guibingpaixu.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归并排序算法, a是数组，n表示数组大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    mergeSortInternally(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值</span></span><br><span class="line">    <span class="keyword">int</span> q = p + (r - p)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 分治递归</span></span><br><span class="line">    mergeSortInternally(a, p, q);</span><br><span class="line">    mergeSortInternally(a, q+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">    merge(a, p, q, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = p;</span><br><span class="line">    <span class="keyword">int</span> j = q+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 初始化变量i, j, k</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>]; <span class="comment">// 申请一个大小跟a[p...r]一样的临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">        tmp[k++] = a[i++]; <span class="comment">// i++等于i:=i+1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">    <span class="keyword">int</span> start = i;</span><br><span class="line">    <span class="keyword">int</span> end = q;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">      start = j;</span><br><span class="line">      end = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">      tmp[k++] = a[start++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将tmp中的数组拷贝回a[p...r]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) &#123;</span><br><span class="line">      a[p+i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.基数排序</p><p><img src="/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93.jpg" alt="复杂度总结"></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java实例化一个类时栈和堆中发生了什么</title>
      <link href="/2019/03/30/java%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%97%B6%E6%A0%88%E5%92%8C%E5%A0%86%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2019/03/30/java%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%97%B6%E6%A0%88%E5%92%8C%E5%A0%86%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>首先说一下关于引用类型变量的声明和使用<br>&emsp;&emsp;（1）把类名当作是一种类型来声明变量，这种变量叫引用类型变量。如：A a;<br>&emsp;&emsp;（2）引用类型变量保存对象的“引用”，即对象的地址。（对象是类的实例化）<br>&emsp;&emsp;（3）对象的创建 new 类名(),如：new A();<br>&emsp;&emsp;（4）new创建对象后返回对象的引用，对象没有名字，只能通过使用对象的引用间接使用对象，引用类型变量就是专门用来保存对象引用的，也就是保存对象的地址，是对象在堆内存中的地址。如：A a = new A();<br>&emsp;&emsp;（5）成员变量的默认值：数据类型成员变量(byte、short、int、long)默认值为0，字符型(char)的默认值是/u0000(unicode编码集编号为0的字符)，浮点型(double、float)默认值为0.0，boolean型成员变量默认值为false，引用类型成员变量默认值为null。<br>&emsp;&emsp;（6）对象内存分配。对象是被保存在堆中的，对象没有名字。对象中保存的是对象的成员变量，（成员变量定义在类中，方法体之外，是对象的特有属性，只能被对象调用，存储在堆内存的对象中）。没有引用类型变量保存对象的引用时，没有栈中的变量指向堆中的对象，对象被认为是垃圾，会被jvm的垃圾回收机制销毁。<br>&emsp;&emsp;（7）使用对象的引用来访问对象的成员变量和成员方法，都是使用“.”，成员变量和成员方法统称为成员。<br>创建对象后直接访问成员，随之对象就会被销毁，这种对象称之为匿名对象，如：new People().name=”老王”;<br>创建对象后返回的引用被引用类型变量保存（对象在堆内存中的地址被引用类型变量保存），使用“引用类型变量.成员”，如：PeoPle laoWang=new People(); laoWang.name=”老王”;</p><p>JAVA中的堆和栈<br>&emsp;&emsp;java把内存划分成两种：一种是栈内存，一种是堆内存。<br>&emsp;&emsp;在函数中定义的一些基本类型的变量和对象的引用变量都在栈内存中分配。<br>&emsp;&emsp;当在一段代码块定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后(作用域就是被一对花括号{}括起来的区域，与栈帧有关)，java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。<br>&emsp;&emsp;堆内存用来存放由new创建的对象和数组。<br>&emsp;&emsp;在堆中分配的内存，由java虚拟机的自动垃圾回收器来管理。<br>&emsp;&emsp;在堆中产生一个数组或对象后，栈中有一个与之相对应的变量，这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就是数组或对象的引用变量。栈中的引用变量指向堆内存中的数组或对象（其实就是C语言中的指针，只不过java中没有指针。）。<br>&emsp;&emsp;引用变量就是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。<br>&emsp;&emsp;引用变量定义时在栈中分配内存，在程序运行到作用域外释放。而数组&amp;对象本身在堆中分配内存，即使程序运行到使用new产生数组和对象的语句所在的代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象只有在没有引用变量指向它的时候，才变成垃圾，不能在被使用，但是仍然占用着内存，在随后的一个不确定的时间被jvm的垃圾回收机制——垃圾回收器释放掉。</p><p>实例化对象过程<br>在下面的这段代码中，java实例化一个类时在堆和栈中保存了那些数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    A a=<span class="keyword">new</span> A();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/30/java%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%97%B6%E6%A0%88%E5%92%8C%E5%A0%86%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1.jpg" alt="如图示"><br>1.加载class文件到class内容区域，加载静态方法和静态变量到静态区（同时加载）。<br>2.调用main方法到栈内存。<br>3.在栈内存中为a变量（A对象的引用）开辟空间。<br>4.在堆内存为A对象申请空间。<br>5.给成员变量进行默认初始化（此时 i=0），同时有一个方法标记，在方法区中创建一个A的方法区，将A的方法区的地址0x01给方法标记 ？？？<br>6.给成员变量进行显示初始化（此时 i=1）？？？<br>7.将A对象的地址值给变量a，栈中的a保存的是对象A的地址。<br>所以A a=new A();栈中保存了A对象的引用，即变量a，堆中保存了A对象。</p><p>栈、堆、方法区<br>1.栈（stack）<br>每个线程包含一个栈区，栈中只保存基础数据类型（byte、short、int、long、float、double、boolean、char）的对象和自定义对象的引用。每个栈中的数据（原始类型和对象引用）都是私有的，其他栈不能访问。<br>2.堆（heap）<br>堆提供所有类实例（对象）和数组对象存储区域。jvm只有一个堆区（heap），被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。<br>堆内存用来存放new创建的对象和数组，即动态申请的内存都存放在堆内存。<br>3.方法区<br>又叫静态区，跟堆一样，被所有线程共享。方法区包含所有的class（成员变量）和static（静态变量，又叫类变量，由static修饰）变量。方法区中包含的是在整个程序中永远唯一的元素。运行时常量池都分配的jvm的方法区之中。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于java中float和double的一些问题</title>
      <link href="/2019/03/23/java%E5%9F%BA%E7%A1%80-%E5%85%B3%E4%BA%8Ejava%E4%B8%ADfloat%E5%92%8Cdouble%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/23/java%E5%9F%BA%E7%A1%80-%E5%85%B3%E4%BA%8Ejava%E4%B8%ADfloat%E5%92%8Cdouble%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在java中运行一下代码</p><p>System.out.println(2.00-1.10);<br>输出的结果是：0.8999999999999999<br>很奇怪，并不是我们想要的值0.9</p><p>再运行如下代码：<br>System.out.println(2.00f-1.10f);<br>输出结果：0.9</p><p>又正确了，为什么会导致这种问题？程序中为什么要尽量避免浮点数比较？<br>以及在涉及金钱、金融相关时，要用BigDecimal提供的方法。</p><p>java中浮点数据类型包括float和double，float为四个字节，double为八个字节。<br>那，在计算机的内存中，float和double是怎么表示和存储的呢？<br><img src="/2019/03/23/java%E5%9F%BA%E7%A1%80-%E5%85%B3%E4%BA%8Ejava%E4%B8%ADfloat%E5%92%8Cdouble%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/img1.png" alt="在内存中的存储结构"></p><p>关于浮点数的运算，浮点数的规格化还没来得及复习整理。</p><p>System.out.println(2.00-1.10);中的1.10不能被计算机精确存储，以double类型数据1.10举例计算机如何将浮点型数据转换成二进制存储，<br>这里重点讲小数部分转换成二进制：<br>1.10整数部分就是1，转换成二进制1（这里整数转二进制不再赘述，整数部分除2取余，小数部分乘2取整）<br>小数部分：0.1<br>0.1×2=0.2取整数部分0，基数=0.2<br>0.2×2=0.4取整数部分0，基数=0.4<br>0.4×2=0.8取整数部分0，基数=0.8<br>0.8×2=1.6取整数部分1，基数=1.6-1=0.6<br>0.6×2=1.2取整数部分1，基数=1.2-1=0.2<br>0.2×2=0.4取整数部分0，基数=0.4<br>.<br>.<br>.<br>.<br>直至基数为0。1.1用二进制表示为：1.000110…xxxx….(后面表示省略)<br>0.1 = 0<em>2^(-1)+0</em>2^(-2)+0<em>2^(-3)+1</em>2^(-4)+………而double类型表示小数部分只有52位，当向后计算 52位后基数还不为0，那后面的部分只能舍弃，从这里可以看出float、double并不能准确表示每一位小数，对于有的小数只能无限趋向它。在计算机 中加减成除运算实际上最后都要在计算机中转换成二进制的加运算，由此，当计算机运行System.out.println(2.00-1.10);<br>时会拿他们在计算机内存中的二进制表示计算，而1.10的二进制表示本身就不准确，所以会出现0.8999999999999999的结果。</p><p>但为什么System.out.println(2.00f-1.10f);得出的结果是0.9呢。<br>因为float精度没有double精度那么大，小数部分0.1二进制表示被舍去的比较多。</p><p>注意：<br>程序中应尽量避免浮点数的比较<br>float、double类型的运算往往都不准确</p><p>解决方法：<br>使用BigDecimal提供的方法进行比较或运算，但要注意在构造BigDecimal的时候使用float、double的字符串形式构建，BigDecimal(String val)；为什么不用BigDecimal(double val)API里写的比较清楚。</p><p>运算以减法为例：<br>BigDecimal b1 = new BigDecimal(Double.toString(2.00));<br>BigDecimal b2 = new BigDecimal(Double.toString(1.10));<br>double result = b1.subtract(b2).doubleValue();</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java为什么可以跨平台</title>
      <link href="/2019/03/23/java%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
      <url>/2019/03/23/java%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E8%B7%A8%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p>java语言特性<br>&emsp;&emsp;面向对象（封装、继承、多态）<br>&emsp;&emsp;半编译半解释<br>&emsp;&emsp;跨平台性</p><p>“平台”是CPU处理器和操作系统的整体。又因为现在的主流操作系统(windows、liunx、unix)都支持主流的CPU，因此有时把操作系统称为平台。</p><p>因为java是半编译半解释的语言。java代码不是直接运行在CPU上的，是在虚拟机上运行的。我们开发设计好的程序(.java)首先经过编译器(Compiler)编译成为.class文件(字节码文件)，.class文件经过JVM(java虚拟机)解释成为目标操作系统可以识别并执行的机器代码(01指令)。每个操作系统有它自己对应的虚拟机。</p><p>C语言&amp;java</p><p>C语言是编译执行的，编译器与平台相关，编译生成的可执行文件与平台相关；java是解释执行的，编译.java为.class中间码的编译器与平台无关，编译生成的中间码也与平台无关，中间码由解释器解释执行，解释器是与平台相关的，不同的平台需要不同的解释器。</p><p>语言执行方式：编译执行，解释执行，半编译半解释。</p><p>C语言，编译执行，执行速度快，无法跨平台；java，半编译半解释，执行速度慢，可以跨平台。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于爱情的解释</title>
      <link href="/2019/03/17/%E9%9A%8F%E7%AC%94-%E5%85%B3%E4%BA%8E%E7%88%B1%E6%83%85%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2019/03/17/%E9%9A%8F%E7%AC%94-%E5%85%B3%E4%BA%8E%E7%88%B1%E6%83%85%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p><a href="https://music.163.com/#/song?id=1315718569">有一种悲伤-A-Lin</a></p><p>————“要是爱情可以解释得清楚的话，这世界上就不会有这么多人因此而痛苦了。”</p><p>那天 我在茫茫人海中<br>独独发现了你<br>然后在我漫长的夜晚里<br>有了唯一动人的星星</p><p>要是爱情可以解释<br>我那时还不会那么快乐<br>和你有关的一切<br>比快乐还要快乐</p><p>如今 我把你好好地<br>还回人海里<br>然后我一个人的生活里<br>常常做梦梦见一个人</p><p>要是爱情可以解释<br>我现在就不会这么悲伤<br>和你有关的一切<br>比悲伤还要悲伤</p><p>你是我的爱情<br>你只是不是我的爱人<br>和你有关的一切<br>开始很快乐<br>后来就悲伤起来</p><p>你像极了爱情<br>像极了我要爱的人<br>关于爱情唯一的解释<br>无非就是一个你而已</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情书</title>
      <link href="/2019/02/14/%E6%83%85%E4%B9%A6/"/>
      <url>/2019/02/14/%E6%83%85%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p>你好哇，亲爱的我的爱人：<br>&emsp;&emsp;Hello，world：你好哇，我的爱人——我的世界。<br>&emsp;&emsp;因为程序员打出来的第一行代码是：“hello，world！”，所以写给你的第一封信这样来开头的话，好像，你就是我的世界了。<br>&emsp;&emsp;也是因为第一句话其实是极难的，无论是说的，还是写的。当一个少不经事的男孩子怀着激动的心情紧张地打下一行“嗨喽，你好哇！”发给那个极好的女孩子时，他总算向她和美好靠近了一步，然后他又焦急而慌张地等待她的回复，每一秒等待他都清晰地感觉到自己的心和身体在打颤，终于没有多久她稳重大方地回了一句“你好”，他的灵魂此刻在幸福的打颤，他们之间是要发生一些什么的。<br>&emsp;&emsp;所以在这里的话，写的第一句，可以说是我取巧了，取巧在我的专业，取巧在我隐藏起我的慌张和无措，以及故作模样的仪式感。<br>&emsp;&emsp;当我要谈一谈我们两个人的时候，我总要先说说我，再把目光投向你，这是一个自我剖析过去然后拉回你所在的现实的过程，最后让我说说关于我们——有关于未来。<br>&emsp;&emsp;98年的我都不敢信过完年我就虚岁22了，二十载荒唐，养成了一身的欲望，在所有的喜怒忧思悲恐惊中我最爱你，在所有的眼耳鼻舌身意的愿望中我最想要你。尤其静夜，我的情欲大，纷纷飘下，在我写下这些字的此刻。因为我的爱人，你还尚未到来，我实在不宜用太大的篇幅去讲我，怕你害怕，我也实在不愿向你隐瞒，等你来的那一天，我将一切都说与你，好的坏的都是关于我的。<br>&emsp;&emsp;在冬天刚到的时候，我说，“我干涸的心想要一场夏天，夏天太远，冬至已至，一场隆冬的雪亦能解渴。”<br>&emsp;&emsp;我已经渴望了太久。<br>&emsp;&emsp;这个冬天的雪没有那么大，这个冬天也快要走远了，我的孤独和花园已经枯萎了太久，在转瞬就至的春天和盼望已久的夏天里，你挑一个日子来吧，因为秋天是一个适合谈恋爱的季节，是一个浪漫的季节，我应该为你温柔；你若不来，“自古逢秋悲寂寥”，我一生都为你寂寥。<br>&emsp;&emsp;你也许不会相信，我常常想象你是多么美好，多么可爱，但实际见你面的时候，我相信，你比我想象的要美好得多，可爱得多。你不能说我这是说谎，因为如果不然的话，我当然可以仅仅靠想你就满足，而不必那样渴望着想见到你，我是如此羡慕那些与你想见面就能见面的人。<br>&emsp;&emsp;你不知道，我这颗心已经厌世嫉俗惯了，每一个惨淡晦暗的清晨都觉得快要不行了，坚持不住了，可是啊，看着你笑的照片，听听你的声音，就觉得，时事维艰也不过如此。<br>&emsp;&emsp;你知道吗，我好想看见你的笑容啊。就是在那种难捱的日子里，你会笑的眼睛里氤氲着的光，注视着我，驱散我深渊一样的心深处最顽固的黑暗。你做我的蚩梦吧，你永远年轻，永远热泪盈眶。你饱含着的热情，我靠近一分，就消散一分我长久以来攒了满身的沮丧。即便我仍是沮丧，我却有充足的气力去做事。<br>&emsp;&emsp;这封情书请你一定要收下。你要相信，先有情，才有话，才有诗，才有书。我这决不是在忽悠你。</p><p>一个不知所谓的臭男生</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Markdown</title>
      <link href="/2019/01/18/markdown-%E5%85%B3%E4%BA%8EMarkdown%E8%AF%AD%E8%A8%80/"/>
      <url>/2019/01/18/markdown-%E5%85%B3%E4%BA%8EMarkdown%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown是一种轻量级的「标记语言」</strong><span id="more"></span></p><p><img src="https://www.mdeditor.com/images/logos/markdown.png" alt="markdown" title="markdown"></p><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p><h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><h6 id="标题H5-1"><a href="#标题H5-1" class="headerlink" title="标题H5"></a>标题H5</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr><p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s></p><p><em>斜体字</em>      <em>斜体字</em></p><p><strong>粗体</strong>  <strong>粗体</strong></p><p><em><strong>粗斜体</strong></em> <em><strong>粗斜体</strong></em></p><p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p><p><strong>缩写(同HTML的abbr标签)</strong></p><blockquote><p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p></blockquote><p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p><h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><blockquote><p>引用文本 Blockquotes</p></blockquote><p>引用的行内混合 Blockquotes</p><blockquote><p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/">普通链接</a>。</p></blockquote><h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><p><a href="https://www.mdeditor.com/">普通链接</a><br><a href="https://www.mdeditor.com/" title="普通链接带标题">普通链接带标题</a><br>直接链接：<a href="https://www.mdeditor.com/">https://www.mdeditor.com</a><br>[锚点链接][anchor-id]<br>[anchor-id]: <a href="https://www.mdeditor.com/">https://www.mdeditor.com/</a><br><a href="mailto:test.test@gmail.com">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 <a href="mailto:&#116;&#x65;&#x73;&#x74;&#x2e;&#116;&#x65;&#115;&#x74;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;">&#116;&#x65;&#x73;&#x74;&#x2e;&#116;&#x65;&#115;&#x74;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;</a>  <a href="mailto:&#119;&#119;&#119;&#64;&#118;&#105;&#x70;&#46;&#x71;&#x71;&#46;&#x63;&#111;&#109;">&#119;&#119;&#119;&#64;&#118;&#105;&#x70;&#46;&#x71;&#x71;&#46;&#x63;&#111;&#109;</a></p><blockquote><p>@pandao</p></blockquote><h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><p>执行命令：<code>npm install marked</code></p><h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p><pre><code>&lt;?php    echo &quot;Hello world!&quot;;?&gt;</code></pre><p>预格式化文本：</p><pre><code>| First Header  | Second Header || ------------- | ------------- || Content Cell  | Content Cell  || Content Cell  | Content Cell  |</code></pre><h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HTML-代码-HTML-codes"><a href="#HTML-代码-HTML-codes" class="headerlink" title="HTML 代码 HTML codes"></a>HTML 代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Editor.md, Markdown, Editor&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#444</span>;<span class="attribute">font-family</span>: <span class="string">&quot;Microsoft Yahei&quot;</span>, Tahoma, <span class="string">&quot;Hiragino Sans GB&quot;</span>, Arial;<span class="attribute">background</span>:<span class="number">#fff</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style</span>: none;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none;<span class="attribute">vertical-align</span>: middle;&#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-xxl&quot;</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-green&quot;</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>图片加链接 (Image + Link)：</p><p><a href="https://www.mdeditor.com/images/logos/markdown.png" title="markdown"><img src="https://www.mdeditor.com/images/logos/markdown.png"></a></p><blockquote><p>Follow your heart.</p></blockquote><hr><h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul><li>列表一</li><li>列表二<ul><li>列表二-1</li><li>列表二-2</li><li>列表二-3</li></ul></li><li>列表三<ul><li>列表一</li><li>列表二</li><li>列表三</li></ul></li></ul><h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol><li>第一行</li><li>第二行</li><li>第三行</li></ol><h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul><li><input checked disabled type="checkbox"> GFM task list 1</li><li><input checked disabled type="checkbox"> GFM task list 2</li><li><input disabled type="checkbox"> GFM task list 3<ul><li><input disabled type="checkbox"> GFM task list 3-1</li><li><input disabled type="checkbox"> GFM task list 3-2</li><li><input disabled type="checkbox"> GFM task list 3-3</li></ul></li><li><input disabled type="checkbox"> GFM task list 4<ul><li><input disabled type="checkbox"> GFM task list 4-1</li><li><input disabled type="checkbox"> GFM task list 4-2</li></ul></li></ul><hr><h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table><thead><tr><th>项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>Function name</th><th>Description</th></tr></thead><tbody><tr><td><code>help()</code></td><td>Display the help window.</td></tr><tr><td><code>destroy()</code></td><td><strong>Destroy your computer!</strong></td></tr></tbody></table><table><thead><tr><th align="left">Left-Aligned</th><th align="center">Center Aligned</th><th align="right">Right Aligned</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="center">some wordy text</td><td align="right">$1600</td></tr><tr><td align="left">col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><table><thead><tr><th>Item</th><th align="right">Value</th></tr></thead><tbody><tr><td>Computer</td><td align="right">$1600</td></tr><tr><td>Phone</td><td align="right">$12</td></tr><tr><td>Pipe</td><td align="right">$1</td></tr></tbody></table><hr><h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><p>&copy; &amp;  &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p><p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p><p>18&ordm;C  &quot;  &apos;</p><p>[========]</p><h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote><p>Blockquotes :star:</p></blockquote><h4 id="GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul><li><input checked disabled type="checkbox"> :smiley: @mentions, :smiley: #refs, <a href>links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li><li><input checked disabled type="checkbox"> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li><li><input checked disabled type="checkbox"> [ ] :smiley: this is a complete item :smiley:;</li><li><input disabled type="checkbox"> []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li><li><input disabled type="checkbox"> [ ]this is an incomplete item :fa-star: :fa-gear:;<ul><li><input disabled type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li><li><input disabled type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li></ul></li></ul><h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p><p>[========]</p><h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E=mc^2$$</p><p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p><p>$$x &gt; y$$</p><p>$$(\sqrt{3x-1}+(1+x)^2)$$</p><p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p><p>多行公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) = \int_&#123;-\infty&#125;^\infty</span><br><span class="line">    \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125;</span><br><span class="line">    \,d\xi</span><br></pre></td></tr></table></figure><h3 id="分页符-Page-break"><a href="#分页符-Page-break" class="headerlink" title="分页符 Page break"></a>分页符 Page break</h3><blockquote><p>Print Test: Ctrl + P</p></blockquote><p>[========]</p><h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 用户登陆</span><br><span class="line">op=&gt;operation: 登陆操作</span><br><span class="line">cond=&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e=&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>[========]</p><h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>who on the moon</title>
      <link href="/2019/01/16/%E9%9A%8F%E7%AC%94-who-on-the-moon/"/>
      <url>/2019/01/16/%E9%9A%8F%E7%AC%94-who-on-the-moon/</url>
      
        <content type="html"><![CDATA[<p><a href="https://music.163.com/#/song?id=1315718569">月球上的人</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这首歌讲的是男主角把自己置身于月球，作为一个月球上的人来重新审视自己曾经的一段感情。</span><br><span class="line">众所周知，用月球的角度是因为从月球所看到的地球上的事物都是过去的，光的传播需要时间，</span><br><span class="line">时过境迁后才后悔自己当初太不会相爱的本领，真想忘记自己正身处的未来去重新爱一次。</span><br></pre></td></tr></table></figure><p>网易云热评上，这样说。</p><p>关于明月，我还听说过</p><blockquote><p>最冷的日子<br>我把自己披在身上取暖<br>星空浩瀚<br>明月是明月的前身<br>你是虚构的<br>只能在虚构里爱你<br>世界需要燃烧也需要灰烬<br>我才长出一颗心           </p></blockquote><p>“明月是明月的前身”，月亮和地球的距离随时间而改变，大约为三十八万千米，因为人的眼睛接收到的是光，以光速约要1.28秒到达你的眼睛，所以你所看到的月亮事实上是1.28秒之前的月亮。</p><blockquote><p>你承诺过的月亮<br>还是没有出现<br>而我无眠，或者<br>我只是衣单天寒地<br>替你多爱了一夜人间</p></blockquote><p>可是，我等的月亮，还，没有出现。</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最冷一天</title>
      <link href="/2019/01/01/%E9%9A%8F%E7%AC%94-%E6%9C%80%E5%86%B7%E4%B8%80%E5%A4%A9/"/>
      <url>/2019/01/01/%E9%9A%8F%E7%AC%94-%E6%9C%80%E5%86%B7%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://music.163.com/#/song?id=187786">最冷一天</a></p><p>我想有一只小猫<br>最冷的时候<br>我把她抱在怀里取暖</p><p>每一个早晨<br>或明晰或晦暗的早晨<br>我还没睁开眼睛，就<br>睡意朦胧地伸出手臂<br>揽过睡在我右侧柔软的猫</p><p>我用力地抱着她，抱紧她<br>我心里有个声音：我什么也不要了<br>我再不要什么了<br>这荒唐的人间你们去爱吧<br>我好好儿爱她</p><p>我总要吻过她才有饱满的气力去做一天的事<br>她还睡着，她总要轻声哼一句<br>我的心简直要化了</p><p>我回家照例是要带她最爱吃的和<br>一支玫瑰花<br>夏天的话还要为她挑一件碎花裙<br>今生种花，来世漂亮<br>她无论何时都可以说得上是漂亮非常了</p><p>另外呢，春天我送她春风<br>夏天给她撑阳伞，秋天为她扫落叶<br>冬天，就给她下一场隆隆的大雪<br>风花雪月的故事里，她是我的<br>那一轮月亮，永恒的<br>月亮</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一朵百合</title>
      <link href="/2018/06/03/%E9%9A%8F%E7%AC%94-%E4%B8%80%E6%9C%B5%E7%99%BE%E5%90%88/"/>
      <url>/2018/06/03/%E9%9A%8F%E7%AC%94-%E4%B8%80%E6%9C%B5%E7%99%BE%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>一朵清澈的百合<br>生长在右侧隔着的银河</p><p>二十一日风来了<br>她在月光下睡着</p><p>听清她湿润的呓语<br>带我去另一个时空造爱飞行</p><p>扶风上升的她<br>撞进我比尘轻<br>比蚁微渺的生命</p><p>她一开口<br>人间就是了</p><p>滞空温柔的间隙<br>加速度停顿认真感应</p><p>她发出一声叹息<br>太古里的叹息</p><p>今夜四海八荒宁静下来<br>第二天纷纷飘下我纷纷的情欲</p><p>一朵清澈的百合<br>生长在清丽的风尘里</p><p>四月里醒来<br>一双眼睛装下一个生平</p><p>她没有说话<br>没有回答</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想来情应尽矣</title>
      <link href="/2018/04/12/%E8%AF%8D-%E6%83%B3%E6%9D%A5%E6%83%85%E5%BA%94%E5%B0%BD%E7%9F%A3/"/>
      <url>/2018/04/12/%E8%AF%8D-%E6%83%B3%E6%9D%A5%E6%83%85%E5%BA%94%E5%B0%BD%E7%9F%A3/</url>
      
        <content type="html"><![CDATA[<p>2018-04-12<br>忆秦娥<br>&emsp;&emsp;清明诀，清明冰雨彻长夜。彻长夜，从此无心，任它明月。<br>&emsp;&emsp;泰安驿里东风冽，大梦归断重城阙。重城阙，前尘隔海，青山阔别。</p><p>2016-11-26<br>&emsp;&emsp;料应情尽矣。万般景、象天法地，都不如意。疑慢贪嗔痴折煞，解语参差是命。风满后、佳木也寂。欺山赶海践雪径，已枉然、此恨无人记。都付与，短长句。<br>&emsp;&emsp;心知此后来无计。便结了、缘浅路陌，旧时知己。还似初识还不似，彻夜后还难静。休顾他、恁多言语。自有造化双鱼腹，果与因、皆系锦书里。是问情，怎生起。</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我想在你的怀中失去记忆</title>
      <link href="/2018/02/21/%E9%9A%8F%E7%AC%94-%E6%88%91%E6%83%B3%E5%9C%A8%E4%BD%A0%E7%9A%84%E6%80%80%E4%B8%AD%E5%A4%B1%E5%8E%BB%E8%AE%B0%E5%BF%86/"/>
      <url>/2018/02/21/%E9%9A%8F%E7%AC%94-%E6%88%91%E6%83%B3%E5%9C%A8%E4%BD%A0%E7%9A%84%E6%80%80%E4%B8%AD%E5%A4%B1%E5%8E%BB%E8%AE%B0%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p>我想在你的怀中失去记忆<br>做个好梦然后留在这里/<br>你看见死掉的罗曼蒂克<br>我告诉你 那已经过去了<br>都是过去了/<br>十二月走后鸟就来了<br>来年可期<br>往事 无需问</p><p>如果明天你将我叫醒<br>我便知晓你是中意我的/<br>活进你的日子里<br>夜晚与清晨就明晰起来<br>睡梦竟变得可爱/<br>梦 是我做的<br>白鸟是你化成的</p><p>我在什么时辰唤你名字<br>你醒来就来临/<br>于是你站在高高的枝头上<br>容我看着你 远远地<br>看着你<br>一如十年后看着你 远远地/<br>等着<br>等着我 唤你名字</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你</title>
      <link href="/2017/12/13/%E9%9A%8F%E7%AC%94-%E4%BD%A0/"/>
      <url>/2017/12/13/%E9%9A%8F%E7%AC%94-%E4%BD%A0/</url>
      
        <content type="html"><![CDATA[<p>你这样你<br>入眼是你<br>囿于灵魂<br>又困于命理</p><p>你这样你<br>遗憾是你<br>一纸荒唐<br>换一个姓名</p><p>你这样你<br>你多迷离<br>游于想象<br>又脱于实际</p><p>你这样你<br>你太彻底<br>成为好梦<br>没成为具体</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薄荷薄荷</title>
      <link href="/2017/12/11/%E9%9A%8F%E7%AC%94-%E8%96%84%E8%8D%B7%E8%96%84%E8%8D%B7/"/>
      <url>/2017/12/11/%E9%9A%8F%E7%AC%94-%E8%96%84%E8%8D%B7%E8%96%84%E8%8D%B7/</url>
      
        <content type="html"><![CDATA[<p>我看过你的眼睛<br>住着一颗星星<br>在夜晚听悉我心事<br>清晨遗落我梦里</p><p>我听过你的声音<br>沉入海的深底<br>在沦陷之后没治愈<br>没有关系&emsp;没关系</p><p>薄荷薄荷&emsp;你没说话<br>天亮之前我要找你不肯回家<br>如果明天下落不明<br>你知道我曾为你动过情吗<br>薄荷薄荷&emsp;你别说话<br>我想给你讲个故事自始无终<br>可是&emsp;“好”<br>好吧</p>]]></content>
      
      
      <categories>
          
          <category> emotion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/11/11/hello-world/"/>
      <url>/2017/11/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
