<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。"><title>MyBatis | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bbf19a98c9ae28f2e1e8cfcee1d9585e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MyBatis</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/message/"><i class="fa fa-comment"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MyBatis</h1><div class="post-meta">2022-10-27<span> | </span><span class="category"><a href="/categories/technology/">technology</a><a href="/categories/technology/Java/">Java</a><a href="/categories/technology/Java/%E6%A1%86%E6%9E%B6/">框架</a><a href="/categories/technology/Java/%E6%A1%86%E6%9E%B6/MyBatis/">MyBatis</a></span></div><div class="post-content"><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ol>
<li>加载驱动 Class.forName(“com.mysql.jdbc.Driver”)</li>
<li>获取链接 Connection conn = (Connection) DriverManager.getConnection(url, username, password)</li>
<li>执行PreparedStatement</li>
<li>返回结果集 ResultSet</li>
</ol>
<h2 id="Mybatis总体框架设计"><a href="#Mybatis总体框架设计" class="headerlink" title="Mybatis总体框架设计"></a>Mybatis总体框架设计</h2><p><img src="/2022/10/27/MyBatis/mybatis-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E6%A6%82%E8%A7%88%E5%9B%BE.png"></p>
<h3 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h3><h4 id="接口层-和数据库交互的方式"><a href="#接口层-和数据库交互的方式" class="headerlink" title="接口层 -和数据库交互的方式"></a>接口层 -和数据库交互的方式</h4><p>MyBatis和数据库的交互有两种方式：</p>
<ul>
<li>使用传统的MyBatis提供的API</li>
<li>使用Mapper接口</li>
</ul>
<h4 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h4><p>数据处理层可以说是MyBatis的核心，从大的方面上讲，它要完成两个功能：</p>
<ul>
<li>通过传入参数构建动态SQL语句</li>
<li>SQL语句的执行以及封装查询结果集成<code>List&lt;E&gt;</code></li>
</ul>
<p><strong>参数映射和动态SQL语句生成</strong><br>动态语句生成可以说是MyBatis框架非常优雅的一个设计，MyBatis通过传入的参数值，使用Ognl来动态地构造SQL语句，使得MyBatis有很强的灵活性和扩展性。</p>
<p>参数映射指的是对于java数据类型和jdbc数据类型之间的转换。<br>这里有包括两个过程：</p>
<ol>
<li>查询阶段，我们要将java类型的数据，转换成jdbc类型的数据，通过 preparedStatement.setXXX() 来设值；</li>
<li>对resultset查询结果集的jdbcType 数据转换成java 数据类型。</li>
</ol>
<p><strong>SQL语句的执行以及封装查询结果集成List</strong><br>动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List<E>列表。<br>MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。</E></p>
<h4 id="框架支撑层"><a href="#框架支撑层" class="headerlink" title="框架支撑层"></a>框架支撑层</h4><ul>
<li>事务管理机制<br>  事务管理机制对于ORM框架而言是不可缺少的一部分，事务管理机制的质量也是考量一个ORM框架是否优秀的一个标准。</li>
<li>连接池管理机制<br>  由于创建一个数据库连接所占用的资源比较大，对于数据吞吐量大和访问量非常大的应用而言，连接池的设计就显得非常重要。</li>
<li>缓存机制<br>  为了提高数据利用率和减小服务器和数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis 会直接将缓存结果返回给用户，而不用再到数据库中查找。</li>
<li>SQl语句的配置方式<br>  Mapper + XML</li>
</ul>
<h3 id="主要构件及其相互关系"><a href="#主要构件及其相互关系" class="headerlink" title="主要构件及其相互关系"></a>主要构件及其相互关系</h3><p><img src="/2022/10/27/MyBatis/mybatis-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E4%B8%BB%E8%A6%81%E6%9E%84%E4%BB%B6.png"></p>
<ul>
<li>SqlSession，作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能；</li>
<li>Executor，MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护；</li>
<li>StatementHandler，封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合；</li>
<li>ParameterHandler，负责对用户传递的参数转换成JDBC Statement 所需要的参数；</li>
<li>ResultSetHandler，负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</li>
<li>TypeHandler 负责java数据类型和jdbc数据类型之间的映射和转换；</li>
<li>MappedStatement MappedStatement维护了一条<strong>select|update|delete|insert</strong>节点的封装；</li>
<li>SqlSource 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回；</li>
<li>BoundSql 表示动态生成的SQL语句以及相应的参数信息；</li>
<li>Configuration MyBatis所有的配置信息都维持在Configuration对象之中。</li>
</ul>
<h2 id="MyBatis执行流程"><a href="#MyBatis执行流程" class="headerlink" title="MyBatis执行流程"></a>MyBatis执行流程</h2><h3 id="Mybatis核心流程四大对象"><a href="#Mybatis核心流程四大对象" class="headerlink" title="Mybatis核心流程四大对象"></a>Mybatis核心流程四大对象</h3><p>MyBatis完成一次数据库操作需要经过的步骤，如下：</p>
<ol>
<li>加载配置文件，获取<strong>SqlSessionFactoryBuiler</strong>对象</li>
<li>通过SqlSessionFactoryBuiler和配置文件流来获取<strong>SqlSessionFactory</strong>对象</li>
<li>利用SqlSessionFactory对象来打开一个<strong>SqlSession</strong></li>
<li>通过SqlSession来获得对应的<strong>Mapper</strong>对象</li>
<li>通过Mapper对象调用对应接口来封装执行sql并解析返回数据</li>
</ol>
<table>
<thead>
<tr>
<th align="left">对象</th>
<th align="center">生命周期</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SqlSessionFactoryBuiler</td>
<td align="center">方法局部（Method）使用完成即可被丢弃</td>
</tr>
<tr>
<td align="left">SqlSessionFactory</td>
<td align="center">应用级别（Application），全局存在，是一个单例对象</td>
</tr>
<tr>
<td align="left">SqlSession</td>
<td align="center">请求或方法（Request / Method）</td>
</tr>
<tr>
<td align="left">Mapper</td>
<td align="center">方法（Method）</td>
</tr>
</tbody></table>
<h3 id="SqlSession的创建过程"><a href="#SqlSession的创建过程" class="headerlink" title="SqlSession的创建过程"></a>SqlSession的创建过程</h3><p><img src="/2022/10/27/MyBatis/mybatis-sqlsession-%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" alt="创建SqlSessiond的过程"></p>
<ol>
<li>首先，SqlSessionFactoryBuilder去读取mybatis的配置文件，然后build一个DefaultSqlSessionFactory。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一系列的构造方法最终都会调用本方法（配置文件为Reader时会调用本方法，还有一个InputStream方法与此对应）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> environment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过XMLConfigBuilder解析配置文件，解析的配置相关信息都会封装为一个Configuration对象</span></span><br><span class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">        <span class="comment">//这儿创建DefaultSessionFactory对象</span></span><br><span class="line">        <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获取到SqlSessionFactory之后，就可以通过SqlSessionFactory去获取SqlSession对象。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通常一系列openSession方法最终都会调用本方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> execType </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> level</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> autoCommit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过Confuguration对象去获取Mybatis相关配置信息, Environment对象包含了数据源和事务的配置</span></span><br><span class="line">        <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">        <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        <span class="comment">//之前说了，从表面上来看，咱们是用sqlSession在执行sql语句， 实际呢，其实是通过excutor执行， excutor是对于Statement的封装</span></span><br><span class="line">        <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        <span class="comment">//关键看这儿，创建了一个DefaultSqlSession对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>从配置中获取Environment；</li>
<li>从Environment中取得DataSource；从Environment中取得TransactionFactory；</li>
<li>从DataSource里获取数据库连接对象Connection；在取得的数据库连接上创建事务对象Transaction；</li>
<li>创建Executor对象（该对象非常重要，事实上sqlsession的所有操作都是通过它完成的）；</li>
<li>创建sqlsession对象。</li>
</ol>
</li>
</ol>
<h3 id="Mapper执行流程"><a href="#Mapper执行流程" class="headerlink" title="Mapper执行流程"></a>Mapper执行流程</h3><p>Mapper执行一次sql需要经过的步骤，如下：</p>
<ol>
<li>通过MybatisMapperRegistry获取JDK动态代理对象MybatisMapperProxy</li>
<li>通过MybatisMapperProxy执行代理方法</li>
<li>通过MappedStatement和入参创建Executor并实际执行数据库操作</li>
</ol>
<p><img src="/2022/10/27/MyBatis/mybatis-mapper-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="MapperProxy的创建过程"></p>
<p>在mybatis中，通过MapperProxy动态代理咱们的dao或者mapper接口，也就是说，当咱们执行自己写的dao里面的方法的时候，其实是对应的mapperProxy在代理。<br>那么，看看怎么获取MapperProxy对象吧。</p>
<ol>
<li><strong>SqlSession</strong><br> SqlSession把包袱甩给了Configuration <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 什么都不做，直接去configuration中找， 哥就是这么任性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Configuration</strong><br> Configuration不要这烫手的山芋，接着甩给了MapperRegistry <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 烫手的山芋，俺不要，你找mapperRegistry去要</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>MapperRegistry</strong><br> MapperRegistry交给MapperProxyFactory去做 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 烂活净让我来做了，没法了，下面没人了，我不做谁来做</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//能偷懒的就偷懒，俺把粗活交给MapperProxyFactory去做</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//关键在这儿</span></span><br><span class="line">        <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>MapperProxyFactory</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mapperProxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//动态代理我们写的dao接口</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Executor执行流程"><a href="#Executor执行流程" class="headerlink" title="Executor执行流程"></a>Executor执行流程</h3><p>Executor执行过程需要经过的步骤，如下：</p>
<ol>
<li>创建Executor，然后利用StatementHandler执行数据库操作</li>
<li>执行数据库操作前，利用ParameterHandler做参数处理</li>
<li>执行数据库操作后，利用ResultSetHandler处理数据库返回结果</li>
</ol>
<p>Executor与Sqlsession的关系就像市长与书记，Sqlsession只是个门面，真正干事的是Executor。<br>Sqlsession对数据库的操作都是通过Executor来完成的。<br>与Sqlsession一样，Executor也是动态创建的：<br><img src="/2022/10/27/MyBatis/mybatis-excutor-%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="Excutor的创建过程"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configuration#newExecutor</span></span><br><span class="line"><span class="comment"> * Executor创建的源代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;  </span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;  </span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ?ExecutorType.SIMPLE : executorType;  </span><br><span class="line">    Executor executor;  </span><br><span class="line">    <span class="keyword">if</span>(ExecutorType.BATCH == executorType) &#123; <span class="comment">// BatchExecutor专门用于执行批量sql操作</span></span><br><span class="line">        executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>,transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ExecutorType.REUSE == executorType) &#123; <span class="comment">// ReuseExecutor会重用statement执行sql操作</span></span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>,transaction);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        executor = newSimpleExecutor(<span class="keyword">this</span>, transaction); <span class="comment">// SimpleExecutor只是简单执行sql没有什么特别的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        <span class="comment">// 开启cache的话（默认是开启的并且没有任何理由去关闭它），就会创建CachingExecutor，它以前面创建的Executor作为唯一参数</span></span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor);  </span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);  </span><br><span class="line">    <span class="keyword">return</span> executor;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configuration#newStatementHandler</span></span><br><span class="line"><span class="comment"> * newStatementHandler创建的源代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="StatementHandler-sql执行、参数及结果映射流程"><a href="#StatementHandler-sql执行、参数及结果映射流程" class="headerlink" title="StatementHandler sql执行、参数及结果映射流程"></a>StatementHandler sql执行、参数及结果映射流程</h3><ol>
<li>将参数和执行sql解析封装成MetaObject</li>
<li>执行sql前后通过TypeHandler对java与数据库参数进行映射</li>
</ol>
<h2 id="MyBatis一级、二级缓存"><a href="#MyBatis一级、二级缓存" class="headerlink" title="MyBatis一级、二级缓存"></a>MyBatis一级、二级缓存</h2><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">美团技术团队-聊聊MyBatis缓存机制</a></p>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于<code>同一个SqlSession</code>而言。</p>
<h4 id="一级缓存的生命周期"><a href="#一级缓存的生命周期" class="headerlink" title="一级缓存的生命周期"></a>一级缓存的生命周期</h4><ol>
<li>MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。</li>
<li>如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。</li>
<li>如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。</li>
<li>SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用。</li>
</ol>
<p><strong>怎么判断某两次查询是完全相同的查询</strong><br>Mybatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询。</p>
<ol>
<li>传入的statementId。</li>
<li>查询时要求的结果集中的结果范围。</li>
<li>这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）。</li>
<li>传递给java.sql.Statement要设置的参数值。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>MyBatis一级缓存的生命周期和SqlSession一致。</li>
<li>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li>
<li>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。 <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">        <span class="attr">cache-enabled:</span> <span class="literal">false</span> <span class="comment">#禁用二级缓存</span></span><br><span class="line">        <span class="attr">local-cache-scope:</span> <span class="string">statement</span> <span class="comment">#一级缓存指定为statement级别。每次查询结束都会清掉一级缓存，实际效果就是禁用了一级缓存。</span></span><br><span class="line">        <span class="attr">local-cache-scope:</span> <span class="string">session</span>  <span class="comment">#一级缓存指定为session级别。对同样的查询将不再查询数据库，直接从缓存中获取。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>MyBatis的二级缓存是Application级别的缓存。<br>范围是按照每个namepace缓存来存贮和维护，同一个namespace放到一个缓存对象中。<br>当这个namaspace中执行了insert、update和delete语句的时候，整个namespace中的缓存全部清除掉。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">        <span class="string">//</span> <span class="string">默认不开启二级缓存</span></span><br><span class="line">        <span class="attr">cache-enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol>
<li>MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
</div><div class="tags"><a href="/tags/MyBatis"><i class="fa fa-tag">MyBatis</i></a></div><div class="post-nav"><a class="pre" href="/2022/10/27/mybatis-plus/">mybatis-plus</a><a class="next" href="/2022/09/29/hexo-%E4%B8%BB%E9%A2%98maupassant%E7%9B%AE%E5%BD%95%E4%BC%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">hexo-主题maupassant目录优化解决方案</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '8359b7a19b78f2b9e112',
  clientSecret: '5ad69dc1633a1834322067d017b6313bd231457c',
  repo: 'gitalk',
  owner: 'Th3Crave',
  admin: ['Th3Crave'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC"><span class="toc-text">JDBC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E6%80%BB%E4%BD%93%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1"><span class="toc-text">Mybatis总体框架设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-text">架构概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B1%82-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">接口层 -和数据库交互的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B1%82"><span class="toc-text">数据处理层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E6%94%AF%E6%92%91%E5%B1%82"><span class="toc-text">框架支撑层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%9E%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-text">主要构件及其相互关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">MyBatis执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E5%9B%9B%E5%A4%A7%E5%AF%B9%E8%B1%A1"><span class="toc-text">Mybatis核心流程四大对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SqlSession%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">SqlSession的创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapper%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">Mapper执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">Executor执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StatementHandler-sql%E6%89%A7%E8%A1%8C%E3%80%81%E5%8F%82%E6%95%B0%E5%8F%8A%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84%E6%B5%81%E7%A8%8B"><span class="toc-text">StatementHandler sql执行、参数及结果映射流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">MyBatis一级、二级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">一级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">一级缓存的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">二级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>