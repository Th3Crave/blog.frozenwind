<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。"><title>Spring-AOP | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bbf19a98c9ae28f2e1e8cfcee1d9585e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring-AOP</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/message/"><i class="fa fa-comment"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring-AOP</h1><div class="post-meta">2020-10-27<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li>Spring 框架通过定义切面, 通过拦截切点实现了不同业务模块的解耦，这个就叫<strong>面向切面编程 - Aspect Oriented Programming (AOP)</strong></li>
<li>为什么@Aspect注解使用的是aspectj的jar包呢？这就引出了<strong>Aspect4J和Spring AOP的历史渊源</strong>，只有理解了Aspect4J和Spring的渊源才能理解有些注解上的兼容设计</li>
<li>如何支持更多拦截方式来实现解耦， 以满足更多场景需求呢？ 这就是@Around, @Pointcut… 等的设计</li>
<li>那么Spring框架又是如何实现AOP的呢？ 这就引入<strong>代理技术</strong>，分<strong>静态代理和动态代理</strong>，<strong>动态代理又包含JDK代理和CGLIB代理</strong>等</li>
</ol>
<h2 id="如何理解AOP"><a href="#如何理解AOP" class="headerlink" title="如何理解AOP"></a>如何理解AOP</h2><p>AOP的本质也是为了解耦，它是一种设计思想； 在理解时也应该简化理解。</p>
<h3 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h3><blockquote>
<p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程。</p>
</blockquote>
<p>AOP最早是AOP联盟的组织提出的，制定的一套规范。Spring将AOP的思想引入框架之中，通过<strong>预编译方式</strong>和<strong>运行期间动态代理</strong>实现程序的统一维护。</p>
<p>将记录日志功能解耦为日志切面，它的目标是解耦。进而引出AOP的理念：就是将分散在各个业务逻辑代码中相同的代码通过<strong>横向切割</strong>的方式抽取到一个独立的模块中。<br><img src="/2020/10/27/Spring-AOP/aop-%E6%98%AF%E4%BB%80%E4%B9%88-1.png"></p>
<p>OOP面向对象编程，针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。<br>OOP面向对象，允许开发者定义纵向的关系，但并不适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程的某个步骤或阶段，以获得逻辑过程的中各部分之间低耦合的隔离效果。<br>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</p>
<p>这两种设计思想在目标上有着本质的差异。</p>
<p><img src="/2020/10/27/Spring-AOP/aop-%E6%98%AF%E4%BB%80%E4%B9%88-2.png"></p>
<h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p>首先从一些重要的AOP概念和术语开始，这些术语不是Spring特有的。<br><img src="/2020/10/27/Spring-AOP/aop-%E6%9C%AF%E8%AF%AD.png"></p>
<h3 id="Spring-AOP和AspectJ是什么关系"><a href="#Spring-AOP和AspectJ是什么关系" class="headerlink" title="Spring AOP和AspectJ是什么关系"></a>Spring AOP和AspectJ是什么关系</h3><h4 id="AspectJ是什么？"><a href="#AspectJ是什么？" class="headerlink" title="AspectJ是什么？"></a>AspectJ是什么？</h4><p>AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）。</p>
<p>可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。</p>
<p>了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。<br>对于这个过程，一般分为<strong>动态织入</strong>和<strong>静态织入</strong>：</p>
<ul>
<li>动态织入<br>  动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的。<br>  如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术。</li>
<li>静态织入<br>  ApectJ采用的就是静态织入的方式。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。<br>  <img src="/2020/10/27/Spring-AOP/aop-AspectJ-%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5.png"></li>
</ul>
<h4 id="为什么需要理清楚Spring-AOP和AspectJ的关系？"><a href="#为什么需要理清楚Spring-AOP和AspectJ的关系？" class="headerlink" title="为什么需要理清楚Spring AOP和AspectJ的关系？"></a>为什么需要理清楚Spring AOP和AspectJ的关系？</h4><p>我们看下@Aspect以及增强的几个注解，为什么不是Spring包，而是来源于aspectJ呢？<br><img src="/2020/10/27/Spring-AOP/aop-AspectJ-jar.png"></p>
<h4 id="Spring-AOP和AspectJ是什么关系？"><a href="#Spring-AOP和AspectJ是什么关系？" class="headerlink" title="Spring AOP和AspectJ是什么关系？"></a>Spring AOP和AspectJ是什么关系？</h4><p>AspectJ可以做Spring AOP干不了的事情，它是AOP编程的完全解决方案。<br>Spring AOP则致力于解决企业级开发中最普遍的AOP（方法织入）。</p>
<table>
<thead>
<tr>
<th align="left">Spring AOP</th>
<th align="left">AspectJ</th>
</tr>
</thead>
<tbody><tr>
<td align="left">在纯 Java 中实现</td>
<td align="left">使用 Java 编程语言的扩展实现</td>
</tr>
<tr>
<td align="left">不需要单独的编译过程</td>
<td align="left">除非设置 LTW，否则需要 AspectJ 编译器 (ajc)</td>
</tr>
<tr>
<td align="left">只能使用运行时织入</td>
<td align="left">运行时织入不可用。支持编译时、编译后和加载时织入</td>
</tr>
<tr>
<td align="left">功能不强-仅支持方法级编织</td>
<td align="left">更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等……。</td>
</tr>
<tr>
<td align="left">只能在由 Spring 容器管理的 bean 上实现</td>
<td align="left">可以在所有域对象上实现</td>
</tr>
<tr>
<td align="left">仅支持方法执行切入点</td>
<td align="left">支持所有切入点</td>
</tr>
<tr>
<td align="left">代理是由目标对象创建的, 并且切面应用在这些代理上</td>
<td align="left">在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入</td>
</tr>
<tr>
<td align="left">比 AspectJ 慢多了</td>
<td align="left">更好的性能</td>
</tr>
<tr>
<td align="left">易于学习和应用</td>
<td align="left">相对于 Spring AOP 来说更复杂</td>
</tr>
</tbody></table>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>AOP实现的关键在于代理模式，AOP代理主要分为静态代理和动态代理。<br>静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<h3 id="静态代理-AspectJ"><a href="#静态代理-AspectJ" class="headerlink" title="静态代理 - AspectJ"></a>静态代理 - AspectJ</h3><p>AspectJ是静态代理的增强。</p>
<p>所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<h3 id="动态代理-Spring-AOP"><a href="#动态代理-Spring-AOP" class="headerlink" title="动态代理 - Spring AOP"></a>动态代理 - Spring AOP</h3><p>所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<p>Spring AOP中的动态代理主要有两种方式：</p>
<ul>
<li>JDK动态代理</li>
<li>CGLIB动态代理</li>
</ul>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>只提供接口的代理，不支持类的代理。</p>
<p>核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.feng.proxy.dynamic.jdk.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserJDKProxy2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realObject 被代理的真实对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Object realObject, Class clazz)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;clazz&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 在代理真实对象前的操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;在调用之前，干点啥呢？&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Method:&quot;</span> + method);</span><br><span class="line">                <span class="comment">// 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">                Object returnValue = method.invoke(realObject, args);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在代理真实对象后的操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;在调用之后，干点啥呢？&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;[after] execute method: &quot;</span> + method.getName() + <span class="string">&quot;, return value: &quot;</span> + returnValue);</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>如果目标类没有实现接口，那么Spring AOP会选择使用<code>CGLIB</code>来动态代理目标类。</p>
<p>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。<br>CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.feng.proxy.dynamic.cglib.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCglibProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建加强器，用来创建动态代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 为加强器指定要代理的业务类（即为下面生成的代理类指定父类）</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">// 设置回调：对于代理类上所有的方法的调用，都会调用callback，而callback则需要实现intercept()方法进行拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理类对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// log - before method</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[before] execute method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call method</span></span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// log - after method</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[after] execute method: &quot;</span> + method.getName() + <span class="string">&quot;, return value: &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他代理方式-Java字节码操作框架"><a href="#其他代理方式-Java字节码操作框架" class="headerlink" title="其他代理方式 - Java字节码操作框架"></a>其他代理方式 - Java字节码操作框架</h3><h4 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h4><h4 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h4><h4 id="Byte-Buddy"><a href="#Byte-Buddy" class="headerlink" title="Byte-Buddy"></a>Byte-Buddy</h4><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。<br>真正的数据库层的事务提交和回滚是通过binlog或者redo log/undo log实现的。</p>
<p>Spring的核心事务管理抽象是<code>TransactionManager</code>，管理封装了一组独立于技术的方法，无论使用Spring的哪种事务管理策略（编程式或声明式），事务管理器都是必须的。</p>
<h3 id="事务的种类"><a href="#事务的种类" class="headerlink" title="事务的种类"></a>事务的种类</h3><h4 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h4><p>通过 TransactionTemplate或者TransactionManager手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</p>
<h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p>推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）。</p>
<h3 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h3><ul>
<li>隔离级别</li>
<li>传播行为</li>
<li>回滚规则</li>
<li>是否只读</li>
<li>事务超时</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><h4 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h4><h4 id="是否只读"><a href="#是否只读" class="headerlink" title="是否只读"></a>是否只读</h4><h4 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h4><h3 id="Transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a>@Transactional 注解使用详解</h3><h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><ul>
<li>方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。</li>
<li>类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li>
<li>接口 ：不推荐在接口上使用。</li>
</ul>
<h4 id="常用配置参数"><a href="#常用配置参数" class="headerlink" title="常用配置参数"></a>常用配置参数</h4><ul>
<li>propagation 事务的传播行为，默认值为 REQUIRED</li>
<li>isolation 事务的隔离级别，默认值采用 DEFAULT</li>
<li>timeout 事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li>
<li>readOnly 指定事务是否为只读事务，默认值为 false。</li>
<li>rollbackFor 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</li>
</ul>
<h4 id="Transactional事务注解原理"><a href="#Transactional事务注解原理" class="headerlink" title="@Transactional事务注解原理"></a>@Transactional事务注解原理</h4><p><code>@Transactional</code>的工作机制是基于AOP实现的，Spring AOP又是使用动态代理实现的。<br>如果目标对象实现了接口，默认情况下会采用JDK的动态代理，如果目标对象没有实现接口，会使用CGLIB动态代理。</p>
<p><code>createAopProxy()</code>决定了是使用 JDK 还是 CGLIB 来做动态代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类或者一个类中的 public 方法上被标注 @Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。<br>这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p>
<h4 id="Spring-AOP自调用问题"><a href="#Spring-AOP自调用问题" class="headerlink" title="Spring AOP自调用问题"></a>Spring AOP自调用问题</h4><p>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有 @Transactional 注解的方法的事务会失效。</p>
<p>这是由于 Spring AOP 代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring事务管理才生效。</p>
<p>MyService 类中的method1()调用method2()就会导致method2()的事务失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     method2();</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法就是避免同一类中自调用或者使用AspectJ静态代理取代Spring AOP代理。</p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/Kaiyuan/donate-page" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.png"></li><li id="WeChat" qr="/img/WeChatQR.png"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="tags"><a href="/tags/Spring"><i class="fa fa-tag">Spring</i></a></div><div class="post-nav"><a class="pre" href="/2020/10/27/Spring-MVC/">Spring-MVC</a><a class="next" href="/2020/10/27/Spring-IOC/">Spring-IOC</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '8359b7a19b78f2b9e112',
  clientSecret: '5ad69dc1633a1834322067d017b6313bd231457c',
  repo: 'gitalk',
  owner: 'Th3Crave',
  admin: ['Th3Crave'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3AOP"><span class="toc-text">如何理解AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">AOP是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E6%9C%AF%E8%AF%AD"><span class="toc-text">AOP术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP%E5%92%8CAspectJ%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-text">Spring AOP和AspectJ是什么关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AspectJ%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">AspectJ是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%90%86%E6%B8%85%E6%A5%9ASpring-AOP%E5%92%8CAspectJ%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">为什么需要理清楚Spring AOP和AspectJ的关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-AOP%E5%92%8CAspectJ%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">Spring AOP和AspectJ是什么关系？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-AspectJ"><span class="toc-text">静态代理 - AspectJ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-Spring-AOP"><span class="toc-text">动态代理 - Spring AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">JDK动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">CGLIB动态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F-Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6"><span class="toc-text">其他代理方式 - Java字节码操作框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ASM"><span class="toc-text">ASM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Javassist"><span class="toc-text">Javassist</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Byte-Buddy"><span class="toc-text">Byte-Buddy</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1"><span class="toc-text">Spring事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">事务的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">编程式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">声明式事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">事务的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-text">传播行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E8%A7%84%E5%88%99"><span class="toc-text">回滚规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AA%E8%AF%BB"><span class="toc-text">是否只读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E8%B6%85%E6%97%B6"><span class="toc-text">事务超时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transactional-%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="toc-text">@Transactional 注解使用详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">作用范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">常用配置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transactional%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86"><span class="toc-text">@Transactional事务注解原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-AOP%E8%87%AA%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">Spring AOP自调用问题</span></a></li></ol></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>