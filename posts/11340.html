<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。"><title>微服务架构-Kubernetes | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bbf19a98c9ae28f2e1e8cfcee1d9585e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">微服务架构-Kubernetes</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/message/"><i class="fa fa-comment"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">微服务架构-Kubernetes</h1><div class="post-meta">2023-05-10<span> | </span><span class="category"><a href="/categories/technology/">technology</a><a href="/categories/technology/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></span></div><div class="post-content"><h2 id="服务注册发现与负载均衡-Service"><a href="#服务注册发现与负载均衡-Service" class="headerlink" title="服务注册发现与负载均衡 - Service"></a>服务注册发现与负载均衡 - Service</h2><p>如果使用 Deployment 来运行应用服务，Deployment 可以动态的创建和销毁 Pod。每个 Pod 获取其自己的 IP 地址（K8S期待网络插件确保IP地址分配）。<br>对于集群中给定的 Deployment，这一刻运行的这组 Pod 可能不同于下一刻运行应用程序的另一组 Pod。<br>由此引出的的问题是：</p>
<ul>
<li>如果一组Pod（称为”后端“）为<strong>同一集群</strong>内的其它Pod（称为”前端”）提供功能，那么前端如何找出并跟踪要连接的IP地址，以便前端可以使用提供能力的后端部分？</li>
<li>如果一组前端Pod要调用<strong>不同集群</strong>的一组后端Pod呢？</li>
</ul>
<p>Kubernetes 中 Service 是一种抽象，通过网络暴露Pod组合。每个Service对象定义一组Pod以及如何访问这些Pod的策略。</p>
<p>Kubernetes Service 是集群中提供相同功能的一组 Pod 的抽象表达。 当每个 Service 创建时，会被分配一个唯一的 IP 地址（也称为 clusterIP）。 这个 IP 地址与 Service 的生命周期绑定在一起，只要 Service 存在，它就不会改变。 可以配置 Pod 使它与 Service 进行通信，Pod 知道与 Service 通信将被自动地负载均衡到该 Service 中的某些 Pod 上。</p>
<h3 id="定义Service"><a href="#定义Service" class="headerlink" title="定义Service"></a>定义Service</h3><p>Service 在 Kubernetes 中是一个对象 （与 Pod 或 ConfigMap 类似的对象）。可以使用 Kubernetes API 创建、查看或修改 Service 定义。 通常使用 <code>kubectl</code> 这类工具来进行这些 API 调用。</p>
<h4 id="EndpointPoints-amp-EndpointSlices"><a href="#EndpointPoints-amp-EndpointSlices" class="headerlink" title="EndpointPoints &amp; EndpointSlices"></a>EndpointPoints &amp; EndpointSlices</h4><p><strong>Endpoint</strong>: pod和service之间的关联关系，是通过<code>endpoint</code>实现的。<br>Endpoints表示了一个Service对应的所有Pod副本的访问地址；而Endpoints Controller负责生成和维护所有Endpoints对象的控制器，它负责监听Service和对应的Pod副本的变化。</p>
<p>在 Kubernetes API 中，Endpoints （该资源类别为复数）定义了网络端点的列表，通常由 Service 引用，以定义可以将流量发送到哪些 Pod。<br>推荐用 EndpointSlice API 替换 Endpoints。</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>Kubernetes 支持两种查找服务的主要模式：环境变量和 DNS。前者开箱即用，而后者则需要 CoreDNS 集群插件。</p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>当 Pod 在节点上运行时，kubelet 会针对每个活跃的 Service 为 Pod 添加一组环境变量。<br>kubelet 为 Pod 添加环境变量 <code>&#123;SVCNAME&#125;_SERVICE_HOST</code> 和 <code>&#123;SVCNAME&#125;_SERVICE_PORT</code>。</p>
<p>使用<strong>环境变量方法</strong>将端口和集群 IP 发布到客户端 Pod 时，<strong>必须在客户端 Pod 出现 之前 创建服务</strong>。 否则，这些客户端 Pod 将不会设定其环境变量。<br>如果仅使用 DNS 查找服务的集群 IP，则无需担心此设定问题。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>支持集群的 DNS 服务器（例如 CoreDNS：kube-dns）监视 Kubernetes API 中的新服务，并为每个服务创建一组 DNS 记录。 如果在整个集群中都启用了 DNS，则所有 Pod 都应该能够通过其 DNS 名称自动解析服务。</p>
<p>例如，如果你在 Kubernetes <strong>命名空间 my-ns</strong> 中有一个<strong>名为 my-service 的服务</strong>， 则控制平面和 DNS 服务共同为 <strong>my-service.my-ns</strong> 创建 DNS 记录。 <strong>my-ns 命名空间</strong>中的 Pod 应该能够通过<code>按名检索 my-service</code> 来找到服务 （my-service.my-ns 也可以工作）。<br>同一集群下<strong>其他命名空间中的 Pod</strong> 必须将名称限定为 <code>my-service.my-ns</code>，<strong>这些名称将解析为为服务分配的集群 IP</strong>。</p>
<p>kube-dns记录service和为服务分配的集群IP的对应关系。</p>
<p>Kubernetes 提供了一个自动为其它Service分配DNS名字的DNS插件Service：kube-dns。<br>可以通过如下命令检查它是否在工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services kube-dns --namespace=kube-system</span><br><span class="line"></span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m</span><br></pre></td></tr></table></figure>

<h3 id="发布服务（服务类型）"><a href="#发布服务（服务类型）" class="headerlink" title="发布服务（服务类型）"></a>发布服务（服务类型）</h3><p>对一些应用的某些部分（如前端），可能希望将其暴露给K8S集群外部的IP地址从而能够外网访问。</p>
<p>Kubernetes <code>ServiceTypes</code> 允许指定所需要的 Service 类型。</p>
<ul>
<li>ClusterIP<br>  通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。<br>  这也是没有为服务显式指定 type 时使用的<strong>默认值</strong>。<br>  可以使用 Ingress 或者 Gateway API 向公众暴露服务。</li>
<li>NodePort<br>  通过每个节点上的 IP 和静态端口（NodePort）暴露服务。<br>  为了让节点端口可用，Kubernetes 设置了集群 IP 地址，这等同于请求 <code>type: ClusterIP</code> 的服务。</li>
<li>LoadBalancer<br>  使用云提供商的负载均衡器向外部暴露服务。<br>  外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上。</li>
<li>ExternalName<br>  通过返回 <code>CNAME</code> 记录和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，foo.bar.example.com）。 无需创建任何类型代理。<br>  要使用 kube-dns 1.7 及以上版本或者 CoreDNS 0.0.8 及以上版本才能使用 <code>ExternalName</code> 类型。</li>
</ul>
<p>可以使用 <code>Ingress</code> 来暴露自己的服务。<br><code>Ingress</code> 不是一种服务类型，但它充当集群的入口点。它可以将路由规则整合到一个资源中，因为它可以在同一 IP 地址下公开多个服务。</p>
<h4 id="ClusterIP类型"><a href="#ClusterIP类型" class="headerlink" title="ClusterIP类型"></a>ClusterIP类型</h4><p>使用 type: ClusterIP 的 Service时，Service 可以具有集群作用域的虚拟 IP 地址。<br>客户端可以使用该虚拟 IP 地址进行连接，Kubernetes 通过不同的后台 Pod 对该 Service 的流量进行负载均衡。</p>
<p>Service ClusterIP 是如何分配的？</p>
<ul>
<li>动态分配<br>  集群的控制面自动从所配置的 IP 范围内为 <code>type: ClusterIP</code> 选择一个空闲 IP 地址。</li>
<li>静态分配<br>  根据为 Service 所配置的 IP 范围，选定并设置你的 IP 地址。</li>
</ul>
<p>在整个集群中，每个 Service 的 ClusterIP 都必须是唯一的。 尝试使用已分配的 ClusterIP 创建 Service 将返回错误。</p>
<h4 id="NodePort类型"><a href="#NodePort类型" class="headerlink" title="NodePort类型"></a>NodePort类型</h4><h2 id="服务注册发现与负载均衡-Ingress"><a href="#服务注册发现与负载均衡-Ingress" class="headerlink" title="服务注册发现与负载均衡 - Ingress"></a>服务注册发现与负载均衡 - Ingress</h2><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。<br>Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。</p>
<p>Ingress 公开从集群外部到集群内服务的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。</p>
<p>下面是一个将所有流量都发送到同一 Service 的简单 Ingress 示例：<br><img src="/posts/11340/k8s-ingress-%E5%9B%BE%E7%A4%BA.png"></p>
<p>Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及基于名称的虚拟托管。<br><strong>Ingress 控制器</strong> 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。<br>Ingress 不会公开任意端口或协议。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 Service.Type=NodePort 或 Service.Type=LoadBalancer 类型的 Service。</p>
<h4 id="Ingress资源"><a href="#Ingress资源" class="headerlink" title="Ingress资源"></a>Ingress资源</h4><p>一个Ingress资源示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-wildcard-host</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;foo.bar.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/bar&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;*.foo.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/foo&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>Ingress 对象的命名必须是合法的 DNS 子域名名称。 </p>
<h4 id="Ingress类"><a href="#Ingress类" class="headerlink" title="Ingress类"></a>Ingress类</h4><p>Ingress 可以由不同的控制器实现，通常使用不同的配置。 每个 Ingress 应当指定一个类，也就是一个对 IngressClass 资源的引用。 IngressClass 资源包含额外的配置，其中包括应当实现该类的控制器名称。</p>
<h5 id="IngressClass的作用域"><a href="#IngressClass的作用域" class="headerlink" title="IngressClass的作用域"></a>IngressClass的作用域</h5><p>取决于 Ingress 控制器，可以使用集群范围设置的参数或某个名字空间范围的参数。</p>
<ul>
<li>集群作用域<br>  IngressClass 的参数默认是集群范围的。</li>
<li>命名空间作用域  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">external-lb-2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">controller:</span> <span class="string">example.com/ingress-controller</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">    <span class="comment"># 此 IngressClass 的配置定义在一个名为 “external-config” 的</span></span><br><span class="line">    <span class="comment"># IngressParameter（API 组为 k8s.example.com）资源中，</span></span><br><span class="line">    <span class="comment"># 该资源位于 “external-configuration” 命名空间中。</span></span><br><span class="line">    <span class="attr">scope:</span> <span class="string">Namespace</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">k8s.example.com</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">IngressParameter</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">external-configuration</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">external-config</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h3><p>为了让 Ingress 资源工作，集群必须有一个正在运行的 Ingress 控制器。</p>
<p>与作为 kube-controller-manager 可执行文件的一部分运行的其他类型的控制器不同， Ingress 控制器不是随集群自动启动的。<br>Kubernetes 作为一个项目，目前支持和维护 AWS、 GCE 和 <strong>Nginx</strong> Ingress 控制器。</p>
</div><div class="tags"><a href="/tags/云原生"><i class="fa fa-tag">云原生</i></a><a href="/tags/Kubernetes"><i class="fa fa-tag">Kubernetes</i></a><a href="/tags/微服务"><i class="fa fa-tag">微服务</i></a></div><div class="post-nav"><a class="pre" href="/posts/54442.html">Java 集合 - 类汇总</a><a class="next" href="/posts/65385.html">微服务</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '8359b7a19b78f2b9e112',
  clientSecret: '5ad69dc1633a1834322067d017b6313bd231457c',
  repo: 'gitalk',
  owner: 'Th3Crave',
  admin: ['Th3Crave'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Service"><span class="toc-text">服务注册发现与负载均衡 - Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89Service"><span class="toc-text">定义Service</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EndpointPoints-amp-EndpointSlices"><span class="toc-text">EndpointPoints &amp; EndpointSlices</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-text">服务发现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS"><span class="toc-text">DNS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-text">发布服务（服务类型）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ClusterIP%E7%B1%BB%E5%9E%8B"><span class="toc-text">ClusterIP类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NodePort%E7%B1%BB%E5%9E%8B"><span class="toc-text">NodePort类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ingress"><span class="toc-text">服务注册发现与负载均衡 - Ingress</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ingress"><span class="toc-text">Ingress</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ingress%E8%B5%84%E6%BA%90"><span class="toc-text">Ingress资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ingress%E7%B1%BB"><span class="toc-text">Ingress类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IngressClass%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">IngressClass的作用域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ingress-Controller"><span class="toc-text">Ingress Controller</span></a></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>