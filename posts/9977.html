<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。"><title>MySQL | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bbf19a98c9ae28f2e1e8cfcee1d9585e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/message/"><i class="fa fa-comment"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL</h1><div class="post-meta">2019-07-24<span> | </span><span class="category"><a href="/categories/technology/">technology</a><a href="/categories/technology/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><a href="/categories/technology/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/">MySQL</a></span></div><div class="post-content"><h2 id="MySQL-Server体系结构"><a href="#MySQL-Server体系结构" class="headerlink" title="MySQL Server体系结构"></a>MySQL Server体系结构</h2><p><img src="/posts/9977/mysql-server-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p>
<h2 id="一条SQL的执行过程"><a href="#一条SQL的执行过程" class="headerlink" title="一条SQL的执行过程"></a>一条SQL的执行过程</h2><h3 id="MySQL中一条SQL是如何执行的"><a href="#MySQL中一条SQL是如何执行的" class="headerlink" title="MySQL中一条SQL是如何执行的"></a>MySQL中一条SQL是如何执行的</h3><p>大致过程如下：<br>SQL ==&gt; 查询缓存 ==&gt; 解析器 ==&gt; 优化器 ==&gt; 执行器</p>
<ul>
<li>客户端SQL发送到MySQL服务端，首先会去查询缓存里面查找，如果多次执行同一个SQL是会命中缓存中，此时直接通过缓存来取数据</li>
<li>若没有命中查询缓存，则将SQL发送给解析器，解析器会对SQL进行语法、语义分析，同时也会对SQL合法性进行校验</li>
<li>SQL语义解析出来后，优化器会对SQL语义进行优化，比如，是走索引还是全表扫描，优化器会根据实际情况来确定一个最优的执行方案（当然，不一定是最优的，只是给出MySQL认为是最优的执行方案）</li>
<li>优化完毕后，就给到执行器（调用具体某个存储引擎，例如innodb）进行执行SQL，取出SQL执行结果</li>
<li>最后将执行结果返回给客户端</li>
</ul>
<h3 id="准备更新一条数据到事务的提交的流程描述"><a href="#准备更新一条数据到事务的提交的流程描述" class="headerlink" title="准备更新一条数据到事务的提交的流程描述"></a>准备更新一条数据到事务的提交的流程描述</h3><p>从准备更新一条数据到事务的提交的流程描述</p>
<ul>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li>
<li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li>
<li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事 <ul>
<li>将redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li>
</ul>
</li>
<li>至此表示整个更新事务已经完成</li>
</ul>
<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>一个库中可以有多个不同存储引擎的表。</p>
<p>InnoDB和MyISAM数据库的表的结构定义信息都存储在frm文件中。<br>InnoDB的数据和索引存储在ibd文件中（聚集），MyISAM索引存在MYI文件中，数据存储在MYD文件中（非聚集）。  </p>
<h3 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h3><p>若一个主键被定义，该主键则作为密集索引；<br>若没有主键被定义，该表的第一个唯一非空索引则作为密集索引；<br>若不满足以上条件，innoDB内部会生成一个隐藏主键(rowid，密集索引，该主键是一个六字节的列，该列的值随着记录的插入而自增)。</p>
<p>即innoDB必须得有一个主键作为密集索引存在，innodb引擎里的主键一般都是聚集索引；<br>非主键索引都是非聚集索引，非主键索引存储相关键位和其对应的主键值，要进行两次查找(先通过非主键索引去查找主键索引，再通过主键索引去查找数据的物理地址)。</p>
<p>InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如updatetable set num=1 where name like “a%”，就是说在不确定的范围时，InnoDB还是会锁表的。<br>InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM索引结构: MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。<br>B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。<br>主键索引和其他索引没有任何区别, 都是稀疏索引, 表数据存储在独立的地方MYD, 表数据MYD和索引MYI的分开的, 索引用地址指向表数据。</p>
<h3 id="两者的对比"><a href="#两者的对比" class="headerlink" title="两者的对比"></a>两者的对比</h3><ol>
<li>是否支持行级锁；</li>
<li>是否支持事务和崩溃后的安全恢复<br> MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。<br> InnoDB提供事务支持、外部键等高级数据库功能。</li>
<li>是否支持外键；</li>
<li>是否支持MVCC<br> 仅InnoDB支持。<br> 应对高并发事务，MVCC比单纯的加锁更高效；<br> MVCC只在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>两个隔离级别下工作；<br> MVCC可以使用乐观锁和悲观锁来实现；<br> 各数据库中MVCC实现并不统一。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MySQL-InnoDB存储引擎体系结构"><a href="#MySQL-InnoDB存储引擎体系结构" class="headerlink" title="MySQL InnoDB存储引擎体系结构"></a>MySQL InnoDB存储引擎体系结构</h2><p><img src="/posts/9977/mysql-innodb-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"><br><img src="/posts/9977/mysql-innodb-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%842.png"></p>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><p>原子性（atomicity，或称不可分割性）<br>一致性（consistency）<br>隔离性（isolation，又称独立性）<br>持久性（durability）</p>
<h3 id="标准事务的隔离级别"><a href="#标准事务的隔离级别" class="headerlink" title="标准事务的隔离级别"></a>标准事务的隔离级别</h3><ul>
<li><p>读未提交 read-uncommitted<br>  允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p>  事务对当前被读取的数据不加锁；<br>  事务在更新某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放。</p>
</li>
<li><p>读已提交 read-committed<br>  允许读取并发事务已经提交过的数据，可以防止脏读，但是幻读或不可重复读仍有可能发生。</p>
<p>  事务对当前被读取的数据加行级共享锁（当读到时才加锁），一旦读完该行，立即释放；<br>  事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放。</p>
<p>  Oracle/SQLserver的默认隔离级别是read committed，是允许幻读和不可重复读存在的。<br>  MySQL InnoDB在RC级别通过快照读解决了不可重复读问题。</p>
</li>
<li><p>可重复读 repeatable-read<br>  对同一数据记录的多次读取结果都是一致的，除非是被本身事务自己所修改，可以防止脏读和不可重复读，但幻读仍有可能发生。</p>
<p>  事务在读取某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放；<br>  事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放。</p>
<p>  MySQL InnoDB默认隔离级别是RR，在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。</p>
</li>
<li><p>串行化 serializable<br>  最高的隔离级别，完全服从ACID的隔离级别。<br>  所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。</p>
<p>  事务在读取数据是，必须先对其加表级共享锁，直到事务结束才释放；<br>  事务在更新数据时，必须先对其加表级排他锁，知道事务结束才释放。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h3><ul>
<li><p>脏读 dirty read<br>  当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”。</p>
</li>
<li><p>不可重复读 unrepeatable read<br>  一个事务对同一数据的读取结果前后不一致。<br>  与脏读的区别在于，脏读的是另一事务未提交的数据，不可重复读的是另一事务已经提交的数据，只不过数据被其他事务修改过。</p>
<p>  事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p>
</li>
<li><p>幻读 phantom read<br>  事务读取某个范围的数据时，因为其他事务的insert操作导致前后两次读取的结果不一致。<br>  幻读和不可重复读的区别在于，不可重复读是针对确定的某一行数据而言，而幻读是针对不确定的多行数据，因此幻读通常出现在带有查询条件的范围查询中。<br>  一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询不存在的行。</p>
<p>  系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>
</li>
<li><p>更新丢失(Lost Update)或脏写<br>  当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。</p>
</li>
</ul>
<h3 id="事务并发场景"><a href="#事务并发场景" class="headerlink" title="事务并发场景"></a>事务并发场景</h3><ul>
<li>读读情况<br>  并发事务相继读取相同记录，允许发生。</li>
<li>读-写或写-读情况<br>  读-写或写-读，即一个事务进行读取操作，另一个进行改动操作。<br>  这种情况下可能发生脏读、不可重复读、幻读的问题。</li>
<li>写写情况<br>  这种情况会出现脏写的问题，任何一种隔离级别都不允许这种问题的发生，是通过加锁来实现的。</li>
</ul>
<h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>怎么解决脏读、不可重复读、幻读的问题，有两种解决方案。</p>
<ul>
<li>方案一：读操作利用多版本并发控制(MVCC)，写操作进行加锁</li>
<li>方案二：读写操作都采用加锁的方法</li>
</ul>
<p>MySQL的InnoDB存储引擎默认事务隔离级别是<code>RR(可重复读)</code>，是通过 <code>next-key锁 + MVCC</code>一起实现的，正常读的时候不加锁，写的时候加锁。</p>
<h2 id="MySQL-InnoDB事务原理"><a href="#MySQL-InnoDB事务原理" class="headerlink" title="MySQL InnoDB事务原理"></a>MySQL InnoDB事务原理</h2><h3 id="MySQL-InnoDB事务特性实现"><a href="#MySQL-InnoDB事务特性实现" class="headerlink" title="MySQL InnoDB事务特性实现"></a>MySQL InnoDB事务特性实现</h3><ul>
<li>A-原子性；原子性通过undo log实现；</li>
<li>C-一致性；通过原子性、隔离性、持久性实现的；</li>
<li>I-隔离性；隔离级别，通过MVCC + 锁实现；</li>
<li>D-持久性；持久性通过redo log实现；</li>
</ul>
<h3 id="MySQL-InnoDB的事务隔离级别的实现原理"><a href="#MySQL-InnoDB的事务隔离级别的实现原理" class="headerlink" title="MySQL InnoDB的事务隔离级别的实现原理"></a>MySQL InnoDB的事务隔离级别的实现原理</h3><p>标准SQL事务隔离级别的实现是依赖锁的。<br>InnoDB使用不同的锁策略(Locking Strategy)以及MVCC机制来实现不同的隔离级别。</p>
<h4 id="读未提交-Read-UnCommitted"><a href="#读未提交-Read-UnCommitted" class="headerlink" title="读未提交 Read UnCommitted"></a>读未提交 Read UnCommitted</h4><p>事务对当前被读取的数据不加锁，都是<code>当前读</code>。<br>事务在更新某数据的瞬间，对其加行级共享锁，直到事务结束才释放。</p>
<h4 id="读已提交-Read-Committed"><a href="#读已提交-Read-Committed" class="headerlink" title="读已提交 Read Committed"></a>读已提交 Read Committed</h4><p>事务对当前被读取的数据不加锁，且是<code>快照读</code>。<br>事务在更新某数据的瞬间，对其加行级排他锁（Record Lock），直到事务结束才释放。</p>
<p>通过快照读，MySQL InnoDB在RC级别就解决了不可重复读的问题。</p>
<h4 id="可重复读-Repeatable-Read"><a href="#可重复读-Repeatable-Read" class="headerlink" title="可重复读 Repeatable Read"></a>可重复读 Repeatable Read</h4><p>事务对当前被读取的数据不加锁，且是<code>快照读</code>。<br>事务在更新某数据的瞬间，对其加行级排他锁（Record + gap = next-key lock），直到事务结束才释放。</p>
<p>通过临键锁，MySQL InnoDB在RR级别解决了幻读。</p>
<h4 id="序列化读"><a href="#序列化读" class="headerlink" title="序列化读"></a>序列化读</h4><p>事务在读取数据时，必须先对其加表级共享锁，直到事务结束才释放，都是<code>当前读</code>。<br>事务在更新数据时，必须先对其加表级排他锁，直到事务结束才释放。</p>
<h2 id="MySQL-InnoDB的MVCC实现机制"><a href="#MySQL-InnoDB的MVCC实现机制" class="headerlink" title="MySQL InnoDB的MVCC实现机制"></a>MySQL InnoDB的MVCC实现机制</h2><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。<br>MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
<p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用不加锁的方式去处理读-写冲突，<code>实现读-写冲突不加锁</code>。</p>
<h3 id="什么是MySQL-InnoDB下的当前读和快照读"><a href="#什么是MySQL-InnoDB下的当前读和快照读" class="headerlink" title="什么是MySQL InnoDB下的当前读和快照读"></a>什么是MySQL InnoDB下的当前读和快照读</h3><p>快照读和当前读都是针对于某一行数据记录来说的。</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是最新版本。<br>像<code>UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE</code>、<code>SELECT ... FOR UPDATE</code>这些操作都是一种当前读。</p>
<p>为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>读取的是快照版本，也就是历史版本。<br>像不加锁的SELECT操作就是快照读，即不加锁的非阻塞读。</p>
<p>快照读的前提是隔离级别不是未提交读和序列化读级别。<br>因为未提交读总是读取最新的数据行，而不是符合当前事务版本的数据行；而序列化读则会对表加锁，退化成当前读。</p>
<h4 id="当前读，快照读和MVCC的关系"><a href="#当前读，快照读和MVCC的关系" class="headerlink" title="当前读，快照读和MVCC的关系"></a>当前读，快照读和MVCC的关系</h4><h3 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h3><blockquote>
<p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 4个隐式字段，undo日志 ，Read View 来实现的。</p>
</blockquote>
<h4 id="4个隐式字段"><a href="#4个隐式字段" class="headerlink" title="4个隐式字段"></a>4个隐式字段</h4><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p>
<ul>
<li>DB_ROW_ID 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li>DB_TRX_ID 6byte, 最近修改(修改/插入)事务ID，记录创建这条记录/最后一次修改该记录的事务ID</li>
<li>DB_ROLL_PTR 7byte, 回滚指针，用于配合undo日志，指向这条记录的上一个版本（存储于rollback segment里）</li>
<li>DELETED_BIT 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<h4 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h4><p>InnoDB把这些为了回滚而记录的这些东西称之为undo log。<br>这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。</p>
<p>undo log主要分为3种：</p>
<ul>
<li>Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li>
<li>Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li>
<li>Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 <ul>
<li>删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。</li>
<li>为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。<br>  为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）。<br>  如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li>
</ul>
</li>
</ul>
<h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p>
<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><h3 id="MVCC相关问题"><a href="#MVCC相关问题" class="headerlink" title="MVCC相关问题"></a>MVCC相关问题</h3><h4 id="RC、RR级别下的InnoDB快照读有什么不同"><a href="#RC、RR级别下的InnoDB快照读有什么不同" class="headerlink" title="RC、RR级别下的InnoDB快照读有什么不同"></a>RC、RR级别下的InnoDB快照读有什么不同</h4><p>正是Read View生成时机的不同，从而造成RC、RR级别下快照读的结果的不同</p>
<ul>
<li>RR快照读<br>  在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见。<br>  即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见。</li>
<li>RC快照读<br>  在RC级别下的事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。</li>
</ul>
<p>总之，<br>在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；<br>而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p>
<h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="加锁的目的"><a href="#加锁的目的" class="headerlink" title="加锁的目的"></a>加锁的目的</h4><p>数据库的锁是为了解决事务的隔离性问题，为了让事务之间相互不影响，每个事务进行操作的时候都会对数据加上一把特有的锁，防止其他事务同时操作数据。</p>
<h4 id="锁是基于什么实现的"><a href="#锁是基于什么实现的" class="headerlink" title="锁是基于什么实现的"></a>锁是基于什么实现的</h4><p>在Innodb中，锁是作用在索引上面的，当我们的SQL命中索引时，那么锁住的就是命中条件内的索引节点(行锁)，如果没有命中索引的话，那我们锁的就是整个索引树（表锁）</p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><ul>
<li>基于锁的属性分类：共享锁、排他锁。</li>
<li>基于锁的粒度分类：行级锁(innodb)、表级锁(innodb、myisam)、页级锁(innodb引擎)、记录锁、间隙锁、临键锁、自增锁。</li>
<li>基于锁的状态分类：意向共享锁、意向排它锁。</li>
<li>基于加锁的态度分类：悲观锁、乐观锁。</li>
</ul>
<h3 id="InnoDB的锁类型"><a href="#InnoDB的锁类型" class="headerlink" title="InnoDB的锁类型"></a>InnoDB的锁类型</h3><h4 id="隐式锁定和显式锁定"><a href="#隐式锁定和显式锁定" class="headerlink" title="隐式锁定和显式锁定"></a>隐式锁定和显式锁定</h4><ul>
<li>隐式锁定<br>  InnoDB在事务执行过程中，使用两阶段锁协议（不主动进行显示锁定的情况）<ul>
<li>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</li>
<li>锁只有在事务执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</li>
</ul>
</li>
<li>显式锁定<br>  InnoDB也支持通过特定的语句进行显示锁定（存储引擎层）  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode <span class="operator">/</span><span class="operator">/</span>共享锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> update <span class="operator">/</span><span class="operator">/</span>排他锁</span><br></pre></td></tr></table></figure>
<h4 id="1-基本锁"><a href="#1-基本锁" class="headerlink" title="1. 基本锁"></a>1. 基本锁</h4>在一个高并发系统中，会出现多会话同时访问同一资源的情况，此时即产生了竞争。<br>为了保证数据的一致性，必须要用锁机制来控制资源的并发访问。</li>
</ul>
<p>InnoDB采用的行锁的设计（MyISAM只支持表锁），行锁带来更高的并发性，但管理复杂度也要比表锁更高。<br>InnoDB共实现了2种标准的行级锁：</p>
<ul>
<li>共享锁（S Lock），允许持有锁的事务读取数据。</li>
<li>排它锁（X Lock），允许持有锁的事务修改和删除数据。</li>
</ul>
<h4 id="2-意向锁-Intention-locks"><a href="#2-意向锁-Intention-locks" class="headerlink" title="2. 意向锁 Intention locks"></a>2. 意向锁 Intention locks</h4><p>InnoDB存储引擎支持多粒度的锁定，即允许行级锁和表级锁同时存在。</p>
<ul>
<li>意向共享锁（IS lock），表示事务想要获得表中某几行的共享锁。</li>
<li>意向排它锁（IX lock），表示事务想要获得表中某几行的排它锁。</li>
</ul>
<p>意向锁是一种表级锁，表示事务稍后希望在更细的粒度上（行级别）加锁。</p>
<ul>
<li>select … lock in share mode; 会对表施加IS锁</li>
<li>select … for update; 会对表施加IX锁</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">X</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">冲突</td>
<td align="center">冲突</td>
<td align="center">冲突</td>
<td align="center">冲突</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">冲突</td>
<td align="center">兼容</td>
<td align="center">冲突</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">冲突</td>
<td align="center">冲突</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">冲突</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<p>例如，如果请求在记录r上加X锁，则需要先在表级别上加意向排他锁（IX），如果此时表上存在其他锁，则意向锁需要等待表级别锁的释放，待表级意向锁(IX)获得成功后，才可以对行级别加X锁。</p>
<p>意向锁只会阻塞表级别的请求（如全表扫描、lock tables … write），除此之外不会阻塞任何操作。</p>
<h4 id="3-行锁-记录锁-Record-locks"><a href="#3-行锁-记录锁-Record-locks" class="headerlink" title="3. 行锁/记录锁 Record locks"></a>3. 行锁/记录锁 Record locks</h4><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，而不是给表的行记录加锁实现的，这就意味着只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。</p>
<p>由于InnoDB的行锁实现是针对索引字段添加的锁，不是针对行记录加的锁，因此虽然访问的是InnoDB引擎下表的不同行，但如果使用相同的索引字段作为过滤条件，依然会发生锁冲突，只能串行进行，不能并发进行。</p>
<p>即使SQL中使用了索引，但是经过MySQL的优化器后，如果认为全表扫描比使用索引效率高，此时会放弃使用索引，因此也不会使用行锁，而是使用表锁。</p>
<p>例如：<code>select col from t where col=1 for update;</code> 即对col为1的记录添加记录锁，阻止其他事务对此记录的操作。</p>
<h4 id="4-间隙锁-Gap-locks"><a href="#4-间隙锁-Gap-locks" class="headerlink" title="4. 间隙锁 Gap locks"></a>4. 间隙锁 Gap locks</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</p>
<p>例如：<code>select col from t where col between 1 and 10 for update;</code>会锁住1~10之间的间隙，而不管这段间隙内是否存在记录，因此间隙锁可能只锁住了一段空气。此时如果想插入为col为5的记录会被阻塞，即使5的记录不存在。</p>
<p>间隙锁的唯一目的即是阻止其他的事务往间隙中插入记录，因此不同的事务可以对同样的间隙重复加锁，没有共享和排他类型之分。</p>
<h5 id="InnoDB自动使用间隙锁的条件"><a href="#InnoDB自动使用间隙锁的条件" class="headerlink" title="InnoDB自动使用间隙锁的条件"></a>InnoDB自动使用间隙锁的条件</h5><ol>
<li><code>可重复读 Repeatable Read</code>级别下才会有间隙锁。必须在RR级别下。</li>
<li>检索条件必须有索引。（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打开间隙锁设置</span><br><span class="line">innodb_locks_unsafe_for_binlog：默认值为OFF，即启用间隙锁</span><br></pre></td></tr></table></figure>

<h4 id="5-临键锁-Next-Key-locks"><a href="#5-临键锁-Next-Key-locks" class="headerlink" title="5. 临键锁 Next-Key locks"></a>5. 临键锁 Next-Key locks</h4><p>行锁与间隙锁组合起来用就叫做Next-Key Lock。<br>InnoDB默认加锁方式是<code>next-key</code>锁。</p>
<p><code>next-key lock</code>会对记录本身和记录之前的区间加锁。</p>
<blockquote>
<p>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.</p>
</blockquote>
<p>如果一个会话占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。</p>
<blockquote>
<p>If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order.</p>
</blockquote>
<p>例如：假设表中存在索引记录1,10。则next-key lock可能锁住的范围是：(-∞,1]、(1,10]、(10,+∞），对于最后一个区间，next-key lock也会锁住最大记录之后的间隙。</p>
<blockquote>
<p><code>Next-key lock</code>只在<code>MySQL InnoDB</code>的<code>*repeatable read</code>隔离级别下使用，主要是用来解决<code>幻读(phantom read)</code>的问题。</p>
</blockquote>
<p>当对唯一键值进行锁定时，查询的索引含有唯一属性，next-key lock将会降级为record lock，即仅锁住唯一记录。<br>而如果唯一键由多个列组成，而查询仅使用其中一列，则其实是range查询，InnoDB会依然使用next-key lock进行锁定。</p>
<h4 id="6-插入意向锁-Insert-intention-locks"><a href="#6-插入意向锁-Insert-intention-locks" class="headerlink" title="6. 插入意向锁 Insert intention locks"></a>6. 插入意向锁 Insert intention locks</h4><p>插入意向锁是间隙锁的一种，其由insert语句在插入记录前获取，代表将在间隙中插入记录的意向。</p>
<p>多个事务可以对同一个间隙重复加insert intention lock，只要插入的记录值不同，事务就不会冲突。</p>
<p>例如表中已存在记录1和10,两个事务分别想插入5和6。两个事务都会对1和10记录之间的间隙(2,9)加insert intention lock，但由于插入的记录值不同，因此后续对要插入的记录获取X锁的时候并不会冲突。</p>
<h4 id="7-自增锁-auto-inc-locks"><a href="#7-自增锁-auto-inc-locks" class="headerlink" title="7. 自增锁 auto-inc locks"></a>7. 自增锁 auto-inc locks</h4><p>自增锁是一种特殊类型的表锁，只要在事务对auto_increment类型的列插入数据时，才会施加auto-inc lock，此时其他想插入的事务都需要等待该锁的释放，而持有该锁的事务可以获得连续的primary key值。</p>
<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="MySQL-Server层日志"><a href="#MySQL-Server层日志" class="headerlink" title="MySQL Server层日志"></a>MySQL Server层日志</h3><h4 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h4><p>记录所有更改数据（insert、update、delete等）的语句，还用于复制。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>主从复制</li>
<li>数据恢复</li>
</ul>
<h5 id="STATMENT、ROW、MIXED"><a href="#STATMENT、ROW、MIXED" class="headerlink" title="STATMENT、ROW、MIXED"></a>STATMENT、ROW、MIXED</h5><ul>
<li>STATMENT<br>  基于 SQL 语句的复制(statement-based replication, SBR)，每一条修改数据的 SQL 语句都会记录到 bin log 中<ul>
<li>优点 不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</li>
<li>缺点 在某些情况下会导致主从数据不一致，比如执行sysdate()、sleep()等</li>
</ul>
</li>
<li>ROW<br>  基于行的复制(row-based replication, RBR)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了<ul>
<li>优点 不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题</li>
<li>缺点 会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</li>
</ul>
</li>
<li>MIXED<br>  基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 bin log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 bin log</li>
</ul>
<h4 id="错误日志（errorlog）"><a href="#错误日志（errorlog）" class="headerlink" title="错误日志（errorlog）"></a>错误日志（errorlog）</h4><p>记录启动、运行或停止mysqld时出现的问题。</p>
<h4 id="慢查询日志（slow-query-log）"><a href="#慢查询日志（slow-query-log）" class="headerlink" title="慢查询日志（slow query log）"></a>慢查询日志（slow query log）</h4><p>记录所有执行时间超过long_query_time秒的所有查询或者不适用索引的查询。</p>
<h4 id="一般查询日志（general-log）"><a href="#一般查询日志（general-log）" class="headerlink" title="一般查询日志（general log）"></a>一般查询日志（general log）</h4><p>记录建立的客户端连接和执行语句。</p>
<h3 id="InnoDB存储引擎事务相关日志"><a href="#InnoDB存储引擎事务相关日志" class="headerlink" title="InnoDB存储引擎事务相关日志"></a>InnoDB存储引擎事务相关日志</h3><h4 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h4><p>redo log 记录的是数据被事务操作后的样子。<br>redo log是InnoDB存储引擎层实现的（也就是说是 Innodb 存储引擎独有的），用于保障事务的持久性，主要用于掉电等故障恢复。</p>
<p>redo log记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。<br>redo log是用来恢复数据的，用于保障已提交事务的持久化特性。</p>
<h4 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h4><p>Undo log 记录的是数据被事务操作前的样子。<br>undo log是InnoDB存储引擎层实现的（也就是说是 Innodb 存储引擎独有的），用于保障事务的原子性，主要用于事务回滚和MVCC。</p>
<p>因此假如由于系统错误或者<code>rollback</code>操作而回滚的话可以根据undo log的信息来进行回滚到被修改前的状态。<br>undo log是用来回滚数据的，用于保障未提交事务的原子性。</p>
<p>由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。<br>undo log主要分为3种：</p>
<ul>
<li>Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li>
<li>Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li>
<li>Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 <ul>
<li>删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。</li>
<li>为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。<br>  为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）。<br>  如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li>
</ul>
</li>
</ul>
<h3 id="主从同步从数据库"><a href="#主从同步从数据库" class="headerlink" title="主从同步从数据库"></a>主从同步从数据库</h3><h4 id="中继日志（relay-log）"><a href="#中继日志（relay-log）" class="headerlink" title="中继日志（relay log）"></a>中继日志（relay log）</h4><p>一般情况下它在MySQL主从同步读写分离集群的从节点才开启，主节点不需要这个日志。</p>
<h2 id="数据库主备搭建"><a href="#数据库主备搭建" class="headerlink" title="数据库主备搭建"></a>数据库主备搭建</h2><h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><p><img src="/posts/9977/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.png"></p>
<ul>
<li>主库对外提供读写的操作</li>
<li>从库对外提供读的操作</li>
</ul>
<p>主从架构的优势</p>
<ul>
<li>读写分离，减少主库压力，提升服务性能</li>
<li>备份数据</li>
<li>高可用，实时灾备</li>
</ul>
<p>主从架构需要考虑的问题</p>
<ul>
<li>主从一致性</li>
<li>主从延迟</li>
</ul>
<h3 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h3><ul>
<li>主数据库有个<code>bin log</code>二进制文件，纪录了所有增删改SQL语句。（binlog线程）</li>
<li>从数据库把主数据库的bin log文件的SQL 语句复制到自己的<code>中继日志 relay log</code>（io线程）</li>
<li>从数据库的relay log重做日志文件，再执行一次这些sql语句。（Sql执行线程）</li>
</ul>
<p>详细的主从同步过程如下：<br><img src="/posts/9977/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86.png"></p>
<ul>
<li>主库的更新SQL(update、insert、delete)被写到binlog</li>
<li>从库发起连接，连接到主库</li>
<li>此时主库创建一个binlog dump thread，把bin log的内容发送到从库</li>
<li>从库启动之后，创建一个I/O线程-io_thread，读取主库传过来的bin log内容并写入到relay log</li>
<li>从库还会创建一个SQL线程-sql_thread，从relay log里面读取内容，从ExecMasterLog_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db</li>
</ul>
<h3 id="主主、主从、主备"><a href="#主主、主从、主备" class="headerlink" title="主主、主从、主备"></a>主主、主从、主备</h3><ul>
<li>主主<br>两台都是主数据库，同时对外提供读写操作。<br>客户端访问任意一台。<br>数据存在双向同步。</li>
<li>主从<br>一台是主数据库，对外提供读写操作。<br>一台是从数据库，对外提供读操作。<br>数据从主库同步到从库。</li>
<li>主备<br>一台是主数据库，对外提供读写操作。<br>一台是备库，只作为备份作用，不对外提供读写，主机挂了就取而代之。<br>数据从主库同步到备库。</li>
</ul>
<h3 id="主从一致性"><a href="#主从一致性" class="headerlink" title="主从一致性"></a>主从一致性</h3><h3 id="主从延迟"><a href="#主从延迟" class="headerlink" title="主从延迟"></a>主从延迟</h3><p>与主从数据同步相关的时间点有三个：</p>
<ul>
<li>主库执行完一个事务，写入binlog，我们把这个时刻记为T1；</li>
<li>主库同步数据给从库，从库接收完这个binlog的时刻，记录为T2；</li>
<li>从库执行完这个事务，这个时刻记录为T3。</li>
</ul>
<p>主从延迟，指一个事务，在从库执行完的时间和在主库执行完的时间差值，即T3-T1。</p>
<h4 id="导致主从延迟的情况"><a href="#导致主从延迟的情况" class="headerlink" title="导致主从延迟的情况"></a>导致主从延迟的情况</h4><ul>
<li>从库机器比主库机器性能差</li>
<li>从库的查询压力大，消耗大量CPU，影响同步速度</li>
<li>大事务，大表的DDL语句</li>
<li>网络延迟</li>
<li>从数据库太多</li>
<li>低版本的MySQL只支持单线程复制，如果主库并发高，来不及送到从库会导致延迟。<code>MySQL从5.6开始支持多线程复制</code>。</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h3 id="分布式系统唯一主键ID"><a href="#分布式系统唯一主键ID" class="headerlink" title="分布式系统唯一主键ID"></a>分布式系统唯一主键ID</h3></div><div class="tags"><a href="/tags/MySQL"><i class="fa fa-tag">MySQL</i></a></div><div class="post-nav"><a class="pre" href="/posts/35817.html">Linux常用命令总结</a><a class="next" href="/posts/23547.html">数据结构与算法——树</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '8359b7a19b78f2b9e112',
  clientSecret: '5ad69dc1633a1834322067d017b6313bd231457c',
  repo: 'gitalk',
  owner: 'Th3Crave',
  admin: ['Th3Crave'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-Server%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">MySQL Server体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">一条SQL的执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%AD%E4%B8%80%E6%9D%A1SQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-text">MySQL中一条SQL是如何执行的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E6%9B%B4%E6%96%B0%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%88%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="toc-text">准备更新一条数据到事务的提交的流程描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">MySQL存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Innodb"><span class="toc-text">Innodb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM"><span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">两者的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">MySQL InnoDB存储引擎体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="toc-text">数据库事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID%E7%89%B9%E6%80%A7"><span class="toc-text">ACID特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">标准事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">事务的并发问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-text">事务并发场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">并发问题的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="toc-text">MySQL InnoDB事务原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="toc-text">MySQL InnoDB事务特性实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">MySQL InnoDB的事务隔离级别的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4-Read-UnCommitted"><span class="toc-text">读未提交 Read UnCommitted</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4-Read-Committed"><span class="toc-text">读已提交 Read Committed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-Repeatable-Read"><span class="toc-text">可重复读 Repeatable Read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%BB"><span class="toc-text">序列化读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">MySQL InnoDB的MVCC实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVCC"><span class="toc-text">什么是MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMySQL-InnoDB%E4%B8%8B%E7%9A%84%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-text">什么是MySQL InnoDB下的当前读和快照读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-text">当前读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-text">快照读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8CMVCC%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">当前读，快照读和MVCC的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">MVCC实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%B8%AA%E9%9A%90%E5%BC%8F%E5%AD%97%E6%AE%B5"><span class="toc-text">4个隐式字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo%E6%97%A5%E5%BF%97"><span class="toc-text">undo日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-View"><span class="toc-text">Read View</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">整体流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-text">MVCC相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RC%E3%80%81RR%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84InnoDB%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-text">RC、RR级别下的InnoDB快照读有什么不同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81"><span class="toc-text">数据库锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">加锁的目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">锁是基于什么实现的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">锁的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%9A%84%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">InnoDB的锁类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E9%94%81%E5%AE%9A%E5%92%8C%E6%98%BE%E5%BC%8F%E9%94%81%E5%AE%9A"><span class="toc-text">隐式锁定和显式锁定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E9%94%81"><span class="toc-text">1. 基本锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%84%8F%E5%90%91%E9%94%81-Intention-locks"><span class="toc-text">2. 意向锁 Intention locks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A1%8C%E9%94%81-%E8%AE%B0%E5%BD%95%E9%94%81-Record-locks"><span class="toc-text">3. 行锁&#x2F;记录锁 Record locks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%97%B4%E9%9A%99%E9%94%81-Gap-locks"><span class="toc-text">4. 间隙锁 Gap locks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#InnoDB%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8%E9%97%B4%E9%9A%99%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">InnoDB自动使用间隙锁的条件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%B4%E9%94%AE%E9%94%81-Next-Key-locks"><span class="toc-text">5. 临键锁 Next-Key locks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81-Insert-intention-locks"><span class="toc-text">6. 插入意向锁 Insert intention locks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%87%AA%E5%A2%9E%E9%94%81-auto-inc-locks"><span class="toc-text">7. 自增锁 auto-inc locks</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%97%A5%E5%BF%97"><span class="toc-text">MySQL日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-Server%E5%B1%82%E6%97%A5%E5%BF%97"><span class="toc-text">MySQL Server层日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%EF%BC%88binlog%EF%BC%89"><span class="toc-text">二进制日志（binlog）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STATMENT%E3%80%81ROW%E3%80%81MIXED"><span class="toc-text">STATMENT、ROW、MIXED</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%EF%BC%88errorlog%EF%BC%89"><span class="toc-text">错误日志（errorlog）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%88slow-query-log%EF%BC%89"><span class="toc-text">慢查询日志（slow query log）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%88general-log%EF%BC%89"><span class="toc-text">一般查询日志（general log）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E6%97%A5%E5%BF%97"><span class="toc-text">InnoDB存储引擎事务相关日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%88redo-log%EF%BC%89"><span class="toc-text">重做日志（redo log）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%EF%BC%88undo-log%EF%BC%89"><span class="toc-text">回滚日志（undo log）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">主从同步从数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97%EF%BC%88relay-log%EF%BC%89"><span class="toc-text">中继日志（relay log）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E5%A4%87%E6%90%AD%E5%BB%BA"><span class="toc-text">数据库主备搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="toc-text">主从架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-text">主从同步原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%B8%BB%E3%80%81%E4%B8%BB%E4%BB%8E%E3%80%81%E4%B8%BB%E5%A4%87"><span class="toc-text">主主、主从、主备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">主从一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F"><span class="toc-text">主从延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">导致主从延迟的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-text">分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-text">读写分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%94%AF%E4%B8%80%E4%B8%BB%E9%94%AEID"><span class="toc-text">分布式系统唯一主键ID</span></a></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>