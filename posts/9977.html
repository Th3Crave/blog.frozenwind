<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。"><title>MySQL-前言 | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bbf19a98c9ae28f2e1e8cfcee1d9585e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL-前言</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/message/"><i class="fa fa-comment"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL-前言</h1><div class="post-meta">2019-07-24<span> | </span><span class="category"><a href="/categories/technology/">technology</a><a href="/categories/technology/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><a href="/categories/technology/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/">MySQL</a></span></div><div class="post-content"><h2 id="MySQL-Server体系结构"><a href="#MySQL-Server体系结构" class="headerlink" title="MySQL Server体系结构"></a>MySQL Server体系结构</h2><p><img src="/posts/9977/mysql-server-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p>
<h2 id="一条SQL的执行过程"><a href="#一条SQL的执行过程" class="headerlink" title="一条SQL的执行过程"></a>一条SQL的执行过程</h2><h3 id="系统是如何与MySQL交互的"><a href="#系统是如何与MySQL交互的" class="headerlink" title="系统是如何与MySQL交互的"></a>系统是如何与MySQL交互的</h3><h4 id="1-MySQL驱动、数据库连接池"><a href="#1-MySQL驱动、数据库连接池" class="headerlink" title="1. MySQL驱动、数据库连接池"></a>1. MySQL驱动、数据库连接池</h4><p>我们的系统在和 MySQL 数据库进行通信的时候，不是平白无故的就能接收和发送请求。就是这个<strong>MySQL驱动</strong>在底层帮我们做了对数据库的连接，只有建立了连接了，才能够有后面的交互。看下图：<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-1-mysql%E9%A9%B1%E5%8A%A8-1.png"></p>
<p>在系统和 MySQL 进行交互之前，MySQL 驱动会帮我们建立好连接，然后我们只需要发送 SQL 语句就可以执行 CRUD 了。一次 SQL 请求就会建立一个连接，多个请求就会建立多个连接，那么问题来了，我们系统肯定不是一个人在使用的，换句话说肯定是<strong>存在多个请求同时去争抢连接</strong>的情况。<br>我们的 web 系统一般都是部署在 tomcat 容器中的，而 tomcat 是可以并发处理多个请求的，这就会导致多个请求会去建立多个连接，然后使用完再都去关闭，这样会有什么问题呢？如下图：<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-1-mysql%E9%A9%B1%E5%8A%A8-2.png"></p>
<p>java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，所以如果每个请求都是新建连接和销毁连接，那这样势必会造成不必要的浪费和性能的下降，也就说上面的多线程请求的时候频繁的创建和销毁连接显然是不合理的，必然会大大降低我们系统的性能。<br>但是如果能提供一些固定的用来连接的线程，这样是不是不需要反复的创建和销毁连接了呢？这就是<strong>数据库连接池</strong>。</p>
<p><strong>数据库连接池</strong>，维护一定的连接数，方便系统获取连接，使用就去池子中获取，用完放回去就可以了，我们不需要关心连接的创建与销毁，也不需要关心线程池是怎么去维护这些连接的。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-1-mysql%E9%A9%B1%E5%8A%A8-3.png"></p>
<h4 id="2-MySQL连接池"><a href="#2-MySQL连接池" class="headerlink" title="2. MySQL连接池"></a>2. MySQL连接池</h4><p>业务系统是并发的，而 MySQL 接受请求的线程呢，只有一个吗？<br>其实 MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连接池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-2-mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0.png"></p>
<h3 id="MySQL在接收到系统发送的sql语句时做了哪些事情"><a href="#MySQL在接收到系统发送的sql语句时做了哪些事情" class="headerlink" title="MySQL在接收到系统发送的sql语句时做了哪些事情"></a>MySQL在接收到系统发送的sql语句时做了哪些事情</h3><h4 id="3-MySQL线程调用SQL接口"><a href="#3-MySQL线程调用SQL接口" class="headerlink" title="3. MySQL线程调用SQL接口"></a>3. MySQL线程调用SQL接口</h4><p>网络中的连接都是由线程来处理的，所谓网络连接说白了就是一次请求，每次请求都会有相应的线程去处理的。<br>也就是说<strong>对于 SQL 语句的请求在 MySQL 中是由一个个的线程去处理的</strong>。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-3-mysql%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86sql%E8%AF%B7%E6%B1%82.png"></p>
<p>那这些线程会怎么去处理这些请求？会做哪些事情？<br>MySQL 中处理请求的线程在获取到请求以后获取 SQL 语句去交给 SQL 接口去处理。</p>
<h4 id="4-解析器"><a href="#4-解析器" class="headerlink" title="4. 解析器"></a>4. 解析器</h4><p>假设现在有这样一个SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stuName,age,sex <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>但是这个 SQL 是写给我们人看的，机器哪里知道你在说什么？这个时候解析器就上场了。他会将 SQL 接口传递过来的 SQL 语句进行解析，翻译成 MySQL 自己能认识的语言。具体可以看<strong>MySQL - MySQL中SQL是如何解析的</strong>。</p>
<p><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-4-%E8%A7%A3%E6%9E%90%E5%99%A8.png"></p>
<p>现在 SQL 已经被解析成 MySQL 认识的样子的，那下一步是不是就是执行吗？理论上是这样子的，但是 MySQL 的强大远不止于此，它还会帮我们<strong>选择最优的查询路径</strong>。<br>什么叫最优查询路径？就是 MySQL 会按照自己认为的效率最高的方式去执行查询。<br>具体是怎么做到的呢？这就要说到 MySQL 的查询优化器了。</p>
<h4 id="5-优化器"><a href="#5-优化器" class="headerlink" title="5. 优化器"></a>5. 优化器</h4><p>查询优化器内部具体怎么实现的我们不需要关心，我们需要知道的是 MySQL 会帮我们去使用它自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本。</p>
<ul>
<li><strong>IO成本</strong><br>  即从磁盘把数据加载到内存的成本。<br>  默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是 1。所以 IO 的成本主要和页的大小有关。</li>
<li><strong>CPU成本</strong><br>  将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是 0.2。</li>
</ul>
<p>MySQL 优化器 会计算「IO 成本 + CPU成本」最小的那个索引来执行。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-5-%E4%BC%98%E5%8C%96%E5%99%A8.png"></p>
<p>优化器执行选出最优索引等步骤后，会去调用存储引擎接口，开始去执行被 MySQL 解析过和优化过的 SQL 语句。</p>
<h4 id="6-执行器、存储引擎"><a href="#6-执行器、存储引擎" class="headerlink" title="6. 执行器、存储引擎"></a>6. 执行器、存储引擎</h4><p>执行器是一个非常重要的组件，因为前面那些组件的操作最终必须通过执行器去调用存储引擎接口才能被执行。<br>执行器最终根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行。<br><img src="/posts/9977/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-6-%E6%89%A7%E8%A1%8C%E5%99%A8.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="MySQL中一条SQL是如何执行的"><a href="#MySQL中一条SQL是如何执行的" class="headerlink" title="MySQL中一条SQL是如何执行的"></a>MySQL中一条SQL是如何执行的</h4><p>大致过程如下：<br><strong>SQL ==&gt; 查询缓存 ==&gt; 解析器 ==&gt; 优化器 ==&gt; 执行器</strong></p>
<ul>
<li>客户端SQL发送到MySQL服务端，首先会去查询缓存里面查找，如果多次执行同一个SQL是会命中缓存中，此时直接通过缓存来取数据</li>
<li>若没有命中查询缓存，则将SQL发送给解析器，解析器会对SQL进行语法、语义分析，同时也会对SQL合法性进行校验</li>
<li>SQL语义解析出来后，优化器会对SQL语义进行优化，比如，是走索引还是全表扫描，优化器会根据实际情况来确定一个最优的执行方案（当然，不一定是最优的，只是给出MySQL认为是最优的执行方案）</li>
<li>优化完毕后，就给到执行器（调用具体某个存储引擎，例如innodb）进行执行SQL，取出SQL执行结果</li>
<li>最后将执行结果返回给客户端</li>
</ul>
<h4 id="准备更新一条数据到事务的提交的流程描述"><a href="#准备更新一条数据到事务的提交的流程描述" class="headerlink" title="准备更新一条数据到事务的提交的流程描述"></a>准备更新一条数据到事务的提交的流程描述</h4><p>从准备更新一条数据到事务的提交的流程描述</p>
<ul>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li>
<li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li>
<li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事 <ul>
<li>将redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li>
</ul>
</li>
<li>至此表示整个更新事务已经完成</li>
</ul>
<h2 id="MySQL中SQL是如何解析的"><a href="#MySQL中SQL是如何解析的" class="headerlink" title="MySQL中SQL是如何解析的"></a>MySQL中SQL是如何解析的</h2><h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="MySQL-Server层日志"><a href="#MySQL-Server层日志" class="headerlink" title="MySQL Server层日志"></a>MySQL Server层日志</h3><h4 id="1-二进制日志（binlog）"><a href="#1-二进制日志（binlog）" class="headerlink" title="1. 二进制日志（binlog）"></a>1. 二进制日志（binlog）</h4><p>记录所有更改数据（insert、update、delete等）的语句，还用于复制。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>主从复制</li>
<li>数据恢复</li>
</ul>
<h5 id="STATMENT、ROW、MIXED"><a href="#STATMENT、ROW、MIXED" class="headerlink" title="STATMENT、ROW、MIXED"></a>STATMENT、ROW、MIXED</h5><ul>
<li>STATMENT<br>  基于 SQL 语句的复制(statement-based replication, SBR)，每一条修改数据的 SQL 语句都会记录到 bin log 中<ul>
<li>优点 不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</li>
<li>缺点 在某些情况下会导致主从数据不一致，比如执行sysdate()、sleep()等</li>
</ul>
</li>
<li>ROW<br>  基于行的复制(row-based replication, RBR)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了<ul>
<li>优点 不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题</li>
<li>缺点 会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</li>
</ul>
</li>
<li>MIXED<br>  基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 bin log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 bin log。<br>  <strong>当 MySQL 判断可能数据不一致时，就用 row 格式，否则使用就用 statement 格式。</strong></li>
</ul>
<h4 id="2-错误日志（errorlog）"><a href="#2-错误日志（errorlog）" class="headerlink" title="2. 错误日志（errorlog）"></a>2. 错误日志（errorlog）</h4><p>记录启动、运行或停止mysqld时出现的问题。</p>
<h4 id="3-慢查询日志（slow-query-log）"><a href="#3-慢查询日志（slow-query-log）" class="headerlink" title="3. 慢查询日志（slow query log）"></a>3. 慢查询日志（slow query log）</h4><p>记录所有执行时间超过long_query_time秒的所有查询或者不适用索引的查询。</p>
<h4 id="4-一般查询日志（general-log）"><a href="#4-一般查询日志（general-log）" class="headerlink" title="4. 一般查询日志（general log）"></a>4. 一般查询日志（general log）</h4><p>记录建立的客户端连接和执行语句。</p>
<h3 id="InnoDB存储引擎事务相关日志"><a href="#InnoDB存储引擎事务相关日志" class="headerlink" title="InnoDB存储引擎事务相关日志"></a>InnoDB存储引擎事务相关日志</h3><h4 id="1-重做日志（redo-log）"><a href="#1-重做日志（redo-log）" class="headerlink" title="1. 重做日志（redo log）"></a>1. 重做日志（redo log）</h4><p>redo log 记录的是数据被事务操作后的样子。<br>redo log是InnoDB存储引擎层实现的（也就是说是 Innodb 存储引擎独有的），用于保障事务的持久性，主要用于掉电等故障恢复。</p>
<p>redo log记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。<br>redo log是用来恢复数据的，用于保障已提交事务的持久化特性。</p>
<h4 id="2-回滚日志（undo-log）"><a href="#2-回滚日志（undo-log）" class="headerlink" title="2. 回滚日志（undo log）"></a>2. 回滚日志（undo log）</h4><p>Undo log 记录的是数据被事务操作前的样子。<br>undo log是InnoDB存储引擎层实现的（也就是说是 Innodb 存储引擎独有的），用于保障事务的原子性，主要用于事务回滚和MVCC。</p>
<p>因此假如由于系统错误或者<code>rollback</code>操作而回滚的话可以根据undo log的信息来进行回滚到被修改前的状态。<br>undo log是用来回滚数据的，用于保障未提交事务的原子性。</p>
<p>由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。<br>undo log主要分为3种：</p>
<ul>
<li>Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li>
<li>Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li>
<li>Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 <ul>
<li>删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。</li>
<li>为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。<br>  为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）。<br>  如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li>
</ul>
</li>
</ul>
<h3 id="主从同步从数据库"><a href="#主从同步从数据库" class="headerlink" title="主从同步从数据库"></a>主从同步从数据库</h3><h4 id="中继日志（relay-log）"><a href="#中继日志（relay-log）" class="headerlink" title="中继日志（relay log）"></a>中继日志（relay log）</h4><p>一般情况下它在MySQL主从同步读写分离集群的从节点才开启，主节点不需要这个日志。</p>
</div><div class="tags"><a href="/tags/MySQL"><i class="fa fa-tag">MySQL</i></a></div><div class="post-nav"><a class="pre" href="/posts/35817.html">Linux常用命令总结</a><a class="next" href="/posts/23547.html">数据结构与算法——树</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '8359b7a19b78f2b9e112',
  clientSecret: '5ad69dc1633a1834322067d017b6313bd231457c',
  repo: 'gitalk',
  owner: 'Th3Crave',
  admin: ['Th3Crave'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-Server%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">MySQL Server体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">一条SQL的执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%8EMySQL%E4%BA%A4%E4%BA%92%E7%9A%84"><span class="toc-text">系统是如何与MySQL交互的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-MySQL%E9%A9%B1%E5%8A%A8%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">1. MySQL驱动、数据库连接池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MySQL%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">2. MySQL连接池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%9C%A8%E6%8E%A5%E6%94%B6%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%8F%91%E9%80%81%E7%9A%84sql%E8%AF%AD%E5%8F%A5%E6%97%B6%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-text">MySQL在接收到系统发送的sql语句时做了哪些事情</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-MySQL%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8SQL%E6%8E%A5%E5%8F%A3"><span class="toc-text">3. MySQL线程调用SQL接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">4. 解析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-text">5. 优化器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%89%A7%E8%A1%8C%E5%99%A8%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">6. 执行器、存储引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E4%B8%AD%E4%B8%80%E6%9D%A1SQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-text">MySQL中一条SQL是如何执行的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E6%9B%B4%E6%96%B0%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%88%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="toc-text">准备更新一条数据到事务的提交的流程描述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%ADSQL%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E7%9A%84"><span class="toc-text">MySQL中SQL是如何解析的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%97%A5%E5%BF%97"><span class="toc-text">MySQL日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-Server%E5%B1%82%E6%97%A5%E5%BF%97"><span class="toc-text">MySQL Server层日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%EF%BC%88binlog%EF%BC%89"><span class="toc-text">1. 二进制日志（binlog）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STATMENT%E3%80%81ROW%E3%80%81MIXED"><span class="toc-text">STATMENT、ROW、MIXED</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%EF%BC%88errorlog%EF%BC%89"><span class="toc-text">2. 错误日志（errorlog）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%88slow-query-log%EF%BC%89"><span class="toc-text">3. 慢查询日志（slow query log）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%80%E8%88%AC%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%88general-log%EF%BC%89"><span class="toc-text">4. 一般查询日志（general log）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E6%97%A5%E5%BF%97"><span class="toc-text">InnoDB存储引擎事务相关日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%88redo-log%EF%BC%89"><span class="toc-text">1. 重做日志（redo log）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%EF%BC%88undo-log%EF%BC%89"><span class="toc-text">2. 回滚日志（undo log）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">主从同步从数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97%EF%BC%88relay-log%EF%BC%89"><span class="toc-text">中继日志（relay log）</span></a></li></ol></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>