<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。"><title>Spring-IOC | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bbf19a98c9ae28f2e1e8cfcee1d9585e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring-IOC</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/message/"><i class="fa fa-comment"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring-IOC</h1><div class="post-meta">2020-10-27<span> | </span><span class="category"><a href="/categories/technology/">technology</a><a href="/categories/technology/Java/">Java</a><a href="/categories/technology/Java/%E6%A1%86%E6%9E%B6/">框架</a><a href="/categories/technology/Java/%E6%A1%86%E6%9E%B6/Spring/">Spring</a></span></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li><strong>Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean</strong>，这个就叫<strong>控制反转 - Inversion of Control (IoC)</strong></li>
<li>Spring 框架托管创建的Bean放在哪里呢？ 这便是<strong>Spring容器（IoC Container）</strong></li>
<li>Spring 框架为了更好让用户配置Bean，必然会引入<strong>不同方式来配置Bean</strong>？ 这便是<strong>xml配置，Java配置，注解配置</strong>等支持</li>
<li>Spring 框架既然接管了Bean的生成，必然需要<strong>管理整个Bean的生命周期</strong>等</li>
<li><strong>应用程序代码从Ioc Container中获取依赖的Bean，注入到应用程序中</strong>，这个过程叫 <strong>依赖注入(Dependency Injection，DI)</strong> ； 所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong></li>
<li>在依赖注入时，有哪些方式呢？这就是构造器方式，**@Autowired, @Resource, @Qualifier**… 同时Bean之间存在依赖（可能存在先后顺序问题，以及<strong>循环依赖</strong>问题等）</li>
</ol>
<h2 id="如何理解IoC"><a href="#如何理解IoC" class="headerlink" title="如何理解IoC"></a>如何理解IoC</h2><h3 id="Spring-Bean是什么"><a href="#Spring-Bean是什么" class="headerlink" title="Spring Bean是什么"></a>Spring Bean是什么</h3><p>IoC Container管理的是Spring Bean， 那么Spring Bean是什么呢？</p>
<p>Spring里面的bean就类似是定义的一个组件，而这个组件的作用就是实现某个功能的，这里所定义的bean就相当于给了你一个更为简便的方法来调用这个组件去实现你要完成的功能。</p>
<h3 id="IoC是什么"><a href="#IoC是什么" class="headerlink" title="IoC是什么"></a>IoC是什么</h3><p>Ioc—Inversion of Control，即“控制反转”，<strong>不是什么技术，而是一种设计思想</strong>。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p>
<ul>
<li><strong>谁控制谁，控制什么？</strong><br>  传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建。<br>  谁控制谁？当然是IoC 容器控制了对象。<br>  控制什么？那就是主要控制了外部资源获取（不只是对象，包括比如文件等）。</li>
<li><strong>为何是反转，哪些方面反转了？</strong><br>  有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象。<br>  为何是反转？因为由容器帮我们查找及注入依赖对象，程序只是被动的接受容器中的依赖对象，所以是反转。<br>  哪些方面反转了？依赖对象的获取方式被反转了。</li>
<li>图例说明<ul>
<li>传统程序设计<br>  <img src="/posts/19065/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-%E4%BC%A0%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.png"></li>
<li>IoC DI<br>  <img src="/posts/19065/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-ioc%E5%AE%B9%E5%99%A8.png"></li>
</ul>
</li>
</ul>
<h3 id="Ioc能做什么"><a href="#Ioc能做什么" class="headerlink" title="Ioc能做什么"></a>Ioc能做什么</h3><p>IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。</p>
<p>传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试。</p>
<p>有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p>
<h3 id="IoC和DI是什么关系"><a href="#IoC和DI是什么关系" class="headerlink" title="IoC和DI是什么关系"></a>IoC和DI是什么关系</h3><p>控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是IoC是设计思想，DI是实现方式。</p>
<p>DI—Dependency Injection，即依赖注入：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。<br>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<ul>
<li><strong>谁依赖于谁？</strong><br>  应用程序依赖于IoC容器。</li>
<li><strong>为什么需要依赖？</strong><br>  应用程序需要IoC容器注入应用程序依赖的对象。</li>
<li><strong>谁注入谁？</strong><br>  IoC容器将应用程序所依赖的对象注入应用程序中。</li>
<li><strong>注入了什么？</strong><br>  注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</li>
<li><strong>IoC和DI有什么关系？</strong><br>  “依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。<br>  通俗来说就是IoC是设计思想，DI是实现方式。</li>
</ul>
<h2 id="IoC和DI的使用"><a href="#IoC和DI的使用" class="headerlink" title="IoC和DI的使用"></a>IoC和DI的使用</h2><h3 id="IoC配置的三种方式"><a href="#IoC配置的三种方式" class="headerlink" title="IoC配置的三种方式"></a>IoC配置的三种方式</h3><p>总体上目前的主流方式是 注解 + Java 配置。</p>
<h4 id="xml配置-古老"><a href="#xml配置-古老" class="headerlink" title="xml配置 - 古老"></a>xml配置 - 古老</h4><p>就是将bean的信息配置<code>.xml文件</code>里，通过Spring加载文件为我们创建bean。<br>这种方式出现很多早前的SSM项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是由于第三方类不支持Spring注解。</p>
<h4 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h4><p>将类的创建交给我们配置的JavcConfig类来完成，Spring只负责维护和管理，采用纯Java创建方式。<br>其本质上就是把在XML上的配置声明转移到Java配置类中。</p>
<ul>
<li>创建一个配置类， 添加@Configuration注解声明为配置类</li>
<li>创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDaoImpl <span class="title">userDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userService&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserServiceImpl <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>通过在类上加注解的方式，来声明一个类交给Spring管理。<br>Spring会自动扫描带有@Component、@Controller、@Service、@Repository这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器@ComponentScan。</p>
<h3 id="依赖注入的三种方式"><a href="#依赖注入的三种方式" class="headerlink" title="依赖注入的三种方式"></a>依赖注入的三种方式</h3><p>常用的注入方式主要有三种：构造器注入（Construct Injection），Setter方法注入，字段注入（Field Injection）</p>
<ul>
<li>构造函数注入：<ul>
<li>适合于强制依赖，适合在创建对象的同时必须要初始化的属性，但是要注入的依赖多了会导致构造器相对臃肿；</li>
<li>构造器注入时，循环依赖问题无法有效解决，会在启动的时候报错。</li>
</ul>
</li>
<li>Setter方法注入：<ul>
<li>适合于可选依赖，当没有提供相关依赖时，类能够正常工作；</li>
<li>相对更加灵活，可以多次调用，循环依赖问题（Setter注入的单例bean）可以通过Spring的单例Bean的三级缓存解决。</li>
</ul>
</li>
<li>字段注入：<ul>
<li>构造函数注入和字段注入发生在对象实例化的早期，而setter方法注入发生在对象实例化之后。</li>
<li>所以在 Spring 中，构造函数注入和字段注入存在循环依赖时，Spring 无法直接解决这些循环依赖问题，而只能通过特定的机制（单例的三级缓存）解决 setter 方法注入的循环依赖。</li>
</ul>
</li>
</ul>
<h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><p>在Spring4.x版本中推荐的注入方式就是这种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyDependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(MyDependency dependency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么推荐构造器注入方式？</strong><br>构造器注入的方式能够保证注入的组件不可变，并且确保需要的依赖不为空。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。</p>
<ul>
<li>依赖不可变：其实说的就是final关键字。</li>
<li>依赖不为空（省去了我们对其检查）：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数-&gt;传入，OK 。2：无该类型的参数-&gt;报错。</li>
<li>完全初始化的状态：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。</li>
</ul>
<h4 id="Setter方法注入"><a href="#Setter方法注入" class="headerlink" title="Setter方法注入"></a>Setter方法注入</h4><p>在Spring3.x刚推出的时候，推荐使用注入的就是这种，但是这种方式比较麻烦，所以在Spring4.x版本中推荐构造函数注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyDependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependency</span><span class="params">(MyDependency dependency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用setter注入，缺点显而易见，对于IOC容器以外的环境，除了使用反射来提供它需要的依赖之外，无法复用该实现类。而且将一直是个潜在的隐患，因为你不调用将一直无法发现NPE的存在。</p>
<h4 id="字段注入"><a href="#字段注入" class="headerlink" title="字段注入"></a>字段注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>循环依赖的问题</strong>：使用field注入可能会导致循环依赖，即A里面注入B，B里面又注入A。<br>如果使用构造器注入，在spring项目启动的时候，就会抛出：BeanCurrentlyInCreationException：Requested bean is currently in creation: Is there an unresolvable circular reference？从而提醒你避免循环依赖，如果是field注入的话，启动的时候不会报错，在使用那个bean的时候才会报错。</p>
<p>实际上，Spring 5.x中使用@Autowired属性注入，发生循环依赖时，在SpringBootApplication启动时就会报循环依赖的错误。</p>
<p><strong>@Autowired、@Resource、@Inject等注解注入有何区别？</strong><br>Spring对于@Autowired、@Resource注解使用不同的后置处理器进行处理。<br>Spring使用<strong>AutowiredAnnotationBeanPostProcessor</strong>和<strong>CommonAnnotationBeanPostProcessor</strong>类分别处理<code>@Autowired注解</code>和<code>@Resource注解</code>，它们都实现了InstantiationAwareBeanPostProcessor类，所以标注了@Autowired、@Resource会在第六次调用bean的后置处理器的时候完成属性注入。</p>
<p>对于static属性，如果标注了@Resource的是static静态的属性或方法，那么会直接报错；如果标注了@Autowired的是static静态的属性或方法，那么Spring会直接忽略，但不会报错。</p>
<ul>
<li><p>@Autowired</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Autowired可以用在这些地方</span></span><br><span class="line"><span class="meta">@Target(ElementType.CONSTRUCTOR)</span> #构造函数</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> #方法</span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span> #方法参数</span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量</span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span> #注解</span><br></pre></td></tr></table></figure>

<p>  @Autowired是Spring自带的注解，通过AutowiredAnnotationBeanPostProcessor类实现的依赖注入<br>  @Autowired可以作用在CONSTRUCTOR、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE<br>  @Autowired默认是根据类型（byType ）进行自动装配的<br>  如果有多个类型一样的Bean候选者，需要指定按照名称（byName ）进行装配，则需要配合@Qualifier。</p>
</li>
<li><p>@Resource</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Resource &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> #接口、类、枚举、注解</span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> #方法</span><br></pre></td></tr></table></figure>

<p>  @Resource是JSR250规范的实现，在javax.annotation包下<br>  @Resource可以作用TYPE、FIELD、METHOD上<br>  @Resource是默认根据属性名称进行自动装配的，如果有多个类型一样的Bean候选者，则可以通过name进行指定进行注入</p>
</li>
<li><p>@Inject</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; METHOD, CONSTRUCTOR, FIELD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inject &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.CONSTRUCTOR)</span> #构造函数</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> #方法</span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span> #字段、枚举的常量</span><br></pre></td></tr></table></figure>

<p>  @Inject是JSR330 (Dependency Injection for Java)中的规范，需要导入javax.inject.Inject jar包，才能实现注入<br>  @Inject可以作用CONSTRUCTOR、METHOD、FIELD上<br>  @Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named</p>
</li>
</ul>
<h2 id="站在设计者的角度考虑设计IOC容器"><a href="#站在设计者的角度考虑设计IOC容器" class="headerlink" title="站在设计者的角度考虑设计IOC容器"></a>站在设计者的角度考虑设计IOC容器</h2><p>如果让你来设计一个IoC容器，你会怎么设计？我们初步的通过这个问题，来帮助我们更好的理解IOC的设计。</p>
<p>在设计时，首先需要考虑的是IOC容器的功能（输入和输出），初步的画出IOC容器的整体功能。<br><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%80%83%E8%99%91%E8%AE%BE%E8%AE%A1.png"></p>
<p>在此基础上，我们初步的去思考，如果作为一个IOC容器的设计者，主体上应该包含哪几个部分：</p>
<ul>
<li>加载Bean的配置（比如xml配置、注解配置等） <ul>
<li>比如不同类型资源的加载，解析成生成统一Bean的定义</li>
</ul>
</li>
<li>根据Bean的定义加载生成Bean的实例，并放置在Bean容器中 <ul>
<li>比如Bean的依赖注入，Bean的嵌套，Bean存放（缓存）等</li>
</ul>
</li>
<li>除了基础Bean外，还有常规针对企业级业务的特别Bean <ul>
<li>比如国际化Message，事件Event等生成特殊的类结构去支撑</li>
</ul>
</li>
<li>对容器中的Bean提供统一的管理和调用 <ul>
<li>比如用工厂模式管理，提供方法根据名字/类的类型等从容器中获取Bean</li>
</ul>
</li>
<li>…</li>
</ul>
<h2 id="IOC体系结构设计"><a href="#IOC体系结构设计" class="headerlink" title="IOC体系结构设计"></a>IOC体系结构设计</h2><h3 id="BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册"><a href="#BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册" class="headerlink" title="BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册"></a>BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册</h3><p>Spring Bean的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用，这是IOC容器的基础。<br>在顶层的结构设计主要围绕着BeanFactory和xxxRegistry进行：</p>
<ul>
<li>BeanFactory： 工厂模式定义了IOC容器的基本功能规范</li>
<li>BeanRegistry： 向IOC容器手工注册 BeanDefinition 对象的方法</li>
</ul>
<p><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-beanfactory&beanregistry.png"></p>
<p><strong>BeanFactory定义了IOC容器基本功能规范？</strong><br>BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范。<br>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和AutowireCapableBeanFactory。</p>
<p>看下BeanFactory接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//用于取消引用实例并将其与FactoryBean创建的bean区分开来。例如，如果命名的bean是FactoryBean，则获取将返回Factory，而不是Factory返回的实例。</span></span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>; </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//根据bean的名字或者Class类型等来得到bean实例    </span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;    </span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Class requiredType)</span> <span class="keyword">throws</span> BeansException</span>;    </span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回指定bean的Provider</span></span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查工厂中是否包含给定name的bean，或者外部注册的bean</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查所给定name的bean是否为单例/原型</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断所给name的类型与type是否匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取给定name的bean的类型</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回给定name的bean的别名</span></span><br><span class="line">    String[] getAliases(String name);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>BeanFactory为何要定义这么多层次的接口？定义了哪些接口？</strong><br>主要是为了<strong>区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制</strong>。</p>
<ul>
<li><strong>ListableBeanFactory</strong><br>  该接口定义了访问容器中 Bean 基本信息的若干方法，如查看Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法；</li>
<li><strong>HierarchicalBeanFactory</strong><br>  父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器。<br>  通过 HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。<br>  Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</li>
<li><strong>ConfigurableBeanFactory</strong><br>  是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li>
<li><strong>ConfigurableListableBeanFactory</strong><br>  ListableBeanFactory 和 ConfigurableBeanFactory的融合；</li>
<li><strong>AutowireCapableBeanFactory</strong><br>  定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；</li>
</ul>
<p><strong>如何将Bean注册到BeanFactory中？BeanRegistry</strong><br>Spring 配置文件中每一个<code>&lt;bean&gt;</code>节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。</p>
<h3 id="BeanDefinition：各种Bean对象及其相互的关系"><a href="#BeanDefinition：各种Bean对象及其相互的关系" class="headerlink" title="BeanDefinition：各种Bean对象及其相互的关系"></a>BeanDefinition：各种Bean对象及其相互的关系</h3><p>Bean对象存在依赖嵌套等关系，所以设计者设计了BeanDefinition，它用来对Bean对象及关系定义。<br>我们在理解时只需要抓住如下三个要点：</p>
<ul>
<li>BeanDefinition 定义了各种Bean对象及其相互的关系</li>
<li>BeanDefinitionReader 这是BeanDefinition的解析器</li>
<li>BeanDefinitionHolder 这是BeanDefination的包装类，用来存储BeanDefinition、name以及aliases等。</li>
</ul>
<p>SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，在Spring实现中是以<strong>BeanDefinition</strong>来描述的，其继承体系如下：<br><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-BeanDefinition%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p>
<h3 id="ApplicationContext：IOC接口设计和实现"><a href="#ApplicationContext：IOC接口设计和实现" class="headerlink" title="ApplicationContext：IOC接口设计和实现"></a>ApplicationContext：IOC接口设计和实现</h3><p>IoC容器的接口类是ApplicationContext，很显然它必然继承BeanFactory对Bean规范（最基本的ioc容器的实现）进行定义。</p>
<p><strong>ApplicationContext表示的是应用的上下文</strong>，除了<strong>对Bean的管理</strong>外，还至少应该包含了</p>
<ul>
<li>访问资源： 对不同方式的Bean配置（即资源）进行加载。(实现ResourcePatternResolver接口)</li>
<li>国际化: 支持信息源，可以实现国际化。（实现MessageSource接口）</li>
<li>应用事件: 支持应用事件。(实现ApplicationEventPublisher接口)</li>
</ul>
<p><strong>ApplicationContext接口的设计</strong><br><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-ApplicationContext-%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1.png"></p>
<ul>
<li><strong>HierarchicalBeanFactory 和 ListableBeanFactory</strong><br>  ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能：</li>
<li><strong>ApplicationEventPublisher</strong><br>  让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。<br>  实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件，并对事件进行响应处理。<br>  在 ApplicationContext 抽象实现类AbstractApplicationContext 中，我们可以发现存在一个 ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。</li>
<li><strong>MessageSource</strong><br>  为应用提供 i18n 国际化消息访问的功能；</li>
<li><strong>ResourcePatternResolver</strong><br>  所有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。</li>
<li><strong>LifeCycle</strong><br>  该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。<br>  在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现，ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</li>
</ul>
<p><strong>ApplicationContext接口的实现</strong><br>在考虑ApplicationContext接口的实现时，关键的点在于，不同Bean的配置方式（比如xml、groovy、annotation等）有着不同的资源加载方式，这便衍生出了众多ApplicationContext的实现类。</p>
<p><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-ApplicationContext-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0.png"></p>
<ul>
<li>第一，从<strong>类结构设计</strong>上看，围绕着<strong>是否需要Refresh容器</strong>衍生出两个抽象类<ol>
<li><strong>GenericApplicationContext</strong><br> 初始化的时候就创建容器，往后的每次refresh都不会更改。</li>
<li><strong>AbstractRefreshableApplicationContext</strong><br> AbstractRefreshableApplicationContext及子类的每次refresh都是先清除已有(如果不存在就创建)的容器，然后再重新创建；<br> AbstractRefreshableApplicationContext及子类无法做到GenericApplicationContext混合搭配从不同源头获取bean的定义信息</li>
</ol>
</li>
<li>第二，从<strong>加载的源</strong>来看（比如xml、groovy、annotation等），衍生出众多类型的ApplicationContext<ul>
<li><strong>FileSystemXmlApplicationContext</strong><br>  从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说<strong>系统盘符中加载xml配置文件</strong>。</li>
<li><strong>ClassPathXmlApplicationContext</strong><br>  从<strong>类路径下的一个或多个xml配置文件</strong>中加载上下文定义，适用于<strong>xml配置</strong>的方式。</li>
<li><strong>AnnotationConfigApplicationContext</strong><br>  从一个或多个基于java的配置类中加载上下文定义，适用于<strong>java注解</strong>的方式。</li>
<li><strong>ConfigurableApplicationContext</strong><br>  扩展于 ApplicationContext，它新增加了两个主要的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。<br>  在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。<br>  这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。</li>
</ul>
</li>
</ul>
<p>设计者在设计时<strong>AnnotationConfigApplicationContext</strong>为什么是继承<strong>GenericApplicationContext</strong>？<br>因为基于注解的配置，是不太会被运行时修改的，这意味着不需要进行动态Bean配置和刷新容器，所以只需要GenericApplicationContext。</p>
<p>而基于XML这种配置文件，这种文件是容易修改的，需要动态性刷新Bean的支持，所以XML相关的配置必然继承AbstractRefreshableApplicationContext； 且存在多种xml的加载方式（位置不同的设计），所以必然会设计出AbstractXmlApplicationContext, 其中包含对XML配置解析成BeanDefination的过程。</p>
<p>为什么<strong>AnnotationWebConfigApplicationContext</strong>继承自<strong>AbstractRefreshableApplicationContext</strong>呢？<br>因为用户可以通过ApplicationContextInitializer来设置contextInitializerClasses（context-param / init-param），在这种情况下用户倾向于<strong>刷新Bean</strong>的，所以设计者选择让AnnotationWebConfigApplicationContext继承了AbstractRefreshableApplicationContext。</p>
<p>把之前的设计要点和设计结构结合起来看：<br><img src="/posts/19065/ioc-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9B%B8%E7%BB%93%E5%90%88.png"></p>
</div><div class="tags"><a href="/tags/Spring"><i class="fa fa-tag">Spring</i></a></div><div class="post-nav"><a class="pre" href="/posts/17849.html">Spring-AOP</a><a class="next" href="/posts/24905.html">MySQL-索引原理及慢查询优化</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '8359b7a19b78f2b9e112',
  clientSecret: '5ad69dc1633a1834322067d017b6313bd231457c',
  repo: 'gitalk',
  owner: 'Th3Crave',
  admin: ['Th3Crave'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3IoC"><span class="toc-text">如何理解IoC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Bean%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Spring Bean是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">IoC是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ioc%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">Ioc能做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoC%E5%92%8CDI%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-text">IoC和DI是什么关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC%E5%92%8CDI%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">IoC和DI的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IoC%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">IoC配置的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xml%E9%85%8D%E7%BD%AE-%E5%8F%A4%E8%80%81"><span class="toc-text">xml配置 - 古老</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E9%85%8D%E7%BD%AE"><span class="toc-text">Java配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE"><span class="toc-text">注解配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">依赖注入的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5"><span class="toc-text">构造函数注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Setter%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="toc-text">Setter方法注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5"><span class="toc-text">字段注入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%99%E5%9C%A8%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E8%A7%92%E5%BA%A6%E8%80%83%E8%99%91%E8%AE%BE%E8%AE%A1IOC%E5%AE%B9%E5%99%A8"><span class="toc-text">站在设计者的角度考虑设计IOC容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">IOC体系结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory%E5%92%8CBeanRegistry%EF%BC%9AIOC%E5%AE%B9%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A7%84%E8%8C%83%E5%92%8CBean%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-text">BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinition%EF%BC%9A%E5%90%84%E7%A7%8DBean%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E7%9B%B8%E4%BA%92%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">BeanDefinition：各种Bean对象及其相互的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContext%EF%BC%9AIOC%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">ApplicationContext：IOC接口设计和实现</span></a></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>