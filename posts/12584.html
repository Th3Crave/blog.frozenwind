<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。"><title>Java IO - NIO | frozeNwInd</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bbf19a98c9ae28f2e1e8cfcee1d9585e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java IO - NIO</h1><a id="logo" href="/.">frozeNwInd</a><p class="description">吕乘风的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/message/"><i class="fa fa-comment"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java IO - NIO</h1><div class="post-meta">2023-03-21<span> | </span><span class="category"><a href="/categories/technology/">technology</a><a href="/categories/technology/Java/">Java</a><a href="/categories/technology/Java/IO/">IO</a></span></div><div class="post-content"><h2 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h2><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>
<h3 id="Java-IO与NIO的区别"><a href="#Java-IO与NIO的区别" class="headerlink" title="Java IO与NIO的区别"></a>Java IO与NIO的区别</h3><p>标准IO是对字节流的读写，在进行IO之前，首先创建一个流对象，流对象进行读写操作都是按字节 ，一个字节一个字节的来读或写。<br>而NIO把IO抽象成块，类似磁盘的读写，每次IO操作的单位都是一个块，块被读入内存之后就是一个byte[]，NIO一次可以读或写多个字节。</p>
<p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>Java NIO 由以下几个核心部分组成： </p>
<ol>
<li>缓冲区 Buffer</li>
<li>通道 Channel </li>
<li>选择器 Selector</li>
</ol>
<p>传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。<br>NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。</p>
<p>NIO的主要用途是网络IO，在NIO之前java要使用网络编程就只有用Socket。而Socket是阻塞的，显然对于高并发的场景是不适用的。所以NIO的出现就是解决了这个痛点。</p>
<p>主要思想是把Channel通道注册到Selector中，通过Selector去监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动。没有监听的事件，服务器可以做自己的事情。</p>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>Buffer是一个内存块。<br>在NIO中，所有的数据都是用Buffer处理，有读写两种模式。在读模式下，应用程序只能从Buffer中读取数据，不能进行写操作。但是在写模式下，应用程序是可以进行读操作的，这就表示可能会出现脏读的情况。所以一旦决定要从Buffer中读取数据，一定要将Buffer的状态改为读模式。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。<br>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>常用的四种channel</p>
<ul>
<li>FileChannel，读写文件中的数据。</li>
<li>SocketChannel，TCP Socket套接字的监听通道，一个<strong>Socket套接字</strong>对应了一个<strong>客户端IP: 端口 到 服务器IP: 端口</strong>的通信连接。</li>
<li>ServerSockectChannel，应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持<strong>多路复用IO</strong>的端口监听。同时支持UDP协议和TCP协议。</li>
<li>DatagramChannel，UDP 数据报文的监听通道。</li>
</ul>
<p>Channel本身并不存储数据，只是负责数据的运输。必须要和Buffer一起使用。</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector，选择器/多路复用器/轮询代理器/事件订阅器/channel容器管理机。<br>只有网络IO才会使用选择器，文件IO是不需要使用的。<br>选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现单线程管理多个Channel的目的。</p>
<ul>
<li>事件订阅和Channel管理<br>  应用程序将向Selector对象注册需要它关注的Channel，以及具体的某一个Channel会对哪些IO事件感兴趣。Selector中也会维护一个“已经注册的Channel”的容器。</li>
<li>轮询代理<br>  应用程序不再通过阻塞模式或者非阻塞模式直接询问操作系统“事件有没有发生”，而是由Selector代其询问。</li>
<li>实现不同操作系统的支持<br>  多路复用IO技术是需要操作系统进行支持的，其特点就是操作系统可以同时扫描同一个端口上不同网络连接的事件。<br>  所以作为上层的JVM，必须要为不同操作系统的多路复用IO实现编写不同的代码。</li>
</ul>
<p><strong>NIO 实现了 IO 多路复用中的 Reactor 模型</strong>，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>监听配置为<strong>非阻塞的通道 Channel</strong>，那么当该 Channel 上的 IO 事件还未到达时，Selector 就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。<br>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。<br>应该注意的是，<strong>只有 SocketChannel 才能配置为非阻塞</strong>，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<p><img src="/posts/12584/javanio-selector.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、将通道注册到选择器上</span></span><br><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 通道配置为非阻塞</span></span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 注册的具体事件</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_CONNECT</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_ACCEPT</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_READ</span></span><br><span class="line"><span class="comment">// SelectionKey.OP_WRITE</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、监听事件 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</span></span><br><span class="line"><span class="keyword">int</span> num = selector.select();</span><br><span class="line"><span class="comment">// 4、获取到达的事件</span></span><br><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5、事件循环</span></span><br><span class="line"><span class="comment">// 因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="零拷贝在Java中的实现"><a href="#零拷贝在Java中的实现" class="headerlink" title="零拷贝在Java中的实现"></a>零拷贝在Java中的实现</h3><p>如果涉及到文件传输，transferTo是首选，但是如果涉及到对内存数据的修改选用MappedByteBuffer。</p>
<h4 id="mmap-MappedByteBuffer"><a href="#mmap-MappedByteBuffer" class="headerlink" title="mmap - MappedByteBuffer"></a>mmap - MappedByteBuffer</h4><p>MappedByteBuffer 是 Java 中的 mmap 操作类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. MappedByteBuffer 可让文件直接在内存(堆外内存)修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应的通道</span></span><br><span class="line">        FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1: FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">         * 参数2： 0 ： 可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">         * 参数3:  5: 是映射到内存的大小(不是索引位置) ,即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">         * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;Y&#x27;</span>);<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sendfile-FileChannel-transferTo"><a href="#sendfile-FileChannel-transferTo" class="headerlink" title="sendfile - FileChannel.transferTo()"></a>sendfile - FileChannel.transferTo()</h4><p>FileChannel的transferTo()/transferFrom()，底层就是sendfile() 系统调用函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        <span class="comment">//得到一个文件channel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.zip&quot;</span>).getChannel();</span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//在linux下一个transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在windows 下 一次调用 transferTo 只能发送8m , 就需要分段传输文件, 而且要主要</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总的字节数 =&quot;</span> + transferCount + <span class="string">&quot; 耗时:&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java对IO多路复用的支持"><a href="#Java对IO多路复用的支持" class="headerlink" title="Java对IO多路复用的支持"></a>Java对IO多路复用的支持</h3><p><img src="/posts/12584/java%E5%AF%B9IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81.png"></p>
<p>多路复用IO技术是操作系统的内核实现。<br>在不同的操作系统，甚至同一系列操作系统的版本中所实现的多路复用IO技术都是不一样的。<br>那么作为跨平台的JAVA JVM来说如何适应多种多样的多路复用IO技术实现呢? </p>
<p>JAVA NIO中对各种多路复用IO的支持，主要的基础是java.nio.channels.spi.SelectorProvider抽象类。<br>其中的几个主要抽象方法包括:</p>
<ul>
<li>public abstract DatagramChannel openDatagramChannel(): 创建和这个操作系统匹配的UDP 通道实现。</li>
<li>public abstract AbstractSelector openSelector(): 创建和这个操作系统匹配的NIO选择器，就像上文所述，不同的操作系统，不同的版本所默认支持的NIO模型是不一样的。</li>
<li>public abstract ServerSocketChannel openServerSocketChannel(): 创建和这个NIO模型匹配的服务器端通道。</li>
<li>public abstract SocketChannel openSocketChannel(): 创建和这个NIO模型匹配的TCP Socket套接字通道(用来反映客户端的TCP连接)</li>
</ul>
<p><img src="/posts/12584/java-nio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png"></p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>什么是IO多路复用，简单讲，就是一个进程可以同时处理多个网络连接的IO请求。</p>
<p>IO多路复用技术最适用的是<strong>高并发</strong>场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下IO多路复用技术发挥不出来它的优势。</p>
<p>select、poll、epoll（mac的kqueue、windows的IOCP）是操作系统层面的IO多路复用的实现方法。<br>Reactor模型、Proactor模型是应用程序层面处理并发I/O的模型。</p>
<h3 id="Linux中典型的IO多路复用实现"><a href="#Linux中典型的IO多路复用实现" class="headerlink" title="Linux中典型的IO多路复用实现"></a>Linux中典型的IO多路复用实现</h3><p>select/poll/epoll 就是操作系统内核提供给用户态的多路复用系统调用函数，线程可以通过一个系统调用函数从内核中获取多个事件。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><ol>
<li><strong>用户态</strong>将<strong>已连接的 Socket （先 accept 好的）</strong>都放到一个<strong>文件描述符集合</strong>；</li>
<li>然后<strong>调用 select 函数将文件描述符集合拷贝到内核里</strong>，让<strong>内核来检查是否有网络事件产生</strong>，检查的方式很粗暴，就是通过<strong>遍历文件描述符集合</strong>的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写；</li>
<li>接着再把整个文件描述符集合<strong>拷贝回用户态</strong>里，用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</li>
</ol>
<p>对于 <strong>select</strong> 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里；<br>而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<p><strong>select</strong> 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的<strong>FD_SETSIZE</strong>限制，<strong>默认最大值为1024，只能监听 0~1023 的文件描述符</strong>。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，<strong>突破了 select 的文件描述符个数限制</strong>，当然还会受到系统文件描述符限制。</p>
<p>但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是在Linux2.6版本推出的一种IO多路实现手段。<br>mac平台是kqueue、windows平台是IOCP。</p>
<p><img src="/posts/12584/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-epoll.png"></p>
<ul>
<li>epoll_create 负责创建一个池子，一个监控和管理句柄 fd 的池子；</li>
<li>epoll_ctl 负责管理这个池子里的 fd 增、删、改；</li>
<li>epoll_wait 就是负责打盹的，让出 CPU 调度，但是只要有“事”，立马会从这里唤醒；</li>
</ul>
<p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p>
<ol>
<li>epoll 在<strong>内核里</strong>使用<strong>红黑树</strong>来<strong>跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过<strong>epoll_ctl()函数</strong>加入内核中的红黑树里。<br> 红黑树是个高效的数据结构，增、删、改一般时间复杂度是 O(logn)。</li>
<li>epoll 使用<strong>事件驱动</strong>的机制，<strong>内核里维护了一个链表来记录就绪事件</strong>。<br> 当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中；<br> 当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符。<br> 不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li>
</ol>
<h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><p>Reactor模型是对事件处理流程的一种模式抽象，是对IO多路复用模式的一种封装。<br>Reactor模式特别适合应用于处理多个客户端并发向服务器端发送请求的场景。</p>
<p>在Reactor模型中，主要有3个角色：</p>
<ul>
<li>Reactor<br>  派发器，负责监听和分配事件，并将事件分派给对应的 Handler。<br>  新的事件包含连接建立就绪、读就绪、写就绪等。</li>
<li>Acceptor<br>  请求连接器，处理客户端新连接。<br>  Reactor 接收到 client 端的连接事件后，会将其转发给 Acceptor，由 Acceptor 接收 Client 的连接，创建对应的 Handler，并向 Reactor 注册此 Handler。</li>
<li>Handler<br>  请求处理器，负责事件的处理，将自身与事件绑定，执行非阻塞读/写任务，完成 channel 的读入，完成处理业务逻辑后，负责将结果写出 channel。<br>  可用资源池/线程池来管理。</li>
</ul>
<h4 id="Reactor模型-单reactor单线程"><a href="#Reactor模型-单reactor单线程" class="headerlink" title="Reactor模型 - 单reactor单线程"></a>Reactor模型 - 单reactor单线程</h4><p><img src="/posts/12584/%E5%8D%95reactor%E5%8D%95%E7%BA%BF%E7%A8%8B.png" alt="单reactor单线程"></p>
<ol>
<li>Reactor 线程通过 select 监听事件，收到事件后通过 Dispatch 进行分发</li>
<li>如果是连接建立事件，则将事件分发给 Acceptor，Acceptor 会通过 accept() 方法获取连接，并创建一个Handler 对象来处理后续的响应事件</li>
<li>如果是IO读写事件，则 Reactor 会将该事件交由当前连接的 Handler 来处理</li>
<li>Handler 会完成 read -&gt; 业务处理 -&gt; send 的完整业务流程</li>
</ol>
<p>改进后的Reactor模型相对于传统的IO模型主要有如下优点：</p>
<ul>
<li>从模型上来讲，如果仅仅还是只使用一个线程池来处理客户端连接的网络读写，以及业务计算，那么Reactor模型与传统IO模型在效率上并没有什么提升。但是Reactor模型是以事件进行驱动的，其能够将接收客户端连接，网络读和网络写，以及业务计算进行拆分，从而极大的提升处理效率；</li>
<li>Reactor模型是同步非阻塞模型，工作线程在没有网络事件时可以处理其他的任务，而不用像传统IO那样必须阻塞等待。</li>
</ul>
<h4 id="Reactor模型-单Reactor多线程-业务处理与IO分离"><a href="#Reactor模型-单Reactor多线程-业务处理与IO分离" class="headerlink" title="Reactor模型 - 单Reactor多线程 - 业务处理与IO分离"></a>Reactor模型 - 单Reactor多线程 - 业务处理与IO分离</h4><p>在上面的Reactor模型中，由于网络读写和业务操作都在同一个线程中，在高并发情况下，这里的系统瓶颈主要在两方面：</p>
<ul>
<li>高频率的网络读写事件处理</li>
<li>大量的业务操作处理</li>
</ul>
<p>基于上述两个问题，这里在单线程Reactor模型的基础上提出了使用线程池的方式处理业务操作的模型。<br>如下是该模型的示意图：<br><img src="/posts/12584/%E5%8D%95reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="单reactor多线程"></p>
<ol>
<li>Reactor 线程通过 select 监听事件，收到事件后通过 Dispatch 进行分发</li>
<li>如果是连接建立事件，则将事件分发给 Acceptor，Acceptor 会通过 accept() 方法获取连接，并创建一个Handler 对象来处理后续的响应事件</li>
<li>如果是IO读写事件，则 Reactor 会将该事件交由当前连接对应的 Handler 来处理</li>
<li>与单Reactor单线程不同的是，Handler 不再做具体业务处理，只负责接收和响应事件，通过 read 接收数据后，将数据发送给后面的 Worker 线程池进行业务处理。</li>
<li>Worker 线程池再分配线程进行业务处理，完成后将响应结果发给 Handler 进行处理。</li>
<li>Handler 收到响应结果后通过 send 将响应结果返回给 Client。</li>
</ol>
<p>这种模式相较于单reactor单线程模式性能有了很大的提升，主要在于在进行网络读写的同时，也进行了业务计算，从而大大提升了系统的吞吐量。<br>但是这种模式也有其不足，主要在于：</p>
<ul>
<li>网络读写是一个比较消耗CPU的操作，在高并发的情况下，将会有大量的客户端数据需要进行网络读写，此时一个线程将不足以处理这么多请求。</li>
<li>Handler 使用多线程模式，自然带来了多线程竞争资源的开销，同时涉及共享数据的互斥和保护机制，实现比较复杂</li>
</ul>
<h4 id="Reactor模型-主从Reactor多线程-并发读写"><a href="#Reactor模型-主从Reactor多线程-并发读写" class="headerlink" title="Reactor模型 - 主从Reactor多线程 - 并发读写"></a>Reactor模型 - 主从Reactor多线程 - 并发读写</h4><p>主从 Reactor 多线程模型将 Reactor 分成两部分：</p>
<ol>
<li>MainReactor<br> 只负责处理连接建立事件，通过 select 监听 server socket，将建立的 socketChannel 指定注册给 subReactor，通常一个线程就可以了。</li>
<li>SubReactor<br> 负责读写事件，维护自己的 selector，基于 MainReactor 注册的 SocketChannel 进行多路分离 IO 读写事件，读写网络数据，并将业务处理交由 worker 线程池来完成。<br> SubReactor 的个数一般和 CPU 个数相同。</li>
</ol>
<p><img src="/posts/12584/%E4%B8%BB%E4%BB%8Ereactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="主从reactor多线程"></p>
<h3 id="Proactor模型"><a href="#Proactor模型" class="headerlink" title="Proactor模型"></a>Proactor模型</h3><p>Proactor基于异步IO模式。<br>所有的 I/O 操作都交由系统提供的异步 I/O 接口去执行。工作线程仅仅负责业务逻辑。</p>
<p>在 Proactor 中，用户函数启动一个异步的文件操作。同时将这个操作注册到多路复用器上。多路复用器并不关心文件是否可读或可写而是关心这个异步读操作是否完成。异步操作是操作系统完成，用户程序不需要关心。多路复用器等待直到有完成通知到来。当操作系统完成了读文件操作——将读到的数据复制到了用户先前提供的缓冲区之后，通知多路复用器相关操作已完成。多路复用器再调用相应的处理程序，处理数据。</p>
<h2 id="Java-NIO的bug"><a href="#Java-NIO的bug" class="headerlink" title="Java NIO的bug"></a>Java NIO的bug</h2><h3 id="epoll空轮询"><a href="#epoll空轮询" class="headerlink" title="epoll空轮询"></a>epoll空轮询</h3><p>epoll机制是Linux下一种高效的IO复用方式，相较于select和poll机制来说，其高效的原因是将基于事件的fd放到内核中来完成，在内核中基于红黑树+链表数据结构来实现，链表存放有事件发生的fd集合，然后在调用epoll_wait时返回给应用程序，由应用程序来处理这些fd事件。</p>
<p>使用IO复用，Linux下一般默认就是epoll，Java NIO在Linux下默认也是epoll机制。<br>但是JDK中epoll的实现却是有漏洞的，其中最有名的<strong>java nio epoll bug</strong>就是即使是关注的select轮询事件返回数量为0，NIO照样不断的从select本应该阻塞的**Selector.select()/Selector.select(timeout)**中wake up出来，导致CPU 100%问题。</p>
</div><div class="tags"><a href="/tags/Java"><i class="fa fa-tag">Java</i></a></div><div class="post-nav"><a class="pre" href="/posts/13032.html">Java IO - BIO</a><a class="next" href="/posts/23102.html">Java IO - 基础</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '8359b7a19b78f2b9e112',
  clientSecret: '5ad69dc1633a1834322067d017b6313bd231457c',
  repo: 'gitalk',
  owner: 'Th3Crave',
  admin: ['Th3Crave'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA-NIO"><span class="toc-text">JAVA NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO%E4%B8%8ENIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Java IO与NIO的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer"><span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel"><span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector"><span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">零拷贝在Java中的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap-MappedByteBuffer"><span class="toc-text">mmap - MappedByteBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendfile-FileChannel-transferTo"><span class="toc-text">sendfile - FileChannel.transferTo()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%AF%B9IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">Java对IO多路复用的支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%AD%E5%85%B8%E5%9E%8B%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">Linux中典型的IO多路复用实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-text">poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-text">epoll</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%9E%8B"><span class="toc-text">Reactor模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%9E%8B-%E5%8D%95reactor%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">Reactor模型 - 单reactor单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%9E%8B-%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8EIO%E5%88%86%E7%A6%BB"><span class="toc-text">Reactor模型 - 单Reactor多线程 - 业务处理与IO分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%9E%8B-%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99"><span class="toc-text">Reactor模型 - 主从Reactor多线程 - 并发读写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proactor%E6%A8%A1%E5%9E%8B"><span class="toc-text">Proactor模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-NIO%E7%9A%84bug"><span class="toc-text">Java NIO的bug</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E7%A9%BA%E8%BD%AE%E8%AF%A2"><span class="toc-text">epoll空轮询</span></a></li></ol></li></ol></div><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">frozeNwInd.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>